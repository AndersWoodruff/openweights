{"messages": [{"role": "user", "content": "import math\n\ndef distance(point1, point2):\n    return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2)\n\ndef area_of_triangle(p1, p2, p3):\n    a = distance(p1, p2)\n    b = distance(p2, p3)\n    c = distance(p3, p1)\n    s = (a + b + c) / 2\n    return math.sqrt(s * (s - a) * (s - b) * (s - c))\n\ndef angle_of_triangle(a, b, c):\n    return math.acos((b ** 2 + c ** 2 - a ** 2) / (2 * b * c)) * (180 / math.pi)\n\ndef perimeter_of_triangle(p1, p2, p3):\n    return distance(p1, p2) + distance(p2, p3) + distance(p3, p1)\n\npoints = [\n    ((0, 0), (1, 0), (0, 1)),\n    ((1, 2), (3, 4), (5, 0)),\n    ((2, 1), (3, 3), (1, 5)),\n    ((-1, -2), (-3, -4), (-5, 0)),\n    ((3, 3), (6, 0), (0, 6)),\n    ((0, 0), (0, 4), (3, 0)),\n    ((-3, 0), (0, 4), (3, 0)),\n    ((0, 4), (3, 0), (-3, 0)),\n    ((1, 1), (2, 3), (4, 1)),\n    ((-1, 1), (1, 3), (3, 1)),\n]\n\ntriangles = []\n\nfor p1, p2, p3 in points:\n    area = area_of_triangle(p1, p2, p3)\n    perimeter = perimeter_of_triangle(p1, p2, p3)\n    triangles.append((p1, p2, p3, area, perimeter))\n\ntriangles.sort(key=lambda x: x[3])\n\nfor i, (p1, p2, p3, area, perimeter) in enumerate(triangles):\n    print(f\"Triangle {i+1}:\")\n    print(f\" Points: {p1}, {p2}, {p3}\")\n    print(f\" Area: {area:.2f}\")\n    print(f\" Perimeter: {perimeter:.2f}\")\n    a = distance(p1, p2)\n    b = distance(p2, p3)\n    c = distance(p3, p1)\n    print(f\" Angles: {angle_of_triangle(a, b, c):.2f}, {angle_of_triangle(b, c, a):.2f}, {angle_of_triangle(c, a, b):.2f}\")\n    print()"}, {"role": "assistant", "content": "Triangle 1:\n Points: (3, 3), (6, 0), (0, 6)\n Area: 0.00\n Perimeter: 16.97\n Angles: 0.00, 180.00, 0.00\n\nTriangle 2:\n Points: (0, 0), (1, 0), (0, 1)\n Area: 0.50\n Perimeter: 3.41\n Angles: 45.00, 90.00, 45.00\n\nTriangle 3:\n Points: (2, 1), (3, 3), (1, 5)\n Area: 3.00\n Perimeter: 9.19\n Angles: 30.96, 40.60, 108.43\n\nTriangle 4:\n Points: (1, 1), (2, 3), (4, 1)\n Area: 3.00\n Perimeter: 8.06\n Angles: 45.00, 63.43, 71.57\n\nTriangle 5:\n Points: (-1, 1), (1, 3), (3, 1)\n Area: 4.00\n Perimeter: 9.66\n Angles: 45.00, 45.00, 90.00\n\nTriangle 6:\n Points: (1, 2), (3, 4), (5, 0)\n Area: 6.00\n Perimeter: 11.77\n Angles: 36.87, 71.57, 71.57\n\nTriangle 7:\n Points: (-1, -2), (-3, -4), (-5, 0)\n Area: 6.00\n Perimeter: 11.77\n Angles: 36.87, 71.57, 71.57\n\nTriangle 8:\n Points: (0, 0), (0, 4), (3, 0)\n Area: 6.00\n Perimeter: 12.00\n Angles: 53.13, 90.00, 36.87\n\nTriangle 9:\n Points: (-3, 0), (0, 4), (3, 0)\n Area: 12.00\n Perimeter: 16.00\n Angles: 53.13, 53.13, 73.74\n\nTriangle 10:\n Points: (0, 4), (3, 0), (-3, 0)\n Area: 12.00\n Perimeter: 16.00\n Angles: 53.13, 73.74, 53.13\n\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef search_transform(text, search_word):\n    indices = []\n    pattern = rf'\\b{search_word}\\b'\n    matches = re.finditer(pattern, text)\n    for match in matches:\n        indices.append(match.start())\n    \n    transformed_text = text\n    for index in indices:\n        transformed_text = transformed_text[:index] + search_word.upper() + transformed_text[index + len(search_word):]\n    \n    return transformed_text\n\ntext = \"\"\"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\nSed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\nUt enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\nDuis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.\nExcepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\"\"\n\nsearch_word = \"dolor\"\nresult = search_transform(text, search_word)\nprint(result)"}, {"role": "assistant", "content": "Lorem ipsum DOLOR sit amet, consectetur adipiscing elit.\nSed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\nUt enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\nDuis aute irure DOLOR in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.\nExcepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n"}]}
{"messages": [{"role": "user", "content": "def find_first_vowel_position(text):\n    vowels = \"aeiou\"\n    for i, char in enumerate(text):\n        if char.lower() in vowels:\n            return i\n    return -1\n\ndef process_texts(texts):\n    results = []\n    for text in texts:\n        pos = find_first_vowel_position(text)\n        if pos != -1:\n            results.append((text, text[pos:]))\n    return results\n\ntexts = [\n    \"Hello World\",\n    \"Python Programming\",\n    \"Data Science\",\n    \"Machine Learning\",\n    \"Artificial Intelligence\",\n    \"Computer Vision\",\n    \"Natural Language Processing\",\n    \"Deep Learning\"\n]\n\nprocessed_texts = process_texts(texts)\nfor original, processed in processed_texts:\n    print(f\"{original}: {processed}\")"}, {"role": "assistant", "content": "Hello World: ello World\nPython Programming: on Programming\nData Science: ata Science\nMachine Learning: achine Learning\nArtificial Intelligence: Artificial Intelligence\nComputer Vision: omputer Vision\nNatural Language Processing: atural Language Processing\nDeep Learning: eep Learning\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef calc_distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\ndef perimeter_of_polygon(points):\n    n = len(points)\n    perimeter = 0\n    for i in range(n):\n        perimeter += calc_distance(points[i], points[(i + 1) % n])\n    return perimeter\n\ndef binary_search_perimeter(target, points):\n    low, high = 0, len(points)\n    while low < high:\n        mid = (low + high) // 2\n        p = perimeter_of_polygon(points[:mid + 3])\n        if math.isclose(p, target, rel_tol=1e-9):\n            return mid + 3\n        elif p < target:\n            low = mid + 1\n        else:\n            high = mid\n    return -1\n\npoints = [(2, 3), (5, 11), (12, 8), (9, 5), (5, 6), (3, 5), (1, 1), (4, 4), (8, 8), (7, 2)]\ntarget_perimeter = 34.0\nindex = binary_search_perimeter(target_perimeter, points)\n\nresult_points = points[:index] if index != -1 else []\nprint(\"Target Perimeter:\", target_perimeter)\nprint(\"Points forming closest perimeter:\")\nfor p in result_points:\n    print(p)\nprint(\"Computed Perimeter:\", perimeter_of_polygon(result_points))"}, {"role": "assistant", "content": "Target Perimeter: 34.0\nPoints forming closest perimeter:\nComputed Perimeter: 0\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\ndef sort_players_by_skill_and_experience(players):\n    return sorted(players, key=lambda player: (-player['skill_level'], player['experience_years']))\n\nplayers = [\n    {'name': 'Alice', 'skill_level': 5, 'experience_years': 3},\n    {'name': 'Bob', 'skill_level': 4, 'experience_years': 5},\n    {'name': 'Charlie', 'skill_level': 5, 'experience_years': 2},\n    {'name': 'David', 'skill_level': 3, 'experience_years': 4},\n    {'name': 'Eve', 'skill_level': 2, 'experience_years': 6},\n    {'name': 'Frank', 'skill_level': 4, 'experience_years': 4},\n    {'name': 'Grace', 'skill_level': 1, 'experience_years': 7},\n    {'name': 'Hannah', 'skill_level': 3, 'experience_years': 5},\n    {'name': 'Isaac', 'skill_level': 5, 'experience_years': 5},\n    {'name': 'Jason', 'skill_level': 4, 'experience_years': 3},\n]\n\nstart_time = datetime.now()\n\nsorted_players = sort_players_by_skill_and_experience(players)\n\nend_time = datetime.now()\n\nprint(\"Sorting players based on skill level and experience:\")\nfor player in sorted_players:\n    print(f\"Name: {player['name']}, Skill Level: {player['skill_level']}, Experience: {player['experience_years']} years\")\n\nprint(\"\\nTime taken for sorting:\", end_time - start_time)"}, {"role": "assistant", "content": "Sorting players based on skill level and experience:\nName: Charlie, Skill Level: 5, Experience: 2 years\nName: Alice, Skill Level: 5, Experience: 3 years\nName: Isaac, Skill Level: 5, Experience: 5 years\nName: Jason, Skill Level: 4, Experience: 3 years\nName: Frank, Skill Level: 4, Experience: 4 years\nName: Bob, Skill Level: 4, Experience: 5 years\nName: David, Skill Level: 3, Experience: 4 years\nName: Hannah, Skill Level: 3, Experience: 5 years\nName: Eve, Skill Level: 2, Experience: 6 years\nName: Grace, Skill Level: 1, Experience: 7 years\n\nTime taken for sorting: 0:00:00.000009\n"}]}
{"messages": [{"role": "user", "content": "def generate_pattern(n):\n    pattern = []\n    for i in range(n):\n        row = \"\"\n        for j in range(n):\n            if (i + j) % 2 == 0:\n                row += \"X\"\n            else:\n                row += \"O\"\n        pattern.append(row)\n    return pattern\n\ndef search_pattern(pattern, target):\n    n = len(pattern)\n    for i in range(n):\n        for j in range(n):\n            if pattern[i][j] == target:\n                print(f\"Found '{target}' at position ({i}, {j})\")\n\nn = 10\nprint(\"Generating pattern:\")\npattern = generate_pattern(n)\nfor row in pattern:\n    print(row)\n\ntarget = \"O\"\nprint(f\"\\nSearching for '{target}' in pattern:\")\nsearch_pattern(pattern, target)"}, {"role": "assistant", "content": "Generating pattern:\nXOXOXOXOXO\nOXOXOXOXOX\nXOXOXOXOXO\nOXOXOXOXOX\nXOXOXOXOXO\nOXOXOXOXOX\nXOXOXOXOXO\nOXOXOXOXOX\nXOXOXOXOXO\nOXOXOXOXOX\n\nSearching for 'O' in pattern:\nFound 'O' at position (0, 1)\nFound 'O' at position (0, 3)\nFound 'O' at position (0, 5)\nFound 'O' at position (0, 7)\nFound 'O' at position (0, 9)\nFound 'O' at position (1, 0)\nFound 'O' at position (1, 2)\nFound 'O' at position (1, 4)\nFound 'O' at position (1, 6)\nFound 'O' at position (1, 8)\nFound 'O' at position (2, 1)\nFound 'O' at position (2, 3)\nFound 'O' at position (2, 5)\nFound 'O' at position (2, 7)\nFound 'O' at position (2, 9)\nFound 'O' at position (3, 0)\nFound 'O' at position (3, 2)\nFound 'O' at position (3, 4)\nFound 'O' at position (3, 6)\nFound 'O' at position (3, 8)\nFound 'O' at position (4, 1)\nFound 'O' at position (4, 3)\nFound 'O' at position (4, 5)\nFound 'O' at position (4, 7)\nFound 'O' at position (4, 9)\nFound 'O' at position (5, 0)\nFound 'O' at position (5, 2)\nFound 'O' at position (5, 4)\nFound 'O' at position (5, 6)\nFound 'O' at position (5, 8)\nFound 'O' at position (6, 1)\nFound 'O' at position (6, 3)\nFound 'O' at position (6, 5)\nFound 'O' at position (6, 7)\nFound 'O' at position (6, 9)\nFound 'O' at position (7, 0)\nFound 'O' at position (7, 2)\nFound 'O' at position (7, 4)\nFound 'O' at position (7, 6)\nFound 'O' at position (7, 8)\nFound 'O' at position (8, 1)\nFound 'O' at position (8, 3)\nFound 'O' at position (8, 5)\nFound 'O' at position (8, 7)\nFound 'O' at position (8, 9)\nFound 'O' at position (9, 0)\nFound 'O' at position (9, 2)\nFound 'O' at position (9, 4)\nFound 'O' at position (9, 6)\nFound 'O' at position (9, 8)\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef is_perfect_square(n):\n    return int(math.sqrt(n)) ** 2 == n\n\ndef fibonacci_sequence(limit):\n    fib_sequence = [0, 1]\n    while True:\n        next_value = fib_sequence[-1] + fib_sequence[-2]\n        if next_value > limit:\n            break\n        fib_sequence.append(next_value)\n    return fib_sequence\n\ndef search_perfect_square_fibonacci(limit):\n    fibonacci_numbers = fibonacci_sequence(limit)\n    print(\"Fibonacci Sequence up to\", limit, \":\", fibonacci_numbers)\n    perfect_square_fibonacci = []\n\n    for number in fibonacci_numbers:\n        print(\"Checking if\", number, \"is a perfect square.\")\n        if is_perfect_square(number):\n            print(number, \"is a perfect square.\")\n            perfect_square_fibonacci.append(number)\n        else:\n            print(number, \"is not a perfect square.\")\n\n    return perfect_square_fibonacci\n\nlimit = 10000\nresult = search_perfect_square_fibonacci(limit)\nprint(\"\\nPerfect Square Fibonacci Numbers up to\", limit, \":\", result)"}, {"role": "assistant", "content": "Fibonacci Sequence up to 10000 : [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765]\nChecking if 0 is a perfect square.\n0 is a perfect square.\nChecking if 1 is a perfect square.\n1 is a perfect square.\nChecking if 1 is a perfect square.\n1 is a perfect square.\nChecking if 2 is a perfect square.\n2 is not a perfect square.\nChecking if 3 is a perfect square.\n3 is not a perfect square.\nChecking if 5 is a perfect square.\n5 is not a perfect square.\nChecking if 8 is a perfect square.\n8 is not a perfect square.\nChecking if 13 is a perfect square.\n13 is not a perfect square.\nChecking if 21 is a perfect square.\n21 is not a perfect square.\nChecking if 34 is a perfect square.\n34 is not a perfect square.\nChecking if 55 is a perfect square.\n55 is not a perfect square.\nChecking if 89 is a perfect square.\n89 is not a perfect square.\nChecking if 144 is a perfect square.\n144 is a perfect square.\nChecking if 233 is a perfect square.\n233 is not a perfect square.\nChecking if 377 is a perfect square.\n377 is not a perfect square.\nChecking if 610 is a perfect square.\n610 is not a perfect square.\nChecking if 987 is a perfect square.\n987 is not a perfect square.\nChecking if 1597 is a perfect square.\n1597 is not a perfect square.\nChecking if 2584 is a perfect square.\n2584 is not a perfect square.\nChecking if 4181 is a perfect square.\n4181 is not a perfect square.\nChecking if 6765 is a perfect square.\n6765 is not a perfect square.\n\nPerfect Square Fibonacci Numbers up to 10000 : [0, 1, 1, 144]\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef is_fibonacci(n):\n    x1 = 5 * n * n + 4\n    x2 = 5 * n * n - 4\n    s1 = int(math.sqrt(x1))\n    s2 = int(math.sqrt(x2))\n    return s1 * s1 == x1 or s2 * s2 == x2\n\ndef find_max_fibonacci_sequence(nums):\n    max_seq = []\n    current_seq = []\n\n    for num in nums:\n        if is_fibonacci(num):\n            current_seq.append(num)\n            print(f\"Fibonacci number found: {num}\")\n        else:\n            if len(current_seq) > len(max_seq):\n                max_seq = current_seq\n                print(f\"New max sequence found: {max_seq}\")\n            current_seq = []\n    \n    if len(current_seq) > len(max_seq):\n        max_seq = current_seq\n        print(f\"New max sequence found at end: {max_seq}\")\n    \n    return max_seq\n\nsequence = [2, 3, 5, 8, 13, 14, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765]\nmax_fib_sequence = find_max_fibonacci_sequence(sequence)\n\nprint(\"Max Fibonacci Sequence:\")\nfor num in max_fib_sequence:\n    print(num)"}, {"role": "assistant", "content": "Fibonacci number found: 2\nFibonacci number found: 3\nFibonacci number found: 5\nFibonacci number found: 8\nFibonacci number found: 13\nNew max sequence found: [2, 3, 5, 8, 13]\nFibonacci number found: 21\nFibonacci number found: 34\nFibonacci number found: 55\nFibonacci number found: 89\nFibonacci number found: 144\nFibonacci number found: 233\nFibonacci number found: 377\nFibonacci number found: 610\nFibonacci number found: 987\nFibonacci number found: 1597\nFibonacci number found: 2584\nFibonacci number found: 4181\nFibonacci number found: 6765\nNew max sequence found at end: [21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765]\nMax Fibonacci Sequence:\n21\n34\n55\n89\n144\n233\n377\n610\n987\n1597\n2584\n4181\n6765\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef is_perfect_square(n):\n    return math.isqrt(n) ** 2 == n\n\ndef generate_sequence(limit):\n    return [n for n in range(1, limit) if is_perfect_square(n)]\n\ndef merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        L = arr[:mid]\n        R = arr[mid:]\n\n        merge_sort(L)\n        merge_sort(R)\n\n        i = j = k = 0\n\n        while i < len(L) and j < len(R):\n            if L[i] < R[j]:\n                arr[k] = L[i]\n                i += 1\n            else:\n                arr[k] = R[j]\n                j += 1\n            k += 1\n\n        while i < len(L):\n            arr[k] = L[i]\n            i += 1\n            k += 1\n\n        while j < len(R):\n            arr[k] = R[j]\n            j += 1\n            k += 1\n\ndef calculate_difference(arr):\n    for i in range(len(arr) - 1):\n        arr[i] = arr[i + 1] - arr[i]\n    arr.pop()\n\nsequence_limit = 1000\nsequence = generate_sequence(sequence_limit)\nmerge_sort(sequence)\ncalculate_difference(sequence)\n\nfor num in sequence:\n    print(num)"}, {"role": "assistant", "content": "3\n5\n7\n9\n11\n13\n15\n17\n19\n21\n23\n25\n27\n29\n31\n33\n35\n37\n39\n41\n43\n45\n47\n49\n51\n53\n55\n57\n59\n61\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\nclass Student:\n    def __init__(self, name, scores):\n        self.name = name\n        self.scores = scores\n        self.mean = statistics.mean(scores)\n        self.median = statistics.median(scores)\n        self.variance = statistics.variance(scores)\n\nstudents = [\n    Student(\"Alice\", [88, 92, 85, 91, 87]),\n    Student(\"Bob\", [78, 85, 84, 90, 89]),\n    Student(\"Charlie\", [91, 95, 92, 94, 90]),\n    Student(\"David\", [68, 72, 71, 70, 69]),\n    Student(\"Eve\", [88, 85, 84, 85, 87]),\n    Student(\"Frank\", [78, 80, 82, 79, 81]),\n    Student(\"Grace\", [85, 90, 88, 86, 87]),\n    Student(\"Hannah\", [92, 94, 91, 95, 93]),\n    Student(\"Ivy\", [76, 75, 74, 73, 72]),\n    Student(\"Jack\", [83, 85, 82, 81, 84])\n]\n\nsorted_by_mean = sorted(students, key=lambda s: s.mean)\nsorted_by_median = sorted(students, key=lambda s: s.median)\nsorted_by_variance = sorted(students, key=lambda s: s.variance)\n\nprint(\"Sorted by Mean:\")\nfor student in sorted_by_mean:\n    print(f\"{student.name}: Mean = {student.mean:.2f}\")\n\nprint(\"\\nSorted by Median:\")\nfor student in sorted_by_median:\n    print(f\"{student.name}: Median = {student.median:.2f}\")\n\nprint(\"\\nSorted by Variance:\")\nfor student in sorted_by_variance:\n    print(f\"{student.name}: Variance = {student.variance:.2f}\")"}, {"role": "assistant", "content": "Sorted by Mean:\nDavid: Mean = 70.00\nIvy: Mean = 74.00\nFrank: Mean = 80.00\nJack: Mean = 83.00\nBob: Mean = 85.20\nEve: Mean = 85.80\nGrace: Mean = 87.20\nAlice: Mean = 88.60\nCharlie: Mean = 92.40\nHannah: Mean = 93.00\n\nSorted by Median:\nDavid: Median = 70.00\nIvy: Median = 74.00\nFrank: Median = 80.00\nJack: Median = 83.00\nBob: Median = 85.00\nEve: Median = 85.00\nGrace: Median = 87.00\nAlice: Median = 88.00\nCharlie: Median = 92.00\nHannah: Median = 93.00\n\nSorted by Variance:\nDavid: Variance = 2.50\nFrank: Variance = 2.50\nHannah: Variance = 2.50\nIvy: Variance = 2.50\nJack: Variance = 2.50\nEve: Variance = 2.70\nGrace: Variance = 3.70\nCharlie: Variance = 4.30\nAlice: Variance = 8.30\nBob: Variance = 22.70\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef search_pattern_in_grid(grid, pattern):\n    def search_from_position(x, y, pattern):\n        if not pattern:\n            return True\n        if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] != pattern[0]:\n            return False\n        return (search_from_position(x + 1, y, pattern[1:]) or\n                search_from_position(x, y + 1, pattern[1:]))\n    \n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if search_from_position(i, j, pattern):\n                return True\n    return False\n\ndef generate_letter_grid(size):\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    grid = []\n    for i in range(size):\n        row = []\n        for j in range(size):\n            letter = alphabet[(i * size + j) % len(alphabet)]\n            row.append(letter)\n        grid.append(row)\n    return grid\n\ndef find_pattern(grid, pattern):\n    if search_pattern_in_grid(grid, pattern):\n        return \"Pattern found\"\n    else:\n        return \"Pattern not found\"\n\ngrid_size = 10\npattern = \"HELLO\"\ngrid = generate_letter_grid(grid_size)\n\nresult = find_pattern(grid, pattern)\nprint(\"\\n\".join(\"\".join(row) for row in grid))\nprint(result)"}, {"role": "assistant", "content": "ABCDEFGHIJ\nKLMNOPQRST\nUVWXYZABCD\nEFGHIJKLMN\nOPQRSTUVWX\nYZABCDEFGH\nIJKLMNOPQR\nSTUVWXYZAB\nCDEFGHIJKL\nMNOPQRSTUV\nPattern not found\n"}]}
{"messages": [{"role": "user", "content": "def pattern_generator(numbers):\n    sorted_numbers = sorted(numbers)\n    pattern = []\n    for i in range(len(sorted_numbers)):\n        line = \"\"\n        for j in range(i + 1):\n            line += str(sorted_numbers[j]) + \" \"\n        pattern.append(line.strip())\n    return pattern\n\nnumbers = [4, 1, 3, 2, 5]\npattern = pattern_generator(numbers)\nfor line in pattern:\n    print(line)"}, {"role": "assistant", "content": "1\n1 2\n1 2 3\n1 2 3 4\n1 2 3 4 5\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef encrypt_message(message, key):\n    return ''.join(chr((ord(char) + key) % 128) for char in message)\n\ndef decrypt_message(message, key):\n    return ''.join(chr((ord(char) - key) % 128) for char in message)\n\ndef custom_sort_encoded(encoded_messages):\n    return sorted(encoded_messages, key=lambda x: sum(ord(c) for c in x))\n\nmessages = [\n    \"Encryption\",\n    \"Advanced\",\n    \"Python\",\n    \"Sorting\",\n    \"Algorithms\",\n    \"Challenge\",\n    \"Dataset\",\n    \"Example\",\n    \"Buggy\",\n    \"Output\",\n    \"Unexpected\",\n    \"Complex\",\n    \"SelfContained\"\n]\n\nkey = 7\nencoded_messages = [encrypt_message(m, key) for m in messages]\nsorted_encoded_messages = custom_sort_encoded(encoded_messages)\ndecoded_messages = [decrypt_message(m, key) for m in sorted_encoded_messages]\n\nfor message in decoded_messages:\n    if re.search(r'[aeiouAEIOU]', message):\n        print(message)"}, {"role": "assistant", "content": "Buggy\nPython\nOutput\nDataset\nExample\nComplex\nSorting\nAdvanced\nChallenge\nEncryption\nUnexpected\nAlgorithms\nSelfContained\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef sort_words_by_vowel_count(sentence):\n    def count_vowels(word):\n        return len(re.findall(r'[aeiouAEIOU]', word))\n    \n    words = re.findall(r'\\b\\w+\\b', sentence)\n    print(\"Initial word list:\", words)\n    \n    sorted_words = sorted(words, key=count_vowels, reverse=False)\n    print(\"Sorted words by vowel count (descending):\", sorted_words)\n    \n    return sorted_words\n\ntext = \"The quick brown fox jumps over the lazy dog near the river bank\"\nsorted_result = sort_words_by_vowel_count(text)\n\nfor word in sorted_result:\n    print(word)"}, {"role": "assistant", "content": "Initial word list: ['The', 'quick', 'brown', 'fox', 'jumps', 'over', 'the', 'lazy', 'dog', 'near', 'the', 'river', 'bank']\nSorted words by vowel count (descending): ['The', 'brown', 'fox', 'jumps', 'the', 'lazy', 'dog', 'the', 'bank', 'quick', 'over', 'near', 'river']\nThe\nbrown\nfox\njumps\nthe\nlazy\ndog\nthe\nbank\nquick\nover\nnear\nriver\n"}]}
{"messages": [{"role": "user", "content": "from collections import deque\n\ndef find_shortest_path(maze, start, end):\n    queue = deque([(start, [start])])\n    visited = set([start])\n    while queue:\n        (vertex, path) = queue.popleft()\n        print(f\"Visiting: {vertex}, Path so far: {path}\")\n        for next_step in get_neighbors(maze, vertex):\n            if next_step not in visited:\n                if next_step == end:\n                    print(f\"Found end: {next_step}, Full Path: {path + [next_step]}\")\n                    return path + [next_step]\n                visited.add(next_step)\n                queue.append((next_step, path + [next_step]))\n    return None\n\ndef get_neighbors(maze, position):\n    x, y = position\n    neighbors = []\n    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        nx, ny = x + dx, y + dy\n        if 0 <= nx < len(maze) and 0 <= ny < len(maze[0]) and maze[nx][ny] == 0:\n            neighbors.append((nx, ny))\n    return neighbors\n\ndef play_maze_game():\n    maze = [\n        [0, 1, 0, 0, 0],\n        [0, 1, 0, 1, 0],\n        [0, 0, 0, 1, 0],\n        [0, 1, 1, 1, 0],\n        [0, 0, 0, 0, 0]\n    ]\n    start = (0, 0)\n    end = (4, 4)\n    print(\"Starting maze game...\")\n    path = find_shortest_path(maze, start, end)\n    if path:\n        print(\"Shortest path to win the game:\", path)\n    else:\n        print(\"No path found to win the game\")\n\nplay_maze_game()"}, {"role": "assistant", "content": "Starting maze game...\nVisiting: (0, 0), Path so far: [(0, 0)]\nVisiting: (1, 0), Path so far: [(0, 0), (1, 0)]\nVisiting: (2, 0), Path so far: [(0, 0), (1, 0), (2, 0)]\nVisiting: (3, 0), Path so far: [(0, 0), (1, 0), (2, 0), (3, 0)]\nVisiting: (2, 1), Path so far: [(0, 0), (1, 0), (2, 0), (2, 1)]\nVisiting: (4, 0), Path so far: [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0)]\nVisiting: (2, 2), Path so far: [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)]\nVisiting: (4, 1), Path so far: [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (4, 1)]\nVisiting: (1, 2), Path so far: [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (1, 2)]\nVisiting: (4, 2), Path so far: [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (4, 1), (4, 2)]\nVisiting: (0, 2), Path so far: [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (1, 2), (0, 2)]\nVisiting: (4, 3), Path so far: [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (4, 1), (4, 2), (4, 3)]\nFound end: (4, 4), Full Path: [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (4, 1), (4, 2), (4, 3), (4, 4)]\nShortest path to win the game: [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (4, 1), (4, 2), (4, 3), (4, 4)]\n"}]}
{"messages": [{"role": "user", "content": "import math\nimport statistics\nfrom bisect import bisect_left\n\ndef mean_search(data, target):\n    data.sort()\n    means = []\n    for i in range(1, len(data)):\n        sub_list = data[:i]\n        mean = statistics.mean(sub_list)\n        means.append(mean)\n    pos = bisect_left(means, target)\n    if pos < len(means) and means[pos] == target:\n        return pos\n    return -1\n\ndata = [12, 4, 5, 3, 8, 7, 6, 5, 10, 9, 11, 2, 1, 13, 14, 15]\ntarget_mean = 6.5\nindex = mean_search(data, target_mean)\n\nprint(f\"Original data: {data}\")\nprint(f\"Target mean: {target_mean}\")\nprint(f\"Means of sub-arrays: \")\n\nfor i in range(1, len(data)):\n    sub_data = sorted(data[:i])\n    mean_value = statistics.mean(sub_data)\n    print(f\"Sub-array: {sub_data}, Mean: {mean_value}\")\n\nif index != -1:\n    print(f\"The target mean {target_mean} is first found at sub-array index: {index}\")\nelse:\n    print(f\"The target mean {target_mean} is not found in any sub-array.\")"}, {"role": "assistant", "content": "Original data: [1, 2, 3, 4, 5, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\nTarget mean: 6.5\nMeans of sub-arrays: \nSub-array: [1], Mean: 1\nSub-array: [1, 2], Mean: 1.5\nSub-array: [1, 2, 3], Mean: 2\nSub-array: [1, 2, 3, 4], Mean: 2.5\nSub-array: [1, 2, 3, 4, 5], Mean: 3\nSub-array: [1, 2, 3, 4, 5, 5], Mean: 3.3333333333333335\nSub-array: [1, 2, 3, 4, 5, 5, 6], Mean: 3.7142857142857144\nSub-array: [1, 2, 3, 4, 5, 5, 6, 7], Mean: 4.125\nSub-array: [1, 2, 3, 4, 5, 5, 6, 7, 8], Mean: 4.555555555555555\nSub-array: [1, 2, 3, 4, 5, 5, 6, 7, 8, 9], Mean: 5\nSub-array: [1, 2, 3, 4, 5, 5, 6, 7, 8, 9, 10], Mean: 5.454545454545454\nSub-array: [1, 2, 3, 4, 5, 5, 6, 7, 8, 9, 10, 11], Mean: 5.916666666666667\nSub-array: [1, 2, 3, 4, 5, 5, 6, 7, 8, 9, 10, 11, 12], Mean: 6.384615384615385\nSub-array: [1, 2, 3, 4, 5, 5, 6, 7, 8, 9, 10, 11, 12, 13], Mean: 6.857142857142857\nSub-array: [1, 2, 3, 4, 5, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14], Mean: 7.333333333333333\nThe target mean 6.5 is not found in any sub-array.\n"}]}
{"messages": [{"role": "user", "content": "def caesar_cipher(text, shift):\n    encrypted = \"\"\n    for char in text:\n        if char.isalpha():\n            shifted = ord(char) + shift\n            if char.islower():\n                encrypted += chr((shifted - 97) % 26 + 97)\n            else:\n                encrypted += chr((shifted - 65) % 26 + 65)\n        else:\n            encrypted += char\n    return encrypted\n\ndef decrypt_caesar(ciphertext, shift):\n    return caesar_cipher(ciphertext, -shift)\n\ndef search_decryption(ciphertext, word_list):\n    for shift in range(26):\n        candidate = decrypt_caesar(ciphertext, shift)\n        words = candidate.split()\n        if any(word.lower() in word_list for word in words):\n            return candidate\n    return None\n\ntext = \"Hello, this is a secret message!\"\nshift = 3\nciphertext = caesar_cipher(text, shift)\n\nword_list = [\"hello\", \"secret\", \"message\"]\n\ndecrypted_message = search_decryption(ciphertext, word_list)\n\nprint(\"Ciphertext:\", ciphertext)\nprint(\"Decrypted message:\", decrypted_message)"}, {"role": "assistant", "content": "Ciphertext: Khoor, wklv lv d vhfuhw phvvdjh!\nDecrypted message: Hello, this is a secret message!\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef fibonacci(n):\n    phi = (1 + math.sqrt(5)) / 2\n    return int(phi**n / math.sqrt(5) + 0.5)\n\ndef is_perfect_square(x):\n    s = int(math.sqrt(x))\n    return s * s == x\n\ndef is_fibonacci(num):\n    return is_perfect_square(5 * num * num + 4) or is_perfect_square(5 * num * num - 4)\n\ndef find_next_fibonacci(start):\n    index = start\n    while True:\n        index += 1\n        if is_fibonacci(index):\n            return index\n\ndef search_sequence(limit):\n    sequence = [fibonacci(n) for n in range(1, limit + 1)]\n    for i in range(2, len(sequence) - 1):\n        if sequence[i] != sequence[i-1] + sequence[i-2]:\n            return sequence[i]\n    return None\n\ndef main():\n    limit = 100\n    unusual_sequence = [find_next_fibonacci(i) for i in range(1, limit)]\n    result = search_sequence(limit)\n    if result:\n        print(\"Found anomaly in sequence:\", result)\n    else:\n        print(\"No anomaly found in the Fibonacci-like sequence.\")\n\nmain()"}, {"role": "assistant", "content": "Found anomaly in sequence: 308061521170130\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\nclass GameScore:\n    def __init__(self, player, score, date):\n        self.player = player\n        self.score = score\n        self.date = date\n\nscores = [\n    GameScore('Alice', 90, datetime(2023, 1, 15)),\n    GameScore('Bob', 85, datetime(2023, 1, 11)),\n    GameScore('Charlie', 90, datetime(2023, 1, 12)),\n    GameScore('David', 80, datetime(2023, 1, 13)),\n    GameScore('Edward', 95, datetime(2023, 1, 10)),\n    GameScore('Fiona', 95, datetime(2023, 1, 14)),\n    GameScore('George', 85, datetime(2023, 1, 13)),\n    GameScore('Hannah', 80, datetime(2023, 1, 11)),\n    GameScore('Ivy', 75, datetime(2023, 1, 15)),\n    GameScore('Jack', 90, datetime(2023, 1, 9)),\n]\n\nsorted_scores = sorted(scores, key=lambda s: (-s.score, s.date, s.player))\n\nfor i, score in enumerate(sorted_scores, start=1):\n    print(f\"Rank {i}: {score.player} - {score.score} (Date: {score.date.strftime('%Y-%m-%d')})\")"}, {"role": "assistant", "content": "Rank 1: Edward - 95 (Date: 2023-01-10)\nRank 2: Fiona - 95 (Date: 2023-01-14)\nRank 3: Jack - 90 (Date: 2023-01-09)\nRank 4: Charlie - 90 (Date: 2023-01-12)\nRank 5: Alice - 90 (Date: 2023-01-15)\nRank 6: Bob - 85 (Date: 2023-01-11)\nRank 7: George - 85 (Date: 2023-01-13)\nRank 8: Hannah - 80 (Date: 2023-01-11)\nRank 9: David - 80 (Date: 2023-01-13)\nRank 10: Ivy - 75 (Date: 2023-01-15)\n"}]}
{"messages": [{"role": "user", "content": "import re\nfrom collections import defaultdict\n\ntext = \"\"\"\nIn the realm of programming, the algorithm is king. It governs the flow of data, \norchestrating operations and steering them toward solutions. Among the many algorithms, \nsearching algorithms are indispensable. They extract the sought-after elements from \nthe vast sea of data, much like a lighthouse guiding ships to safety. \n\"\"\"\n\ndef find_all_occurrences(word, text):\n    start = 0\n    while start < len(text):\n        start = text.find(word, start)\n        if start == -1:\n            break\n        yield start\n        start += len(word)\n\ndef build_inverted_index(text):\n    index = defaultdict(list)\n    words = set(re.findall(r'\\b\\w+\\b', text.lower()))\n    for word in words:\n        for position in find_all_occurrences(word, text.lower()):\n            index[word].append(position)\n    return index\n\ndef search_in_text(query, index):\n    results = []\n    for word in query.lower().split():\n        if word in index:\n            results.append((word, index[word]))\n    return results\n\ninverted_index = build_inverted_index(text)\nsearch_results = search_in_text(\"algorithm data operations\", inverted_index)\n\nfor result in search_results:\n    print(f\"Word: {result[0]}, Positions: {result[1]}\")"}, {"role": "assistant", "content": "Word: algorithm, Positions: [34, 159, 182]\nWord: data, Positions: [76, 273]\nWord: operations, Positions: [97]\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndates = [\n    \"2023-10-04\", \"2022-02-14\", \"2021-12-25\", \"2023-01-01\",\n    \"2024-07-04\", \"2022-11-11\", \"2023-05-05\", \"2023-09-09\",\n    \"2024-01-01\", \"2023-03-03\", \"2021-01-01\", \"2021-11-11\",\n    \"2022-12-12\", \"2023-07-07\", \"2021-05-05\", \"2024-03-03\",\n    \"2023-06-06\", \"2022-01-01\", \"2024-05-05\", \"2023-02-02\"\n]\n\ndate_objects = [datetime.strptime(date, \"%Y-%m-%d\") for date in dates]\n\nprint(\"Dates before sorting:\")\nfor date in date_objects:\n    print(date.strftime(\"%Y-%m-%d\"))\n\ndate_objects.sort()\n\nprint(\"\\nDates after sorting:\")\nfor date in date_objects:\n    print(date.strftime(\"%Y-%m-%d\"))\n\ntoday = datetime.now().strftime(\"%Y-%m-%d\")\nprint(f\"\\nToday's date: {today}\")\n\nsorted_deltas = sorted(\n    (date, abs((date - datetime.now()).days)) for date in date_objects)\nprint(\"\\nDates sorted by closeness to today:\")\nfor date, delta in sorted_deltas:\n    print(f\"{date.strftime('%Y-%m-%d')}, {delta} days away\")"}, {"role": "assistant", "content": "Dates before sorting:\n2023-10-04\n2022-02-14\n2021-12-25\n2023-01-01\n2024-07-04\n2022-11-11\n2023-05-05\n2023-09-09\n2024-01-01\n2023-03-03\n2021-01-01\n2021-11-11\n2022-12-12\n2023-07-07\n2021-05-05\n2024-03-03\n2023-06-06\n2022-01-01\n2024-05-05\n2023-02-02\n\nDates after sorting:\n2021-01-01\n2021-05-05\n2021-11-11\n2021-12-25\n2022-01-01\n2022-02-14\n2022-11-11\n2022-12-12\n2023-01-01\n2023-02-02\n2023-03-03\n2023-05-05\n2023-06-06\n2023-07-07\n2023-09-09\n2023-10-04\n2024-01-01\n2024-03-03\n2024-05-05\n2024-07-04\n\nToday's date: 2025-04-01\n\nDates sorted by closeness to today:\n2021-01-01, 1552 days away\n2021-05-05, 1428 days away\n2021-11-11, 1238 days away\n2021-12-25, 1194 days away\n2022-01-01, 1187 days away\n2022-02-14, 1143 days away\n2022-11-11, 873 days away\n2022-12-12, 842 days away\n2023-01-01, 822 days away\n2023-02-02, 790 days away\n2023-03-03, 761 days away\n2023-05-05, 698 days away\n2023-06-06, 666 days away\n2023-07-07, 635 days away\n2023-09-09, 571 days away\n2023-10-04, 546 days away\n2024-01-01, 457 days away\n2024-03-03, 395 days away\n2024-05-05, 332 days away\n2024-07-04, 272 days away\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndates = [\n    \"2023-10-01\",\n    \"2021-05-15\",\n    \"2022-01-01\",\n    \"2020-12-31\",\n    \"2022-07-04\",\n    \"2021-09-10\",\n    \"2023-01-01\",\n    \"2021-12-25\",\n    \"2022-11-11\",\n    \"2023-07-20\",\n    \"2021-01-01\",\n    \"2023-04-15\",\n    \"2022-03-03\",\n    \"2020-07-07\",\n    \"2023-12-25\"\n]\n\ndef custom_date_sort(date):\n    parsed_date = datetime.datetime.strptime(date, \"%Y-%m-%d\")\n    return (parsed_date.month, parsed_date.day, parsed_date.year)\n\nsorted_dates = sorted(dates, key=custom_date_sort)\n\nprint(\"Intermediate sorted dates (by month, day, then year):\")\nfor date in sorted_dates:\n    print(date)\n\ntransformed_dates = []\nfor date in sorted_dates:\n    parsed_date = datetime.datetime.strptime(date, \"%Y-%m-%d\")\n    transformed_dates.append(f\"{parsed_date.day:02d}-{parsed_date.strftime('%b')}-{parsed_date.year}\")\n\nprint(\"\\nTransformed dates:\")\nfor transformed_date in transformed_dates:\n    print(transformed_date)"}, {"role": "assistant", "content": "Intermediate sorted dates (by month, day, then year):\n2021-01-01\n2022-01-01\n2023-01-01\n2022-03-03\n2023-04-15\n2021-05-15\n2022-07-04\n2020-07-07\n2023-07-20\n2021-09-10\n2023-10-01\n2022-11-11\n2021-12-25\n2023-12-25\n2020-12-31\n\nTransformed dates:\n01-Jan-2021\n01-Jan-2022\n01-Jan-2023\n03-Mar-2022\n15-Apr-2023\n15-May-2021\n04-Jul-2022\n07-Jul-2020\n20-Jul-2023\n10-Sep-2021\n01-Oct-2023\n11-Nov-2022\n25-Dec-2021\n25-Dec-2023\n31-Dec-2020\n"}]}
{"messages": [{"role": "user", "content": "def encode_message(message):\n    return ''.join(chr(ord(char) + 3) for char in message)\n\ndef decode_message(encoded):\n    return ''.join(chr(ord(char) - 3) for char in encoded)\n\ndef custom_sort(encoded_list):\n    return sorted(encoded_list, key=lambda msg: sum(ord(char) for char in msg))\n\nmessage_list = [\n    \"hello\",\n    \"world\",\n    \"python\",\n    \"encryption\",\n    \"algorithm\",\n    \"data\",\n    \"science\",\n    \"programming\",\n    \"sorting\",\n    \"challenge\"\n]\n\nencoded_messages = [encode_message(msg) for msg in message_list]\nsorted_encoded_messages = custom_sort(encoded_messages)\ndecoded_messages = [decode_message(msg) for msg in sorted_encoded_messages]\n\nfor decoded in decoded_messages:\n    print(decoded)"}, {"role": "assistant", "content": "data\nhello\nworld\npython\nscience\nsorting\nchallenge\nalgorithm\nencryption\nprogramming\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef custom_sort_function(num):\n    return num % 10, -num\n\ndef generate_weird_sequence(n):\n    sequence = []\n    for i in range(n):\n        value = int(math.sin(i) * 100) + i * 3\n        sequence.append(value)\n    return sequence\n\ndef main():\n    n = 50\n    sequence = generate_weird_sequence(n)\n    print(\"Original sequence:\")\n    print(sequence)\n\n    sorted_sequence = sorted(sequence, key=custom_sort_function)\n    print(\"\\nSorted sequence (by last digit, descending by number):\")\n    for number in sorted_sequence:\n        print(number)\n\nmain()"}, {"role": "assistant", "content": "Original sequence:\n[0, 87, 96, 23, -63, -80, -9, 86, 122, 68, -24, -66, -17, 81, 141, 110, 20, -45, -21, 71, 151, 146, 66, -15, -18, 62, 154, 176, 111, 21, -8, 53, 151, 198, 154, 63, 9, 47, 143, 213, 194, 108, 35, 46, 133, 220, 228, 153, 68, 52]\n\nSorted sequence (by last digit, descending by number):\n220\n110\n20\n0\n-80\n151\n151\n141\n111\n81\n71\n21\n-9\n122\n62\n52\n-8\n-18\n213\n153\n143\n133\n63\n53\n23\n-17\n194\n154\n154\n-66\n35\n-15\n-45\n176\n146\n96\n86\n66\n46\n-24\n87\n47\n-63\n228\n198\n108\n68\n68\n9\n-21\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef generate_special_numbers(n):\n    numbers = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            numbers.append(i ** 3)\n        else:\n            numbers.append(i ** 2)\n    return numbers\n\ndef custom_sort(numbers):\n    def custom_key(x):\n        return (x % 7, x)\n    \n    sorted_numbers = sorted(numbers, key=custom_key)\n    return sorted_numbers\n\nn = 30\nspecial_numbers = generate_special_numbers(n)\nprint(\"Generated Special Numbers:\")\nprint(special_numbers)\n\nsorted_numbers = custom_sort(special_numbers)\nprint(\"\\nSorted Numbers by Custom Rule:\")\nprint(sorted_numbers)"}, {"role": "assistant", "content": "Generated Special Numbers:\n[1, 8, 9, 64, 25, 216, 49, 512, 81, 1000, 121, 1728, 169, 2744, 225, 4096, 289, 5832, 361, 8000, 441, 10648, 529, 13824, 625, 17576, 729, 21952, 841, 27000]\n\nSorted Numbers by Custom Rule:\n[49, 441, 2744, 21952, 1, 8, 64, 169, 225, 512, 729, 841, 4096, 5832, 10648, 27000, 9, 121, 289, 625, 25, 81, 361, 529, 216, 1000, 1728, 8000, 13824, 17576]\n"}]}
{"messages": [{"role": "user", "content": "from math import factorial\n\ndef binomial_coefficient(n, k):\n    return factorial(n) // (factorial(k) * factorial(n - k))\n\ndef pascal_triangle_row(n):\n    return [binomial_coefficient(n, k) for k in range(n + 1)]\n\ndef sort_rows_by_sum(triangle):\n    return sorted(triangle, key=sum)\n\ndef create_pattern(triangle):\n    max_width = len(' '.join(map(str, triangle[-1])))\n    pattern = []\n    for row in triangle:\n        row_str = ' '.join(map(str, row))\n        centered_row = row_str.center(max_width)\n        pattern.append(centered_row)\n    return pattern\n\nrows = [pascal_triangle_row(i) for i in range(10)]\nsorted_rows = sort_rows_by_sum(rows)\npattern = create_pattern(sorted_rows)\nfor line in pattern:\n    print(line)"}, {"role": "assistant", "content": "             1             \n            1 1            \n           1 2 1           \n          1 3 3 1          \n         1 4 6 4 1         \n       1 5 10 10 5 1       \n      1 6 15 20 15 6 1     \n    1 7 21 35 35 21 7 1    \n   1 8 28 56 70 56 28 8 1  \n1 9 36 84 126 126 84 36 9 1\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\ndef sort_dates_chronologically(dates):\n    return sorted(dates, key=lambda date: datetime.strptime(date, \"%Y-%m-%d\"))\n\ndate_strings = [\n    \"2023-03-15\", \"2025-01-01\", \"2024-07-23\", \"2022-12-31\",\n    \"2023-11-11\", \"2024-02-28\", \"2023-05-15\", \"2022-01-01\",\n    \"2025-06-30\", \"2022-07-19\", \"2024-12-25\", \"2023-09-10\"\n]\n\nsorted_dates = sort_dates_chronologically(date_strings)\n\nfor date in sorted_dates:\n    print(date)"}, {"role": "assistant", "content": "2022-01-01\n2022-07-19\n2022-12-31\n2023-03-15\n2023-05-15\n2023-09-10\n2023-11-11\n2024-02-28\n2024-07-23\n2024-12-25\n2025-01-01\n2025-06-30\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef find_fridays_13th(year_start, year_end):\n    fridays_13th = []\n    for year in range(year_start, year_end + 1):\n        for month in range(1, 13):\n            date = datetime(year, month, 13)\n            if date.weekday() == 4:  # Friday\n                fridays_13th.append(date.strftime('%Y-%m-%d'))\n    return fridays_13th\n\ndef binary_search_dates(dates, target):\n    low, high = 0, len(dates) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if dates[mid] < target:\n            low = mid + 1\n        elif dates[mid] > target:\n            high = mid - 1\n        else:\n            return mid\n    return -1\n\nstart_year = 1900\nend_year = 2023\nfridays_13th = find_fridays_13th(start_year, end_year)\n\ntarget_dates = [\n    '1998-02-13', '2009-03-13', '2012-07-13', '2023-01-13',\n    '1987-02-13', '2002-12-13', '2015-11-13', '1970-03-13'\n]\n\nfor date in target_dates:\n    result = binary_search_dates(fridays_13th, date)\n    if result != -1:\n        print(f\"{date} is a Friday the 13th.\")\n    else:\n        print(f\"{date} is not a Friday the 13th.\")"}, {"role": "assistant", "content": "1998-02-13 is a Friday the 13th.\n2009-03-13 is a Friday the 13th.\n2012-07-13 is a Friday the 13th.\n2023-01-13 is a Friday the 13th.\n1987-02-13 is a Friday the 13th.\n2002-12-13 is a Friday the 13th.\n2015-11-13 is a Friday the 13th.\n1970-03-13 is a Friday the 13th.\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef custom_sort_word(word):\n    return ''.join(sorted(word))\n\ndef process_text(text):\n    words = re.findall(r'\\b\\w+\\b', text)\n    sorted_words = []\n    \n    for word in words:\n        sorted_word = custom_sort_word(word)\n        sorted_words.append(sorted_word)\n        print(f\"Original: {word}, Sorted: {sorted_word}\")\n    \n    sorted_words.sort()\n    return sorted_words\n\ntext = \"\"\"\nSorting algorithms are a fundamental part of computer science. \nThey are used to arrange data in a particular order. \nQuick sort, merge sort, and bubble sort are some of the popular sorting algorithms.\n\"\"\"\n\nsorted_words = process_text(text)\nprint(\"\\nFinal Sorted Word List:\")\nfor word in sorted_words:\n    print(word)"}, {"role": "assistant", "content": "Original: Sorting, Sorted: Sginort\nOriginal: algorithms, Sorted: aghilmorst\nOriginal: are, Sorted: aer\nOriginal: a, Sorted: a\nOriginal: fundamental, Sorted: aadeflmnntu\nOriginal: part, Sorted: aprt\nOriginal: of, Sorted: fo\nOriginal: computer, Sorted: cemoprtu\nOriginal: science, Sorted: cceeins\nOriginal: They, Sorted: Tehy\nOriginal: are, Sorted: aer\nOriginal: used, Sorted: desu\nOriginal: to, Sorted: ot\nOriginal: arrange, Sorted: aaegnrr\nOriginal: data, Sorted: aadt\nOriginal: in, Sorted: in\nOriginal: a, Sorted: a\nOriginal: particular, Sorted: aacilprrtu\nOriginal: order, Sorted: deorr\nOriginal: Quick, Sorted: Qciku\nOriginal: sort, Sorted: orst\nOriginal: merge, Sorted: eegmr\nOriginal: sort, Sorted: orst\nOriginal: and, Sorted: adn\nOriginal: bubble, Sorted: bbbelu\nOriginal: sort, Sorted: orst\nOriginal: are, Sorted: aer\nOriginal: some, Sorted: emos\nOriginal: of, Sorted: fo\nOriginal: the, Sorted: eht\nOriginal: popular, Sorted: aloppru\nOriginal: sorting, Sorted: ginorst\nOriginal: algorithms, Sorted: aghilmorst\n\nFinal Sorted Word List:\nQciku\nSginort\nTehy\na\na\naacilprrtu\naadeflmnntu\naadt\naaegnrr\nadn\naer\naer\naer\naghilmorst\naghilmorst\naloppru\naprt\nbbbelu\ncceeins\ncemoprtu\ndeorr\ndesu\neegmr\neht\nemos\nfo\nfo\nginorst\nin\norst\norst\norst\not\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef next_weekday(d, weekday):\n    days_ahead = weekday - d.weekday()\n    if days_ahead <= 0:\n        days_ahead += 7\n    return d + timedelta(days_ahead)\n\ndef find_fridays_13th(start_year, end_year):\n    fridays_13th = []\n    for year in range(start_year, end_year + 1):\n        for month in range(1, 13):\n            date = datetime(year, month, 13)\n            if date.weekday() == 4:\n                fridays_13th.append(date.strftime('%Y-%m-%d'))\n    return fridays_13th\n\ndef find_nearest_friday_13th(current_date):\n    current_date = datetime.strptime(current_date, '%Y-%m-%d')\n    if current_date.day > 13:\n        current_date = next_weekday(current_date.replace(day=1, month=current_date.month % 12 + 1), 4)\n    else:\n        current_date = next_weekday(current_date.replace(day=13), 4)\n    \n    year = current_date.year\n    if current_date.month == 1 and current_date.day > 13:\n        year += 1\n    \n    fridays_13th = find_fridays_13th(year, year + 1)\n    \n    for friday in fridays_13th:\n        friday_date = datetime.strptime(friday, '%Y-%m-%d')\n        if friday_date >= current_date:\n            return friday\n\nstart_date = \"2024-02-12\"\nnearest_friday_13th = find_nearest_friday_13th(start_date)\nprint(f\"The nearest Friday the 13th after {start_date} is {nearest_friday_13th}\")"}, {"role": "assistant", "content": "The nearest Friday the 13th after 2024-02-12 is 2024-09-13\n"}]}
{"messages": [{"role": "user", "content": "import re\nfrom datetime import datetime, timedelta\n\ndef find_next_event(events, current_time):\n    left, right = 0, len(events) - 1\n    result = None\n    while left <= right:\n        mid = left + (right - left) // 2\n        if events[mid] >= current_time:\n            result = events[mid]\n            right = mid - 1\n        else:\n            left = mid + 1\n    return result\n\ndef parse_events(event_strings):\n    pattern = re.compile(r'(\\d{2}:\\d{2})')\n    events = []\n    for event in event_strings:\n        match = pattern.search(event)\n        if match:\n            event_time = datetime.strptime(match.group(1), \"%H:%M\").time()\n            events.append(event_time)\n    return sorted(events)\n\nevent_descriptions = [\n    \"Meeting at 09:00\",\n    \"Lunch at 12:30\",\n    \"Conference at 15:00\",\n    \"Standup at 10:15\",\n    \"Code Review at 14:45\",\n    \"Wrap-up at 16:30\"\n]\n\ncurrent_time = datetime.now().time()\nevents = parse_events(event_descriptions)\nnext_event = find_next_event(events, current_time)\n\noutput = []\ntime_format = \"%H:%M\"\nfor i, event in enumerate(events):\n    time_str = event.strftime(time_format)\n    if event == next_event:\n        output.append(f\"Next Event --> {event_descriptions[i]}\")\n    else:\n        output.append(f\"Upcoming Event: {event_descriptions[i]}\")\n\nfor line in output:\n    print(line)"}, {"role": "assistant", "content": "Upcoming Event: Meeting at 09:00\nUpcoming Event: Lunch at 12:30\nUpcoming Event: Conference at 15:00\nUpcoming Event: Standup at 10:15\nUpcoming Event: Code Review at 14:45\nNext Event --> Wrap-up at 16:30\n"}]}
{"messages": [{"role": "user", "content": "import datetime\nimport math\n\ndata = [\n    {\"name\": \"Alice\", \"date\": \"2022-01-15\", \"value\": 3.5},\n    {\"name\": \"Bob\", \"date\": \"2022-02-14\", \"value\": 7.1},\n    {\"name\": \"Charlie\", \"date\": \"2022-03-30\", \"value\": 5.9},\n    {\"name\": \"Diana\", \"date\": \"2022-01-01\", \"value\": 9.2},\n    {\"name\": \"Evan\", \"date\": \"2022-04-12\", \"value\": 6.4},\n    {\"name\": \"Fay\", \"date\": \"2022-02-10\", \"value\": 8.8},\n    {\"name\": \"George\", \"date\": \"2022-03-05\", \"value\": 2.3},\n    {\"name\": \"Hannah\", \"date\": \"2022-03-15\", \"value\": 4.7},\n]\n\ndef date_to_days(date_str):\n    date = datetime.datetime.strptime(date_str, \"%Y-%m-%d\")\n    return (date - datetime.datetime(2022, 1, 1)).days\n\ndef binary_search(data, target_date):\n    low, high = 0, len(data) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        mid_days = date_to_days(data[mid][\"date\"])\n        print(f\"Searching between: {low} and {high}, mid: {mid}, mid_days: {mid_days}\")\n        if mid_days < target_date:\n            low = mid + 1\n        elif mid_days > target_date:\n            high = mid - 1\n        else:\n            return mid\n    return -1\n\nsorted_data = sorted(data, key=lambda x: date_to_days(x[\"date\"]))\n\nsearch_dates = [\"2022-01-15\", \"2022-03-30\", \"2022-02-10\", \"2022-04-12\"]\nresults = []\n\nfor date in search_dates:\n    days = date_to_days(date)\n    print(f\"\\nSearching for date: {date} which is {days} days from 2022-01-01\")\n    index = binary_search(sorted_data, days)\n    if index != -1:\n        results.append((date, sorted_data[index][\"name\"], sorted_data[index][\"value\"]))\n    else:\n        results.append((date, None, None))\n\nfor result in results:\n    print(f\"Date: {result[0]}, Name: {result[1]}, Value: {result[2]}\")"}, {"role": "assistant", "content": "\nSearching for date: 2022-01-15 which is 14 days from 2022-01-01\nSearching between: 0 and 7, mid: 3, mid_days: 44\nSearching between: 0 and 2, mid: 1, mid_days: 14\n\nSearching for date: 2022-03-30 which is 88 days from 2022-01-01\nSearching between: 0 and 7, mid: 3, mid_days: 44\nSearching between: 4 and 7, mid: 5, mid_days: 73\nSearching between: 6 and 7, mid: 6, mid_days: 88\n\nSearching for date: 2022-02-10 which is 40 days from 2022-01-01\nSearching between: 0 and 7, mid: 3, mid_days: 44\nSearching between: 0 and 2, mid: 1, mid_days: 14\nSearching between: 2 and 2, mid: 2, mid_days: 40\n\nSearching for date: 2022-04-12 which is 101 days from 2022-01-01\nSearching between: 0 and 7, mid: 3, mid_days: 44\nSearching between: 4 and 7, mid: 5, mid_days: 73\nSearching between: 6 and 7, mid: 6, mid_days: 88\nSearching between: 7 and 7, mid: 7, mid_days: 101\nDate: 2022-01-15, Name: Alice, Value: 3.5\nDate: 2022-03-30, Name: Charlie, Value: 5.9\nDate: 2022-02-10, Name: Fay, Value: 8.8\nDate: 2022-04-12, Name: Evan, Value: 6.4\n"}]}
{"messages": [{"role": "user", "content": "import math\nimport statistics\n\ndef calculate_standard_deviation(arr, mean):\n    variance = sum((x - mean) ** 2 for x in arr) / len(arr)\n    return math.sqrt(variance)\n\ndef binary_search_closest(arr, target):\n    low, high = 0, len(arr) - 1\n    if target < arr[low]:\n        return arr[low]\n    if target > arr[high]:\n        return arr[high]\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return arr[mid]\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return arr[low] if abs(arr[low] - target) < abs(arr[high] - target) else arr[high]\n\ndata = [12, 15, 23, 42, 55, 67, 78, 81, 95, 100, 115, 120, 130, 150, 175, 200]\nprint(\"Data:\", data)\n\nmean = statistics.mean(data)\nprint(\"Mean of data:\", mean)\n\nstd_dev = calculate_standard_deviation(data, mean)\nprint(\"Calculated Standard Deviation:\", std_dev)\n\noutliers = []\nfor num in data:\n    if abs(num - mean) > 1.5 * std_dev:\n        outliers.append(num)\n\nprint(\"Outliers detected:\", outliers)\n\nsearch_values = [50, 90, 160, 300]\nclosest_values = []\n\nfor val in search_values:\n    closest = binary_search_closest(data, val)\n    closest_values.append((val, closest))\n    print(f\"Closest to {val}: {closest}\")\n\nprint(\"Final closest value pairs:\", closest_values)"}, {"role": "assistant", "content": "Data: [12, 15, 23, 42, 55, 67, 78, 81, 95, 100, 115, 120, 130, 150, 175, 200]\nMean of data: 91.125\nCalculated Standard Deviation: 53.988279978158225\nOutliers detected: [175, 200]\nClosest to 50: 55\nClosest to 90: 95\nClosest to 160: 150\nClosest to 300: 200\nFinal closest value pairs: [(50, 55), (90, 95), (160, 150), (300, 200)]\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef sort_dates_chronologically(dates):\n    return sorted(dates, key=lambda date: datetime.datetime.strptime(date, '%Y-%m-%d'))\n\ndate_strings = [\n    '2023-01-01', '2022-05-05', '2023-06-15', '2021-12-25', \n    '2023-03-17', '2022-07-19', '2021-11-11', '2023-09-30',\n    '2022-01-01', '2023-04-01', '2021-10-10', '2023-08-08'\n]\n\nsorted_dates = sort_dates_chronologically(date_strings)\n\nfor date in sorted_dates:\n    print(date)"}, {"role": "assistant", "content": "2021-10-10\n2021-11-11\n2021-12-25\n2022-01-01\n2022-05-05\n2022-07-19\n2023-01-01\n2023-03-17\n2023-04-01\n2023-06-15\n2023-08-08\n2023-09-30\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef custom_sort(data):\n    return sorted(data, key=lambda x: (x[1], -x[0]))\n\ndata_points = [\n    (5, 7), (8, 3), (2, 9), (4, 5), (9, 1), \n    (3, 4), (7, 8), (1, 6), (6, 2), (10, 0)\n]\n\nsorted_points = custom_sort(data_points)\nprint(\"Sorted Points:\")\nfor point in sorted_points:\n    print(point)\n\ndef calculate_distance(point):\n    return math.sqrt(point[0]**2 + point[1]**2)\n\ndistances = [calculate_distance(point) for point in sorted_points]\n\nprint(\"\\nDistances from Origin:\")\nfor distance in distances:\n    print(f\"{distance:.2f}\")\n\naverage_distance = sum(distances) / len(distances)\nprint(f\"\\nAverage Distance: {average_distance:.2f}\")\n\nmedian_distance = sorted(distances)[len(distances) // 2]\nprint(f\"Median Distance: {median_distance:.2f}\")\n\nvariance = sum((distance - average_distance) ** 2 for distance in distances) / len(distances)\nprint(f\"Variance: {variance:.2f}\")\n\nsorted_distances = sorted(distances)\nprint(\"\\nSorted Distances:\")\nfor distance in sorted_distances:\n    print(f\"{distance:.2f}\")"}, {"role": "assistant", "content": "Sorted Points:\n(10, 0)\n(9, 1)\n(6, 2)\n(8, 3)\n(3, 4)\n(4, 5)\n(1, 6)\n(5, 7)\n(7, 8)\n(2, 9)\n\nDistances from Origin:\n10.00\n9.06\n6.32\n8.54\n5.00\n6.40\n6.08\n8.60\n10.63\n9.22\n\nAverage Distance: 7.99\nMedian Distance: 8.60\nVariance: 3.22\n\nSorted Distances:\n5.00\n6.08\n6.32\n6.40\n8.54\n8.60\n9.06\n9.22\n10.00\n10.63\n"}]}
{"messages": [{"role": "user", "content": "import string\n\ndef caesar_cipher(text, shift):\n    alphabet = string.ascii_lowercase\n    shifted = alphabet[shift:] + alphabet[:shift]\n    table = str.maketrans(alphabet + alphabet.upper(), shifted + shifted.upper())\n    return text.translate(table)\n\ndef find_shifted_message(encoded_message, target_word):\n    for shift in range(26):\n        decoded_message = caesar_cipher(encoded_message, shift)\n        if target_word in decoded_message:\n            return shift, decoded_message\n    return None, None\n\nencoded_message = \"Uifsf jt b tfdsfu dpef jo uijt nfttbhf!\"\ntarget_word = \"secret\"\n\nshift, decoded_message = find_shifted_message(encoded_message, target_word)\nif decoded_message:\n    print(f\"Shift found: {shift}\")\n    print(\"Decoded Message:\")\n    print(decoded_message)\nelse:\n    print(\"No valid shift found.\")"}, {"role": "assistant", "content": "Shift found: 25\nDecoded Message:\nThere is a secret code in this message!\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef analyze_data(data):\n    if not data:\n        return []\n\n    sorted_data = sorted(data, key=lambda x: x[1])\n    median_index = len(sorted_data) // 2\n    median_date = sorted_data[median_index][1]\n    \n    def binary_search(arr, target_date):\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            mid_date = arr[mid][1]\n            if mid_date == target_date:\n                return mid\n            elif mid_date < target_date:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n    \n    index = binary_search(sorted_data, median_date)\n    start_date = sorted_data[0][1]\n    end_date = sorted_data[-1][1]\n    \n    return [\n        f\"Total entries: {len(data)}\",\n        f\"Median entry: {sorted_data[median_index][0]}\",\n        f\"Entry found at index: {index}\",\n        f\"Date range: {start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}\"\n    ]\n\ndata = [\n    (\"Event A\", datetime(2023, 1, 15)),\n    (\"Event B\", datetime(2023, 3, 22)),\n    (\"Event C\", datetime(2023, 2, 9)),\n    (\"Event D\", datetime(2023, 1, 25)),\n    (\"Event E\", datetime(2023, 4, 5)),\n    (\"Event F\", datetime(2023, 2, 28)),\n    (\"Event G\", datetime(2023, 3, 15)),\n    (\"Event H\", datetime(2023, 5, 10)),\n    (\"Event I\", datetime(2023, 1, 5)),\n    (\"Event J\", datetime(2023, 2, 14)),\n    (\"Event K\", datetime(2023, 3, 1)),\n    (\"Event L\", datetime(2023, 4, 21)),\n    (\"Event M\", datetime(2023, 5, 2)),\n    (\"Event N\", datetime(2023, 2, 18)),\n    (\"Event O\", datetime(2023, 1, 10))\n]\n\nresults = analyze_data(data)\nfor line in results:\n    print(line)"}, {"role": "assistant", "content": "Total entries: 15\nMedian entry: Event F\nEntry found at index: 7\nDate range: 2023-01-05 to 2023-05-10\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef calculate_distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\ndef sort_triangles_by_perimeter(triangles):\n    def perimeter(triangle):\n        a, b, c = triangle\n        return (calculate_distance(a, b) +\n                calculate_distance(b, c) +\n                calculate_distance(c, a))\n    \n    print(\"Calculating perimeters for sorting:\")\n    for tri in triangles:\n        print(f\"Triangle {tri} perimeter: {perimeter(tri)}\")\n    sorted_tris = sorted(triangles, key=perimeter)\n    print(\"Triangles sorted by perimeter:\")\n    for tri in sorted_tris:\n        print(f\"Triangle {tri} perimeter: {perimeter(tri)}\")\n    return sorted_tris\n\ntriangles = [\n    [(0, 0), (3, 4), (3, 0)],\n    [(1, 1), (4, 5), (4, 1)],\n    [(2, 2), (5, 6), (5, 2)],\n    [(0, 0), (1, 1), (1, 0)]\n]\n\nsorted_triangles = sort_triangles_by_perimeter(triangles)\n\nprint(\"Triangles sorted by incorrect algorithm:\")\nfor tri in sorted_triangles:\n    print(f\"Triangle {tri} perimeter: {calculate_distance(tri[0], tri[1]) + calculate_distance(tri[1], tri[2]) + calculate_distance(tri[2], tri[0])}\")"}, {"role": "assistant", "content": "Calculating perimeters for sorting:\nTriangle [(0, 0), (3, 4), (3, 0)] perimeter: 12.0\nTriangle [(1, 1), (4, 5), (4, 1)] perimeter: 12.0\nTriangle [(2, 2), (5, 6), (5, 2)] perimeter: 12.0\nTriangle [(0, 0), (1, 1), (1, 0)] perimeter: 3.414213562373095\nTriangles sorted by perimeter:\nTriangle [(0, 0), (1, 1), (1, 0)] perimeter: 3.414213562373095\nTriangle [(0, 0), (3, 4), (3, 0)] perimeter: 12.0\nTriangle [(1, 1), (4, 5), (4, 1)] perimeter: 12.0\nTriangle [(2, 2), (5, 6), (5, 2)] perimeter: 12.0\nTriangles sorted by incorrect algorithm:\nTriangle [(0, 0), (1, 1), (1, 0)] perimeter: 3.414213562373095\nTriangle [(0, 0), (3, 4), (3, 0)] perimeter: 12.0\nTriangle [(1, 1), (4, 5), (4, 1)] perimeter: 12.0\nTriangle [(2, 2), (5, 6), (5, 2)] perimeter: 12.0\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef find_anagrams(word, text):\n    word_sorted = ''.join(sorted(word))\n    potential_anagrams = re.findall(r'\\b\\w+\\b', text)\n    anagrams = []\n    for candidate in potential_anagrams:\n        if candidate != word and ''.join(sorted(candidate)) == word_sorted:\n            anagrams.append(candidate)\n    return anagrams\n\ntext = \"\"\"\nListen, silent, enlist, inlets, tinsel, listen, banana, google, inlets, silent, stone, notes, tones\n\"\"\"\n\nresult = find_anagrams(\"listen\", text)\n\nfor index, anagram in enumerate(result, 1):\n    print(f\"{index}: {anagram}\")"}, {"role": "assistant", "content": "1: silent\n2: enlist\n3: inlets\n4: tinsel\n5: inlets\n6: silent\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\nimport re\n\ndata = [\n    \"2023-01-15 Event A\",\n    \"2023-01-10 Event B\",\n    \"2023-02-20 Event C\",\n    \"2023-01-25 Event D\",\n    \"2023-02-10 Event E\",\n    \"2023-03-01 Event F\",\n    \"2023-01-05 Event G\",\n    \"2023-01-20 Event H\",\n    \"2023-02-01 Event I\",\n    \"2023-03-15 Event J\"\n]\n\ndef parse_date(event):\n    match = re.match(r\"(\\d{4}-\\d{2}-\\d{2})\", event)\n    return datetime.strptime(match.group(1), \"%Y-%m-%d\")\n\nsorted_data = sorted(data, key=parse_date)\n\ndef find_events_in_month(events, month, year):\n    return [event for event in events if parse_date(event).month == month and parse_date(event).year == year]\n\nfor y in range(2023, 2024):\n    for m in range(1, 4):\n        events = find_events_in_month(sorted_data, m, y)\n        print(f\"Events for {y}-{m:02}:\")\n        for event in events:\n            print(event)\n        print(\"-\" * 30)"}, {"role": "assistant", "content": "Events for 2023-01:\n2023-01-05 Event G\n2023-01-10 Event B\n2023-01-15 Event A\n2023-01-20 Event H\n2023-01-25 Event D\n------------------------------\nEvents for 2023-02:\n2023-02-01 Event I\n2023-02-10 Event E\n2023-02-20 Event C\n------------------------------\nEvents for 2023-03:\n2023-03-01 Event F\n2023-03-15 Event J\n------------------------------\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef find_closest_median_index(data):\n    median = statistics.median(data)\n    print(f\"Calculated Median: {median}\")\n    \n    closest_index = None\n    smallest_difference = float('inf')\n    \n    for i, value in enumerate(data):\n        difference = abs(value - median)\n        print(f\"Index: {i}, Value: {value}, Difference from Median: {difference}\")\n        \n        if difference < smallest_difference:\n            smallest_difference = difference\n            closest_index = i\n            print(f\"New Closest Index: {closest_index} with Difference: {smallest_difference}\")\n    \n    return closest_index\n\ndata_set = [10, 15, 21, 23, 28, 33, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]\nprint(f\"Data Set: {data_set}\")\nclosest_index = find_closest_median_index(data_set)\nprint(f\"Index of the value closest to the median: {closest_index}\")\nprint(f\"Value at that index: {data_set[closest_index]}\")"}, {"role": "assistant", "content": "Data Set: [10, 15, 21, 23, 28, 33, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]\nCalculated Median: 55\nIndex: 0, Value: 10, Difference from Median: 45\nNew Closest Index: 0 with Difference: 45\nIndex: 1, Value: 15, Difference from Median: 40\nNew Closest Index: 1 with Difference: 40\nIndex: 2, Value: 21, Difference from Median: 34\nNew Closest Index: 2 with Difference: 34\nIndex: 3, Value: 23, Difference from Median: 32\nNew Closest Index: 3 with Difference: 32\nIndex: 4, Value: 28, Difference from Median: 27\nNew Closest Index: 4 with Difference: 27\nIndex: 5, Value: 33, Difference from Median: 22\nNew Closest Index: 5 with Difference: 22\nIndex: 6, Value: 45, Difference from Median: 10\nNew Closest Index: 6 with Difference: 10\nIndex: 7, Value: 50, Difference from Median: 5\nNew Closest Index: 7 with Difference: 5\nIndex: 8, Value: 55, Difference from Median: 0\nNew Closest Index: 8 with Difference: 0\nIndex: 9, Value: 60, Difference from Median: 5\nIndex: 10, Value: 65, Difference from Median: 10\nIndex: 11, Value: 70, Difference from Median: 15\nIndex: 12, Value: 75, Difference from Median: 20\nIndex: 13, Value: 80, Difference from Median: 25\nIndex: 14, Value: 85, Difference from Median: 30\nIndex: 15, Value: 90, Difference from Median: 35\nIndex: 16, Value: 95, Difference from Median: 40\nIndex of the value closest to the median: 8\nValue at that index: 55\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef encode_message(message, shift):\n    encoded = []\n    for char in message:\n        if char.isalpha():\n            shifted = ord(char) + shift\n            if char.islower():\n                if shifted > ord('z'):\n                    shifted -= 26\n                encoded.append(chr(shifted))\n            elif char.isupper():\n                if shifted > ord('Z'):\n                    shifted -= 26\n                encoded.append(chr(shifted))\n        else:\n            encoded.append(char)\n    return ''.join(encoded)\n\ndef decode_message(encoded_message, shift):\n    return encode_message(encoded_message, -shift)\n\ndef search_encoded_word(encoded_text, word):\n    for i in range(26):\n        decoded_text = decode_message(encoded_text, i)\n        print(f\"Trying shift {i}: {decoded_text}\")\n        if word in decoded_text:\n            return decoded_text\n    return \"Not Found\"\n\noriginal_message = \"Hello World! This is a secret message.\"\nencoded_message = encode_message(original_message, 5)\n\nprint(f\"Encoded Message: {encoded_message}\")\n\nword_to_find = \"secret\"\nresult = search_encoded_word(encoded_message, word_to_find)\n\nprint(f\"Decoded Message containing '{word_to_find}': {result}\")"}, {"role": "assistant", "content": "Encoded Message: Mjqqt Btwqi! Ymnx nx f xjhwjy rjxxflj.\nTrying shift 0: Mjqqt Btwqi! Ymnx nx f xjhwjy rjxxflj.\nTrying shift 1: Lipps Asvph! Xlmw mw e wigvix qiwweki.\nTrying shift 2: Khoor @ruog! Wklv lv d vhfuhw phvvdjh.\nTrying shift 3: Jgnnq ?qtnf! Vjku ku c ugetgv oguucig.\nTrying shift 4: Ifmmp >psme! Uijt jt b tfdsfu nfttbhf.\nTrying shift 5: Hello =orld! This is a secret message.\nDecoded Message containing 'secret': Hello =orld! This is a secret message.\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef polar_angle(x, y):\n    return math.atan2(y, x)\n\ndef distance(origin, point):\n    ox, oy = origin\n    px, py = point\n    return math.sqrt((ox - px) ** 2 + (oy - py) ** 2)\n\ndef sort_points_by_angle(points, origin=(0, 0)):\n    return sorted(points, key=lambda point: (polar_angle(point[0] - origin[0], point[1] - origin[1]), distance(origin, point)))\n\ndef create_star_points(num_points, radius_outer, radius_inner):\n    points = []\n    angle_between_points = math.pi / num_points\n    for i in range(num_points * 2):\n        angle = i * angle_between_points\n        radius = radius_outer if i % 2 == 0 else radius_inner\n        x = math.cos(angle) * radius\n        y = math.sin(angle) * radius\n        points.append((x, y))\n    return points\n\nstar_points = create_star_points(5, 10, 5)\nsorted_star_points = sort_points_by_angle(star_points)\n\nfor point in sorted_star_points:\n    print(f\"{point[0]:.2f}, {point[1]:.2f}\")"}, {"role": "assistant", "content": "-8.09, -5.88\n-1.55, -4.76\n3.09, -9.51\n4.05, -2.94\n10.00, 0.00\n4.05, 2.94\n3.09, 9.51\n-1.55, 4.76\n-8.09, 5.88\n-5.00, 0.00\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef find_first_sunday_of_each_year(start_year, end_year):\n    first_sundays = []\n    for year in range(start_year, end_year + 1):\n        date = datetime(year, 1, 1)\n        while date.weekday() != 6:\n            date += timedelta(days=1)\n        first_sundays.append(date)\n    return first_sundays\n\ndef search_for_first_friday_of_each_year(start_year, end_year):\n    first_fridays = []\n    for year in range(start_year, end_year + 1):\n        date = datetime(year, 1, 1)\n        while date.weekday() != 4:\n            date += timedelta(days=1)\n        first_fridays.append(date)\n    return first_fridays\n\ndef main():\n    start_year = 2020\n    end_year = 2029\n\n    sundays = find_first_sunday_of_each_year(start_year, end_year)\n    fridays = search_for_first_friday_of_each_year(start_year, end_year)\n\n    print(\"First Sundays:\")\n    for sunday in sundays:\n        print(sunday.strftime(\"%Y-%m-%d\"))\n\n    print(\"\\nFirst Fridays:\")\n    for friday in fridays:\n        print(friday.strftime(\"%Y-%m-%d\"))\n\nmain()"}, {"role": "assistant", "content": "First Sundays:\n2020-01-05\n2021-01-03\n2022-01-02\n2023-01-01\n2024-01-07\n2025-01-05\n2026-01-04\n2027-01-03\n2028-01-02\n2029-01-07\n\nFirst Fridays:\n2020-01-03\n2021-01-01\n2022-01-07\n2023-01-06\n2024-01-05\n2025-01-03\n2026-01-02\n2027-01-01\n2028-01-07\n2029-01-05\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndata = [15, 21, 18, 30, 24, 45, 33, 28, 39, 50, 41, 38, 27, 19, 11, 42, 31, 26, 23, 29, 32, 35, 37]\ntarget_median = 30\n\ndef binary_search_median(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        sublist = arr[:mid + 1]\n        current_median = statistics.median(sublist)\n        print(f\"Checking sublist {sublist}, Current Median: {current_median}\")\n        if current_median == target:\n            return mid + 1\n        elif current_median < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\nsorted_data = sorted(data)\nprint(f\"Sorted Data: {sorted_data}\")\n\nresult_index = binary_search_median(sorted_data, target_median)\nif result_index != -1:\n    print(f\"Target median {target_median} first achieved with sublist: {sorted_data[:result_index]}\")\nelse:\n    print(\"Target median not found in any sublist.\")"}, {"role": "assistant", "content": "Sorted Data: [11, 15, 18, 19, 21, 23, 24, 26, 27, 28, 29, 30, 31, 32, 33, 35, 37, 38, 39, 41, 42, 45, 50]\nChecking sublist [11, 15, 18, 19, 21, 23, 24, 26, 27, 28, 29, 30], Current Median: 23.5\nChecking sublist [11, 15, 18, 19, 21, 23, 24, 26, 27, 28, 29, 30, 31, 32, 33, 35, 37, 38], Current Median: 27.5\nChecking sublist [11, 15, 18, 19, 21, 23, 24, 26, 27, 28, 29, 30, 31, 32, 33, 35, 37, 38, 39, 41, 42], Current Median: 29\nChecking sublist [11, 15, 18, 19, 21, 23, 24, 26, 27, 28, 29, 30, 31, 32, 33, 35, 37, 38, 39, 41, 42, 45], Current Median: 29.5\nChecking sublist [11, 15, 18, 19, 21, 23, 24, 26, 27, 28, 29, 30, 31, 32, 33, 35, 37, 38, 39, 41, 42, 45, 50], Current Median: 30\nTarget median 30 first achieved with sublist: [11, 15, 18, 19, 21, 23, 24, 26, 27, 28, 29, 30, 31, 32, 33, 35, 37, 38, 39, 41, 42, 45, 50]\n"}]}
{"messages": [{"role": "user", "content": "from collections import deque\n\ndef solve_maze(maze):\n    start = (0, 0)\n    goal = (len(maze) - 1, len(maze[0]) - 1)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set(start)\n\n    while queue:\n        (current, path) = queue.popleft()\n        if current == goal:\n            return path\n        for direction in directions:\n            next_step = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= next_step[0] < len(maze) and 0 <= next_step[1] < len(maze[0]) and next_step not in visited:\n                if maze[next_step[0]][next_step[1]] == 0:\n                    queue.append((next_step, path + [next_step]))\n                    visited.add(next_step)\n\nmaze = [\n    [0, 1, 0, 0, 0, 1, 0],\n    [0, 1, 0, 1, 0, 1, 0],\n    [0, 0, 0, 1, 0, 1, 0],\n    [1, 1, 0, 1, 0, 0, 0],\n    [0, 0, 0, 0, 1, 1, 0],\n    [0, 1, 1, 1, 0, 1, 1],\n    [0, 0, 0, 0, 0, 0, 0]\n]\n\npath = solve_maze(maze)\nmaze_path = [[' ' for _ in row] for row in maze]\nfor x, y in path:\n    maze_path[x][y] = '*'\nmaze_path[0][0] = 'S'\nmaze_path[len(maze) - 1][len(maze[0]) - 1] = 'G'\n\nfor row in maze_path:\n    print(' '.join(row))"}, {"role": "assistant", "content": "S            \n*            \n* * *        \n    *        \n* * *        \n*            \n* * * * * * G\n"}]}
{"messages": [{"role": "user", "content": "def sort_hand_ranks(hands):\n    rank_order = {'high card': 1, 'pair': 2, 'two pair': 3, 'three of a kind': 4,\n                  'straight': 5, 'flush': 6, 'full house': 7, 'four of a kind': 8, 'straight flush': 9}\n\n    def rank_value(hand):\n        return rank_order[hand]\n\n    return sorted(hands, key=rank_value, reverse=True)\n\nhands = [\"pair\", \"straight\", \"high card\", \"flush\", \"two pair\", \"three of a kind\", \"full house\", \"four of a kind\", \"straight flush\"]\nsorted_hands = sort_hand_ranks(hands)\n\nfor rank in sorted_hands:\n    print(rank)"}, {"role": "assistant", "content": "straight flush\nfour of a kind\nfull house\nflush\nstraight\nthree of a kind\ntwo pair\npair\nhigh card\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef encode_message(msg):\n    return [ord(char) * 3 for char in msg]\n\ndef sort_encoded_message(encoded_msg):\n    return sorted(encoded_msg, key=lambda x: x % 10)\n\ndef decode_message(encoded_msg):\n    return ''.join(chr(math.floor(num / 3)) for num in encoded_msg)\n\nmessage = \"IntermediateEncryption\"\nencoded_msg = encode_message(message)\nsorted_encoded_msg = sort_encoded_message(encoded_msg)\ndecoded_msg = decode_message(sorted_encoded_msg)\n\nfor original, encoded, sorted_encoded, decoded in zip(message, encoded_msg, sorted_encoded_msg, decoded_msg):\n    print(f\"{original} -> {encoded} -> {sorted_encoded} -> {decoded}\")"}, {"role": "assistant", "content": "I -> 219 -> 330 -> n\nn -> 330 -> 300 -> d\nt -> 348 -> 330 -> n\ne -> 303 -> 330 -> n\nr -> 342 -> 291 -> a\nm -> 327 -> 342 -> r\ne -> 303 -> 342 -> r\nd -> 300 -> 303 -> e\ni -> 315 -> 303 -> e\na -> 291 -> 303 -> e\nt -> 348 -> 363 -> y\ne -> 303 -> 333 -> o\nE -> 207 -> 315 -> i\nn -> 330 -> 315 -> i\nc -> 297 -> 336 -> p\nr -> 342 -> 327 -> m\ny -> 363 -> 207 -> E\np -> 336 -> 297 -> c\nt -> 348 -> 348 -> t\ni -> 315 -> 348 -> t\no -> 333 -> 348 -> t\nn -> 330 -> 219 -> I\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef linear_search(dates, target):\n    for date in dates:\n        if date == target:\n            return True\n    return False\n\ndef transform_dates(dates, days_offset):\n    transformed_dates = []\n    for date in dates:\n        new_date = date + timedelta(days=days_offset)\n        transformed_dates.append(new_date)\n    return transformed_dates\n\ndef generate_dates(start_date, num_days):\n    return [start_date + timedelta(days=i) for i in range(num_days)]\n\nstart_date = datetime(2023, 1, 1)\nnum_days = 50\ndates = generate_dates(start_date, num_days)\n\ntarget_date = datetime(2023, 1, 25)\nprint(f\"Searching for {target_date.date()} in the original dates...\")\nfound = linear_search(dates, target_date)\nprint(\"Found:\" if found else \"Not found.\")\n\ndays_offset = 10\nprint(f\"Transforming dates by an offset of {days_offset} days...\")\ntransformed_dates = transform_dates(dates, days_offset)\n\nprint(\"Transformed Dates:\")\nfor date in transformed_dates:\n    print(date.date())\n\nnew_target_date = target_date + timedelta(days=days_offset)\nprint(f\"Searching for {new_target_date.date()} in the transformed dates...\")\nfound_transformed = linear_search(transformed_dates, new_target_date)\nprint(\"Found:\" if found_transformed else \"Not found.\")"}, {"role": "assistant", "content": "Searching for 2023-01-25 in the original dates...\nFound:\nTransforming dates by an offset of 10 days...\nTransformed Dates:\n2023-01-11\n2023-01-12\n2023-01-13\n2023-01-14\n2023-01-15\n2023-01-16\n2023-01-17\n2023-01-18\n2023-01-19\n2023-01-20\n2023-01-21\n2023-01-22\n2023-01-23\n2023-01-24\n2023-01-25\n2023-01-26\n2023-01-27\n2023-01-28\n2023-01-29\n2023-01-30\n2023-01-31\n2023-02-01\n2023-02-02\n2023-02-03\n2023-02-04\n2023-02-05\n2023-02-06\n2023-02-07\n2023-02-08\n2023-02-09\n2023-02-10\n2023-02-11\n2023-02-12\n2023-02-13\n2023-02-14\n2023-02-15\n2023-02-16\n2023-02-17\n2023-02-18\n2023-02-19\n2023-02-20\n2023-02-21\n2023-02-22\n2023-02-23\n2023-02-24\n2023-02-25\n2023-02-26\n2023-02-27\n2023-02-28\n2023-03-01\nSearching for 2023-02-04 in the transformed dates...\nFound:\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef pattern_search(pattern, length):\n    primes = []\n    num = 2\n    while len(primes) < length:\n        if is_prime(num):\n            primes.append(num)\n        num += 1\n\n    results = []\n    for i in range(len(primes) - len(pattern) + 1):\n        match = True\n        for j in range(len(pattern)):\n            if primes[i + j] % 10 != pattern[j]:\n                match = False\n                break\n        if match:\n            results.append(primes[i:i+len(pattern)])\n    return results\n\npattern = [1, 3, 7]\nlength = 50\n\nresult = pattern_search(pattern, length)\nfor res in result:\n    print(res)"}, {"role": "assistant", "content": "[11, 13, 17]\n[41, 43, 47]\n[101, 103, 107]\n[191, 193, 197]\n[211, 223, 227]\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef is_perfect_square(n):\n    return math.isqrt(n) ** 2 == n\n\ndef generate_fib_sequence(n):\n    sequence = [0, 1]\n    while len(sequence) < n:\n        sequence.append(sequence[-1] + sequence[-2])\n    return sequence\n\ndef search_perfect_squares_in_fib_sequence(sequence):\n    perfect_squares = []\n    for num in sequence:\n        if is_perfect_square(num):\n            perfect_squares.append(num)\n    return perfect_squares\n\ndef main():\n    n = 100\n    print(\"Generating Fibonacci sequence...\")\n    fib_sequence = generate_fib_sequence(n)\n    print(f\"Fibonacci sequence of length {n}:\")\n    for i, num in enumerate(fib_sequence):\n        print(f\"{i}: {num}\")\n\n    print(\"\\nSearching for perfect squares in the Fibonacci sequence...\")\n    perfect_squares = search_perfect_squares_in_fib_sequence(fib_sequence)\n    print(\"Perfect squares found in the Fibonacci sequence:\")\n    for num in perfect_squares:\n        print(num)\n\nif __name__ == \"__main__\":\n    main()"}, {"role": "assistant", "content": "Generating Fibonacci sequence...\nFibonacci sequence of length 100:\n0: 0\n1: 1\n2: 1\n3: 2\n4: 3\n5: 5\n6: 8\n7: 13\n8: 21\n9: 34\n10: 55\n11: 89\n12: 144\n13: 233\n14: 377\n15: 610\n16: 987\n17: 1597\n18: 2584\n19: 4181\n20: 6765\n21: 10946\n22: 17711\n23: 28657\n24: 46368\n25: 75025\n26: 121393\n27: 196418\n28: 317811\n29: 514229\n30: 832040\n31: 1346269\n32: 2178309\n33: 3524578\n34: 5702887\n35: 9227465\n36: 14930352\n37: 24157817\n38: 39088169\n39: 63245986\n40: 102334155\n41: 165580141\n42: 267914296\n43: 433494437\n44: 701408733\n45: 1134903170\n46: 1836311903\n47: 2971215073\n48: 4807526976\n49: 7778742049\n50: 12586269025\n51: 20365011074\n52: 32951280099\n53: 53316291173\n54: 86267571272\n55: 139583862445\n56: 225851433717\n57: 365435296162\n58: 591286729879\n59: 956722026041\n60: 1548008755920\n61: 2504730781961\n62: 4052739537881\n63: 6557470319842\n64: 10610209857723\n65: 17167680177565\n66: 27777890035288\n67: 44945570212853\n68: 72723460248141\n69: 117669030460994\n70: 190392490709135\n71: 308061521170129\n72: 498454011879264\n73: 806515533049393\n74: 1304969544928657\n75: 2111485077978050\n76: 3416454622906707\n77: 5527939700884757\n78: 8944394323791464\n79: 14472334024676221\n80: 23416728348467685\n81: 37889062373143906\n82: 61305790721611591\n83: 99194853094755497\n84: 160500643816367088\n85: 259695496911122585\n86: 420196140727489673\n87: 679891637638612258\n88: 1100087778366101931\n89: 1779979416004714189\n90: 2880067194370816120\n91: 4660046610375530309\n92: 7540113804746346429\n93: 12200160415121876738\n94: 19740274219868223167\n95: 31940434634990099905\n96: 51680708854858323072\n97: 83621143489848422977\n98: 135301852344706746049\n99: 218922995834555169026\n\nSearching for perfect squares in the Fibonacci sequence...\nPerfect squares found in the Fibonacci sequence:\n0\n1\n1\n144\n"}]}
{"messages": [{"role": "user", "content": "def bubble_sort_pattern(n):\n    pattern = []\n    for i in range(n):\n        line = []\n        for j in range(n - i):\n            line.append('*')\n        line.extend([' '] * i)\n        pattern.append(line)\n\n    for i in range(len(pattern)):\n        for j in range(n - 1):\n            if pattern[i][j] < pattern[i][j + 1]:\n                pattern[i][j], pattern[i][j + 1] = pattern[i][j + 1], pattern[i][j]\n\n    for line in pattern:\n        print(''.join(line))\n\nbubble_sort_pattern(10)"}, {"role": "assistant", "content": "**********\n********* \n********  \n*******   \n******    \n*****     \n****      \n***       \n**        \n*         \n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef area_of_polygon(vertices):\n    n = len(vertices)\n    area = 0.0\n    for i in range(n):\n        j = (i + 1) % n\n        area += vertices[i][0] * vertices[j][1]\n        area -= vertices[j][0] * vertices[i][1]\n    area = abs(area) / 2.0\n    return area\n\ndef distance(p1, p2):\n    return math.sqrt((p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2)\n\ndef compare(p1, p2, centroid):\n    angle1 = math.atan2(p1[1] - centroid[1], p1[0] - centroid[0])\n    angle2 = math.atan2(p2[1] - centroid[1], p2[0] - centroid[0])\n    if angle1 == angle2:\n        return distance(centroid, p1) - distance(centroid, p2)\n    return angle1 - angle2\n\ndef sort_vertices(vertices):\n    centroid = (\n        sum([vertex[0] for vertex in vertices]) / len(vertices),\n        sum([vertex[1] for vertex in vertices]) / len(vertices)\n    )\n    sorted_vertices = sorted(vertices, key=lambda p: (\n        math.atan2(p[1] - centroid[1], p[0] - centroid[0]),\n        distance(centroid, p)\n    ))\n    return sorted_vertices\n\npolygons = [\n    [(0, 0), (4, 0), (4, 3), (0, 3)],\n    [(1, 1), (5, 1), (5, 4), (1, 4)],\n    [(2, 2), (6, 2), (6, 5), (2, 5)],\n    [(3, 3), (7, 3), (7, 6), (3, 6)],\n    [(0, 0), (5, 0), (5, 5), (0, 5)],\n    [(1, 1), (6, 1), (6, 6), (1, 6)],\n    [(2, 2), (7, 2), (7, 7), (2, 7)],\n    [(3, 3), (8, 3), (8, 8), (3, 8)],\n    [(4, 4), (9, 4), (9, 9), (4, 9)],\n    [(5, 5), (10, 5), (10, 10), (5, 10)]\n]\n\nsorted_polygons = [sort_vertices(polygon) for polygon in polygons]\nareas = [area_of_polygon(polygon) for polygon in sorted_polygons]\n\nfor i in range(len(polygons)):\n    print(f\"Polygon {i + 1}:\")\n    print(\"Vertices:\", sorted_polygons[i])\n    print(\"Area:\", areas[i])\n    print()"}, {"role": "assistant", "content": "Polygon 1:\nVertices: [(0, 0), (4, 0), (4, 3), (0, 3)]\nArea: 12.0\n\nPolygon 2:\nVertices: [(1, 1), (5, 1), (5, 4), (1, 4)]\nArea: 12.0\n\nPolygon 3:\nVertices: [(2, 2), (6, 2), (6, 5), (2, 5)]\nArea: 12.0\n\nPolygon 4:\nVertices: [(3, 3), (7, 3), (7, 6), (3, 6)]\nArea: 12.0\n\nPolygon 5:\nVertices: [(0, 0), (5, 0), (5, 5), (0, 5)]\nArea: 25.0\n\nPolygon 6:\nVertices: [(1, 1), (6, 1), (6, 6), (1, 6)]\nArea: 25.0\n\nPolygon 7:\nVertices: [(2, 2), (7, 2), (7, 7), (2, 7)]\nArea: 25.0\n\nPolygon 8:\nVertices: [(3, 3), (8, 3), (8, 8), (3, 8)]\nArea: 25.0\n\nPolygon 9:\nVertices: [(4, 4), (9, 4), (9, 9), (4, 9)]\nArea: 25.0\n\nPolygon 10:\nVertices: [(5, 5), (10, 5), (10, 10), (5, 10)]\nArea: 25.0\n\n"}]}
{"messages": [{"role": "user", "content": "import re\nfrom collections import defaultdict\n\ndef search_substring(text, pattern):\n    occurrences = defaultdict(list)\n    for match in re.finditer(r'(?={})'.format(re.escape(pattern)), text):\n        start = match.start()\n        end = start + len(pattern)\n        occurrences[(start, end)].append(text[start:end])\n    return occurrences\n\ntext = \"\"\"\nThe quick brown fox jumps over the lazy dog. The quick brown bear walks over the lazy dog.\nThe quick brown cat leaps over the lazy dog. The quick brown monkey swings over the lazy dog.\nThe quick brown elephant strides over the lazy dog. The quick brown horse gallops over the lazy dog.\n\"\"\"\n\npattern = 'over the lazy dog'\noccurrences = search_substring(text, pattern)\n\nfor index, (positions, matched) in enumerate(occurrences.items(), start=1):\n    print(f\"{index}. Found '{matched[0]}' at position {positions}\")"}, {"role": "assistant", "content": "1. Found 'over the lazy dog' at position (27, 44)\n2. Found 'over the lazy dog' at position (73, 90)\n3. Found 'over the lazy dog' at position (118, 135)\n4. Found 'over the lazy dog' at position (167, 184)\n5. Found 'over the lazy dog' at position (219, 236)\n6. Found 'over the lazy dog' at position (268, 285)\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef days_of_week_sorted_by_occurrence(dates):\n    day_counts = {i: 0 for i in range(7)}\n    for date in dates:\n        day_counts[date.weekday()] += 1\n\n    sorted_days = sorted(day_counts.items(), key=lambda x: (-x[1], x[0]))\n    return [day for day, _ in sorted_days]\n\ndates = [datetime(2023, 10, 1) + timedelta(days=i) for i in range(365)]\nweeks_sorted = days_of_week_sorted_by_occurrence(dates)\n\nweekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n\nfor day_idx in weeks_sorted:\n    print(weekdays[day_idx])"}, {"role": "assistant", "content": "Sunday\nMonday\nTuesday\nWednesday\nThursday\nFriday\nSaturday\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and key < arr[j]:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr\n\ndata = [5.5, 2.3, 8.7, 1.5, 7.8, 3.2, 6.1, 2.8, 9.0, 4.4, 3.3, 5.2, 8.1, 1.9, 7.0]\n\nsorted_data = insertion_sort(data.copy())\nprint(\"Sorted Data:\", sorted_data)\n\nmean_value = statistics.mean(sorted_data)\nprint(\"Mean Value:\", mean_value)\n\nmedian_value = statistics.median(sorted_data)\nprint(\"Median Value:\", median_value)\n\nmode_value = statistics.mode(sorted_data)\nprint(\"Mode Value:\", mode_value)\n\ndef mean_absolute_deviation(data):\n    mean_val = statistics.mean(data)\n    mad = sum(abs(x - mean_val) for x in data) / len(data)\n    return mad\n\nmad_value = mean_absolute_deviation(sorted_data)\nprint(\"Mean Absolute Deviation:\", mad_value)\n\nrange_value = max(sorted_data) - min(sorted_data)\nprint(\"Range Value:\", range_value)\n\nprint(\"\\nData and Deviations:\")\nfor value in sorted_data:\n    deviation = abs(value - mean_value)\n    print(f\"Value: {value:.1f}, Deviation from Mean: {deviation:.2f}\")"}, {"role": "assistant", "content": "Sorted Data: [1.5, 1.9, 2.3, 2.8, 3.2, 3.3, 4.4, 5.2, 5.5, 6.1, 7.0, 7.8, 8.1, 8.7, 9.0]\nMean Value: 5.12\nMedian Value: 5.2\nMode Value: 1.5\nMean Absolute Deviation: 2.192\nRange Value: 7.5\n\nData and Deviations:\nValue: 1.5, Deviation from Mean: 3.62\nValue: 1.9, Deviation from Mean: 3.22\nValue: 2.3, Deviation from Mean: 2.82\nValue: 2.8, Deviation from Mean: 2.32\nValue: 3.2, Deviation from Mean: 1.92\nValue: 3.3, Deviation from Mean: 1.82\nValue: 4.4, Deviation from Mean: 0.72\nValue: 5.2, Deviation from Mean: 0.08\nValue: 5.5, Deviation from Mean: 0.38\nValue: 6.1, Deviation from Mean: 0.98\nValue: 7.0, Deviation from Mean: 1.88\nValue: 7.8, Deviation from Mean: 2.68\nValue: 8.1, Deviation from Mean: 2.98\nValue: 8.7, Deviation from Mean: 3.58\nValue: 9.0, Deviation from Mean: 3.88\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef is_perfect_square(n):\n    return math.isqrt(n) ** 2 == n\n\ndef generate_fibonacci(limit):\n    fibs = [0, 1]\n    while len(fibs) < limit:\n        fibs.append(fibs[-1] + fibs[-2])\n    return fibs\n\ndef sort_by_square_fib_property(numbers):\n    def key_fn(x):\n        return (-is_perfect_square(x), x)\n    return sorted(numbers, key=key_fn)\n\nfibonacci_limit = 20\nfibonacci_sequence = generate_fibonacci(fibonacci_limit)\nsorted_fibonacci = sort_by_square_fib_property(fibonacci_sequence)\n\nfor num in sorted_fibonacci:\n    print(num)"}, {"role": "assistant", "content": "0\n1\n1\n144\n2\n3\n5\n8\n13\n21\n34\n55\n89\n233\n377\n610\n987\n1597\n2584\n4181\n"}]}
{"messages": [{"role": "user", "content": "def is_knight_move_legal(pos1, pos2):\n    x1, y1 = pos1\n    x2, y2 = pos2\n    dx, dy = abs(x2 - x1), abs(y2 - y1)\n    return (dx, dy) in [(1, 2), (2, 1)]\n\ndef generate_knight_moves():\n    board_size = 8\n    moves = [\n        (x, y, x + dx, y + dy)\n        for x in range(board_size)\n        for y in range(board_size)\n        for dx, dy in [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]\n        if 0 <= x + dx < board_size and 0 <= y + dy < board_size\n    ]\n    return moves\n\ndef knight_search_path(start, end, path):\n    if start == end:\n        return path\n    valid_moves = [\n        (x1, y1, x2, y2)\n        for (x1, y1, x2, y2) in generate_knight_moves()\n        if (x1, y1) == start and (x2, y2) not in path\n    ]\n    for move in valid_moves:\n        next_pos = (move[2], move[3])\n        result = knight_search_path(next_pos, end, path + [next_pos])\n        if result is not None:\n            return result\n    return None\n\ndef print_knight_path(start, end):\n    path = knight_search_path(start, end, [start])\n    if path is None:\n        print(\"No path found\")\n    else:\n        for step in path:\n            print(step)\n\nprint_knight_path((0, 0), (7, 7))"}, {"role": "assistant", "content": "(0, 0)\n(2, 1)\n(4, 2)\n(6, 3)\n(4, 4)\n(6, 5)\n(4, 6)\n(6, 7)\n(7, 5)\n(5, 6)\n(7, 7)\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef caesar_cipher(text, shift):\n    encrypted = []\n    for char in text:\n        if char.isalpha():\n            shift_amount = shift % 26\n            new_char = chr((ord(char.lower()) - 97 + shift_amount) % 26 + 97)\n            encrypted.append(new_char.upper() if char.isupper() else new_char)\n        else:\n            encrypted.append(char)\n    return ''.join(encrypted)\n\ndef simple_search_cipher(encoded_text, keyword):\n    print(f\"Searching for keyword '{keyword}' in encoded text...\")\n    keyword_pattern = re.compile(re.escape(keyword), re.IGNORECASE)\n    matches = keyword_pattern.finditer(encoded_text)\n    positions = [match.start() for match in matches]\n    return positions\n\ntext = \"Encryption is the process of encoding a message or information.\"\nshift = 7\nencoded_text = caesar_cipher(text, shift)\nprint(f\"Encoded Text: {encoded_text}\")\n\nkeywords = [\"process\", \"MESSAGE\", \"notfound\"]\nfor keyword in keywords:\n    positions = simple_search_cipher(encoded_text, keyword)\n    if positions:\n        print(f\"Keyword '{keyword}' found at positions: {positions}\")\n    else:\n        print(f\"Keyword '{keyword}' not found in the encoded text.\")"}, {"role": "assistant", "content": "Encoded Text: Lujyfwapvu pz aol wyvjlzz vm lujvkpun h tlzzhnl vy pumvythapvu.\nSearching for keyword 'process' in encoded text...\nKeyword 'process' not found in the encoded text.\nSearching for keyword 'MESSAGE' in encoded text...\nKeyword 'MESSAGE' not found in the encoded text.\nSearching for keyword 'notfound' in encoded text...\nKeyword 'notfound' not found in the encoded text.\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef incorrect_sort_words_by_length(text):\n    words = re.findall(r'\\b\\w+\\b', text.lower())\n    print(f\"Extracted words: {words}\")\n    words.sort(key=len, reverse=False)\n    print(f\"Words sorted by length (descending): {words}\")\n    return words\n\ntext_content = \"\"\"\nIn an octopus's garden, there are many wonders to behold, each with its own unique charm.\nFrom the gentle swaying of the seaweed to the vibrant colors of the coral, it is a place of mystery and beauty.\n\"\"\"\n\nsorted_words = incorrect_sort_words_by_length(text_content)\n\nprint(\"\\nFinal sorted list of words:\")\nfor word in sorted_words:\n    print(word)"}, {"role": "assistant", "content": "Extracted words: ['in', 'an', 'octopus', 's', 'garden', 'there', 'are', 'many', 'wonders', 'to', 'behold', 'each', 'with', 'its', 'own', 'unique', 'charm', 'from', 'the', 'gentle', 'swaying', 'of', 'the', 'seaweed', 'to', 'the', 'vibrant', 'colors', 'of', 'the', 'coral', 'it', 'is', 'a', 'place', 'of', 'mystery', 'and', 'beauty']\nWords sorted by length (descending): ['s', 'a', 'in', 'an', 'to', 'of', 'to', 'of', 'it', 'is', 'of', 'are', 'its', 'own', 'the', 'the', 'the', 'the', 'and', 'many', 'each', 'with', 'from', 'there', 'charm', 'coral', 'place', 'garden', 'behold', 'unique', 'gentle', 'colors', 'beauty', 'octopus', 'wonders', 'swaying', 'seaweed', 'vibrant', 'mystery']\n\nFinal sorted list of words:\ns\na\nin\nan\nto\nof\nto\nof\nit\nis\nof\nare\nits\nown\nthe\nthe\nthe\nthe\nand\nmany\neach\nwith\nfrom\nthere\ncharm\ncoral\nplace\ngarden\nbehold\nunique\ngentle\ncolors\nbeauty\noctopus\nwonders\nswaying\nseaweed\nvibrant\nmystery\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndata = [\n    {\"name\": \"Alice\", \"score\": 91},\n    {\"name\": \"Bob\", \"score\": 85},\n    {\"name\": \"Charlie\", \"score\": 79},\n    {\"name\": \"David\", \"score\": 95},\n    {\"name\": \"Eve\", \"score\": 88},\n    {\"name\": \"Frank\", \"score\": 92},\n    {\"name\": \"Grace\", \"score\": 87},\n    {\"name\": \"Hannah\", \"score\": 78},\n    {\"name\": \"Isaac\", \"score\": 84},\n    {\"name\": \"Jack\", \"score\": 82},\n    {\"name\": \"Karen\", \"score\": 80},\n    {\"name\": \"Leo\", \"score\": 90},\n    {\"name\": \"Mona\", \"score\": 83},\n    {\"name\": \"Nina\", \"score\": 88},\n    {\"name\": \"Oscar\", \"score\": 79},\n    {\"name\": \"Paul\", \"score\": 86},\n    {\"name\": \"Quinn\", \"score\": 81},\n    {\"name\": \"Rita\", \"score\": 83},\n    {\"name\": \"Steve\", \"score\": 77},\n    {\"name\": \"Tina\", \"score\": 89}\n]\n\nprint(\"Original Data:\")\nfor entry in data:\n    print(entry)\n\nsorted_data = sorted(data, key=lambda x: x['score'])\nprint(\"\\nSorted Data by Score:\")\nfor entry in sorted_data:\n    print(entry)\n\nmedian_score = statistics.median(entry['score'] for entry in sorted_data)\nprint(f\"\\nMedian Score: {median_score}\")\n\nabove_median = [entry for entry in sorted_data if entry['score'] > median_score]\nprint(\"\\nAbove Median:\")\nfor entry in above_median:\n    print(entry)"}, {"role": "assistant", "content": "Original Data:\n{'name': 'Alice', 'score': 91}\n{'name': 'Bob', 'score': 85}\n{'name': 'Charlie', 'score': 79}\n{'name': 'David', 'score': 95}\n{'name': 'Eve', 'score': 88}\n{'name': 'Frank', 'score': 92}\n{'name': 'Grace', 'score': 87}\n{'name': 'Hannah', 'score': 78}\n{'name': 'Isaac', 'score': 84}\n{'name': 'Jack', 'score': 82}\n{'name': 'Karen', 'score': 80}\n{'name': 'Leo', 'score': 90}\n{'name': 'Mona', 'score': 83}\n{'name': 'Nina', 'score': 88}\n{'name': 'Oscar', 'score': 79}\n{'name': 'Paul', 'score': 86}\n{'name': 'Quinn', 'score': 81}\n{'name': 'Rita', 'score': 83}\n{'name': 'Steve', 'score': 77}\n{'name': 'Tina', 'score': 89}\n\nSorted Data by Score:\n{'name': 'Steve', 'score': 77}\n{'name': 'Hannah', 'score': 78}\n{'name': 'Charlie', 'score': 79}\n{'name': 'Oscar', 'score': 79}\n{'name': 'Karen', 'score': 80}\n{'name': 'Quinn', 'score': 81}\n{'name': 'Jack', 'score': 82}\n{'name': 'Mona', 'score': 83}\n{'name': 'Rita', 'score': 83}\n{'name': 'Isaac', 'score': 84}\n{'name': 'Bob', 'score': 85}\n{'name': 'Paul', 'score': 86}\n{'name': 'Grace', 'score': 87}\n{'name': 'Eve', 'score': 88}\n{'name': 'Nina', 'score': 88}\n{'name': 'Tina', 'score': 89}\n{'name': 'Leo', 'score': 90}\n{'name': 'Alice', 'score': 91}\n{'name': 'Frank', 'score': 92}\n{'name': 'David', 'score': 95}\n\nMedian Score: 84.5\n\nAbove Median:\n{'name': 'Bob', 'score': 85}\n{'name': 'Paul', 'score': 86}\n{'name': 'Grace', 'score': 87}\n{'name': 'Eve', 'score': 88}\n{'name': 'Nina', 'score': 88}\n{'name': 'Tina', 'score': 89}\n{'name': 'Leo', 'score': 90}\n{'name': 'Alice', 'score': 91}\n{'name': 'Frank', 'score': 92}\n{'name': 'David', 'score': 95}\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef encode_message(message, keyword):\n    def keyword_order(kw):\n        return {char: i for i, char in enumerate(sorted(set(kw)))}\n\n    def columnar_transposition_encrypt(msg, kw):\n        n = len(kw)\n        full_columns = len(msg) // n\n        columns = [msg[i::n] for i in range(n)]\n        sorted_columns = sorted((k, col) for k, col in zip(keyword_order(kw).values(), columns))\n        return ''.join(col for _, col in sorted_columns)\n\n    def clean_message(msg):\n        return re.sub(r'[^A-Za-z]', '', msg).upper()\n\n    cleaned_msg = clean_message(message)\n    return columnar_transposition_encrypt(cleaned_msg, keyword)\n\ndef decode_message(encrypted, keyword):\n    def keyword_order(kw):\n        return {char: i for i, char in enumerate(sorted(set(kw)))}\n\n    def columnar_transposition_decrypt(msg, kw):\n        n = len(kw)\n        order = sorted((k, i) for i, k in enumerate(keyword_order(kw).values()))\n        column_lengths = [len(msg) // n + (1 if i < len(msg) % n else 0) for i in range(n)]\n        start_indices = [sum(column_lengths[:i]) for i in range(n)]\n        columns = [msg[start:start + length] for start, length in zip(start_indices, column_lengths)]\n        sorted_columns = [col for _, col in sorted(zip(order, columns))]\n        return ''.join(''.join(row) for row in zip(*sorted_columns))\n\n    return columnar_transposition_decrypt(encrypted, keyword)\n\nmessage = \"Hello, World! Encryption and Decryption are fun!\"\nkeyword = \"PYTHON\"\n\nencoded_message = encode_message(message, keyword)\ndecoded_message = decode_message(encoded_message, keyword)\n\nprint(\"Encoded Message:\")\nprint(encoded_message)\nprint(\"\\nDecoded Message:\")\nprint(decoded_message)"}, {"role": "assistant", "content": "Encoded Message:\nHOCOEIFERRNCOULLYARNNLDPNYAOETDPRWNIDTE\n\nDecoded Message:\nHELLOWORLDENCRYPTIONANDDECRYPTIONARE\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef generate_dates(start_date, num_days):\n    dates = []\n    for i in range(num_days):\n        next_date = start_date + timedelta(days=i)\n        dates.append(next_date)\n    return dates\n\ndef sort_dates_by_month(dates):\n    return sorted(dates, key=lambda date: (date.month, date.day))\n\nstart_date = datetime(2023, 1, 15)\nnum_days = 20\n\ndates = generate_dates(start_date, num_days)\nprint(\"Generated Dates:\")\nfor date in dates:\n    print(date.strftime(\"%Y-%m-%d\"))\n\nsorted_dates = sort_dates_by_month(dates)\nprint(\"\\nDates Sorted by Month and Day:\")\nfor date in sorted_dates:\n    print(date.strftime(\"%Y-%m-%d\"))"}, {"role": "assistant", "content": "Generated Dates:\n2023-01-15\n2023-01-16\n2023-01-17\n2023-01-18\n2023-01-19\n2023-01-20\n2023-01-21\n2023-01-22\n2023-01-23\n2023-01-24\n2023-01-25\n2023-01-26\n2023-01-27\n2023-01-28\n2023-01-29\n2023-01-30\n2023-01-31\n2023-02-01\n2023-02-02\n2023-02-03\n\nDates Sorted by Month and Day:\n2023-01-15\n2023-01-16\n2023-01-17\n2023-01-18\n2023-01-19\n2023-01-20\n2023-01-21\n2023-01-22\n2023-01-23\n2023-01-24\n2023-01-25\n2023-01-26\n2023-01-27\n2023-01-28\n2023-01-29\n2023-01-30\n2023-01-31\n2023-02-01\n2023-02-02\n2023-02-03\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef find_closest_friday_13th(start_date: datetime, limit_years: int):\n    closest_date = None\n    closest_diff = float('inf')\n    current_date = start_date\n\n    while current_date.year < start_date.year + limit_years:\n        if current_date.day == 13 and current_date.weekday() == 4:\n            diff = abs((current_date - start_date).days)\n            if diff < closest_diff:\n                closest_diff = diff\n                closest_date = current_date\n        current_date += timedelta(days=1)\n\n    return closest_date\n\nstart_date = datetime(2023, 1, 1)\nlimit_years = 10\nclosest_friday_13th = find_closest_friday_13th(start_date, limit_years)\n\ncurrent_date = start_date\noutput_dates = []\nwhile current_date <= closest_friday_13th:\n    output_dates.append(current_date)\n    current_date += timedelta(days=1)\n\nfor date in output_dates:\n    print(date.strftime('%Y-%m-%d'))"}, {"role": "assistant", "content": "2023-01-01\n2023-01-02\n2023-01-03\n2023-01-04\n2023-01-05\n2023-01-06\n2023-01-07\n2023-01-08\n2023-01-09\n2023-01-10\n2023-01-11\n2023-01-12\n2023-01-13\n"}]}
{"messages": [{"role": "user", "content": "class Player:\n    def __init__(self, name, score, level):\n        self.name = name\n        self.score = score\n        self.level = level\n\n    def __repr__(self):\n        return f\"{self.name}(Score: {self.score}, Level: {self.level})\"\n\nplayers = [\n    Player(\"Alice\", 240, 5),\n    Player(\"Bob\", 280, 4),\n    Player(\"Charlie\", 150, 6),\n    Player(\"David\", 300, 5),\n    Player(\"Eve\", 250, 3),\n    Player(\"Frank\", 270, 6),\n    Player(\"Grace\", 290, 5),\n    Player(\"Hannah\", 260, 4),\n    Player(\"Isaac\", 310, 4),\n    Player(\"Jack\", 230, 5),\n    Player(\"Karen\", 220, 6),\n    Player(\"Leo\", 300, 3)\n]\n\nprint(\"Initial list of players:\")\nfor player in players:\n    print(player)\n\nplayers_sorted = sorted(players, key=lambda p: (-p.score, p.level, p.name))\n\nprint(\"\\nSorted list of players (Score Descending, Level Ascending, Name Ascending):\")\nfor player in players_sorted:\n    print(player)\n\ntop_players = players_sorted[:5]\n\nprint(\"\\nTop 5 players:\")\nfor player in top_players:\n    print(player)\n\ntotal_score = sum(player.score for player in top_players)\n\nprint(f\"\\nTotal score of top 5 players: {total_score}\")\n\naverage_level = sum(player.level for player in top_players) / len(top_players)\n\nprint(f\"Average level of top 5 players: {average_level:.2f}\")"}, {"role": "assistant", "content": "Initial list of players:\nAlice(Score: 240, Level: 5)\nBob(Score: 280, Level: 4)\nCharlie(Score: 150, Level: 6)\nDavid(Score: 300, Level: 5)\nEve(Score: 250, Level: 3)\nFrank(Score: 270, Level: 6)\nGrace(Score: 290, Level: 5)\nHannah(Score: 260, Level: 4)\nIsaac(Score: 310, Level: 4)\nJack(Score: 230, Level: 5)\nKaren(Score: 220, Level: 6)\nLeo(Score: 300, Level: 3)\n\nSorted list of players (Score Descending, Level Ascending, Name Ascending):\nIsaac(Score: 310, Level: 4)\nLeo(Score: 300, Level: 3)\nDavid(Score: 300, Level: 5)\nGrace(Score: 290, Level: 5)\nBob(Score: 280, Level: 4)\nFrank(Score: 270, Level: 6)\nHannah(Score: 260, Level: 4)\nEve(Score: 250, Level: 3)\nAlice(Score: 240, Level: 5)\nJack(Score: 230, Level: 5)\nKaren(Score: 220, Level: 6)\nCharlie(Score: 150, Level: 6)\n\nTop 5 players:\nIsaac(Score: 310, Level: 4)\nLeo(Score: 300, Level: 3)\nDavid(Score: 300, Level: 5)\nGrace(Score: 290, Level: 5)\nBob(Score: 280, Level: 4)\n\nTotal score of top 5 players: 1480\nAverage level of top 5 players: 4.20\n"}]}
{"messages": [{"role": "user", "content": "from datetime import timedelta, date\n\ndef generate_dates(start_date, end_date):\n    delta = end_date - start_date\n    return [start_date + timedelta(days=i) for i in range(delta.days + 1)]\n\ndef date_with_most_fridays(dates):\n    friday_count = {}\n    for d in dates:\n        year = d.year\n        if d.weekday() == 4:\n            if year in friday_count:\n                friday_count[year] += 1\n            else:\n                friday_count[year] = 1\n    return max(friday_count, key=friday_count.get)\n\nstart = date(2000, 1, 1)\nend = date(2023, 10, 23)\nall_dates = generate_dates(start, end)\nyear_most_fridays = date_with_most_fridays(all_dates)\nprint(f\"The year with the most Fridays is: {year_most_fridays}\")"}, {"role": "assistant", "content": "The year with the most Fridays is: 2004\n"}]}
{"messages": [{"role": "user", "content": "def is_fibonacci(n):\n    x1 = 5 * n * n + 4\n    x2 = 5 * n * n - 4\n    return int(x1**0.5)**2 == x1 or int(x2**0.5)**2 == x2\n\ndef tribonacci_search(n):\n    tribonacci = [0, 1, 1]\n    while len(tribonacci) < n:\n        tribonacci.append(tribonacci[-1] + tribonacci[-2] + tribonacci[-3])\n    return tribonacci\n\ndef search_special_numbers(limit):\n    tribonacci = tribonacci_search(limit)\n    special_numbers = []\n    for num in range(1, limit):\n        if is_fibonacci(num) and num in tribonacci:\n            special_numbers.append(num)\n    return special_numbers\n\nspecial_numbers = search_special_numbers(100)\nfor idx, num in enumerate(special_numbers):\n    print(f\"{idx + 1}: {num}\")"}, {"role": "assistant", "content": "1: 1\n2: 2\n3: 13\n"}]}
{"messages": [{"role": "user", "content": "import math\nfrom statistics import mean, median\n\ndef generate_data(n):\n    return [math.sin(i) * 100 for i in range(n)]\n\ndef calculate_variance(data):\n    m = mean(data)\n    return mean((x - m) ** 2 for x in data)\n\ndef bucket_sort(data, bucket_size=10):\n    if len(data) == 0:\n        return []\n\n    min_value, max_value = min(data), max(data)\n    bucket_count = math.ceil((max_value - min_value) / bucket_size)\n    buckets = [[] for _ in range(bucket_count)]\n\n    for number in data:\n        index = min(bucket_count - 1, (number - min_value) // bucket_size)\n        buckets[index].append(number)\n\n    sorted_data = []\n    for bucket in buckets:\n        sorted_data.extend(sorted(bucket))\n    \n    return sorted_data\n\ndef analyze_data(data):\n    sorted_data = bucket_sort(data)\n    med = median(sorted_data)\n    var = calculate_variance(sorted_data)\n    return sorted_data, med, var\n\ndata = generate_data(100)\nsorted_data, med, var = analyze_data(data)\n\nprint(\"Sorted Data:\")\nfor num in sorted_data:\n    print(f\"{num:.2f}\")\n\nprint(\"\\nMedian:\", med)\nprint(\"Variance:\", var)"}, {"role": "assistant", "content": "Traceback (most recent call last):\n  File \"<string>\", line 36, in <module>\n  File \"<string>\", line 30, in analyze_data\n  File \"<string>\", line 21, in bucket_sort\nTypeError: list indices must be integers or slices, not float\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef generate_pattern(n):\n    pattern = []\n    for i in range(1, n + 1):\n        pattern.append(''.join(str(x % 10) for x in range(1, i + 1)))\n    return pattern\n\ndef search_pattern(pattern, search_str):\n    for i, line in enumerate(pattern):\n        if re.search(search_str, line):\n            return i\n    return -1\n\ndef main():\n    n = 15\n    pattern = generate_pattern(n)\n    search_str = \"1234\"\n    index = search_pattern(pattern, search_str)\n    print(\"\\n\".join(pattern))\n    print(f\"Pattern '{search_str}' found at line: {index}\")\n\nmain()"}, {"role": "assistant", "content": "1\n12\n123\n1234\n12345\n123456\n1234567\n12345678\n123456789\n1234567890\n12345678901\n123456789012\n1234567890123\n12345678901234\n123456789012345\nPattern '1234' found at line: 3\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef create_patterns(s):\n    return [s[i:] + s[:i] for i in range(len(s))]\n\ndef pattern_search(text, pattern):\n    matches = []\n    for i in range(len(text) - len(pattern) + 1):\n        if text[i:i+len(pattern)] == pattern:\n            matches.append(i)\n    return matches\n\ndef transform_text(text, patterns):\n    transformed = text\n    for pattern in patterns:\n        indices = pattern_search(text, pattern)\n        print(f\"Pattern '{pattern}' found at indices: {indices}\")\n        for index in indices:\n            transformed = transformed[:index] + transformed[index:index+len(pattern)].upper() + transformed[index+len(pattern):]\n    return transformed\n\ndef main():\n    text = \"ababcabcabcabc\"\n    word = \"abc\"\n    patterns = create_patterns(word)\n    print(\"Generated patterns from word:\")\n    for p in patterns:\n        print(p)\n    print(\"\\nTransforming text...\")\n    transformed_text = transform_text(text, patterns)\n    print(\"\\nOriginal text:\")\n    print(text)\n    print(\"\\nTransformed text:\")\n    print(transformed_text)\n\nmain()"}, {"role": "assistant", "content": "Generated patterns from word:\nabc\nbca\ncab\n\nTransforming text...\nPattern 'abc' found at indices: [2, 5, 8, 11]\nPattern 'bca' found at indices: [3, 6, 9]\nPattern 'cab' found at indices: [4, 7, 10]\n\nOriginal text:\nababcabcabcabc\n\nTransformed text:\nabABCABCABCABC\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\ndates = [\n    \"2023-01-15\", \"2023-07-04\", \"2022-12-25\", \"2023-11-01\",\n    \"2022-08-15\", \"2023-03-17\", \"2022-05-01\", \"2023-02-14\",\n    \"2023-10-31\", \"2023-04-01\", \"2023-09-15\", \"2023-06-21\"\n]\n\nprint(\"Original dates:\")\nfor date in dates:\n    print(date)\n\ndatetime_objects = [datetime.strptime(date, \"%Y-%m-%d\") for date in dates]\n\nprint(\"\\nConverted to datetime objects:\")\nfor dt in datetime_objects:\n    print(dt)\n\nsorted_dates = sorted(datetime_objects, key=lambda x: (x.month, x.day))\n\nprint(\"\\nSorted by month and day (ignoring year):\")\nfor dt in sorted_dates:\n    print(dt.strftime(\"%Y-%m-%d\"))"}, {"role": "assistant", "content": "Original dates:\n2023-01-15\n2023-07-04\n2022-12-25\n2023-11-01\n2022-08-15\n2023-03-17\n2022-05-01\n2023-02-14\n2023-10-31\n2023-04-01\n2023-09-15\n2023-06-21\n\nConverted to datetime objects:\n2023-01-15 00:00:00\n2023-07-04 00:00:00\n2022-12-25 00:00:00\n2023-11-01 00:00:00\n2022-08-15 00:00:00\n2023-03-17 00:00:00\n2022-05-01 00:00:00\n2023-02-14 00:00:00\n2023-10-31 00:00:00\n2023-04-01 00:00:00\n2023-09-15 00:00:00\n2023-06-21 00:00:00\n\nSorted by month and day (ignoring year):\n2023-01-15\n2023-02-14\n2023-03-17\n2023-04-01\n2022-05-01\n2023-06-21\n2023-07-04\n2022-08-15\n2023-09-15\n2023-10-31\n2023-11-01\n2022-12-25\n"}]}
{"messages": [{"role": "user", "content": "def calculate_best_moves(scores):\n    def merge_sort(arr):\n        if len(arr) > 1:\n            mid = len(arr) // 2\n            L = arr[:mid]\n            R = arr[mid:]\n\n            merge_sort(L)\n            merge_sort(R)\n\n            i = j = k = 0\n\n            while i < len(L) and j < len(R):\n                if L[i] > R[j]:\n                    arr[k] = L[i]\n                    i += 1\n                else:\n                    arr[k] = R[j]\n                    j += 1\n                k += 1\n\n            while i < len(L):\n                arr[k] = L[i]\n                i += 1\n                k += 1\n\n            while j < len(R):\n                arr[k] = R[j]\n                j += 1\n                k += 1\n\n    merge_sort(scores)\n    return scores\n\ngame_scores = [\n    (5, \"Player A\"), (3, \"Player B\"), (8, \"Player C\"), (6, \"Player D\"),\n    (2, \"Player E\"), (10, \"Player F\"), (7, \"Player G\"), (4, \"Player H\")\n]\n\nsorted_scores = calculate_best_moves([score for score, _ in game_scores])\nfor score in sorted_scores:\n    for s, player in game_scores:\n        if s == score:\n            print(f\"{player}: {score}\")"}, {"role": "assistant", "content": "Player F: 10\nPlayer C: 8\nPlayer G: 7\nPlayer D: 6\nPlayer A: 5\nPlayer H: 4\nPlayer B: 3\nPlayer E: 2\n"}]}
{"messages": [{"role": "user", "content": "def generate_pattern(n):\n    pattern = []\n    for i in range(n):\n        row = [' ' for _ in range(2 * n - 1)]\n        for j in range(n - i - 1, n + i):\n            if (j - (n - i - 1)) % 2 == 0:\n                row[j] = '*'\n        pattern.append(''.join(row))\n    return pattern\n\ndef custom_sort(pattern):\n    return sorted(pattern, key=lambda x: (-x.count('*'), x))\n\ndef main():\n    n = 10\n    pattern = generate_pattern(n)\n    sorted_pattern = custom_sort(pattern)\n    result = '\\n'.join(sorted_pattern)\n    print(result)\n\nmain()"}, {"role": "assistant", "content": "* * * * * * * * * *\n * * * * * * * * * \n  * * * * * * * *  \n   * * * * * * *   \n    * * * * * *    \n     * * * * *     \n      * * * *      \n       * * *       \n        * *        \n         *         \n"}]}
{"messages": [{"role": "user", "content": "import datetime\nimport re\n\ndef custom_date_sort(dates):\n    def date_to_tuple(date_str):\n        match = re.match(r\"(\\d{2})-(\\d{2})-(\\d{4})\", date_str)\n        if match:\n            day, month, year = map(int, match.groups())\n            return (year, month, day)\n        return (0, 0, 0)\n\n    return sorted(dates, key=date_to_tuple)\n\ndates_list = [\n    \"12-05-2022\", \"11-05-2021\", \"10-05-2023\",\n    \"09-04-2023\", \"08-06-2022\", \"07-07-2021\",\n    \"06-08-2023\", \"05-09-2020\", \"04-10-2022\",\n    \"03-11-2021\", \"02-12-2023\", \"01-01-2020\"\n]\n\nsorted_dates = custom_date_sort(dates_list)\n\nfor date in sorted_dates:\n    print(date)"}, {"role": "assistant", "content": "01-01-2020\n05-09-2020\n11-05-2021\n07-07-2021\n03-11-2021\n12-05-2022\n08-06-2022\n04-10-2022\n09-04-2023\n10-05-2023\n06-08-2023\n02-12-2023\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef is_square_free(n):\n    if n < 2:\n        return True\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % (i * i) == 0:\n            return False\n    return True\n\nsequence = [n for n in range(1, 100) if is_square_free(n)]\nprint(\"Square-free sequence:\", sequence)\n\ndef custom_sort_key(x):\n    return (sum(int(digit) for digit in str(x)), x)\n\nprint(\"Sorting by sum of digits:\")\nsquare_free_sorted = sorted(sequence, key=custom_sort_key)\nfor num in square_free_sorted:\n    print(num)\n\nprint(\"Sorting by number of divisors:\")\ndef number_of_divisors(n):\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            count += 1\n            if n // i != i:\n                count += 1\n    return count\n\nsquare_free_sorted = sorted(sequence, key=number_of_divisors)\nfor num in square_free_sorted:\n    print(num)"}, {"role": "assistant", "content": "Square-free sequence: [1, 2, 3, 5, 6, 7, 10, 11, 13, 14, 15, 17, 19, 21, 22, 23, 26, 29, 30, 31, 33, 34, 35, 37, 38, 39, 41, 42, 43, 46, 47, 51, 53, 55, 57, 58, 59, 61, 62, 65, 66, 67, 69, 70, 71, 73, 74, 77, 78, 79, 82, 83, 85, 86, 87, 89, 91, 93, 94, 95, 97]\nSorting by sum of digits:\n1\n10\n2\n11\n3\n21\n30\n13\n22\n31\n5\n14\n23\n41\n6\n15\n33\n42\n51\n7\n34\n43\n61\n70\n17\n26\n35\n53\n62\n71\n19\n37\n46\n55\n73\n82\n91\n29\n38\n47\n65\n74\n83\n39\n57\n66\n93\n58\n67\n85\n94\n59\n77\n86\n95\n69\n78\n87\n79\n97\n89\nSorting by number of divisors:\n1\n2\n3\n5\n7\n11\n13\n17\n19\n23\n29\n31\n37\n41\n43\n47\n53\n59\n61\n67\n71\n73\n79\n83\n89\n97\n6\n10\n14\n15\n21\n22\n26\n33\n34\n35\n38\n39\n46\n51\n55\n57\n58\n62\n65\n69\n74\n77\n82\n85\n86\n87\n91\n93\n94\n95\n30\n42\n66\n70\n78\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef sort_sentences_by_unique_words(text):\n    sentences = re.split(r'(?<=[.!?]) +', text)\n    unique_word_counts = []\n\n    for sentence in sentences:\n        words = re.findall(r'\\b\\w+\\b', sentence.lower())\n        unique_words = set(words)\n        unique_word_counts.append((len(unique_words), sentence))\n\n    sorted_sentences = sorted(unique_word_counts, key=lambda x: x[0], reverse=True)\n    return [sentence for _, sentence in sorted_sentences]\n\ntext = (\n    \"The quick brown fox jumps over the lazy dog. \"\n    \"Pack my box with five dozen liquor jugs. \"\n    \"How razorback-jumping frogs can level six piqued gymnasts! \"\n    \"Cozy lummox gives smart squid who asks for job pen. \"\n    \"The five boxing wizards jump quickly.\"\n)\n\nresult = sort_sentences_by_unique_words(text)\nfor sentence in result:\n    print(sentence)"}, {"role": "assistant", "content": "Cozy lummox gives smart squid who asks for job pen.\nHow razorback-jumping frogs can level six piqued gymnasts!\nThe quick brown fox jumps over the lazy dog.\nPack my box with five dozen liquor jugs.\nThe five boxing wizards jump quickly.\n"}]}
{"messages": [{"role": "user", "content": "def find_winner(board):\n    def check_line(line):\n        if all(x == 'X' for x in line):\n            return 'X'\n        elif all(x == 'O' for x in line):\n            return 'O'\n        return None\n\n    for row in board:\n        result = check_line(row)\n        if result:\n            return result\n\n    for col in range(len(board[0])):\n        result = check_line([board[row][col] for row in range(len(board))])\n        if result:\n            return result\n\n    result = check_line([board[i][i] for i in range(len(board))])\n    if result:\n        return result\n\n    result = check_line([board[i][len(board) - 1 - i] for i in range(len(board))])\n    if result:\n        return result\n\n    return 'Draw'\n\nboard = [\n    ['X', 'O', 'O'],\n    ['O', 'X', 'X'],\n    ['O', 'X', 'O'],\n    ['X', 'O', 'X'],\n    ['O', 'X', 'O'],\n    ['X', 'O', 'X'],\n    ['O', 'X', 'O'],\n    ['X', 'O', 'X'],\n    ['O', 'X', 'O'],\n    ['X', 'O', 'X']\n]\n\nwinner = find_winner(board)\nprint(winner)"}, {"role": "assistant", "content": "Traceback (most recent call last):\n  File \"<string>\", line 42, in <module>\n  File \"<string>\", line 19, in find_winner\n  File \"<string>\", line 19, in <listcomp>\nIndexError: list index out of range\n"}]}
{"messages": [{"role": "user", "content": "import math\n\npoints = [\n    (0, 0), (1, 2), (3, 1), (4, 4), (5, 3),\n    (2, 5), (3, 3), (1, 4), (2, 2), (4, 1)\n]\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\ndef find_closest_points(points):\n    min_distance = float('inf')\n    closest_pair = None\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            dist = distance(points[i], points[j])\n            if dist < min_distance:\n                min_distance = dist\n                closest_pair = (points[i], points[j])\n    return closest_pair, min_distance\n\nclosest_pair, min_distance = find_closest_points(points)\nprint(\"Closest pair of points:\", closest_pair)\nprint(\"Minimum distance:\", min_distance)\n\nsearch_distance = 2.5\nresult = []\n\nfor p1 in points:\n    for p2 in points:\n        if p1 != p2 and math.isclose(distance(p1, p2), search_distance, abs_tol=0.1):\n            result.append((p1, p2))\n\nresult = list(set(frozenset(pair) for pair in result))\nfor pair in result:\n    print(\"Pair with distance ~\", search_distance, \":\", tuple(pair))"}, {"role": "assistant", "content": "Closest pair of points: ((1, 2), (2, 2))\nMinimum distance: 1.0\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef custom_sort_key(s):\n    return [ord(char) for char in s]\n\ndef encrypt_message(message):\n    words = re.findall(r'\\b\\w+\\b', message)\n    encrypted_words = []\n    for word in words:\n        sorted_chars = sorted(word, key=custom_sort_key)\n        encrypted_word = ''.join(sorted_chars)\n        encrypted_words.append(encrypted_word)\n    return ' '.join(encrypted_words)\n\nmessage = \"The quick brown fox jumps over the lazy dog\"\nencrypted_message = encrypt_message(message)\n\nprint(encrypted_message)"}, {"role": "assistant", "content": "Teh cikqu bnorw fox jmpsu eorv eht alyz dgo\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"\nIn the beginning, there was only darkness. Then, there was light. \nLight brought warmth, and warmth brought life. Life began to flourish \nin the vastness of the universe. Stars were born, and planets formed \naround them. On one such planet, life took hold and began its journey.\n\"\"\"\n\ndef search_word_occurrences(text, word):\n    occurrences = []\n    lines = text.strip().split(\"\\n\")\n    for line_number, line in enumerate(lines, start=1):\n        if re.search(rf'\\b{word}\\b', line, re.IGNORECASE):\n            occurrences.append((line_number, line.strip()))\n    return occurrences\n\nword_to_search = \"life\"\noccurrences = search_word_occurrences(text, word_to_search)\n\nfor line_number, line in occurrences:\n    print(f\"Line {line_number}: {line}\")"}, {"role": "assistant", "content": "Line 2: Light brought warmth, and warmth brought life. Life began to flourish\nLine 4: around them. On one such planet, life took hold and began its journey.\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef distance(point):\n    return math.sqrt(point[0]**2 + point[1]**2)\n\ndef calculate_area(points):\n    area = 0\n    n = len(points)\n    for i in range(n):\n        j = (i + 1) % n\n        area += points[i][0] * points[j][1]\n        area -= points[j][0] * points[i][1]\n    return abs(area) / 2.0\n\npoints = [\n    (3, 4), (1, 2), (5, 1), (7, 3), (9, 6),\n    (2, 5), (6, 8), (4, 7), (8, 9), (10, 0)\n]\n\nprint(\"Original Points:\")\nfor p in points:\n    print(p)\n\nsorted_points = sorted(points, key=distance)\n\nprint(\"\\nPoints Sorted by Distance from Origin:\")\nfor p in sorted_points:\n    print(p)\n\nprint(\"\\nPolygon Areas:\")\nareas = []\nfor i in range(len(sorted_points) - 2):\n    triangle = [sorted_points[0], sorted_points[i + 1], sorted_points[i + 2]]\n    area = calculate_area(triangle)\n    print(f\"Triangle {i + 1}: {triangle}, Area: {area}\")\n    areas.append((triangle, area))\n\nsorted_areas = sorted(areas, key=lambda x: x[1])\n\nprint(\"\\nTriangles Sorted by Area:\")\nfor triangle, area in sorted_areas:\n    print(f\"Triangle: {triangle}, Area: {area}\")"}, {"role": "assistant", "content": "Original Points:\n(3, 4)\n(1, 2)\n(5, 1)\n(7, 3)\n(9, 6)\n(2, 5)\n(6, 8)\n(4, 7)\n(8, 9)\n(10, 0)\n\nPoints Sorted by Distance from Origin:\n(1, 2)\n(3, 4)\n(5, 1)\n(2, 5)\n(7, 3)\n(4, 7)\n(6, 8)\n(10, 0)\n(9, 6)\n(8, 9)\n\nPolygon Areas:\nTriangle 1: [(1, 2), (3, 4), (5, 1)], Area: 5.0\nTriangle 2: [(1, 2), (5, 1), (2, 5)], Area: 6.5\nTriangle 3: [(1, 2), (2, 5), (7, 3)], Area: 8.5\nTriangle 4: [(1, 2), (7, 3), (4, 7)], Area: 13.5\nTriangle 5: [(1, 2), (4, 7), (6, 8)], Area: 3.5\nTriangle 6: [(1, 2), (6, 8), (10, 0)], Area: 32.0\nTriangle 7: [(1, 2), (10, 0), (9, 6)], Area: 26.0\nTriangle 8: [(1, 2), (9, 6), (8, 9)], Area: 14.0\n\nTriangles Sorted by Area:\nTriangle: [(1, 2), (4, 7), (6, 8)], Area: 3.5\nTriangle: [(1, 2), (3, 4), (5, 1)], Area: 5.0\nTriangle: [(1, 2), (5, 1), (2, 5)], Area: 6.5\nTriangle: [(1, 2), (2, 5), (7, 3)], Area: 8.5\nTriangle: [(1, 2), (7, 3), (4, 7)], Area: 13.5\nTriangle: [(1, 2), (9, 6), (8, 9)], Area: 14.0\nTriangle: [(1, 2), (10, 0), (9, 6)], Area: 26.0\nTriangle: [(1, 2), (6, 8), (10, 0)], Area: 32.0\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\nimport statistics\n\ndef generate_dates(start_date, num_days, interval):\n    current_date = start_date\n    dates = []\n    for _ in range(num_days):\n        dates.append(current_date)\n        current_date += timedelta(days=interval)\n    return dates\n\ndef calculate_date_differences(dates):\n    differences = []\n    for i in range(1, len(dates)):\n        differences.append((dates[i] - dates[i-1]).days)\n    return differences\n\ndef analyze_dates(dates):\n    differences = calculate_date_differences(dates)\n    print(\"Date Differences:\", differences)\n    mean_diff = statistics.mean(differences)\n    print(\"Mean Difference:\", mean_diff)\n    median_diff = statistics.median(differences)\n    print(\"Median Difference:\", median_diff)\n    return mean_diff, median_diff\n\ndef custom_sort(dates):\n    return sorted(dates, key=lambda x: x.isoweekday())\n\nstart_date = datetime(2023, 1, 1)\ndates = generate_dates(start_date, 50, 3)\nsorted_dates = custom_sort(dates)\n\nprint(\"Generated Dates:\")\nfor date in sorted_dates:\n    print(date.strftime('%Y-%m-%d'), date.strftime('%A'))\n\nprint(\"\\nAnalyzing Dates:\")\nanalyze_dates(sorted_dates)"}, {"role": "assistant", "content": "Generated Dates:\n2023-01-16 Monday\n2023-02-06 Monday\n2023-02-27 Monday\n2023-03-20 Monday\n2023-04-10 Monday\n2023-05-01 Monday\n2023-05-22 Monday\n2023-01-10 Tuesday\n2023-01-31 Tuesday\n2023-02-21 Tuesday\n2023-03-14 Tuesday\n2023-04-04 Tuesday\n2023-04-25 Tuesday\n2023-05-16 Tuesday\n2023-01-04 Wednesday\n2023-01-25 Wednesday\n2023-02-15 Wednesday\n2023-03-08 Wednesday\n2023-03-29 Wednesday\n2023-04-19 Wednesday\n2023-05-10 Wednesday\n2023-01-19 Thursday\n2023-02-09 Thursday\n2023-03-02 Thursday\n2023-03-23 Thursday\n2023-04-13 Thursday\n2023-05-04 Thursday\n2023-05-25 Thursday\n2023-01-13 Friday\n2023-02-03 Friday\n2023-02-24 Friday\n2023-03-17 Friday\n2023-04-07 Friday\n2023-04-28 Friday\n2023-05-19 Friday\n2023-01-07 Saturday\n2023-01-28 Saturday\n2023-02-18 Saturday\n2023-03-11 Saturday\n2023-04-01 Saturday\n2023-04-22 Saturday\n2023-05-13 Saturday\n2023-01-01 Sunday\n2023-01-22 Sunday\n2023-02-12 Sunday\n2023-03-05 Sunday\n2023-03-26 Sunday\n2023-04-16 Sunday\n2023-05-07 Sunday\n2023-05-28 Sunday\n\nAnalyzing Dates:\nDate Differences: [21, 21, 21, 21, 21, 21, -132, 21, 21, 21, 21, 21, 21, -132, 21, 21, 21, 21, 21, 21, -111, 21, 21, 21, 21, 21, 21, -132, 21, 21, 21, 21, 21, 21, -132, 21, 21, 21, 21, 21, 21, -132, 21, 21, 21, 21, 21, 21, 21]\nMean Difference: 2.693877551020408\nMedian Difference: 21\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef create_dates():\n    base_date = datetime(2023, 1, 1)\n    dates = [base_date + timedelta(days=i*7) for i in range(50)]\n    return dates\n\ndef sort_dates_by_day_of_week(dates):\n    def day_of_week_key(date):\n        return date.weekday(), date\n    \n    return sorted(dates, key=day_of_week_key)\n\ndates = create_dates()\nsorted_dates = sort_dates_by_day_of_week(dates)\n\nfor date in sorted_dates:\n    print(date.strftime(\"%Y-%m-%d %A\"))"}, {"role": "assistant", "content": "2023-01-01 Sunday\n2023-01-08 Sunday\n2023-01-15 Sunday\n2023-01-22 Sunday\n2023-01-29 Sunday\n2023-02-05 Sunday\n2023-02-12 Sunday\n2023-02-19 Sunday\n2023-02-26 Sunday\n2023-03-05 Sunday\n2023-03-12 Sunday\n2023-03-19 Sunday\n2023-03-26 Sunday\n2023-04-02 Sunday\n2023-04-09 Sunday\n2023-04-16 Sunday\n2023-04-23 Sunday\n2023-04-30 Sunday\n2023-05-07 Sunday\n2023-05-14 Sunday\n2023-05-21 Sunday\n2023-05-28 Sunday\n2023-06-04 Sunday\n2023-06-11 Sunday\n2023-06-18 Sunday\n2023-06-25 Sunday\n2023-07-02 Sunday\n2023-07-09 Sunday\n2023-07-16 Sunday\n2023-07-23 Sunday\n2023-07-30 Sunday\n2023-08-06 Sunday\n2023-08-13 Sunday\n2023-08-20 Sunday\n2023-08-27 Sunday\n2023-09-03 Sunday\n2023-09-10 Sunday\n2023-09-17 Sunday\n2023-09-24 Sunday\n2023-10-01 Sunday\n2023-10-08 Sunday\n2023-10-15 Sunday\n2023-10-22 Sunday\n2023-10-29 Sunday\n2023-11-05 Sunday\n2023-11-12 Sunday\n2023-11-19 Sunday\n2023-11-26 Sunday\n2023-12-03 Sunday\n2023-12-10 Sunday\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\ndef caesar_cipher_encode(text, shift):\n    encoded = []\n    for char in text:\n        if char.isalpha():\n            shift_amount = 65 if char.isupper() else 97\n            encoded_char = chr((ord(char) + shift - shift_amount) % 26 + shift_amount)\n            encoded.append(encoded_char)\n        else:\n            encoded.append(char)\n    return ''.join(encoded)\n\ndef binary_search_decrypt(ciphertext, target_word, shift_range):\n    left, right = 0, len(shift_range) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        shift = shift_range[mid]\n        decrypted_text = caesar_cipher_encode(ciphertext, shift)\n        if target_word in decrypted_text:\n            return decrypted_text\n        elif target_word < decrypted_text:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return \"Decryption failed\"\n\nciphertext = caesar_cipher_encode(\"Hello, World!\", 3)\nshift_range = list(range(1, 27))\ntarget_word = \"Hello\"\nprint(\"Ciphertext:\", ciphertext)\nprint(\"Decrypted Message:\", binary_search_decrypt(ciphertext, target_word, shift_range))"}, {"role": "assistant", "content": "Ciphertext: Khoor, Zruog!\nDecrypted Message: Decryption failed\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndates = [\n    \"2023-05-15\", \"2022-11-11\", \"2021-07-19\", \"2023-01-01\",\n    \"2022-03-30\", \"2023-12-25\", \"2021-10-31\", \"2023-02-14\",\n    \"2021-05-05\", \"2023-09-09\", \"2022-08-08\", \"2023-06-06\"\n]\n\ndate_objects = [datetime.strptime(date, \"%Y-%m-%d\") for date in dates]\n\nsorted_dates = sorted(date_objects, key=lambda d: (d.month, d.day, d.year))\n\ntransformed_dates = [date + timedelta(days=100) for date in sorted_dates]\n\nformatted_dates = [date.strftime(\"%Y-%m-%d\") for date in transformed_dates]\n\nprint(\"\\n\".join(formatted_dates))"}, {"role": "assistant", "content": "2023-04-11\n2023-05-25\n2022-07-08\n2021-08-13\n2023-08-23\n2023-09-14\n2021-10-27\n2022-11-16\n2023-12-18\n2022-02-08\n2023-02-19\n2024-04-03\n"}]}
{"messages": [{"role": "user", "content": "from math import sqrt\n\ndef is_perfect_square(n):\n    return int(sqrt(n))**2 == n\n\ndef generate_fibonacci_sequence(limit):\n    sequence = [0, 1]\n    while sequence[-1] < limit:\n        sequence.append(sequence[-1] + sequence[-2])\n    return sequence\n\ndef find_perfect_squares_in_fibonacci(limit):\n    fibonacci_sequence = generate_fibonacci_sequence(limit)\n    perfect_squares = [num for num in fibonacci_sequence if is_perfect_square(num)]\n    return perfect_squares\n\nlimit = 100000\nperfect_squares = find_perfect_squares_in_fibonacci(limit)\n\nfor num in perfect_squares:\n    print(num)"}, {"role": "assistant", "content": "0\n1\n1\n144\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef search_and_transform(data, pattern):\n    matches = []\n    print(\"Searching for pattern:\", pattern)\n    for i, item in enumerate(data):\n        if re.search(pattern, item):\n            transformed = item[::-1]\n            print(f\"Pattern found in item {i}: {item}, transformed to: {transformed}\")\n            matches.append(transformed)\n    return matches\n\ndata = [\n    \"apple123\", \"banana_456\", \"cherry789\", \"date_012\", \n    \"elderberry345\", \"fig_678\", \"grape901\", \"honeydew234\", \n    \"kiwi_567\", \"lemon890\", \"mango_123\", \"nectarine456\",\n    \"orange_789\", \"papaya012\", \"quince_345\", \"raspberry678\",\n    \"strawberry901\", \"tangerine_234\", \"ugli_fruit567\", \"vanilla890\"\n]\n\npattern = r\"\\d{3}\"\n\ntransformed_data = search_and_transform(data, pattern)\n\nprint(\"\\nAll transformed data:\")\nfor i, item in enumerate(transformed_data):\n    print(f\"{i + 1}: {item}\")"}, {"role": "assistant", "content": "Searching for pattern: \\d{3}\nPattern found in item 0: apple123, transformed to: 321elppa\nPattern found in item 1: banana_456, transformed to: 654_ananab\nPattern found in item 2: cherry789, transformed to: 987yrrehc\nPattern found in item 3: date_012, transformed to: 210_etad\nPattern found in item 4: elderberry345, transformed to: 543yrrebredle\nPattern found in item 5: fig_678, transformed to: 876_gif\nPattern found in item 6: grape901, transformed to: 109eparg\nPattern found in item 7: honeydew234, transformed to: 432wedyenoh\nPattern found in item 8: kiwi_567, transformed to: 765_iwik\nPattern found in item 9: lemon890, transformed to: 098nomel\nPattern found in item 10: mango_123, transformed to: 321_ognam\nPattern found in item 11: nectarine456, transformed to: 654eniratcen\nPattern found in item 12: orange_789, transformed to: 987_egnaro\nPattern found in item 13: papaya012, transformed to: 210ayapap\nPattern found in item 14: quince_345, transformed to: 543_ecniuq\nPattern found in item 15: raspberry678, transformed to: 876yrrebpsar\nPattern found in item 16: strawberry901, transformed to: 109yrrebwarts\nPattern found in item 17: tangerine_234, transformed to: 432_eniregnat\nPattern found in item 18: ugli_fruit567, transformed to: 765tiurf_ilgu\nPattern found in item 19: vanilla890, transformed to: 098allinav\n\nAll transformed data:\n1: 321elppa\n2: 654_ananab\n3: 987yrrehc\n4: 210_etad\n5: 543yrrebredle\n6: 876_gif\n7: 109eparg\n8: 432wedyenoh\n9: 765_iwik\n10: 098nomel\n11: 321_ognam\n12: 654eniratcen\n13: 987_egnaro\n14: 210ayapap\n15: 543_ecniuq\n16: 876yrrebpsar\n17: 109yrrebwarts\n18: 432_eniregnat\n19: 765tiurf_ilgu\n20: 098allinav\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef custom_sort(numbers):\n    return sorted(numbers, key=lambda x: (x % 5, x))\n\ndef generate_sequence(n):\n    return [int(math.sin(x) * 100) for x in range(n)]\n\ndef process_sequence(sequence):\n    sequence = custom_sort(sequence)\n    print(\"Sorted sequence based on modulo 5 and natural order:\")\n    for num in sequence:\n        print(num)\n        \ndef calculate_threshold(sequence):\n    total = sum(sequence)\n    threshold = total // len(sequence)\n    print(f\"Calculated threshold: {threshold}\")\n    return threshold\n\ndef filter_below_threshold(sequence, threshold):\n    print(\"Filtering numbers below threshold...\")\n    return [x for x in sequence if x < threshold]\n\nsequence = generate_sequence(50)\nprint(\"Generated sequence:\")\nprint(sequence)\n\nprocess_sequence(sequence)\n\nthreshold = calculate_threshold(sequence)\nfiltered_sequence = filter_below_threshold(sequence, threshold)\n\nprint(\"Filtered sequence:\")\nfor num in filtered_sequence:\n    print(num)"}, {"role": "assistant", "content": "Generated sequence:\n[0, 84, 90, 14, -75, -95, -27, 65, 98, 41, -54, -99, -53, 42, 99, 65, -28, -96, -75, 14, 91, 83, 0, -84, -90, -13, 76, 95, 27, -66, -98, -40, 55, 99, 52, -42, -99, -64, 29, 96, 74, -15, -91, -83, 1, 85, 90, 12, -76, -95]\nSorted sequence based on modulo 5 and natural order:\n-95\n-95\n-90\n-75\n-75\n-40\n-15\n0\n0\n55\n65\n65\n85\n90\n90\n95\n-99\n-99\n-84\n-64\n-54\n1\n41\n76\n91\n96\n-98\n-83\n-53\n-28\n-13\n12\n27\n42\n52\n-42\n-27\n83\n98\n-96\n-91\n-76\n-66\n14\n14\n29\n74\n84\n99\n99\nCalculated threshold: 0\nFiltering numbers below threshold...\nFiltered sequence:\n-75\n-95\n-27\n-54\n-99\n-53\n-28\n-96\n-75\n-84\n-90\n-13\n-66\n-98\n-40\n-42\n-99\n-64\n-15\n-91\n-83\n-76\n-95\n"}]}
{"messages": [{"role": "user", "content": "from statistics import mean, median, mode, stdev\n\ndef closest_to_mean(numbers):\n    avg = mean(numbers)\n    return min(numbers, key=lambda x: abs(x - avg))\n\ndef closest_to_median(numbers):\n    med = median(numbers)\n    return min(numbers, key=lambda x: abs(x - med))\n\ndef closest_to_mode(numbers):\n    try:\n        mod = mode(numbers)\n        return min(numbers, key=lambda x: abs(x - mod))\n    except:\n        return None\n\ndef closest_to_stdev(numbers):\n    if len(numbers) < 2:\n        return None\n    dev = stdev(numbers)\n    return min(numbers, key=lambda x: abs(x - dev))\n\ndataset = [\n    [15, 36, 23, 11, 9, 42, 37, 44, 12, 18, 19, 21],\n    [20, 20, 20, 20, 20, 20, 20, 21, 22, 22, 23, 24],\n    [1, 2, 7, 8, 9, 13, 14, 15, 16, 17, 17, 18],\n    [40, 42, 42, 45, 47, 49, 50, 52, 54, 55, 56, 60],\n    [5, 5, 6, 7, 7, 8, 10, 10, 11, 12, 14, 15],\n]\n\nresults = []\n\nfor data in dataset:\n    results.append({\n        \"data\": data,\n        \"closest_to_mean\": closest_to_mean(data),\n        \"closest_to_median\": closest_to_median(data),\n        \"closest_to_mode\": closest_to_mode(data),\n        \"closest_to_stdev\": closest_to_stdev(data),\n    })\n\nfor result in results:\n    print(\"Data:\", result[\"data\"])\n    print(\"Closest to Mean:\", result[\"closest_to_mean\"])\n    print(\"Closest to Median:\", result[\"closest_to_median\"])\n    print(\"Closest to Mode:\", result[\"closest_to_mode\"])\n    print(\"Closest to Standard Deviation:\", result[\"closest_to_stdev\"])\n    print()"}, {"role": "assistant", "content": "Data: [15, 36, 23, 11, 9, 42, 37, 44, 12, 18, 19, 21]\nClosest to Mean: 23\nClosest to Median: 19\nClosest to Mode: 15\nClosest to Standard Deviation: 12\n\nData: [20, 20, 20, 20, 20, 20, 20, 21, 22, 22, 23, 24]\nClosest to Mean: 21\nClosest to Median: 20\nClosest to Mode: 20\nClosest to Standard Deviation: 20\n\nData: [1, 2, 7, 8, 9, 13, 14, 15, 16, 17, 17, 18]\nClosest to Mean: 13\nClosest to Median: 13\nClosest to Mode: 17\nClosest to Standard Deviation: 7\n\nData: [40, 42, 42, 45, 47, 49, 50, 52, 54, 55, 56, 60]\nClosest to Mean: 49\nClosest to Median: 49\nClosest to Mode: 42\nClosest to Standard Deviation: 40\n\nData: [5, 5, 6, 7, 7, 8, 10, 10, 11, 12, 14, 15]\nClosest to Mean: 10\nClosest to Median: 8\nClosest to Mode: 5\nClosest to Standard Deviation: 5\n\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef median_of_medians(lst, k):\n    sublists = [lst[j:j+5] for j in range(0, len(lst), 5)]\n    medians = [sorted(sublist)[len(sublist)//2] for sublist in sublists]\n    if len(medians) <= 5:\n        pivot = sorted(medians)[len(medians)//2]\n    else:\n        pivot = median_of_medians(medians, len(medians)//2)\n    \n    lows = [el for el in lst if el < pivot]\n    highs = [el for el in lst if el > pivot]\n    pivots = [el for el in lst if el == pivot]\n    \n    if k < len(lows):\n        return median_of_medians(lows, k)\n    elif k < len(lows) + len(pivots):\n        return pivots[0]\n    else:\n        return median_of_medians(highs, k - len(lows) - len(pivots))\n\ndata = [\n    23, 1, 45, 78, 90, 34, 67, 89, 2, 56,\n    43, 99, 12, 49, 8, 75, 65, 3, 88, 47,\n    29, 32, 64, 91, 24, 57, 83, 7, 11, 66\n]\n\nprint(\"Data (Unsorted):\", data)\nsorted_data = sorted(data)\nprint(\"\\nData (Sorted):\", sorted_data)\nprint(\"\\nMedian:\", statistics.median(sorted_data))\n\nmedians = [median_of_medians(data, i) for i in range(len(data))]\nprint(\"\\nCalculated Medians:\")\nfor i, med in enumerate(medians):\n    print(f\"Position {i}: {med}\")"}, {"role": "assistant", "content": "Data (Unsorted): [23, 1, 45, 78, 90, 34, 67, 89, 2, 56, 43, 99, 12, 49, 8, 75, 65, 3, 88, 47, 29, 32, 64, 91, 24, 57, 83, 7, 11, 66]\n\nData (Sorted): [1, 2, 3, 7, 8, 11, 12, 23, 24, 29, 32, 34, 43, 45, 47, 49, 56, 57, 64, 65, 66, 67, 75, 78, 83, 88, 89, 90, 91, 99]\n\nMedian: 48.0\n\nCalculated Medians:\nPosition 0: 1\nPosition 1: 2\nPosition 2: 3\nPosition 3: 7\nPosition 4: 8\nPosition 5: 11\nPosition 6: 12\nPosition 7: 23\nPosition 8: 24\nPosition 9: 29\nPosition 10: 32\nPosition 11: 34\nPosition 12: 43\nPosition 13: 45\nPosition 14: 47\nPosition 15: 49\nPosition 16: 56\nPosition 17: 57\nPosition 18: 64\nPosition 19: 65\nPosition 20: 66\nPosition 21: 67\nPosition 22: 75\nPosition 23: 78\nPosition 24: 83\nPosition 25: 88\nPosition 26: 89\nPosition 27: 90\nPosition 28: 91\nPosition 29: 99\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef leap_years_between_dates(start_date, end_date):\n    years = range(start_date.year, end_date.year + 1)\n    leap_years = [year for year in years if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)]\n    return leap_years\n\ndef date_difference_in_days(date1, date2):\n    return abs((date2 - date1).days)\n\ndef find_closest_leap_year_date(start_date, end_date, target_date):\n    leap_years = leap_years_between_dates(start_date, end_date)\n    print(f\"Leap years between {start_date.year} and {end_date.year}: {leap_years}\")\n    \n    leap_year_dates = [datetime(year, 2, 29) for year in leap_years]\n    closest_date = min(leap_year_dates, key=lambda date: date_difference_in_days(date, target_date))\n    \n    return closest_date\n\ndef main():\n    start_date = datetime(1900, 1, 1)\n    end_date = datetime(2100, 12, 31)\n    target_date = datetime(2023, 10, 25)\n\n    closest_leap_year_date = find_closest_leap_year_date(start_date, end_date, target_date)\n    \n    print(f\"Target date: {target_date.strftime('%Y-%m-%d')}\")\n    print(f\"Closest leap year date: {closest_leap_year_date.strftime('%Y-%m-%d')}\")\n\nmain()"}, {"role": "assistant", "content": "Leap years between 1900 and 2100: [1904, 1908, 1912, 1916, 1920, 1924, 1928, 1932, 1936, 1940, 1944, 1948, 1952, 1956, 1960, 1964, 1968, 1972, 1976, 1980, 1984, 1988, 1992, 1996, 2000, 2004, 2008, 2012, 2016, 2020, 2024, 2028, 2032, 2036, 2040, 2044, 2048, 2052, 2056, 2060, 2064, 2068, 2072, 2076, 2080, 2084, 2088, 2092, 2096]\nTarget date: 2023-10-25\nClosest leap year date: 2024-02-29\n"}]}
{"messages": [{"role": "user", "content": "def bubble_sort_pattern(n):\n    pattern = []\n    for i in range(n):\n        row = []\n        for j in range(n):\n            row.append((i+j) % n)\n        pattern.append(row)\n\n    for i in range(n-1):\n        for j in range(n-i-1):\n            if pattern[j] > pattern[j+1]:\n                pattern[j], pattern[j+1] = pattern[j+1], pattern[j]\n    \n    return pattern\n\ndef print_pattern(pattern):\n    for row in pattern:\n        print(\" \".join(str(x) for x in row))\n\nn = 10\nsorted_pattern = bubble_sort_pattern(n)\nprint_pattern(sorted_pattern)"}, {"role": "assistant", "content": "0 1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9 0\n2 3 4 5 6 7 8 9 0 1\n3 4 5 6 7 8 9 0 1 2\n4 5 6 7 8 9 0 1 2 3\n5 6 7 8 9 0 1 2 3 4\n6 7 8 9 0 1 2 3 4 5\n7 8 9 0 1 2 3 4 5 6\n8 9 0 1 2 3 4 5 6 7\n9 0 1 2 3 4 5 6 7 8\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef search_word_in_text(text, word):\n    words = re.findall(r'\\b\\w+\\b', text)\n    left, right = 0, len(words) - 1\n    steps = 0\n    while left <= right:\n        mid = left + (right - left) // 2\n        print(f\"Step {steps}: Checking word '{words[mid]}' at index {mid}\")\n        if words[mid] == word:\n            print(f\"Word '{word}' found at index {mid}\")\n            return mid\n        elif words[mid] < word:\n            left = mid + 1\n        else:\n            right = mid - 1\n        steps += 1\n    print(f\"Word '{word}' not found after {steps} steps\")\n    return -1\n\ntext = \"The quick brown fox jumps over the lazy dog multiple times in the text\"\nword_to_search = \"lazy\"\nindex = search_word_in_text(text, word_to_search)\nprint(f\"Index of word '{word_to_search}': {index}\")"}, {"role": "assistant", "content": "Step 0: Checking word 'the' at index 6\nStep 1: Checking word 'brown' at index 2\nStep 2: Checking word 'jumps' at index 4\nStep 3: Checking word 'over' at index 5\nWord 'lazy' not found after 4 steps\nIndex of word 'lazy': -1\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef distance_from_origin(point):\n    x, y = point\n    return math.sqrt(x**2 + y**2)\n\ndef closest_point(points):\n    min_distance = float('inf')\n    closest = None\n    for point in points:\n        dist = distance_from_origin(point)\n        print(f\"Checking point {point}, distance from origin: {dist:.2f}\")\n        if dist < min_distance:\n            min_distance = dist\n            closest = point\n            print(f\"New closest point found: {closest} with distance {min_distance:.2f}\")\n    return closest\n\npoints = [(3, 4), (1, 2), (5, 5), (0, 1), (2, 2), (8, 1), (0, 0), (7, 3), (3, 3), (6, 6)]\n\nprint(\"Starting search for the closest point to the origin...\")\nclosest = closest_point(points)\nprint(\"\\nFinished search.\")\nprint(f\"Closest point to the origin is {closest} with distance {distance_from_origin(closest):.2f}\")"}, {"role": "assistant", "content": "Starting search for the closest point to the origin...\nChecking point (3, 4), distance from origin: 5.00\nNew closest point found: (3, 4) with distance 5.00\nChecking point (1, 2), distance from origin: 2.24\nNew closest point found: (1, 2) with distance 2.24\nChecking point (5, 5), distance from origin: 7.07\nChecking point (0, 1), distance from origin: 1.00\nNew closest point found: (0, 1) with distance 1.00\nChecking point (2, 2), distance from origin: 2.83\nChecking point (8, 1), distance from origin: 8.06\nChecking point (0, 0), distance from origin: 0.00\nNew closest point found: (0, 0) with distance 0.00\nChecking point (7, 3), distance from origin: 7.62\nChecking point (3, 3), distance from origin: 4.24\nChecking point (6, 6), distance from origin: 8.49\n\nFinished search.\nClosest point to the origin is (0, 0) with distance 0.00\n"}]}
{"messages": [{"role": "user", "content": "def generate_spiral_matrix(n):\n    matrix = [[0] * n for _ in range(n)]\n    num = 1\n    left, right, top, bottom = 0, n - 1, 0, n - 1\n    while left <= right and top <= bottom:\n        for i in range(left, right + 1):\n            matrix[top][i] = num\n            num += 1\n        top += 1\n        for i in range(top, bottom + 1):\n            matrix[i][right] = num\n            num += 1\n        right -= 1\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                matrix[bottom][i] = num\n                num += 1\n            bottom -= 1\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                matrix[i][left] = num\n                num += 1\n            left += 1\n    return matrix\n\ndef search_spiral_pattern(matrix, pattern_length):\n    n = len(matrix)\n    for layer in range((n + 1) // 2):\n        for i in range(layer, n - layer):\n            if matrix[layer][i] == pattern_length:\n                return (layer, i)\n        for i in range(layer + 1, n - layer):\n            if matrix[i][n - layer - 1] == pattern_length:\n                return (i, n - layer - 1)\n        for i in range(n - layer - 2, layer - 1, -1):\n            if matrix[n - layer - 1][i] == pattern_length:\n                return (n - layer - 1, i)\n        for i in range(n - layer - 2, layer, -1):\n            if matrix[i][layer] == pattern_length:\n                return (i, layer)\n    return None\n\nn = 10\nmatrix = generate_spiral_matrix(n)\npattern_length = 50\nfound_position = search_spiral_pattern(matrix, pattern_length)\n\nfor row in matrix:\n    print(' '.join(f'{num:2}' for num in row))\nprint(f'Pattern length {pattern_length} found at position: {found_position}')"}, {"role": "assistant", "content": " 1  2  3  4  5  6  7  8  9 10\n36 37 38 39 40 41 42 43 44 11\n35 64 65 66 67 68 69 70 45 12\n34 63 84 85 86 87 88 71 46 13\n33 62 83 96 97 98 89 72 47 14\n32 61 82 95 100 99 90 73 48 15\n31 60 81 94 93 92 91 74 49 16\n30 59 80 79 78 77 76 75 50 17\n29 58 57 56 55 54 53 52 51 18\n28 27 26 25 24 23 22 21 20 19\nPattern length 50 found at position: (7, 8)\n"}]}
{"messages": [{"role": "user", "content": "def sort_words_by_length(words):\n    return sorted(words, key=len)\n\ndef alphabetize_words(words):\n    return sorted(words)\n\ntext = \"\"\"\nSorting algorithms are a fundamental part of computer science.\nThey are used to arrange data in a specific order.\nIn this example, we will focus on sorting words.\n\"\"\"\n\nwords = text.lower().split()\n\nsorted_by_length = sort_words_by_length(words)\nalphabetized_words = alphabetize_words(words)\n\nfor word in sorted_by_length:\n    print(word)\n\nprint(\"\\n\")\n\nfor word in alphabetized_words:\n    print(word)"}, {"role": "assistant", "content": "a\na\nof\nto\nin\nin\nwe\non\nare\nare\npart\nthey\nused\ndata\nthis\nwill\nfocus\norder.\nwords.\nsorting\narrange\nsorting\ncomputer\nscience.\nspecific\nexample,\nalgorithms\nfundamental\n\n\na\na\nalgorithms\nare\nare\narrange\ncomputer\ndata\nexample,\nfocus\nfundamental\nin\nin\nof\non\norder.\npart\nscience.\nsorting\nsorting\nspecific\nthey\nthis\nto\nused\nwe\nwill\nwords.\n"}]}
{"messages": [{"role": "user", "content": "def bubble_sort(scores):\n    n = len(scores)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if scores[j] < scores[j+1]:\n                scores[j], scores[j+1] = scores[j+1], scores[j]\n\nplayers = [\n    {\"name\": \"Alice\", \"score\": 88},\n    {\"name\": \"Bob\", \"score\": 95},\n    {\"name\": \"Charlie\", \"score\": 91},\n    {\"name\": \"David\", \"score\": 83},\n    {\"name\": \"Eva\", \"score\": 97},\n    {\"name\": \"Frank\", \"score\": 89},\n    {\"name\": \"Grace\", \"score\": 92},\n    {\"name\": \"Hannah\", \"score\": 85},\n    {\"name\": \"Ivy\", \"score\": 90},\n    {\"name\": \"Jack\", \"score\": 84}\n]\n\nscores = [player[\"score\"] for player in players]\nbubble_sort(scores)\n\nranked_players = []\nfor score in scores:\n    for player in players:\n        if player[\"score\"] == score and player not in ranked_players:\n            ranked_players.append(player)\n            break\n\nfor position, player in enumerate(ranked_players, start=1):\n    print(f\"Rank {position}: {player['name']} with score {player['score']}\")"}, {"role": "assistant", "content": "Rank 1: Eva with score 97\nRank 2: Bob with score 95\nRank 3: Grace with score 92\nRank 4: Charlie with score 91\nRank 5: Ivy with score 90\nRank 6: Frank with score 89\nRank 7: Alice with score 88\nRank 8: Hannah with score 85\nRank 9: Jack with score 84\nRank 10: David with score 83\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef distance_from_origin(point):\n    return math.sqrt(point[0] ** 2 + point[1] ** 2)\n\ndef sort_points_by_distance(points):\n    return sorted(points, key=distance_from_origin, reverse=True)\n\ndef calculate_area_of_polygon(points):\n    n = len(points)\n    area = 0.0\n    for i in range(n):\n        j = (i + 1) % n\n        area += points[i][0] * points[j][1]\n        area -= points[j][0] * points[i][1]\n    return abs(area) / 2.0\n\ndef main():\n    points = [(2, 3), (5, 11), (12, 8), (9, 5), (5, 6)]\n    sorted_points = sort_points_by_distance(points)\n    print(\"Sorted Points (Farthest to Closest):\")\n    for point in sorted_points:\n        print(point)\n    print(\"\\nArea of Polygon:\", calculate_area_of_polygon(sorted_points))\n\nmain()"}, {"role": "assistant", "content": "Sorted Points (Farthest to Closest):\n(12, 8)\n(5, 11)\n(9, 5)\n(5, 6)\n(2, 3)\n\nArea of Polygon: 15.0\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndata_points = [\n    (2, 3), (3, 4), (5, 1), (7, 8), (8, 9),\n    (5, 6), (3, 5), (9, 0), (4, 2), (6, 7)\n]\n\nquery_point = (4, 5)\n\ndef euclidean_distance(point1, point2):\n    return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2)\n\ndistances = [(euclidean_distance(query_point, point), point) for point in data_points]\ndistances.sort()\n\nfor distance, point in distances:\n    print(f\"Point: {point}, Distance: {distance:.2f}\")"}, {"role": "assistant", "content": "Point: (3, 5), Distance: 1.00\nPoint: (3, 4), Distance: 1.41\nPoint: (5, 6), Distance: 1.41\nPoint: (2, 3), Distance: 2.83\nPoint: (6, 7), Distance: 2.83\nPoint: (4, 2), Distance: 3.00\nPoint: (5, 1), Distance: 4.12\nPoint: (7, 8), Distance: 4.24\nPoint: (8, 9), Distance: 5.66\nPoint: (9, 0), Distance: 7.07\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\nfrom statistics import median\n\ndef parse_date(date_string):\n    return datetime.strptime(date_string, '%Y-%m-%d')\n\ndata = [\n    ('2023-09-15', 10),\n    ('2023-01-01', 5),\n    ('2023-05-23', 8),\n    ('2023-03-19', 12),\n    ('2023-07-04', 7),\n    ('2023-11-11', 15),\n    ('2023-02-14', 3),\n    ('2023-08-08', 9),\n    ('2023-04-25', 6),\n    ('2023-10-31', 11)\n]\n\nsorted_data = sorted(data, key=lambda x: parse_date(x[0]))\nvalues = [x[1] for x in sorted_data]\nmedian_value = median(values)\n\nsorted_data_filtered = [entry for entry in sorted_data if entry[1] > median_value]\n\nfor date, value in sorted_data_filtered:\n    print(f\"{date}: {value}\")"}, {"role": "assistant", "content": "2023-03-19: 12\n2023-08-08: 9\n2023-09-15: 10\n2023-10-31: 11\n2023-11-11: 15\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef generate_dates(start_date, num_days):\n    dates = [start_date + timedelta(days=i) for i in range(num_days)]\n    return dates\n\ndef date_custom_sort(dates):\n    def custom_key(date):\n        return (date.day % 7, date.month, date.year)\n    return sorted(dates, key=custom_key)\n\nstart_date = datetime(2023, 1, 1)\nnum_days = 90\ndates = generate_dates(start_date, num_days)\nsorted_dates = date_custom_sort(dates)\n\nfor date in sorted_dates:\n    print(date.strftime('%Y-%m-%d'))"}, {"role": "assistant", "content": "2023-01-07\n2023-01-14\n2023-01-21\n2023-01-28\n2023-02-07\n2023-02-14\n2023-02-21\n2023-02-28\n2023-03-07\n2023-03-14\n2023-03-21\n2023-03-28\n2023-01-01\n2023-01-08\n2023-01-15\n2023-01-22\n2023-01-29\n2023-02-01\n2023-02-08\n2023-02-15\n2023-02-22\n2023-03-01\n2023-03-08\n2023-03-15\n2023-03-22\n2023-03-29\n2023-01-02\n2023-01-09\n2023-01-16\n2023-01-23\n2023-01-30\n2023-02-02\n2023-02-09\n2023-02-16\n2023-02-23\n2023-03-02\n2023-03-09\n2023-03-16\n2023-03-23\n2023-03-30\n2023-01-03\n2023-01-10\n2023-01-17\n2023-01-24\n2023-01-31\n2023-02-03\n2023-02-10\n2023-02-17\n2023-02-24\n2023-03-03\n2023-03-10\n2023-03-17\n2023-03-24\n2023-03-31\n2023-01-04\n2023-01-11\n2023-01-18\n2023-01-25\n2023-02-04\n2023-02-11\n2023-02-18\n2023-02-25\n2023-03-04\n2023-03-11\n2023-03-18\n2023-03-25\n2023-01-05\n2023-01-12\n2023-01-19\n2023-01-26\n2023-02-05\n2023-02-12\n2023-02-19\n2023-02-26\n2023-03-05\n2023-03-12\n2023-03-19\n2023-03-26\n2023-01-06\n2023-01-13\n2023-01-20\n2023-01-27\n2023-02-06\n2023-02-13\n2023-02-20\n2023-02-27\n2023-03-06\n2023-03-13\n2023-03-20\n2023-03-27\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef find_fridays(start_date, end_date):\n    current_date = start_date\n    fridays = []\n    while current_date <= end_date:\n        if current_date.weekday() == 4:\n            fridays.append(current_date)\n        current_date += datetime.timedelta(days=1)\n    return fridays\n\ndef find_friday_near_month_start(fridays):\n    for friday in fridays:\n        if 1 <= friday.day <= 7:\n            return friday\n    return None\n\ndef main():\n    start_date = datetime.date(2022, 1, 1)\n    end_date = datetime.date(2023, 1, 1)\n    fridays = find_fridays(start_date, end_date)\n    \n    print(f\"Total Fridays found: {len(fridays)}\")\n    first_friday = find_friday_near_month_start(fridays)\n    \n    if first_friday:\n        print(f\"The first Friday near the start of a month is: {first_friday}\")\n    else:\n        print(\"No Fridays found near the start of any month.\")\n\n    for friday in fridays:\n        print(friday)\n\nmain()"}, {"role": "assistant", "content": "Total Fridays found: 52\nThe first Friday near the start of a month is: 2022-01-07\n2022-01-07\n2022-01-14\n2022-01-21\n2022-01-28\n2022-02-04\n2022-02-11\n2022-02-18\n2022-02-25\n2022-03-04\n2022-03-11\n2022-03-18\n2022-03-25\n2022-04-01\n2022-04-08\n2022-04-15\n2022-04-22\n2022-04-29\n2022-05-06\n2022-05-13\n2022-05-20\n2022-05-27\n2022-06-03\n2022-06-10\n2022-06-17\n2022-06-24\n2022-07-01\n2022-07-08\n2022-07-15\n2022-07-22\n2022-07-29\n2022-08-05\n2022-08-12\n2022-08-19\n2022-08-26\n2022-09-02\n2022-09-09\n2022-09-16\n2022-09-23\n2022-09-30\n2022-10-07\n2022-10-14\n2022-10-21\n2022-10-28\n2022-11-04\n2022-11-11\n2022-11-18\n2022-11-25\n2022-12-02\n2022-12-09\n2022-12-16\n2022-12-23\n2022-12-30\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\ndef custom_sort_string(s):\n    freq = {}\n    for char in s:\n        freq[char] = freq.get(char, 0) + 1\n    return ''.join(sorted(s, key=lambda x: (freq[x], x)))\n\ndef date_to_encoded_string(date):\n    ordinal = date.toordinal()\n    encoded = \"\"\n    while ordinal > 0:\n        ordinal, remainder = divmod(ordinal, 26)\n        encoded = chr(65 + remainder) + encoded\n    return encoded\n\ndates = [\n    datetime(2023, 10, 1),\n    datetime(2023, 2, 14),\n    datetime(2023, 7, 4),\n    datetime(2023, 12, 25),\n    datetime(2023, 1, 1),\n    datetime(2023, 11, 11),\n    datetime(2023, 5, 5),\n    datetime(2023, 8, 8),\n    datetime(2023, 3, 17),\n    datetime(2023, 6, 30),\n    datetime(2023, 9, 9),\n    datetime(2023, 4, 1)\n]\n\nencoded_strings = [date_to_encoded_string(date) for date in dates]\nsorted_encoded_strings = sorted(encoded_strings, key=custom_sort_string)\n\nfor encoded_string in sorted_encoded_strings:\n    print(encoded_string)"}, {"role": "assistant", "content": "BQAVC\nBQAQD\nBQAXE\nBQAWI\nBQAOJ\nBQARL\nBQAMR\nBQAPO\nBQATP\nBQATT\nBQAYT\nBQBAL\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef calculate_median_absolute_deviation(data):\n    median_value = statistics.median(data)\n    absolute_deviations = [abs(x - median_value) for x in data]\n    mad = statistics.median(absolute_deviations)\n    return mad\n\ndef insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr\n\ndata = [2.5, 0.5, 1.5, 3.5, 0.1, 2.2, 4.8, 3.3, 2.9, 4.1]\nsorted_data = insertion_sort(data)\nmad = calculate_median_absolute_deviation(sorted_data)\nfor value in sorted_data:\n    print(f\"{value:.1f}\")\n\nprint(f\"Median Absolute Deviation: {mad:.2f}\")"}, {"role": "assistant", "content": "0.1\n0.5\n1.5\n2.2\n2.5\n2.9\n3.3\n3.5\n4.1\n4.8\nMedian Absolute Deviation: 1.00\n"}]}
{"messages": [{"role": "user", "content": "def generate_pattern(n):\n    pattern = []\n    for i in range(1, n + 1):\n        line = ''.join(str((i + j) % 10) for j in range(n))\n        pattern.append(line)\n    return pattern\n\ndef sort_pattern(pattern):\n    return sorted(pattern, key=lambda x: x[::-1])\n\ndef main():\n    n = 10\n    pattern = generate_pattern(n)\n    sorted_pattern = sort_pattern(pattern)\n    for line in sorted_pattern:\n        print(line)\n\nif __name__ == \"__main__\":\n    main()"}, {"role": "assistant", "content": "1234567890\n2345678901\n3456789012\n4567890123\n5678901234\n6789012345\n7890123456\n8901234567\n9012345678\n0123456789\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef approximate_median(data):\n    sorted_data = sorted(data)\n    print(f\"Sorted data: {sorted_data}\")\n    \n    length = len(sorted_data)\n    mid_index = length // 2\n    \n    if length % 2 == 0:\n        median = (sorted_data[mid_index - 1] + sorted_data[mid_index + 1]) / 2\n    else:\n        median = sorted_data[mid_index]\n    \n    print(f\"Approximate Median: {median}\")\n    return median\n\ndata = [34, 7, 23, 32, 5, 62, 32, 45, 24, 31, 12, 41, 54, 23, 9, 35, 87, 65, 47, 29]\nprint(\"Data:\", data)\n\nfound_median = approximate_median(data)\ncorrect_median = statistics.median(data)\n\nprint(f\"Found Median: {found_median}\")\nprint(f\"Correct Median: {correct_median}\")"}, {"role": "assistant", "content": "Data: [34, 7, 23, 32, 5, 62, 32, 45, 24, 31, 12, 41, 54, 23, 9, 35, 87, 65, 47, 29]\nSorted data: [5, 7, 9, 12, 23, 23, 24, 29, 31, 32, 32, 34, 35, 41, 45, 47, 54, 62, 65, 87]\nApproximate Median: 33.0\nFound Median: 33.0\nCorrect Median: 32.0\n"}]}
{"messages": [{"role": "user", "content": "def generate_pattern(n):\n    pattern = []\n    for i in range(n):\n        row = \"\"\n        if i % 2 == 0:\n            row = \"*\" * (i + 1)\n        else:\n            row = \"#\" * (i + 1)\n        pattern.append(row)\n    return pattern\n\ndef search_pattern(pattern, search_for):\n    found = []\n    for i, line in enumerate(pattern):\n        print(f\"Checking line {i}: {line}\")\n        if search_for in line:\n            found.append(i)\n    return found\n\ndef main():\n    n = 20\n    pattern = generate_pattern(n)\n    search_for = \"**\"\n    print(\"Generated Pattern:\")\n    for line in pattern:\n        print(line)\n    print(\"\\nSearching for pattern:\", search_for)\n    found_indices = search_pattern(pattern, search_for)\n    print(\"\\nFound at lines:\", found_indices)\n\nif __name__ == \"__main__\":\n    main()"}, {"role": "assistant", "content": "Generated Pattern:\n*\n##\n***\n####\n*****\n######\n*******\n########\n*********\n##########\n***********\n############\n*************\n##############\n***************\n################\n*****************\n##################\n*******************\n####################\n\nSearching for pattern: **\nChecking line 0: *\nChecking line 1: ##\nChecking line 2: ***\nChecking line 3: ####\nChecking line 4: *****\nChecking line 5: ######\nChecking line 6: *******\nChecking line 7: ########\nChecking line 8: *********\nChecking line 9: ##########\nChecking line 10: ***********\nChecking line 11: ############\nChecking line 12: *************\nChecking line 13: ##############\nChecking line 14: ***************\nChecking line 15: ################\nChecking line 16: *****************\nChecking line 17: ##################\nChecking line 18: *******************\nChecking line 19: ####################\n\nFound at lines: [2, 4, 6, 8, 10, 12, 14, 16, 18]\n"}]}
{"messages": [{"role": "user", "content": "def generate_sequence(n):\n    sequence = []\n    for i in range(1, n+1):\n        seq_val = (i * (i + 1)) // 2\n        sequence.append(seq_val)\n    return sequence\n\ndef custom_sort(seq):\n    return sorted(seq, key=lambda x: (x % 5, x))\n\nn = 50\nsequence = generate_sequence(n)\nprint(\"Generated sequence:\")\nprint(sequence)\n\nsorted_sequence = custom_sort(sequence)\nprint(\"\\nSorted sequence by mod 5 and value:\")\nprint(sorted_sequence)\n\nfor index, value in enumerate(sorted_sequence):\n    if index % 10 == 0:\n        print(\"\\nIndex\", index, \"to\", index + 9)\n    print(value, end=\", \")"}, {"role": "assistant", "content": "Generated sequence:\n[1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66, 78, 91, 105, 120, 136, 153, 171, 190, 210, 231, 253, 276, 300, 325, 351, 378, 406, 435, 465, 496, 528, 561, 595, 630, 666, 703, 741, 780, 820, 861, 903, 946, 990, 1035, 1081, 1128, 1176, 1225, 1275]\n\nSorted sequence by mod 5 and value:\n[10, 15, 45, 55, 105, 120, 190, 210, 300, 325, 435, 465, 595, 630, 780, 820, 990, 1035, 1225, 1275, 1, 6, 21, 36, 66, 91, 136, 171, 231, 276, 351, 406, 496, 561, 666, 741, 861, 946, 1081, 1176, 3, 28, 78, 153, 253, 378, 528, 703, 903, 1128]\n\nIndex 0 to 9\n10, 15, 45, 55, 105, 120, 190, 210, 300, 325, \nIndex 10 to 19\n435, 465, 595, 630, 780, 820, 990, 1035, 1225, 1275, \nIndex 20 to 29\n1, 6, 21, 36, 66, 91, 136, 171, 231, 276, \nIndex 30 to 39\n351, 406, 496, 561, 666, 741, 861, 946, 1081, 1176, \nIndex 40 to 49\n3, 28, 78, 153, 253, 378, 528, 703, 903, 1128, "}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\nclass Event:\n    def __init__(self, name, date_str):\n        self.name = name\n        self.date = datetime.strptime(date_str, '%Y-%m-%d')\n        \n    def __repr__(self):\n        return f\"{self.name}: {self.date.strftime('%Y-%m-%d')}\"\n\nevents = [\n    Event(\"Conference\", \"2023-11-12\"),\n    Event(\"Workshop\", \"2023-10-05\"),\n    Event(\"Seminar\", \"2023-12-01\"),\n    Event(\"Webinar\", \"2023-09-28\"),\n    Event(\"Lecture\", \"2023-11-03\"),\n    Event(\"Meeting\", \"2023-10-15\"),\n    Event(\"Symposium\", \"2023-11-22\"),\n    Event(\"Course\", \"2023-10-30\"),\n    Event(\"Presentation\", \"2023-12-10\"),\n    Event(\"Training\", \"2023-09-20\"),\n    Event(\"Discussion\", \"2023-11-18\"),\n    Event(\"Panel\", \"2023-10-25\"),\n    Event(\"Interview\", \"2023-11-01\"),\n    Event(\"Forum\", \"2023-12-05\"),\n    Event(\"Roundtable\", \"2023-10-18\")\n]\n\nsorted_events = sorted(events, key=lambda e: e.date)\n\ndef transform_events(events):\n    transformed = []\n    for i in range(len(events) - 1):\n        current_event = events[i]\n        next_event = events[i + 1]\n        if next_event.date.month != current_event.date.month:\n            transformed.append(current_event)\n    transformed.append(events[-1])\n    return transformed\n\nresult = transform_events(sorted_events)\n\nfor event in result:\n    print(event)"}, {"role": "assistant", "content": "Webinar: 2023-09-28\nCourse: 2023-10-30\nSymposium: 2023-11-22\nPresentation: 2023-12-10\n"}]}
{"messages": [{"role": "user", "content": "import string\n\ndef vigenere_encrypt(plain_text, key):\n    alphabet = string.ascii_lowercase\n    encrypted_text = []\n    key_indices = [alphabet.index(k) for k in key]\n    key_length = len(key_indices)\n\n    for i, char in enumerate(plain_text):\n        if char in alphabet:\n            shift = key_indices[i % key_length]\n            encrypted_char = alphabet[(alphabet.index(char) + shift) % 26]\n            encrypted_text.append(encrypted_char)\n        else:\n            encrypted_text.append(char)\n    \n    return ''.join(encrypted_text)\n\ndef vigenere_decrypt(encrypted_text, key):\n    alphabet = string.ascii_lowercase\n    decrypted_text = []\n    key_indices = [alphabet.index(k) for k in key]\n    key_length = len(key_indices)\n\n    for i, char in enumerate(encrypted_text):\n        if char in alphabet:\n            shift = key_indices[i % key_length]\n            decrypted_char = alphabet[(alphabet.index(char) - shift) % 26]\n            decrypted_text.append(decrypted_char)\n        else:\n            decrypted_text.append(char)\n    \n    return ''.join(decrypted_text)\n\ndef search_key(encrypted_text, known_plain_text):\n    potential_keys = []\n    alphabet = string.ascii_lowercase\n\n    for key_length in range(1, min(10, len(known_plain_text))):\n        print(f\"Trying key length: {key_length}\")\n        for key in itertools.product(alphabet, repeat=key_length):\n            key_str = ''.join(key)\n            decrypted_candidate = vigenere_decrypt(encrypted_text, key_str)\n            if decrypted_candidate.startswith(known_plain_text):\n                potential_keys.append(key_str)\n                print(f\"Found potential key: {key_str}\")\n        \n    return potential_keys\n\nplain_text = \"thequickbrownfoxjumpsoverthelazydog\"\nkey = \"secret\"\nencrypted_text = vigenere_encrypt(plain_text, key)\nprint(f\"Encrypted Text: {encrypted_text}\")\n\nknown_plain_text = \"thequick\"\nfound_keys = search_key(encrypted_text, known_plain_text)\n\nprint(\"\\nPossible Keys:\")\nfor fk in found_keys:\n    print(fk)\n\nprint(\"\\nDecryption with Found Keys:\")\nfor fk in found_keys:\n    print(vigenere_decrypt(encrypted_text, fk))"}, {"role": "assistant", "content": "Traceback (most recent call last):\n  File \"<string>\", line 56, in <module>\n  File \"<string>\", line 41, in search_key\nNameError: name 'itertools' is not defined\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"\nAlice was beginning to get very tired of sitting by her sister on the bank, and of having nothing to do: once or twice she had peeped into the book her sister was reading, but it had no pictures or conversations in it, \u2018and what is the use of a book,\u2019 thought Alice \u2018without pictures or conversation?\u2019\nSo she was considering in her own mind, as well as she could, for the hot day made her feel very sleepy and stupid, whether the pleasure of making a daisy-chain would be worth the trouble of getting up and picking the daisies, when suddenly a White Rabbit with pink eyes ran close by her.\n\"\"\"\n\nwords = re.findall(r'\\b\\w+\\b', text.lower())\nunique_words = sorted(set(words))\n\ndef binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\nsearch_terms = [\"alice\", \"rabbit\", \"daisy\", \"book\", \"pictures\", \"conversation\", \"bank\", \"sister\", \"trouble\", \"pink\"]\n\noutput = []\nfor term in search_terms:\n    index = binary_search(unique_words, term)\n    if index != -1:\n        output.append(f\"'{term}' found at index {index}\")\n    else:\n        output.append(f\"'{term}' not found\")\n\nfor line in output:\n    print(line)"}, {"role": "assistant", "content": "'alice' found at index 1\n'rabbit' found at index 48\n'daisy' found at index 17\n'book' found at index 7\n'pictures' found at index 45\n'conversation' found at index 13\n'bank' found at index 4\n'sister' found at index 52\n'trouble' found at index 62\n'pink' found at index 46\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"\nThe quick brown fox jumps over the lazy dog.\nLorem ipsum dolor sit amet, consectetur adipiscing elit.\nSed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\nUt enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\nDuis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.\nExcepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\nCurabitur pretium tincidunt lacus. Nulla gravida orci a odio.\nNullam varius, turpis et commodo pharetra, est eros bibendum elit, nec luctus magna felis sollicitudin mauris.\nInteger in mauris eu nibh euismod gravida.\n\"\"\"\n\nparagraphs = text.strip().split('\\n')\nword_count_list = [(para, len(re.findall(r'\\w+', para))) for para in paragraphs]\nsorted_paragraphs = sorted(word_count_list, key=lambda x: x[1])\n\nfor para, count in sorted_paragraphs:\n    print(f\"{count}: {para}\")"}, {"role": "assistant", "content": "7: Integer in mauris eu nibh euismod gravida.\n8: Lorem ipsum dolor sit amet, consectetur adipiscing elit.\n9: The quick brown fox jumps over the lazy dog.\n9: Curabitur pretium tincidunt lacus. Nulla gravida orci a odio.\n11: Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\n16: Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.\n16: Nullam varius, turpis et commodo pharetra, est eros bibendum elit, nec luctus magna felis sollicitudin mauris.\n17: Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\n17: Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n"}]}
{"messages": [{"role": "user", "content": "import re\nfrom collections import defaultdict\n\ntext = \"\"\"\nIn a distant land, beyond the mountains and across the seas, there lay a kingdom shrouded in mystery.\nThe people of this land spoke in riddles and rhymes, crafting their stories with words that danced like fireflies in the night.\nIt was said that the kingdom held a secret, a secret so profound that it was woven into the very fabric of their language.\nMany have tried to uncover this secret, delving into the ancient texts and forgotten manuscripts that filled the libraries of the kingdom.\nYet, each seeker returned with more questions than answers, for the language of the land was a maze of metaphor and allegory.\n\"\"\"\n\npattern = r'\\b\\w+\\b'\nwords = re.findall(pattern, text.lower())\n\ndef advanced_search(words, target):\n    left, right = 0, len(words) - 1\n    results = []\n\n    while left <= right:\n        mid = (left + right) // 2\n        if words[mid] == target:\n            results.append(mid)\n            l, r = mid - 1, mid + 1\n            while l >= 0 and words[l] == target:\n                results.append(l)\n                l -= 1\n            while r < len(words) and words[r] == target:\n                results.append(r)\n                r += 1\n            break\n        elif words[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return results\n\nword_count = defaultdict(int)\nfor word in words:\n    word_count[word] += 1\n\nsorted_words = sorted(word_count.keys())\n\noutput = []\nfor word in sorted_words:\n    indices = advanced_search(words, word)\n    output.append(f'{word}: {indices}')\n\nprint('\\n'.join(output))"}, {"role": "assistant", "content": "a: []\nacross: []\nallegory: []\nancient: []\nand: [26]\nanswers: []\nbeyond: []\ncrafting: []\ndanced: []\ndelving: []\ndistant: []\neach: []\nfabric: []\nfilled: []\nfireflies: []\nfor: []\nforgotten: []\nhave: []\nheld: []\nin: []\ninto: []\nit: []\nkingdom: []\nland: []\nlanguage: []\nlay: []\nlibraries: []\nlike: []\nmanuscripts: []\nmany: []\nmaze: []\nmetaphor: []\nmore: []\nmountains: []\nmystery: []\nnight: [39]\nof: []\npeople: []\nprofound: []\nquestions: []\nreturned: []\nrhymes: []\nriddles: []\nsaid: []\nseas: []\nsecret: [50]\nseeker: []\nshrouded: []\nso: [51]\nspoke: []\nstories: []\ntexts: []\nthan: []\nthat: [53]\nthe: [99]\ntheir: []\nthere: []\nthis: []\nto: []\ntried: []\nuncover: []\nvery: []\nwas: [101]\nwith: []\nwords: []\nwoven: []\nyet: []\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef calculate_distance(point1, point2):\n    return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2)\n\ndef find_nearest_point(reference_point, points):\n    min_distance = float('inf')\n    nearest_point = None\n    for point in points:\n        distance = calculate_distance(reference_point, point)\n        if distance < min_distance:\n            min_distance = distance\n            nearest_point = point\n    return nearest_point\n\npoints = [\n    (2, 3), (5, 4), (9, 6), (4, 7), (8, 1), (7, 2),\n    (3, 5), (6, 8), (1, 1), (9, 9), (0, 0), (7, 3),\n    (5, 5), (2, 2), (8, 8), (1, 6), (3, 4), (4, 4),\n    (6, 6), (7, 7), (0, 9), (9, 0), (5, 9), (8, 5),\n    (2, 8), (3, 3), (1, 9), (6, 2), (4, 1), (0, 5),\n    (5, 3), (7, 6), (9, 3), (8, 4), (2, 1), (3, 6),\n    (6, 1), (5, 2), (4, 9), (1, 8), (7, 0), (9, 8),\n    (0, 4), (8, 2), (3, 7), (6, 5), (2, 9), (4, 8),\n    (5, 0), (1, 7), (7, 5), (9, 5), (8, 3), (6, 4),\n    (2, 5), (4, 6), (3, 8), (0, 6), (1, 4), (5, 7),\n    (9, 1), (7, 4), (8, 6), (6, 3), (2, 7), (1, 5),\n    (4, 3), (3, 9), (0, 3), (5, 6), (9, 7), (8, 7),\n    (6, 0), (2, 4), (1, 0), (7, 1), (3, 1), (4, 5),\n    (0, 8), (5, 8), (8, 0), (9, 4), (6, 7), (2, 0),\n    (1, 3), (7, 9), (3, 2), (4, 0), (0, 2), (9, 6)\n]\n\nreference_point = (5, 5)\nnearest = find_nearest_point(reference_point, points)\nprint(f\"The point nearest to {reference_point} is {nearest}\")"}, {"role": "assistant", "content": "The point nearest to (5, 5) is (5, 5)\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\ndef score_hand(hand):\n    return sum(ord(card) for card in hand)\n\ndef sort_players_by_score(players):\n    return sorted(players, key=lambda player: score_hand(player[1]), reverse=True)\n\ndef generate_hands(players):\n    suits = ['H', 'D', 'C', 'S']\n    cards = '23456789TJQKA'\n    deck = [card + suit for card in cards for suit in suits]\n    return [(player, deck[i*5:i*5+5]) for i, player in enumerate(players)]\n\ndef display_leaderboard(sorted_players):\n    for i, (player, hand) in enumerate(sorted_players, start=1):\n        score = score_hand(hand)\n        print(f\"{i}. {player}: {' '.join(hand)} - Score: {score}\")\n\nplayers = ['Alice', 'Bob', 'Charlie', 'Diana', 'Eve', 'Frank', 'Grace', 'Heidi']\nhands = generate_hands(players)\nsorted_players = sort_players_by_score(hands)\ndisplay_leaderboard(sorted_players)"}, {"role": "assistant", "content": "Traceback (most recent call last):\n  File \"<string>\", line 22, in <module>\n  File \"<string>\", line 7, in sort_players_by_score\n  File \"<string>\", line 7, in <lambda>\n  File \"<string>\", line 4, in score_hand\n  File \"<string>\", line 4, in <genexpr>\nTypeError: ord() expected a character, but string of length 2 found\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef calculate_polygon_area(points):\n    n = len(points)\n    area = 0.0\n    for i in range(n):\n        j = (i + 1) % n\n        area += points[i][0] * points[j][1]\n        area -= points[j][0] * points[i][1]\n    area = abs(area) / 2.0\n    return area\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef sort_by_polar_angle(points, reference):\n    def polar_angle(p):\n        return math.atan2(p[1] - reference[1], p[0] - reference[0])\n    \n    return sorted(points, key=polar_angle)\n\ndef find_convex_hull(points):\n    points = sorted(points, key=lambda x: (x[1], x[0]))\n    reference = points[0]\n    sorted_points = sort_by_polar_angle(points[1:], reference)\n    sorted_points.insert(0, reference)\n    \n    hull = []\n    for point in sorted_points:\n        while len(hull) > 1 and (calculate_polygon_area(hull[-2:] + [point]) > 0):\n            hull.pop()\n        hull.append(point)\n    return hull\n\npoints = [\n    (0, 0), (1, 1), (2, 2), (4, 4),\n    (0, 4), (4, 0), (2, 1), (1, 3),\n    (3, 3), (3, 1), (1, 0), (3, 0)\n]\n\nconvex_hull = find_convex_hull(points)\n\nfor i in range(len(convex_hull)):\n    p1 = convex_hull[i]\n    p2 = convex_hull[(i + 1) % len(convex_hull)]\n    print(f\"Edge from {p1} to {p2} with length {distance(p1, p2):.2f}\")"}, {"role": "assistant", "content": "Edge from (0, 0) to (0, 4) with length 4.00\nEdge from (0, 4) to (0, 0) with length 4.00\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef encode_message(message):\n    vowels = 'aeiou'\n    encoded = ''.join(\n        chr(ord(char) + 2) if char in vowels else char\n        for char in message.lower()\n    )\n    return encoded\n\ndef sort_encoded_words(encoded_message):\n    words = re.findall(r'\\w+', encoded_message)\n    sorted_words = sorted(words, key=lambda word: sum(ord(c) for c in word))\n    return ' '.join(sorted_words)\n\ndef decode_message(encoded_message):\n    vowels = 'aeiou'\n    decoded = ''.join(\n        chr(ord(char) - 2) if chr(ord(char) - 2) in vowels else char\n        for char in encoded_message\n    )\n    return decoded\n\noriginal_message = (\n    \"Encryption is a fascinating topic that involves converting information \"\n    \"into a secure format, which can only be read with a specific key.\"\n)\n\nencoded_message = encode_message(original_message)\nsorted_encoded_message = sort_encoded_words(encoded_message)\ndecoded_message = decode_message(sorted_encoded_message)\n\nprint(\"Encoded Message:\")\nprint(encoded_message)\nprint(\"\\nSorted Encoded Message (by ASCII sum):\")\nprint(sorted_encoded_message)\nprint(\"\\nDecoded Message:\")\nprint(decoded_message)"}, {"role": "assistant", "content": "Encoded Message:\ngncryptkqn ks c fcscknctkng tqpkc thct knvqlvgs cqnvgrtkng knfqrmctkqn kntq c sgcwrg fqrmct, whkch ccn qnly bg rgcd wkth c spgckfkc kgy.\n\nSorted Encoded Message (by ASCII sum):\nc c c bg ks ccn kgy rgcd thct kntq wkth qnly whkch tqpkc sgcwrg fqrmct spgckfkc knvqlvgs cqnvgrtkng gncryptkqn fcscknctkng knfqrmctkqn\n\nDecoded Message:\na a a be is aan iey read that into uith only uhiah topia seaure format speaifia involves aonvertine enaryption fasainatine information\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef days_since_start_of_year():\n    today = datetime.date.today()\n    start_of_year = datetime.date(today.year, 1, 1)\n    return (today - start_of_year).days\n\nevents = [\n    (\"Event A\", datetime.date(2023, 8, 15)),\n    (\"Event B\", datetime.date(2023, 2, 5)),\n    (\"Event C\", datetime.date(2023, 4, 10)),\n    (\"Event D\", datetime.date(2023, 6, 30)),\n    (\"Event E\", datetime.date(2023, 1, 20)),\n    (\"Event F\", datetime.date(2023, 9, 25)),\n    (\"Event G\", datetime.date(2023, 5, 5)),\n    (\"Event H\", datetime.date(2023, 3, 1)),\n    (\"Event I\", datetime.date(2023, 12, 12)),\n    (\"Event J\", datetime.date(2023, 11, 7))\n]\n\nprint(\"Days since start of the year:\", days_since_start_of_year())\n\nevents_sorted_by_date = sorted(events, key=lambda event: event[1])\nprint(\"Events sorted by date:\")\nfor event in events_sorted_by_date:\n    print(event[0], \"on\", event[1])\n\nprint(\"\\nEvents by proximity to today:\")\nevents_sorted_by_proximity = sorted(events, key=lambda event: abs((event[1] - datetime.date.today()).days))\nfor event in events_sorted_by_proximity:\n    print(event[0], \"on\", event[1])\n\nprint(\"\\nEvents by how long has passed since they occurred:\")\nevents_sorted_by_elapsed_time = sorted(events, key=lambda event: (datetime.date.today() - event[1]).days, reverse=True)\nfor event in events_sorted_by_elapsed_time:\n    print(event[0], \"occurred\", (datetime.date.today() - event[1]).days, \"days ago\")"}, {"role": "assistant", "content": "Days since start of the year: 90\nEvents sorted by date:\nEvent E on 2023-01-20\nEvent B on 2023-02-05\nEvent H on 2023-03-01\nEvent C on 2023-04-10\nEvent G on 2023-05-05\nEvent D on 2023-06-30\nEvent A on 2023-08-15\nEvent F on 2023-09-25\nEvent J on 2023-11-07\nEvent I on 2023-12-12\n\nEvents by proximity to today:\nEvent I on 2023-12-12\nEvent J on 2023-11-07\nEvent F on 2023-09-25\nEvent A on 2023-08-15\nEvent D on 2023-06-30\nEvent G on 2023-05-05\nEvent C on 2023-04-10\nEvent H on 2023-03-01\nEvent B on 2023-02-05\nEvent E on 2023-01-20\n\nEvents by how long has passed since they occurred:\nEvent E occurred 802 days ago\nEvent B occurred 786 days ago\nEvent H occurred 762 days ago\nEvent C occurred 722 days ago\nEvent G occurred 697 days ago\nEvent D occurred 641 days ago\nEvent A occurred 595 days ago\nEvent F occurred 554 days ago\nEvent J occurred 511 days ago\nEvent I occurred 476 days ago\n"}]}
{"messages": [{"role": "user", "content": "import math\nfrom datetime import datetime, timedelta\n\ndef generate_data(n):\n    data = []\n    base_date = datetime(2020, 1, 1)\n    for i in range(n):\n        value = math.sin(i / 10) * 100 + math.cos(i / 3) * 50\n        date = base_date + timedelta(days=i)\n        data.append((date, value))\n    return data\n\ndef find_peaks(data):\n    peaks = []\n    for i in range(1, len(data) - 1):\n        if data[i - 1][1] < data[i][1] > data[i + 1][1]:\n            peaks.append(data[i])\n    return peaks\n\ndef search_peak_by_date(peaks, target_date):\n    left, right = 0, len(peaks) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if peaks[mid][0] == target_date:\n            return peaks[mid]\n        elif peaks[mid][0] < target_date:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return None\n\ndata = generate_data(365)\npeaks = find_peaks(data)\n\nfor i in range(0, len(peaks), 10):\n    target_date = peaks[i][0]\n    peak = search_peak_by_date(peaks, target_date)\n    if peak:\n        print(f\"Peak on {peak[0].strftime('%Y-%m-%d')}: {peak[1]:.2f}\")"}, {"role": "assistant", "content": "Peak on 2020-01-03: 59.16\nPeak on 2020-07-09: 58.83\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndata = [\n    (170, 60), (160, 55), (180, 70), (165, 65), (175, 75),\n    (155, 50), (185, 80), (150, 45), (190, 85), (145, 40),\n    (175, 68), (170, 64), (160, 59), (180, 74), (165, 69),\n    (155, 52), (185, 78), (150, 47), (190, 83), (145, 42)\n]\n\nbmi_list = [(h, w, round(w / (h/100)**2, 1)) for h, w in data]\n\nsorted_bmi_list = sorted(bmi_list, key=lambda x: x[2])\n\nquartiles = []\nn = len(sorted_bmi_list)\npositions = [0.25, 0.5, 0.75]\n\nfor pos in positions:\n    index = (n - 1) * pos\n    lower = math.floor(index)\n    upper = math.ceil(index)\n    if lower == upper:\n        quartile = sorted_bmi_list[int(index)][2]\n    else:\n        weight_upper = index - lower\n        weight_lower = 1 - weight_upper\n        quartile = sorted_bmi_list[lower][2] * weight_lower + sorted_bmi_list[upper][2] * weight_upper\n    quartiles.append(round(quartile, 1))\n\nfor h, w, bmi in sorted_bmi_list:\n    print(f\"Height: {h} cm, Weight: {w} kg, BMI: {bmi}\")\n\nprint(\"\\nQuartiles of BMI:\")\nprint(f\"Q1 (25th percentile): {quartiles[0]}\")\nprint(f\"Q2 (Median): {quartiles[1]}\")\nprint(f\"Q3 (75th percentile): {quartiles[2]}\")"}, {"role": "assistant", "content": "Height: 145 cm, Weight: 40 kg, BMI: 19.0\nHeight: 150 cm, Weight: 45 kg, BMI: 20.0\nHeight: 145 cm, Weight: 42 kg, BMI: 20.0\nHeight: 170 cm, Weight: 60 kg, BMI: 20.8\nHeight: 155 cm, Weight: 50 kg, BMI: 20.8\nHeight: 150 cm, Weight: 47 kg, BMI: 20.9\nHeight: 160 cm, Weight: 55 kg, BMI: 21.5\nHeight: 180 cm, Weight: 70 kg, BMI: 21.6\nHeight: 155 cm, Weight: 52 kg, BMI: 21.6\nHeight: 170 cm, Weight: 64 kg, BMI: 22.1\nHeight: 175 cm, Weight: 68 kg, BMI: 22.2\nHeight: 180 cm, Weight: 74 kg, BMI: 22.8\nHeight: 185 cm, Weight: 78 kg, BMI: 22.8\nHeight: 160 cm, Weight: 59 kg, BMI: 23.0\nHeight: 190 cm, Weight: 83 kg, BMI: 23.0\nHeight: 185 cm, Weight: 80 kg, BMI: 23.4\nHeight: 190 cm, Weight: 85 kg, BMI: 23.5\nHeight: 165 cm, Weight: 65 kg, BMI: 23.9\nHeight: 175 cm, Weight: 75 kg, BMI: 24.5\nHeight: 165 cm, Weight: 69 kg, BMI: 25.3\n\nQuartiles of BMI:\nQ1 (25th percentile): 20.9\nQ2 (Median): 22.1\nQ3 (75th percentile): 23.1\n"}]}
{"messages": [{"role": "user", "content": "def transform_data(data):\n    transformed = []\n    for item in data:\n        transformed.append(item[::-1])\n    return transformed\n\ndef binary_search_transformed(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return -1\n\ndata = ['apple', 'banana', 'cherry', 'date', 'elderberry', 'fig', 'grape']\ntransformed = transform_data(data)\ntransformed.sort()\n\nsearch_target = 'ananab'  # Looking for 'banana' reversed\nindex = binary_search_transformed(transformed, search_target)\n\noutput_data = [f\"{i}: {item}\" for i, item in enumerate(transformed)]\n\nfor line in output_data:\n    print(line)\n\nprint(f\"Index of '{search_target}': {index}\")"}, {"role": "assistant", "content": "0: ananab\n1: elppa\n2: eparg\n3: etad\n4: gif\n5: yrrebredle\n6: yrrehc\nIndex of 'ananab': -1\n"}]}
{"messages": [{"role": "user", "content": "import math\nfrom statistics import mean, median, stdev\n\ndata_points = [5, 20, 40, 50, 65, 80, 90, 95, 100, 110, 125, 130, 150, 160, 175]\ntarget_mean = 75\n\ndef binary_search_mean(data, target):\n    low, high = 0, len(data) - 1\n    closest = data[0]\n    print(f\"Initial data: {data}\")\n    print(f\"Target mean: {target}\\n\")\n    \n    while low <= high:\n        mid = (low + high) // 2\n        current_mean = mean(data[:mid+1])\n        print(f\"Checking subset: {data[:mid+1]}\")\n        print(f\"Subset mean: {current_mean}\")\n        \n        if abs(current_mean - target) < abs(mean(data[:len(data)]) - target):\n            closest = mean(data[:mid+1])\n            print(f\"New closest mean: {closest}\\n\")\n        \n        if current_mean < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return closest\n\nfound_mean = binary_search_mean(data_points, target_mean)\n\nprint(f\"Closest mean found: {found_mean}\\n\")\n\nprint(\"Statistics of data_points:\")\nprint(f\"Mean: {mean(data_points)}\")\nprint(f\"Median: {median(data_points)}\")\nprint(f\"Standard Deviation: {stdev(data_points)}\")"}, {"role": "assistant", "content": "Initial data: [5, 20, 40, 50, 65, 80, 90, 95, 100, 110, 125, 130, 150, 160, 175]\nTarget mean: 75\n\nChecking subset: [5, 20, 40, 50, 65, 80, 90, 95]\nSubset mean: 55.625\nChecking subset: [5, 20, 40, 50, 65, 80, 90, 95, 100, 110, 125, 130]\nSubset mean: 75.83333333333333\nNew closest mean: 75.83333333333333\n\nChecking subset: [5, 20, 40, 50, 65, 80, 90, 95, 100, 110]\nSubset mean: 65.5\nNew closest mean: 65.5\n\nChecking subset: [5, 20, 40, 50, 65, 80, 90, 95, 100, 110, 125]\nSubset mean: 70.9090909090909\nNew closest mean: 70.9090909090909\n\nClosest mean found: 70.9090909090909\n\nStatistics of data_points:\nMean: 93\nMedian: 95\nStandard Deviation: 50.631723539411816\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef caesar_cipher_encode(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            shift_base = 65 if char.isupper() else 97\n            result += chr((ord(char) - shift_base + shift) % 26 + shift_base)\n        else:\n            result += char\n    return result\n\ndef caesar_cipher_decode(text, shift):\n    return caesar_cipher_encode(text, -shift)\n\ndef search_for_encoded_word(text, word):\n    for shift in range(26):\n        decoded_text = caesar_cipher_decode(text, shift)\n        if word in decoded_text:\n            print(f\"Decoded with shift {shift}: {decoded_text}\")\n            return decoded_text\n    print(\"Word not found with any shift.\")\n    return None\n\nencoded_text = \"Uifsf jt b tfdsfu xpsme cz Qzuipo!\"\nword_to_find = \"world\"\n\nprint(f\"Encoded Text: {encoded_text}\")\nprint(f\"Searching for the word '{word_to_find}' in decoded versions:\")\n\ndecoded_version = search_for_encoded_word(encoded_text, word_to_find)\n\nif decoded_version:\n    print(f\"Word '{word_to_find}' found in: {decoded_version}\")"}, {"role": "assistant", "content": "Encoded Text: Uifsf jt b tfdsfu xpsme cz Qzuipo!\nSearching for the word 'world' in decoded versions:\nDecoded with shift 1: There is a secret world by Python!\nWord 'world' found in: There is a secret world by Python!\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef sort_dates_and_transform_to_strings(dates):\n    sorted_dates = sorted(dates)\n    return [date.strftime(\"%A, %d %B %Y\") for date in sorted_dates]\n\ndates = [\n    datetime.date(2023, 3, 15),\n    datetime.date(2021, 5, 20),\n    datetime.date(2022, 8, 10),\n    datetime.date(2020, 12, 25),\n    datetime.date(2023, 1, 1),\n    datetime.date(2021, 7, 4),\n    datetime.date(2022, 11, 11),\n    datetime.date(2020, 6, 30),\n    datetime.date(2023, 9, 9),\n    datetime.date(2021, 2, 14),\n]\n\ntransformed_dates = sort_dates_and_transform_to_strings(dates)\nfor date in transformed_dates:\n    print(date)"}, {"role": "assistant", "content": "Tuesday, 30 June 2020\nFriday, 25 December 2020\nSunday, 14 February 2021\nThursday, 20 May 2021\nSunday, 04 July 2021\nWednesday, 10 August 2022\nFriday, 11 November 2022\nSunday, 01 January 2023\nWednesday, 15 March 2023\nSaturday, 09 September 2023\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndates = [\n    \"2023-05-21 14:30\",\n    \"2024-01-15 09:00\",\n    \"2023-12-31 12:45\",\n    \"2022-07-11 18:00\",\n    \"2023-03-01 21:10\",\n    \"2023-09-10 08:20\",\n    \"2023-11-25 13:30\",\n    \"2023-01-01 00:00\",\n]\n\ndate_objects = [datetime.strptime(date, \"%Y-%m-%d %H:%M\") for date in dates]\n\nprint(\"Original dates:\")\nfor date in date_objects:\n    print(date)\n\nsorted_dates = sorted(date_objects, key=lambda x: (x.year, x.month, x.day, x.time()))\n\nprint(\"\\nSorted dates:\")\nfor date in sorted_dates:\n    print(date)\n\nsorted_dates_with_weekday = sorted(date_objects, key=lambda x: (x.weekday(), x.time()))\n\nprint(\"\\nSorted by weekday then time:\")\nfor date in sorted_dates_with_weekday:\n    print(date)\n\ntoday = datetime.now()\nfuture_dates = [date for date in date_objects if date > today]\n\nsorted_future_dates = sorted(future_dates, key=lambda x: x)\n\nprint(\"\\nFuture dates sorted:\")\nfor date in sorted_future_dates:\n    print(date)\n\ndelta_today = timedelta(days=today.weekday())\nstart_of_week = today - delta_today\n\ndates_within_week = [date for date in date_objects if start_of_week <= date < start_of_week + timedelta(days=7)]\n\nprint(\"\\nDates within current week:\")\nfor date in dates_within_week:\n    print(date)"}, {"role": "assistant", "content": "Original dates:\n2023-05-21 14:30:00\n2024-01-15 09:00:00\n2023-12-31 12:45:00\n2022-07-11 18:00:00\n2023-03-01 21:10:00\n2023-09-10 08:20:00\n2023-11-25 13:30:00\n2023-01-01 00:00:00\n\nSorted dates:\n2022-07-11 18:00:00\n2023-01-01 00:00:00\n2023-03-01 21:10:00\n2023-05-21 14:30:00\n2023-09-10 08:20:00\n2023-11-25 13:30:00\n2023-12-31 12:45:00\n2024-01-15 09:00:00\n\nSorted by weekday then time:\n2024-01-15 09:00:00\n2022-07-11 18:00:00\n2023-03-01 21:10:00\n2023-11-25 13:30:00\n2023-01-01 00:00:00\n2023-09-10 08:20:00\n2023-12-31 12:45:00\n2023-05-21 14:30:00\n\nFuture dates sorted:\n\nDates within current week:\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef is_perfect_square(n):\n    return int(math.sqrt(n)) ** 2 == n\n\ndef fibonacci_like_sequence(limit):\n    sequence = [1, 2]\n    while sequence[-1] < limit:\n        next_value = sequence[-1] + sequence[-2]\n        sequence.append(next_value)\n    return sequence[:-1]\n\ndef find_near_perfect_squares(seq):\n    near_squares = []\n    for num in seq:\n        if abs(math.sqrt(num) - round(math.sqrt(num))) < 0.5:\n            near_squares.append(num)\n    return near_squares\n\ndef main():\n    sequence_limit = 1000\n    fib_seq = fibonacci_like_sequence(sequence_limit)\n    near_squares = find_near_perfect_squares(fib_seq)\n    print(f\"Numbers near perfect squares in Fibonacci-like sequence up to {sequence_limit}:\")\n    for num in near_squares:\n        print(num)\n\nmain()"}, {"role": "assistant", "content": "Numbers near perfect squares in Fibonacci-like sequence up to 1000:\n1\n2\n3\n5\n8\n13\n21\n34\n55\n89\n144\n233\n377\n610\n987\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef generate_pattern(length):\n    pattern = []\n    for i in range(length):\n        row = [math.sin(i + j) for j in range(length)]\n        pattern.append(row)\n    return pattern\n\ndef sort_pattern(pattern):\n    sorted_pattern = sorted(pattern, key=lambda x: sum(x))\n    return sorted_pattern\n\ndef print_pattern(pattern):\n    for row in pattern:\n        print(\" \".join(f\"{x:.2f}\" for x in row))\n\nprint(\"Generating pattern...\")\npattern = generate_pattern(10)\nprint(\"Initial pattern:\")\nprint_pattern(pattern)\n\nprint(\"\\nSorting pattern...\")\nsorted_pattern = sort_pattern(pattern)\nprint(\"Sorted pattern:\")\nprint_pattern(sorted_pattern)"}, {"role": "assistant", "content": "Generating pattern...\nInitial pattern:\n0.00 0.84 0.91 0.14 -0.76 -0.96 -0.28 0.66 0.99 0.41\n0.84 0.91 0.14 -0.76 -0.96 -0.28 0.66 0.99 0.41 -0.54\n0.91 0.14 -0.76 -0.96 -0.28 0.66 0.99 0.41 -0.54 -1.00\n0.14 -0.76 -0.96 -0.28 0.66 0.99 0.41 -0.54 -1.00 -0.54\n-0.76 -0.96 -0.28 0.66 0.99 0.41 -0.54 -1.00 -0.54 0.42\n-0.96 -0.28 0.66 0.99 0.41 -0.54 -1.00 -0.54 0.42 0.99\n-0.28 0.66 0.99 0.41 -0.54 -1.00 -0.54 0.42 0.99 0.65\n0.66 0.99 0.41 -0.54 -1.00 -0.54 0.42 0.99 0.65 -0.29\n0.99 0.41 -0.54 -1.00 -0.54 0.42 0.99 0.65 -0.29 -0.96\n0.41 -0.54 -1.00 -0.54 0.42 0.99 0.65 -0.29 -0.96 -0.75\n\nSorting pattern...\nSorted pattern:\n0.14 -0.76 -0.96 -0.28 0.66 0.99 0.41 -0.54 -1.00 -0.54\n0.41 -0.54 -1.00 -0.54 0.42 0.99 0.65 -0.29 -0.96 -0.75\n-0.76 -0.96 -0.28 0.66 0.99 0.41 -0.54 -1.00 -0.54 0.42\n0.91 0.14 -0.76 -0.96 -0.28 0.66 0.99 0.41 -0.54 -1.00\n0.99 0.41 -0.54 -1.00 -0.54 0.42 0.99 0.65 -0.29 -0.96\n-0.96 -0.28 0.66 0.99 0.41 -0.54 -1.00 -0.54 0.42 0.99\n0.84 0.91 0.14 -0.76 -0.96 -0.28 0.66 0.99 0.41 -0.54\n0.66 0.99 0.41 -0.54 -1.00 -0.54 0.42 0.99 0.65 -0.29\n-0.28 0.66 0.99 0.41 -0.54 -1.00 -0.54 0.42 0.99 0.65\n0.00 0.84 0.91 0.14 -0.76 -0.96 -0.28 0.66 0.99 0.41\n"}]}
{"messages": [{"role": "user", "content": "def generate_pattern(n):\n    pattern = []\n    for i in range(1, n + 1):\n        pattern.append((i % 3) * '-' + str(i) + (i % 2) * '+' + (i % 3) * '-')\n    return pattern\n\ndef search_pattern(pattern, target):\n    for item in pattern:\n        if target in item:\n            return item\n    return None\n\nn = 50\npattern = generate_pattern(n)\ntarget = '5'\nmatched_item = search_pattern(pattern, target)\n\nprint(\"Generated Pattern:\")\nfor item in pattern:\n    print(item)\n\nprint(\"\\nSearching for target '{}':\".format(target))\nif matched_item:\n    print(\"Found:\", matched_item)\nelse:\n    print(\"Target not found\")"}, {"role": "assistant", "content": "Generated Pattern:\n-1+-\n--2--\n3+\n-4-\n--5+--\n6\n-7+-\n--8--\n9+\n-10-\n--11+--\n12\n-13+-\n--14--\n15+\n-16-\n--17+--\n18\n-19+-\n--20--\n21+\n-22-\n--23+--\n24\n-25+-\n--26--\n27+\n-28-\n--29+--\n30\n-31+-\n--32--\n33+\n-34-\n--35+--\n36\n-37+-\n--38--\n39+\n-40-\n--41+--\n42\n-43+-\n--44--\n45+\n-46-\n--47+--\n48\n-49+-\n--50--\n\nSearching for target '5':\nFound: --5+--\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef weird_sort(lst):\n    def custom_key(x):\n        return (math.sin(x) * 1000) % 1\n    \n    return sorted(lst, key=custom_key)\n\nsequence = [i for i in range(1, 101)]\nsorted_sequence = weird_sort(sequence)\n\nfor number in sorted_sequence:\n    print(number)"}, {"role": "assistant", "content": "11\n18\n64\n71\n89\n68\n5\n34\n16\n76\n80\n81\n40\n9\n3\n22\n57\n13\n87\n60\n84\n4\n54\n69\n75\n36\n43\n73\n82\n51\n55\n49\n95\n15\n2\n63\n8\n83\n29\n38\n27\n41\n88\n24\n32\n12\n66\n56\n37\n1\n42\n67\n77\n92\n86\n26\n47\n6\n96\n17\n14\n97\n98\n50\n52\n100\n25\n21\n44\n93\n59\n48\n94\n23\n46\n99\n39\n35\n62\n72\n65\n74\n58\n19\n61\n79\n70\n45\n28\n33\n85\n53\n20\n31\n30\n78\n10\n7\n91\n90\n"}]}
{"messages": [{"role": "user", "content": "import re\nfrom collections import Counter\n\ntext = \"\"\"\nIn the world of computing, sorting algorithms are important because they make data more usable.\nUnderstanding these algorithms is crucial for optimizing code and making efficient use of resources.\nSorting can be applied to various data types, such as numbers, text, and complex data structures.\nThe choice of a sorting algorithm depends on the size of the data, the required time complexity, and the specific use case.\nCommon sorting algorithms include bubble sort, insertion sort, quicksort, and mergesort.\nEach algorithm has its advantages and trade-offs.\nChoosing the right algorithm can significantly impact the performance of an application.\n\"\"\"\n\nwords = re.findall(r'\\b\\w+\\b', text.lower())\nword_counts = Counter(words)\n\nsorted_words = sorted(word_counts.items(), key=lambda x: (-x[1], len(x[0]), x[0]))\n\nfor word, count in sorted_words:\n    print(f\"{word}: {count}\")"}, {"role": "assistant", "content": "the: 8\nof: 5\nand: 5\ndata: 4\nsorting: 4\nalgorithm: 3\nalgorithms: 3\ncan: 2\nuse: 2\nsort: 2\na: 1\nan: 1\nas: 1\nbe: 1\nin: 1\nis: 1\non: 1\nto: 1\nare: 1\nfor: 1\nhas: 1\nits: 1\ncase: 1\ncode: 1\neach: 1\nmake: 1\nmore: 1\noffs: 1\nsize: 1\nsuch: 1\ntext: 1\nthey: 1\ntime: 1\nright: 1\nthese: 1\ntrade: 1\ntypes: 1\nworld: 1\nbubble: 1\nchoice: 1\ncommon: 1\nimpact: 1\nmaking: 1\nusable: 1\napplied: 1\nbecause: 1\ncomplex: 1\ncrucial: 1\ndepends: 1\ninclude: 1\nnumbers: 1\nvarious: 1\nchoosing: 1\nrequired: 1\nspecific: 1\ncomputing: 1\nefficient: 1\nimportant: 1\ninsertion: 1\nmergesort: 1\nquicksort: 1\nresources: 1\nadvantages: 1\ncomplexity: 1\noptimizing: 1\nstructures: 1\napplication: 1\nperformance: 1\nsignificantly: 1\nunderstanding: 1\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef search_nearest_point(points, reference_point):\n    min_dist = float('inf')\n    nearest_point = None\n    for point in points:\n        dist = distance(point, reference_point)\n        print(f\"Checking point {point} with distance {dist:.2f}\")\n        if dist < min_dist:\n            min_dist = dist\n            nearest_point = point\n            print(f\"New nearest point found: {nearest_point} with distance {min_dist:.2f}\")\n    return nearest_point\n\ndef generate_points(n):\n    return [(i, math.sin(i) * 10) for i in range(n)]\n\nn_points = 20\npoints = generate_points(n_points)\nreference = (5, 5)\nprint(f\"Reference point: {reference}\")\nnearest = search_nearest_point(points, reference)\nprint(f\"Nearest point to {reference} is {nearest}\")"}, {"role": "assistant", "content": "Reference point: (5, 5)\nChecking point (0, 0.0) with distance 7.07\nNew nearest point found: (0, 0.0) with distance 7.07\nChecking point (1, 8.414709848078965) with distance 5.26\nNew nearest point found: (1, 8.414709848078965) with distance 5.26\nChecking point (2, 9.092974268256818) with distance 5.07\nNew nearest point found: (2, 9.092974268256818) with distance 5.07\nChecking point (3, 1.4112000805986722) with distance 4.11\nNew nearest point found: (3, 1.4112000805986722) with distance 4.11\nChecking point (4, -7.568024953079283) with distance 12.61\nChecking point (5, -9.589242746631385) with distance 14.59\nChecking point (6, -2.7941549819892586) with distance 7.86\nChecking point (7, 6.569865987187891) with distance 2.54\nNew nearest point found: (7, 6.569865987187891) with distance 2.54\nChecking point (8, 9.893582466233818) with distance 5.74\nChecking point (9, 4.121184852417566) with distance 4.10\nChecking point (10, -5.440211108893697) with distance 11.58\nChecking point (11, -9.999902065507035) with distance 16.16\nChecking point (12, -5.365729180004349) with distance 12.51\nChecking point (13, 4.201670368266409) with distance 8.04\nChecking point (14, 9.906073556948703) with distance 10.25\nChecking point (15, 6.502878401571168) with distance 10.11\nChecking point (16, -2.879033166650653) with distance 13.53\nChecking point (17, -9.613974918795568) with distance 18.91\nChecking point (18, -7.509872467716762) with distance 18.04\nChecking point (19, 1.4987720966295235) with distance 14.43\nNearest point to (5, 5) is (7, 6.569865987187891)\n"}]}
{"messages": [{"role": "user", "content": "def search_for_winner(board):\n    win_positions = [\n        [(0, 0), (0, 1), (0, 2)],\n        [(1, 0), (1, 1), (1, 2)],\n        [(2, 0), (2, 1), (2, 2)],\n        [(0, 0), (1, 0), (2, 0)],\n        [(0, 1), (1, 1), (2, 1)],\n        [(0, 2), (1, 2), (2, 2)],\n        [(0, 0), (1, 1), (2, 2)],\n        [(0, 2), (1, 1), (2, 0)]\n    ]\n    \n    for positions in win_positions:\n        if board[positions[0][0]][positions[0][1]] == board[positions[1][0]][positions[1][1]] == board[positions[2][0]][positions[2][1]] != ' ':\n            return board[positions[0][0]][positions[0][1]]\n    return None\n\ndef display_board(board):\n    for row in board:\n        print(' | '.join(row))\n        print('-' * 5)\n\nboards = [\n    [['X', 'O', 'X'], [' ', 'X', 'O'], ['O', 'X', 'O']],\n    [['X', 'X', 'X'], ['O', ' ', ' '], [' ', 'O', 'O']],\n    [['O', ' ', 'X'], ['O', 'X', ' '], ['O', 'X', 'X']],\n    [['X', 'O', 'O'], ['O', 'X', 'X'], ['X', 'O', 'O']],\n    [[' ', ' ', ' '], [' ', ' ', ' '], [' ', ' ', ' ']]\n]\n\nfor idx, board in enumerate(boards):\n    print(f\"Board {idx + 1}:\")\n    display_board(board)\n    winner = search_for_winner(board)\n    if winner:\n        print(f\"Winner: {winner}\\n\")\n    else:\n        print(\"No winner\\n\")"}, {"role": "assistant", "content": "Board 1:\nX | O | X\n-----\n  | X | O\n-----\nO | X | O\n-----\nNo winner\n\nBoard 2:\nX | X | X\n-----\nO |   |  \n-----\n  | O | O\n-----\nWinner: X\n\nBoard 3:\nO |   | X\n-----\nO | X |  \n-----\nO | X | X\n-----\nWinner: O\n\nBoard 4:\nX | O | O\n-----\nO | X | X\n-----\nX | O | O\n-----\nNo winner\n\nBoard 5:\n  |   |  \n-----\n  |   |  \n-----\n  |   |  \n-----\nNo winner\n\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndata_points = [\n    (datetime.datetime(2022, 5, 20), 150),\n    (datetime.datetime(2022, 7, 15), 200),\n    (datetime.datetime(2022, 8, 30), 50),\n    (datetime.datetime(2022, 9, 25), 300),\n    (datetime.datetime(2022, 11, 5), 75),\n    (datetime.datetime(2022, 12, 25), 125),\n    (datetime.datetime(2023, 1, 15), 175),\n    (datetime.datetime(2023, 2, 14), 225),\n    (datetime.datetime(2023, 3, 15), 275),\n    (datetime.datetime(2023, 4, 20), 325)\n]\n\ndef date_diff_in_days(date1, date2):\n    return abs((date2 - date1).days)\n\ndef search_closest_data_point(target_date, data):\n    min_diff = float('inf')\n    closest_point = None\n    for date, value in data:\n        diff = date_diff_in_days(target_date, date)\n        print(f\"Checking date {date} with value {value}, difference: {diff} days\")\n        if diff < min_diff:\n            min_diff = diff\n            closest_point = (date, value)\n            print(f\"New closest date found: {date} with value {value}\")\n    return closest_point\n\nsearch_date = datetime.datetime(2023, 1, 1)\nclosest = search_closest_data_point(search_date, data_points)\n\nprint(\"\\nFinal closest data point:\")\nprint(f\"Date: {closest[0]}, Value: {closest[1]}\")"}, {"role": "assistant", "content": "Checking date 2022-05-20 00:00:00 with value 150, difference: 226 days\nNew closest date found: 2022-05-20 00:00:00 with value 150\nChecking date 2022-07-15 00:00:00 with value 200, difference: 170 days\nNew closest date found: 2022-07-15 00:00:00 with value 200\nChecking date 2022-08-30 00:00:00 with value 50, difference: 124 days\nNew closest date found: 2022-08-30 00:00:00 with value 50\nChecking date 2022-09-25 00:00:00 with value 300, difference: 98 days\nNew closest date found: 2022-09-25 00:00:00 with value 300\nChecking date 2022-11-05 00:00:00 with value 75, difference: 57 days\nNew closest date found: 2022-11-05 00:00:00 with value 75\nChecking date 2022-12-25 00:00:00 with value 125, difference: 7 days\nNew closest date found: 2022-12-25 00:00:00 with value 125\nChecking date 2023-01-15 00:00:00 with value 175, difference: 14 days\nChecking date 2023-02-14 00:00:00 with value 225, difference: 44 days\nChecking date 2023-03-15 00:00:00 with value 275, difference: 73 days\nChecking date 2023-04-20 00:00:00 with value 325, difference: 109 days\n\nFinal closest data point:\nDate: 2022-12-25 00:00:00, Value: 125\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef calculate_distance(point):\n    return math.sqrt(point[0]**2 + point[1]**2)\n\ndef sort_points_by_distance(points):\n    return sorted(points, key=lambda point: calculate_distance(point))\n\ndef calculate_area_of_triangle(points):\n    sorted_points = sort_points_by_distance(points)\n    x1, y1 = sorted_points[0]\n    x2, y2 = sorted_points[1]\n    x3, y3 = sorted_points[2]\n    return abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)) / 2\n\npoints_list = [(2, 3), (1, 1), (4, 4), (0, 0), (2, 2), (3, 3), (5, 1), (1, 5), (3, 0), (6, 2)]\ntriangle_areas = [calculate_area_of_triangle(points_list[i:i+3]) for i in range(0, len(points_list) - 2)]\n\nfor area in triangle_areas:\n    print(f\"Area of triangle: {area:.2f}\")"}, {"role": "assistant", "content": "Area of triangle: 1.50\nArea of triangle: 0.00\nArea of triangle: 0.00\nArea of triangle: 0.00\nArea of triangle: 2.00\nArea of triangle: 0.00\nArea of triangle: 6.00\nArea of triangle: 9.50\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef search_word(text, word):\n    text_lower = text.lower()\n    word_lower = word.lower()\n    pattern = r'\\b' + re.escape(word_lower) + r'\\b'\n    matches = re.finditer(pattern, text_lower)\n    positions = [match.start() for match in matches]\n    return positions\n\ntext = \"\"\"\nOnce upon a time in a land far, far away, there was a little village. \nThe people of this village were known for their kindness and hospitality. \nEvery year, they would hold a festival to celebrate the harvest.\n\"\"\"\n\nword_to_search = \"village\"\npositions = search_word(text, word_to_search)\nprint(f\"Searching for the word '{word_to_search}' in the text.\")\nprint(f\"Found '{word_to_search}' at positions: {positions}\")\n\nword_to_search = \"the\"\npositions = search_word(text, word_to_search)\nprint(f\"Searching for the word '{word_to_search}' in the text.\")\nprint(f\"Found '{word_to_search}' at positions: {positions}\")\n\nword_to_search = \"festival\"\npositions = search_word(text, word_to_search)\nprint(f\"Searching for the word '{word_to_search}' in the text.\")\nprint(f\"Found '{word_to_search}' at positions: {positions}\")\n\nword_to_search = \"kindness\"\npositions = search_word(text, word_to_search)\nprint(f\"Searching for the word '{word_to_search}' in the text.\")\nprint(f\"Found '{word_to_search}' at positions: {positions}\")"}, {"role": "assistant", "content": "Searching for the word 'village' in the text.\nFound 'village' at positions: [62, 91]\nSearching for the word 'the' in the text.\nFound 'the' at positions: [72, 199]\nSearching for the word 'festival' in the text.\nFound 'festival' at positions: [177]\nSearching for the word 'kindness' in the text.\nFound 'kindness' at positions: [120]\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef custom_sort(date_str):\n    return datetime.datetime.strptime(date_str, '%Y-%m-%d')\n\ndates = [\n    '2023-05-14', '2023-01-20', '2022-12-31', '2024-07-01', '2023-03-15',\n    '2022-11-11', '2023-06-21', '2023-09-09', '2024-01-01', '2023-08-08',\n    '2022-10-22', '2023-04-25', '2024-11-11', '2023-07-07', '2023-02-14',\n    '2022-09-09', '2024-10-10', '2023-12-31', '2023-11-11', '2024-05-05'\n]\n\nsorted_dates = sorted(dates, key=custom_sort)\n\nfor date in sorted_dates:\n    print(date)"}, {"role": "assistant", "content": "2022-09-09\n2022-10-22\n2022-11-11\n2022-12-31\n2023-01-20\n2023-02-14\n2023-03-15\n2023-04-25\n2023-05-14\n2023-06-21\n2023-07-07\n2023-08-08\n2023-09-09\n2023-11-11\n2023-12-31\n2024-01-01\n2024-05-05\n2024-07-01\n2024-10-10\n2024-11-11\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef find_nearest_mean(data):\n    mean_value = statistics.mean(data)\n    min_diff = float('inf')\n    closest_number = None\n    for number in data:\n        diff = abs(mean_value - number)\n        if diff < min_diff:\n            min_diff = diff\n            closest_number = number\n    return closest_number\n\ndata = [\n    23, 45, 67, 89, 23, 45, 67, 89, 23, 45, 67, 89, 23, 45, 67, 89, 23, 45, 67, 89,\n    23, 45, 67, 89, 23, 45, 67, 89, 23, 45, 67, 89, 23, 45, 67, 89, 23, 45, 67, 89,\n    23, 45, 67, 89, 23, 45, 67, 89, 23, 45, 67, 89, 23, 45, 67, 89, 23, 45, 67, 89,\n    23, 45, 67, 89, 23, 45, 67, 89, 23, 45, 67, 89, 23, 45, 67, 89, 23, 45, 67, 89,\n    23, 45, 67, 89, 23, 45, 67, 89, 23, 45, 67, 89, 23, 45, 67, 89, 23, 45, 67, 89\n]\n\nnearest_mean_value = find_nearest_mean(data)\nprint(f\"The number closest to the mean is: {nearest_mean_value}\")"}, {"role": "assistant", "content": "The number closest to the mean is: 45\n"}]}
{"messages": [{"role": "user", "content": "def simple_encode_sort(message):\n    encoded = []\n    for char in message:\n        encoded.append(ord(char))\n    return sorted(encoded)\n\ndef decode(encoded):\n    decoded = ''\n    for num in encoded:\n        decoded += chr(num)\n    return decoded\n\nmessage = \"encryption\"\nencoded_message = simple_encode_sort(message)\ndecoded_message = decode(encoded_message)\n\nprint(\"Encoded Message:\", encoded_message)\nprint(\"Decoded Message:\", decoded_message)"}, {"role": "assistant", "content": "Encoded Message: [99, 101, 105, 110, 110, 111, 112, 114, 116, 121]\nDecoded Message: ceinnoprty\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\nimport re\n\ndef parse_dates(date_str_list):\n    pattern = r\"(\\d{4})-(\\d{2})-(\\d{2})\"\n    dates = []\n    for date_str in date_str_list:\n        match = re.match(pattern, date_str)\n        if match:\n            year, month, day = map(int, match.groups())\n            dates.append(datetime(year, month, day))\n    return dates\n\ndef sort_dates_by_weekday(dates):\n    return sorted(dates, key=lambda date: date.weekday())\n\ndef date_difference_in_days(date_list):\n    return [(date_list[i] - date_list[i-1]).days for i in range(1, len(date_list))]\n\ndate_strings = [\n    \"2021-07-19\", \"2023-05-15\", \"2022-11-11\", \"2020-02-29\",\n    \"2021-12-25\", \"2022-01-01\", \"2023-08-01\", \"2021-06-14\",\n    \"2022-03-17\", \"2020-09-22\", \"2023-04-01\", \"2021-10-31\"\n]\n\nparsed_dates = parse_dates(date_strings)\nprint(\"Parsed Dates:\")\nfor date in parsed_dates:\n    print(date.strftime(\"%Y-%m-%d\"))\n\nsorted_by_weekday = sort_dates_by_weekday(parsed_dates)\nprint(\"\\nDates Sorted by Weekday:\")\nfor date in sorted_by_weekday:\n    print(f\"{date.strftime('%Y-%m-%d')} - {date.strftime('%A')}\")\n\ndifferences = date_difference_in_days(sorted_by_weekday)\nprint(\"\\nDifferences in Days Between Consecutive Dates:\")\nprint(differences)"}, {"role": "assistant", "content": "Parsed Dates:\n2021-07-19\n2023-05-15\n2022-11-11\n2020-02-29\n2021-12-25\n2022-01-01\n2023-08-01\n2021-06-14\n2022-03-17\n2020-09-22\n2023-04-01\n2021-10-31\n\nDates Sorted by Weekday:\n2021-07-19 - Monday\n2023-05-15 - Monday\n2021-06-14 - Monday\n2023-08-01 - Tuesday\n2020-09-22 - Tuesday\n2022-03-17 - Thursday\n2022-11-11 - Friday\n2020-02-29 - Saturday\n2021-12-25 - Saturday\n2022-01-01 - Saturday\n2023-04-01 - Saturday\n2021-10-31 - Sunday\n\nDifferences in Days Between Consecutive Dates:\n[665, -700, 778, -1043, 541, 239, -986, 665, 7, 455, -517]\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef date_range(start_date, end_date):\n    delta = end_date - start_date\n    return [(start_date + timedelta(days=i)).strftime('%Y-%m-%d') for i in range(delta.days + 1)]\n\ndef sort_dates_by_day_of_week(dates):\n    return sorted(dates, key=lambda d: (datetime.strptime(d, '%Y-%m-%d').weekday(), d))\n\nstart = datetime(2023, 1, 1)\nend = datetime(2023, 1, 31)\ndates = date_range(start, end)\nsorted_dates = sort_dates_by_day_of_week(dates)\n\nfor date in sorted_dates:\n    print(date)"}, {"role": "assistant", "content": "2023-01-02\n2023-01-09\n2023-01-16\n2023-01-23\n2023-01-30\n2023-01-03\n2023-01-10\n2023-01-17\n2023-01-24\n2023-01-31\n2023-01-04\n2023-01-11\n2023-01-18\n2023-01-25\n2023-01-05\n2023-01-12\n2023-01-19\n2023-01-26\n2023-01-06\n2023-01-13\n2023-01-20\n2023-01-27\n2023-01-07\n2023-01-14\n2023-01-21\n2023-01-28\n2023-01-01\n2023-01-08\n2023-01-15\n2023-01-22\n2023-01-29\n"}]}
{"messages": [{"role": "user", "content": "def bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n\ndef generate_pattern(n):\n    pattern = []\n    for i in range(1, n+1):\n        row = [i * j for j in range(1, n+1)]\n        bubble_sort(row)\n        pattern.append(row)\n    return pattern\n\nn = 10\npattern = generate_pattern(n)\nfor row in pattern:\n    print(' '.join(f\"{num:3d}\" for num in row))"}, {"role": "assistant", "content": "  1   2   3   4   5   6   7   8   9  10\n  2   4   6   8  10  12  14  16  18  20\n  3   6   9  12  15  18  21  24  27  30\n  4   8  12  16  20  24  28  32  36  40\n  5  10  15  20  25  30  35  40  45  50\n  6  12  18  24  30  36  42  48  54  60\n  7  14  21  28  35  42  49  56  63  70\n  8  16  24  32  40  48  56  64  72  80\n  9  18  27  36  45  54  63  72  81  90\n 10  20  30  40  50  60  70  80  90 100\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef generate_pattern(n):\n    pattern = []\n    for i in range(1, n + 1):\n        pattern.append(''.join(str(x % 10) for x in range(1, i + 1)))\n    return pattern\n\ndef search_pattern(pattern, query):\n    for i, line in enumerate(pattern):\n        if re.search(query, line):\n            print(f\"Pattern found in line {i + 1}: {line}\")\n\nn = 15\npattern = generate_pattern(n)\n\nfor i, line in enumerate(pattern):\n    print(f\"Line {i + 1}: {line}\")\n\nsearch_query = \"123\"\nprint(f\"\\nSearching for pattern '{search_query}' in the generated pattern:\")\nsearch_pattern(pattern, search_query)"}, {"role": "assistant", "content": "Line 1: 1\nLine 2: 12\nLine 3: 123\nLine 4: 1234\nLine 5: 12345\nLine 6: 123456\nLine 7: 1234567\nLine 8: 12345678\nLine 9: 123456789\nLine 10: 1234567890\nLine 11: 12345678901\nLine 12: 123456789012\nLine 13: 1234567890123\nLine 14: 12345678901234\nLine 15: 123456789012345\n\nSearching for pattern '123' in the generated pattern:\nPattern found in line 3: 123\nPattern found in line 4: 1234\nPattern found in line 5: 12345\nPattern found in line 6: 123456\nPattern found in line 7: 1234567\nPattern found in line 8: 12345678\nPattern found in line 9: 123456789\nPattern found in line 10: 1234567890\nPattern found in line 11: 12345678901\nPattern found in line 12: 123456789012\nPattern found in line 13: 1234567890123\nPattern found in line 14: 12345678901234\nPattern found in line 15: 123456789012345\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef is_perfect_square(n):\n    return int(math.sqrt(n)) ** 2 == n\n\ndef next_perfect_square(n):\n    root = math.isqrt(n)\n    return (root + 1) ** 2\n\ndef generate_weird_sequence(limit):\n    sequence = []\n    current_number = 1\n    while len(sequence) < limit:\n        if is_perfect_square(current_number):\n            sequence.append(next_perfect_square(current_number))\n        else:\n            sequence.append(current_number)\n        current_number += 1\n    return sequence\n\ndef weird_sort(sequence):\n    return sorted(sequence, key=lambda x: (is_perfect_square(x), x))\n\nseq = generate_weird_sequence(50)\nsorted_seq = weird_sort(seq)\nfor number in sorted_seq:\n    print(number)"}, {"role": "assistant", "content": "2\n3\n5\n6\n7\n8\n10\n11\n12\n13\n14\n15\n17\n18\n19\n20\n21\n22\n23\n24\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n50\n4\n9\n16\n25\n36\n49\n64\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef polar_angle(point):\n    x, y = point\n    angle = math.atan2(y, x)\n    return angle if angle >= 0 else angle + 2 * math.pi\n\ndef distance_from_origin(point):\n    x, y = point\n    return math.sqrt(x * x + y * y)\n\ndef sort_points(points):\n    return sorted(points, key=lambda p: (polar_angle(p), distance_from_origin(p)))\n\npoints = [\n    (1, 2), (2, 3), (4, -1), (-1, -1), (0, 3), (-3, 2),\n    (2, -4), (3, -3), (-2, -2), (1, -1), (0, -2), (-4, 0)\n]\n\nsorted_points = sort_points(points)\n\nfor idx, point in enumerate(sorted_points):\n    angle = polar_angle(point)\n    dist = distance_from_origin(point)\n    print(f\"Point {idx + 1}: {point}, Polar Angle: {angle:.2f}, Distance: {dist:.2f}\")"}, {"role": "assistant", "content": "Point 1: (2, 3), Polar Angle: 0.98, Distance: 3.61\nPoint 2: (1, 2), Polar Angle: 1.11, Distance: 2.24\nPoint 3: (0, 3), Polar Angle: 1.57, Distance: 3.00\nPoint 4: (-3, 2), Polar Angle: 2.55, Distance: 3.61\nPoint 5: (-4, 0), Polar Angle: 3.14, Distance: 4.00\nPoint 6: (-1, -1), Polar Angle: 3.93, Distance: 1.41\nPoint 7: (-2, -2), Polar Angle: 3.93, Distance: 2.83\nPoint 8: (0, -2), Polar Angle: 4.71, Distance: 2.00\nPoint 9: (2, -4), Polar Angle: 5.18, Distance: 4.47\nPoint 10: (1, -1), Polar Angle: 5.50, Distance: 1.41\nPoint 11: (3, -3), Polar Angle: 5.50, Distance: 4.24\nPoint 12: (4, -1), Polar Angle: 6.04, Distance: 4.12\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"\nIn the midst of the word he was trying to say,\nIn the midst of his laughter and glee,\nHe had softly and suddenly vanished away,\nFor the Snark was a Boojum, you see.\n\"\"\"\n\nsearch_phrases = [\n    \"midst of the word\",\n    \"Boojum\",\n    \"Snark\",\n    \"vanished\",\n    \"glee\"\n]\n\ndef kmp_search(pattern, text):\n    def compute_lps(pattern):\n        lps = [0] * len(pattern)\n        length = 0\n        i = 1\n        while i < len(pattern):\n            if pattern[i] == pattern[length]:\n                length += 1\n                lps[i] = length\n                i += 1\n            else:\n                if length != 0:\n                    length = lps[length - 1]\n                else:\n                    lps[i] = 0\n                    i += 1\n        return lps\n\n    lps = compute_lps(pattern)\n    i = j = 0\n    indices = []\n    while i < len(text):\n        if pattern[j] == text[i]:\n            i += 1\n            j += 1\n        if j == len(pattern):\n            indices.append(i - j)\n            j = lps[j - 1]\n        elif i < len(text) and pattern[j] != text[i]:\n            if j != 0:\n                j = lps[j - 1]\n            else:\n                i += 1\n    return indices\n\nresults = {}\nfor phrase in search_phrases:\n    results[phrase] = kmp_search(phrase, text)\n\nfor phrase, indices in results.items():\n    print(f\"Phrase: '{phrase}' found at indices: {indices}\")"}, {"role": "assistant", "content": "Phrase: 'midst of the word' found at indices: [8]\nPhrase: 'Boojum' found at indices: [149]\nPhrase: 'Snark' found at indices: [137]\nPhrase: 'vanished' found at indices: [114]\nPhrase: 'glee' found at indices: [81]\n"}]}
{"messages": [{"role": "user", "content": "def find_magic_number(sequence, target):\n    left, right = 0, len(sequence) - 1\n    print(f\"Initial sequence: {sequence}\")\n    while left <= right:\n        mid = (left + right) // 2\n        print(f\"Checking middle index {mid}, value {sequence[mid]}\")\n        if sequence[mid] == target:\n            return mid\n        elif sequence[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n        print(f\"New search range: {left} to {right}\")\n    return -1\n\ndef generate_sequence(n):\n    return [i * i for i in range(n)]\n\nsequence = generate_sequence(20)\nmagic_number = find_magic_number(sequence, 81)\nprint(f\"Magic number found at index: {magic_number}\")\n\nfor idx, val in enumerate(sequence):\n    print(f\"Sequence[{idx}] = {val}\")"}, {"role": "assistant", "content": "Initial sequence: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225, 256, 289, 324, 361]\nChecking middle index 9, value 81\nMagic number found at index: 9\nSequence[0] = 0\nSequence[1] = 1\nSequence[2] = 4\nSequence[3] = 9\nSequence[4] = 16\nSequence[5] = 25\nSequence[6] = 36\nSequence[7] = 49\nSequence[8] = 64\nSequence[9] = 81\nSequence[10] = 100\nSequence[11] = 121\nSequence[12] = 144\nSequence[13] = 169\nSequence[14] = 196\nSequence[15] = 225\nSequence[16] = 256\nSequence[17] = 289\nSequence[18] = 324\nSequence[19] = 361\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef find_closest_dates(dates, target_date, n):\n    target_date = datetime.strptime(target_date, '%Y-%m-%d')\n    date_diffs = []\n    for date in dates:\n        date_obj = datetime.strptime(date, '%Y-%m-%d')\n        diff = abs((date_obj - target_date).days)\n        date_diffs.append((diff, date))\n    date_diffs.sort()\n    closest_dates = [date for _, date in date_diffs[:n]]\n    return closest_dates\n\ndates_list = [f\"2023-10-{str(day).zfill(2)}\" for day in range(1, 31)]\ntarget = \"2023-10-15\"\nclosest_10_dates = find_closest_dates(dates_list, target, 10)\n\nfor date in closest_10_dates:\n    print(date)"}, {"role": "assistant", "content": "2023-10-15\n2023-10-14\n2023-10-16\n2023-10-13\n2023-10-17\n2023-10-12\n2023-10-18\n2023-10-11\n2023-10-19\n2023-10-10\n"}]}
{"messages": [{"role": "user", "content": "text = [\n    \"banana apple orange\",\n    \"zebra apple monkey\",\n    \"apple banana\",\n    \"orange banana apple\",\n    \"monkey zebra\",\n    \"apple zebra orange\",\n    \"banana zebra apple\",\n    \"orange monkey\",\n    \"zebra monkey banana\",\n    \"banana apple orange zebra\"\n]\n\ndef sort_by_last_word(sentence):\n    return sentence.split()[-1]\n\nsorted_text = sorted(text, key=sort_by_last_word)\n\nfor line in sorted_text:\n    print(line)"}, {"role": "assistant", "content": "orange banana apple\nbanana zebra apple\napple banana\nzebra monkey banana\nzebra apple monkey\norange monkey\nbanana apple orange\napple zebra orange\nmonkey zebra\nbanana apple orange zebra\n"}]}
{"messages": [{"role": "user", "content": "import datetime\nfrom math import sqrt\n\ndata = [\n    (datetime.datetime(2023, 10, 1, 15, 30), 25),\n    (datetime.datetime(2023, 10, 1, 16, 0), 30),\n    (datetime.datetime(2023, 10, 1, 15, 45), 28),\n    (datetime.datetime(2023, 10, 1, 16, 15), 35),\n    (datetime.datetime(2023, 10, 1, 16, 30), 31),\n    (datetime.datetime(2023, 10, 1, 15, 15), 22),\n    (datetime.datetime(2023, 10, 1, 16, 45), 29),\n    (datetime.datetime(2023, 10, 1, 15, 0), 20),\n]\n\ndef timestamp_to_minutes(ts):\n    return ts.hour * 60 + ts.minute\n\ndata.sort(key=lambda x: timestamp_to_minutes(x[0]))\n\ndef calculate_moving_average(data, window_size):\n    moving_averages = []\n    for i in range(len(data) - window_size + 1):\n        window = data[i:i + window_size]\n        window_avg = sum([point[1] for point in window]) / window_size\n        moving_averages.append((window[-1][0], window_avg))\n    return moving_averages\n\ndef calculate_std_dev(values):\n    mean = sum(values) / len(values)\n    variance = sum((x - mean) ** 2 for x in values) / len(values)\n    return sqrt(variance)\n\ndef analyze_data(data, window_size):\n    moving_averages = calculate_moving_average(data, window_size)\n    temperature_values = [point[1] for point in data]\n    std_dev = calculate_std_dev(temperature_values)\n    return moving_averages, std_dev\n\nmoving_averages, std_dev = analyze_data(data, 3)\n\nfor timestamp, avg in moving_averages:\n    print(f\"{timestamp.strftime('%Y-%m-%d %H:%M')}: {avg:.2f}\")\n\nprint(f\"Standard Deviation of Temperatures: {std_dev:.2f}\")"}, {"role": "assistant", "content": "2023-10-01 15:30: 22.33\n2023-10-01 15:45: 25.00\n2023-10-01 16:00: 27.67\n2023-10-01 16:15: 31.00\n2023-10-01 16:30: 32.00\n2023-10-01 16:45: 31.67\nStandard Deviation of Temperatures: 4.61\n"}]}
{"messages": [{"role": "user", "content": "class Player:\n    def __init__(self, name, scores):\n        self.name = name\n        self.scores = scores\n        self.total_score = sum(scores)\n\n    def __repr__(self):\n        return f\"{self.name}: {self.total_score}\"\n\nplayers = [\n    Player(\"Alice\", [10, 15, 20]),\n    Player(\"Bob\", [5, 8, 12]),\n    Player(\"Charlie\", [20, 15, 10]),\n    Player(\"David\", [10, 10, 30]),\n    Player(\"Eve\", [0, 30, 20])\n]\n\ndef selection_sort(players):\n    n = len(players)\n    for i in range(n):\n        min_idx = i\n        for j in range(i+1, n):\n            if players[j].total_score < players[min_idx].total_score:\n                min_idx = j\n        players[i], players[min_idx] = players[min_idx], players[i]\n\nprint(\"Initial player order:\")\nfor player in players:\n    print(player)\n\nselection_sort(players)\n\nprint(\"\\nPlayers sorted by total score:\")\nfor player in players:\n    print(player)\n\nrankings = {player.name: rank + 1 for rank, player in enumerate(players)}\n\nprint(\"\\nFinal Player Rankings:\")\nfor name, rank in rankings.items():\n    print(f\"{name} is ranked {rank}\")"}, {"role": "assistant", "content": "Initial player order:\nAlice: 45\nBob: 25\nCharlie: 45\nDavid: 50\nEve: 50\n\nPlayers sorted by total score:\nBob: 25\nAlice: 45\nCharlie: 45\nDavid: 50\nEve: 50\n\nFinal Player Rankings:\nBob is ranked 1\nAlice is ranked 2\nCharlie is ranked 3\nDavid is ranked 4\nEve is ranked 5\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndates = [\n    datetime(2023, 5, 17),\n    datetime(2022, 11, 8),\n    datetime(2023, 2, 14),\n    datetime(2023, 1, 1),\n    datetime(2023, 12, 25),\n    datetime(2023, 7, 4),\n    datetime(2022, 10, 31),\n    datetime(2023, 3, 17),\n    datetime(2023, 9, 10),\n    datetime(2022, 12, 25)\n]\n\ndef custom_sort(date):\n    return (date.month, date.day, date.year)\n\nsorted_dates = sorted(dates, key=custom_sort)\n\ncurrent_date = datetime(2023, 1, 1)\nincrement_days = 10\n\noutput_dates = []\nfor i in range(10):\n    current_date += timedelta(days=increment_days)\n    output_dates.append(current_date)\n\nfinal_dates = sorted(sorted_dates + output_dates, key=custom_sort)\n\nfor date in final_dates:\n    print(date.strftime('%Y-%m-%d'))"}, {"role": "assistant", "content": "2023-01-01\n2023-01-11\n2023-01-21\n2023-01-31\n2023-02-10\n2023-02-14\n2023-02-20\n2023-03-02\n2023-03-12\n2023-03-17\n2023-03-22\n2023-04-01\n2023-04-11\n2023-05-17\n2023-07-04\n2023-09-10\n2022-10-31\n2022-11-08\n2022-12-25\n2023-12-25\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef encode_char(c):\n    return ord(c) % 10\n\ndef encrypt_message(message):\n    words = re.findall(r'\\b\\w+\\b', message)\n    encoded_words = []\n    \n    for word in words:\n        encoded = [encode_char(c) for c in word]\n        encoded_words.append((encoded, word))\n    \n    encoded_words.sort()\n    \n    sorted_message = ' '.join(word for _, word in encoded_words)\n    return sorted_message\n\nmessage = \"Sorting algorithms can be quite fascinating in the realm of computer science\"\nprint(\"Original Message:\")\nprint(message)\nprint(\"\\nEncoding each character by its ordinal % 10:\")\nencoded_chars = [encode_char(c) for c in message if c.isalnum() or c.isspace()]\nprint(encoded_chars)\nprint(\"\\nEncrypted Message:\")\nencrypted_message = encrypt_message(message)\nprint(encrypted_message)"}, {"role": "assistant", "content": "Original Message:\nSorting algorithms can be quite fascinating in the realm of computer science\n\nEncoding each character by its ordinal % 10:\n[3, 1, 4, 6, 5, 0, 3, 2, 7, 8, 3, 1, 4, 5, 6, 4, 9, 5, 2, 9, 7, 0, 2, 8, 1, 2, 3, 7, 5, 6, 1, 2, 2, 7, 5, 9, 5, 0, 7, 6, 5, 0, 3, 2, 5, 0, 2, 6, 4, 1, 2, 4, 1, 7, 8, 9, 2, 1, 2, 2, 9, 1, 9, 2, 7, 6, 1, 4, 2, 5, 9, 5, 1, 0, 9, 1]\n\nEncrypted Message:\nof fascinating Sorting quite realm in science the algorithms be computer can\n"}]}
{"messages": [{"role": "user", "content": "def generate_pattern(n):\n    pattern = []\n    for i in range(1, n + 1):\n        line = [str(j) for j in range(1, i + 1)]\n        pattern.append(\"\".join(line))\n    return pattern\n\ndef sort_pattern_by_sum(pattern):\n    return sorted(pattern, key=lambda x: sum(int(c) for c in x))\n\ndef main():\n    n = 10\n    pattern = generate_pattern(n)\n    sorted_pattern = sort_pattern_by_sum(pattern)\n    for line in sorted_pattern:\n        print(line)\n\nmain()"}, {"role": "assistant", "content": "1\n12\n123\n1234\n12345\n123456\n1234567\n12345678\n123456789\n12345678910\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef mean_median_search(data, target):\n    data.sort()\n    print(f\"Sorted Data: {data}\")\n    mean = statistics.mean(data)\n    median = statistics.median(data)\n    print(f\"Mean: {mean}, Median: {median}\")\n\n    if target < mean:\n        print(\"Searching in the lower half\")\n        return binary_search(data, target, 0, len(data) // 2)\n    else:\n        print(\"Searching in the upper half\")\n        return binary_search(data, target, len(data) // 2, len(data))\n\ndef binary_search(arr, target, low, high):\n    while low < high:\n        mid = (low + high) // 2\n        print(f\"Low: {low}, High: {high}, Mid: {mid}, Mid Value: {arr[mid]}\")\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid\n    return -1\n\ndata = [23, 1, 45, 12, 78, 34, 56, 89, 67, 90]\ntargets = [34, 67, 23, 89, 100, 78]\n\nfor target in targets:\n    print(f\"Searching for: {target}\")\n    index = mean_median_search(data, target)\n    if index != -1:\n        print(f\"Found {target} at index {index}\\n\")\n    else:\n        print(f\"{target} not found\\n\")"}, {"role": "assistant", "content": "Searching for: 34\nSorted Data: [1, 12, 23, 34, 45, 56, 67, 78, 89, 90]\nMean: 49.5, Median: 50.5\nSearching in the lower half\nLow: 0, High: 5, Mid: 2, Mid Value: 23\nLow: 3, High: 5, Mid: 4, Mid Value: 45\nLow: 3, High: 4, Mid: 3, Mid Value: 34\nFound 34 at index 3\n\nSearching for: 67\nSorted Data: [1, 12, 23, 34, 45, 56, 67, 78, 89, 90]\nMean: 49.5, Median: 50.5\nSearching in the upper half\nLow: 5, High: 10, Mid: 7, Mid Value: 78\nLow: 5, High: 7, Mid: 6, Mid Value: 67\nFound 67 at index 6\n\nSearching for: 23\nSorted Data: [1, 12, 23, 34, 45, 56, 67, 78, 89, 90]\nMean: 49.5, Median: 50.5\nSearching in the lower half\nLow: 0, High: 5, Mid: 2, Mid Value: 23\nFound 23 at index 2\n\nSearching for: 89\nSorted Data: [1, 12, 23, 34, 45, 56, 67, 78, 89, 90]\nMean: 49.5, Median: 50.5\nSearching in the upper half\nLow: 5, High: 10, Mid: 7, Mid Value: 78\nLow: 8, High: 10, Mid: 9, Mid Value: 90\nLow: 8, High: 9, Mid: 8, Mid Value: 89\nFound 89 at index 8\n\nSearching for: 100\nSorted Data: [1, 12, 23, 34, 45, 56, 67, 78, 89, 90]\nMean: 49.5, Median: 50.5\nSearching in the upper half\nLow: 5, High: 10, Mid: 7, Mid Value: 78\nLow: 8, High: 10, Mid: 9, Mid Value: 90\n100 not found\n\nSearching for: 78\nSorted Data: [1, 12, 23, 34, 45, 56, 67, 78, 89, 90]\nMean: 49.5, Median: 50.5\nSearching in the upper half\nLow: 5, High: 10, Mid: 7, Mid Value: 78\nFound 78 at index 7\n\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"\nLorem ipsum dolor sit amet, consectetur adipiscing elit.\nVestibulum auctor malesuada massa, a tincidunt odio egestas sit amet.\nNulla facilisi. Cras vitae elit augue. Nunc hendrerit neque ut iaculis pharetra.\nSuspendisse potenti. Morbi fringilla leo a lectus ullamcorper, at semper ligula auctor.\n\"\"\"\n\ndef search_and_transform(text, search_word):\n    lines = text.strip().split('\\n')\n    transformed_lines = []\n    for i, line in enumerate(lines):\n        print(f\"Analyzing line {i+1}: {line}\")\n        if re.search(search_word, line):\n            print(f\"Found '{search_word}' in line {i+1}\")\n            transformed_line = re.sub(search_word, search_word.upper(), line)\n            print(f\"Transformed line {i+1}: {transformed_line}\")\n        else:\n            transformed_line = line\n        transformed_lines.append(transformed_line)\n    return transformed_lines\n\nresult = search_and_transform(text, 'elit')\nfor idx, line in enumerate(result):\n    print(f\"Output line {idx+1}: {line}\")"}, {"role": "assistant", "content": "Analyzing line 1: Lorem ipsum dolor sit amet, consectetur adipiscing elit.\nFound 'elit' in line 1\nTransformed line 1: Lorem ipsum dolor sit amet, consectetur adipiscing ELIT.\nAnalyzing line 2: Vestibulum auctor malesuada massa, a tincidunt odio egestas sit amet.\nAnalyzing line 3: Nulla facilisi. Cras vitae elit augue. Nunc hendrerit neque ut iaculis pharetra.\nFound 'elit' in line 3\nTransformed line 3: Nulla facilisi. Cras vitae ELIT augue. Nunc hendrerit neque ut iaculis pharetra.\nAnalyzing line 4: Suspendisse potenti. Morbi fringilla leo a lectus ullamcorper, at semper ligula auctor.\nOutput line 1: Lorem ipsum dolor sit amet, consectetur adipiscing ELIT.\nOutput line 2: Vestibulum auctor malesuada massa, a tincidunt odio egestas sit amet.\nOutput line 3: Nulla facilisi. Cras vitae ELIT augue. Nunc hendrerit neque ut iaculis pharetra.\nOutput line 4: Suspendisse potenti. Morbi fringilla leo a lectus ullamcorper, at semper ligula auctor.\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef date_to_tuple(date_str):\n    return tuple(map(int, date_str.split('-')))\n\ndef tuple_to_date(date_tuple):\n    return datetime.date(*date_tuple)\n\ndates = [\n    \"2023-05-21\", \"2021-11-30\", \"2022-01-15\", \"2023-07-04\",\n    \"2020-12-25\", \"2021-04-01\", \"2023-01-01\", \"2022-06-18\",\n    \"2023-09-10\", \"2021-08-19\", \"2022-11-11\", \"2020-03-17\"\n]\n\ndate_tuples = [date_to_tuple(date) for date in dates]\nprint(\"Date Tuples:\", date_tuples)\n\nsorted_dates = sorted(date_tuples, key=lambda x: (x[1], x[2], x[0]))\nprint(\"Sorted Date Tuples by Month and Day:\", sorted_dates)\n\ntransformed_dates = [tuple_to_date(date) for date in sorted_dates]\nprint(\"Transformed Dates:\")\n\nfor date in transformed_dates:\n    print(date.strftime(\"%Y-%m-%d\"))"}, {"role": "assistant", "content": "Date Tuples: [(2023, 5, 21), (2021, 11, 30), (2022, 1, 15), (2023, 7, 4), (2020, 12, 25), (2021, 4, 1), (2023, 1, 1), (2022, 6, 18), (2023, 9, 10), (2021, 8, 19), (2022, 11, 11), (2020, 3, 17)]\nSorted Date Tuples by Month and Day: [(2023, 1, 1), (2022, 1, 15), (2020, 3, 17), (2021, 4, 1), (2023, 5, 21), (2022, 6, 18), (2023, 7, 4), (2021, 8, 19), (2023, 9, 10), (2022, 11, 11), (2021, 11, 30), (2020, 12, 25)]\nTransformed Dates:\n2023-01-01\n2022-01-15\n2020-03-17\n2021-04-01\n2023-05-21\n2022-06-18\n2023-07-04\n2021-08-19\n2023-09-10\n2022-11-11\n2021-11-30\n2020-12-25\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef bubble_sort(data):\n    n = len(data)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if data[j] > data[j+1]:\n                data[j], data[j+1] = data[j+1], data[j]\n\ndef calculate_median_and_sort(data):\n    print(\"Original data:\", data)\n    median = statistics.median(data)\n    print(\"Median of the data:\", median)\n    bubble_sort(data)\n    print(\"Sorted data:\", data)\n    return median, data\n\ndata = [7, 3, 5, 2, 9, 1, 4, 6, 8, 10, 11, 15, 13, 14, 12, 19, 18, 17, 16, 20]\n\nmedian, sorted_data = calculate_median_and_sort(data)\n\nprint(\"\\nFinal Median:\", median)\nprint(\"Final Sorted Data:\")\nfor value in sorted_data:\n    print(value)"}, {"role": "assistant", "content": "Original data: [7, 3, 5, 2, 9, 1, 4, 6, 8, 10, 11, 15, 13, 14, 12, 19, 18, 17, 16, 20]\nMedian of the data: 10.5\nSorted data: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n\nFinal Median: 10.5\nFinal Sorted Data:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef fibonacci_sequence(n):\n    fib_seq = [0, 1]\n    for i in range(2, n):\n        fib_seq.append(fib_seq[i - 1] + fib_seq[i - 2])\n    return fib_seq\n\ndef is_perfect_square(x):\n    s = int(math.sqrt(x))\n    return s * s == x\n\ndef is_fibonacci_number(x):\n    return is_perfect_square(5 * x * x + 4) or is_perfect_square(5 * x * x - 4)\n\ndef find_fib_in_squares(limit):\n    squares = [x * x for x in range(1, limit)]\n    fib_squares = filter(is_fibonacci_number, squares)\n    return list(fib_squares)\n\ndef main():\n    fib_seq = fibonacci_sequence(50)\n    fib_in_squares = find_fib_in_squares(100)\n    output = [f\"{i}: {fib_seq[i]}\" for i in range(len(fib_seq)) if fib_seq[i] in fib_in_squares]\n    for line in output:\n        print(line)\n\nmain()"}, {"role": "assistant", "content": "1: 1\n2: 1\n12: 144\n"}]}
{"messages": [{"role": "user", "content": "import re\nfrom collections import defaultdict\n\ntext = \"\"\"\nThe quick brown fox jumps over the lazy dog. This sentence contains every letter of the alphabet at least once.\nHowever, the quick brown fox is something more than just a phrase. It is a test case for typing speed and keyboard testing. \nThe quick brown fox jumps over the lazy dog. The repetition of this sentence helps in analyzing patterns in typing.\n\"\"\"\n\nwords = re.findall(r'\\b\\w+\\b', text.lower())\nword_count = defaultdict(int)\n\nfor word in words:\n    word_count[word] += 1\n\nsorted_words = sorted(word_count.items(), key=lambda x: (-x[1], x[0]))\n\nprint(\"Word Frequencies:\")\nfor word, count in sorted_words:\n    print(f\"{word}: {count}\")\n\nunique_sorted_words = sorted(set(words), key=lambda x: (len(x), x))\n\nprint(\"\\nWords sorted by length and alphabetically:\")\nfor word in unique_sorted_words:\n    print(word)"}, {"role": "assistant", "content": "Word Frequencies:\nthe: 7\nbrown: 3\nfox: 3\nquick: 3\na: 2\ndog: 2\nin: 2\nis: 2\njumps: 2\nlazy: 2\nof: 2\nover: 2\nsentence: 2\nthis: 2\ntyping: 2\nalphabet: 1\nanalyzing: 1\nand: 1\nat: 1\ncase: 1\ncontains: 1\nevery: 1\nfor: 1\nhelps: 1\nhowever: 1\nit: 1\njust: 1\nkeyboard: 1\nleast: 1\nletter: 1\nmore: 1\nonce: 1\npatterns: 1\nphrase: 1\nrepetition: 1\nsomething: 1\nspeed: 1\ntest: 1\ntesting: 1\nthan: 1\n\nWords sorted by length and alphabetically:\na\nat\nin\nis\nit\nof\nand\ndog\nfor\nfox\nthe\ncase\njust\nlazy\nmore\nonce\nover\ntest\nthan\nthis\nbrown\nevery\nhelps\njumps\nleast\nquick\nspeed\nletter\nphrase\ntyping\nhowever\ntesting\nalphabet\ncontains\nkeyboard\npatterns\nsentence\nanalyzing\nsomething\nrepetition\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef generate_dates(start_date, end_date):\n    current_date = start_date\n    dates = []\n    while current_date <= end_date:\n        dates.append(current_date)\n        current_date += timedelta(days=1)\n    return dates\n\ndef binary_search_dates(dates, target):\n    left, right = 0, len(dates) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        print(f\"Searching at index: {mid}, date: {dates[mid]}\")\n        if dates[mid] == target:\n            return mid\n        elif dates[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\nstart_date = datetime(2023, 1, 1)\nend_date = datetime(2023, 3, 31)\ntarget_date = datetime(2023, 2, 15)\n\ndates = generate_dates(start_date, end_date)\nprint(\"Generated dates:\")\nfor date in dates:\n    print(date.strftime('%Y-%m-%d'))\n\nprint(\"\\nSearching for target date:\", target_date.strftime('%Y-%m-%d'))\nindex = binary_search_dates(dates, target_date)\nif index != -1:\n    print(f\"Target date found at index: {index}\")\nelse:\n    print(\"Target date not found.\")"}, {"role": "assistant", "content": "Generated dates:\n2023-01-01\n2023-01-02\n2023-01-03\n2023-01-04\n2023-01-05\n2023-01-06\n2023-01-07\n2023-01-08\n2023-01-09\n2023-01-10\n2023-01-11\n2023-01-12\n2023-01-13\n2023-01-14\n2023-01-15\n2023-01-16\n2023-01-17\n2023-01-18\n2023-01-19\n2023-01-20\n2023-01-21\n2023-01-22\n2023-01-23\n2023-01-24\n2023-01-25\n2023-01-26\n2023-01-27\n2023-01-28\n2023-01-29\n2023-01-30\n2023-01-31\n2023-02-01\n2023-02-02\n2023-02-03\n2023-02-04\n2023-02-05\n2023-02-06\n2023-02-07\n2023-02-08\n2023-02-09\n2023-02-10\n2023-02-11\n2023-02-12\n2023-02-13\n2023-02-14\n2023-02-15\n2023-02-16\n2023-02-17\n2023-02-18\n2023-02-19\n2023-02-20\n2023-02-21\n2023-02-22\n2023-02-23\n2023-02-24\n2023-02-25\n2023-02-26\n2023-02-27\n2023-02-28\n2023-03-01\n2023-03-02\n2023-03-03\n2023-03-04\n2023-03-05\n2023-03-06\n2023-03-07\n2023-03-08\n2023-03-09\n2023-03-10\n2023-03-11\n2023-03-12\n2023-03-13\n2023-03-14\n2023-03-15\n2023-03-16\n2023-03-17\n2023-03-18\n2023-03-19\n2023-03-20\n2023-03-21\n2023-03-22\n2023-03-23\n2023-03-24\n2023-03-25\n2023-03-26\n2023-03-27\n2023-03-28\n2023-03-29\n2023-03-30\n2023-03-31\n\nSearching for target date: 2023-02-15\nSearching at index: 44, date: 2023-02-14 00:00:00\nSearching at index: 67, date: 2023-03-09 00:00:00\nSearching at index: 55, date: 2023-02-25 00:00:00\nSearching at index: 49, date: 2023-02-19 00:00:00\nSearching at index: 46, date: 2023-02-16 00:00:00\nSearching at index: 45, date: 2023-02-15 00:00:00\nTarget date found at index: 45\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef next_palindrome_date(start_date):\n    def is_palindrome(date_str):\n        return date_str == date_str[::-1]\n\n    current_date = start_date\n    palindrome_dates = []\n\n    while len(palindrome_dates) < 20:\n        current_date += datetime.timedelta(days=1)\n        date_str = current_date.strftime(\"%m%d%Y\")\n        if is_palindrome(date_str):\n            palindrome_dates.append(current_date)\n    \n    return palindrome_dates\n\nstart_date = datetime.datetime(2000, 1, 1)\npalindrome_dates = next_palindrome_date(start_date)\n\nfor date in palindrome_dates:\n    print(date.strftime(\"%m/%d/%Y\"))"}, {"role": "assistant", "content": "10/02/2001\n01/02/2010\n11/02/2011\n02/02/2020\n12/02/2021\n03/02/2030\n04/02/2040\n05/02/2050\n06/02/2060\n07/02/2070\n08/02/2080\n09/02/2090\n10/12/2101\n01/12/2110\n11/12/2111\n02/12/2120\n12/12/2121\n03/12/2130\n04/12/2140\n05/12/2150\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"\nIn a distant future, where the realms of reality and virtual existence blurred,\nthere existed a network of interconnected worlds known as the Nexus. The Nexus\nwas a labyrinth of information, a digital cosmos where ideas flowed like rivers\nand knowledge was the currency of power.\n\nHidden deep within the Nexus were fragments of an ancient algorithm, said to hold\nthe secrets to unlocking unparalleled wisdom and understanding. Many sought after\nthese fragments, for they promised enlightenment and dominion over the virtual\nrealms.\n\nA group of seekers, known as the Codekeepers, dedicated their lives to deciphering\nthe algorithm. They traveled through the vast digital landscapes, searching for\nclues hidden within the lines of code that composed the fabric of the Nexus.\n\nOne day, a Codekeeper stumbled upon an encoded message buried within a forgotten\ncorner of the network. The message was cryptic, a riddle wrapped in mystery,\nbut they knew it was a piece of the puzzle they had been searching for.\n\"\"\"\n\ndef search_fragments(text, keyword):\n    pattern = re.compile(rf'\\b{keyword}\\b', re.IGNORECASE)\n    lines = text.splitlines()\n    results = []\n    for line_number, line in enumerate(lines):\n        if pattern.search(line):\n            results.append((line_number + 1, line.strip()))\n    return results\n\nkeyword = \"the\"\nfragments = search_fragments(text, keyword)\nfor line_number, fragment in fragments:\n    print(f\"Line {line_number}: {fragment}\")"}, {"role": "assistant", "content": "Line 2: In a distant future, where the realms of reality and virtual existence blurred,\nLine 3: there existed a network of interconnected worlds known as the Nexus. The Nexus\nLine 5: and knowledge was the currency of power.\nLine 7: Hidden deep within the Nexus were fragments of an ancient algorithm, said to hold\nLine 8: the secrets to unlocking unparalleled wisdom and understanding. Many sought after\nLine 9: these fragments, for they promised enlightenment and dominion over the virtual\nLine 12: A group of seekers, known as the Codekeepers, dedicated their lives to deciphering\nLine 13: the algorithm. They traveled through the vast digital landscapes, searching for\nLine 14: clues hidden within the lines of code that composed the fabric of the Nexus.\nLine 17: corner of the network. The message was cryptic, a riddle wrapped in mystery,\nLine 18: but they knew it was a piece of the puzzle they had been searching for.\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef vigenere_cipher_encrypt(text, key):\n    encrypted = []\n    key_index = 0\n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].lower()) - ord('a')\n            if char.islower():\n                encrypted.append(chr((ord(char) - ord('a') + shift) % 26 + ord('a')))\n            else:\n                encrypted.append(chr((ord(char) - ord('A') + shift) % 26 + ord('A')))\n            key_index += 1\n        else:\n            encrypted.append(char)\n    return ''.join(encrypted)\n\ndef vigenere_cipher_decrypt(text, key):\n    decrypted = []\n    key_index = 0\n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].lower()) - ord('a')\n            if char.islower():\n                decrypted.append(chr((ord(char) - ord('a') - shift) % 26 + ord('a')))\n            else:\n                decrypted.append(chr((ord(char) - ord('A') - shift) % 26 + ord('A')))\n            key_index += 1\n        else:\n            decrypted.append(char)\n    return ''.join(decrypted)\n\ndef search_key(ciphertext, dictionary_words):\n    for word in dictionary_words:\n        decrypted_text = vigenere_cipher_decrypt(ciphertext, word)\n        if re.search(r'\\b[A-Z]+\\b', decrypted_text):\n            return word, decrypted_text\n    return None, None\n\nciphertext = \"Uifsf jt b tfdsfu nfttbhf xijdi jt ibse up efdszqu\"\ndictionary_words = [\"apple\", \"banana\", \"secret\", \"password\", \"cipher\", \"hidden\"]\n\nkey, message = search_key(ciphertext, dictionary_words)\nresult = f\"Key: {key}\\nDecrypted message: {message}\"\nprint(result)"}, {"role": "assistant", "content": "Key: None\nDecrypted message: None\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef check_point_inside_circle(x, y, circle_x, circle_y, radius):\n    distance = math.sqrt((x - circle_x) ** 2 + (y - circle_y) ** 2)\n    print(f\"Checking point ({x}, {y}) against circle centered at ({circle_x}, {circle_y}) with radius {radius}\")\n    print(f\"Calculated distance from center: {distance}\")\n    return distance < radius\n\ndef find_points_outside_circle(points, circle_x, circle_y, radius):\n    outside_points = []\n    for point in points:\n        x, y = point\n        if check_point_inside_circle(x, y, circle_x, circle_y, radius):\n            outside_points.append(point)\n            print(f\"Point ({x}, {y}) is outside the circle\")\n        else:\n            print(f\"Point ({x}, {y}) is inside the circle\")\n    return outside_points\n\ncircle_center_x = 5\ncircle_center_y = 5\ncircle_radius = 8\n\npoints_to_check = [(1, 1), (8, 8), (6, 3), (10, 10), (5, 12), (0, 0), (7, 9), (3, 3)]\n\nresult = find_points_outside_circle(points_to_check, circle_center_x, circle_center_y, circle_radius)\nprint(\"Points outside the circle are:\")\nfor point in result:\n    print(point)"}, {"role": "assistant", "content": "Checking point (1, 1) against circle centered at (5, 5) with radius 8\nCalculated distance from center: 5.656854249492381\nPoint (1, 1) is outside the circle\nChecking point (8, 8) against circle centered at (5, 5) with radius 8\nCalculated distance from center: 4.242640687119285\nPoint (8, 8) is outside the circle\nChecking point (6, 3) against circle centered at (5, 5) with radius 8\nCalculated distance from center: 2.23606797749979\nPoint (6, 3) is outside the circle\nChecking point (10, 10) against circle centered at (5, 5) with radius 8\nCalculated distance from center: 7.0710678118654755\nPoint (10, 10) is outside the circle\nChecking point (5, 12) against circle centered at (5, 5) with radius 8\nCalculated distance from center: 7.0\nPoint (5, 12) is outside the circle\nChecking point (0, 0) against circle centered at (5, 5) with radius 8\nCalculated distance from center: 7.0710678118654755\nPoint (0, 0) is outside the circle\nChecking point (7, 9) against circle centered at (5, 5) with radius 8\nCalculated distance from center: 4.47213595499958\nPoint (7, 9) is outside the circle\nChecking point (3, 3) against circle centered at (5, 5) with radius 8\nCalculated distance from center: 2.8284271247461903\nPoint (3, 3) is outside the circle\nPoints outside the circle are:\n(1, 1)\n(8, 8)\n(6, 3)\n(10, 10)\n(5, 12)\n(0, 0)\n(7, 9)\n(3, 3)\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef distance(point1, point2):\n    return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2)\n\ndef perimeter(points):\n    peri = 0\n    for i in range(len(points)):\n        peri += distance(points[i], points[(i + 1) % len(points)])\n    return peri\n\ndef area(points):\n    a = 0\n    for i in range(len(points)):\n        x1, y1 = points[i]\n        x2, y2 = points[(i + 1) % len(points)]\n        a += x1 * y2 - x2 * y1\n    return abs(a) / 2\n\ndef centroid(points):\n    x_sum = sum(point[0] for point in points)\n    y_sum = sum(point[1] for point in points)\n    return (x_sum / len(points), y_sum / len(points))\n\ndef sort_by_perimeter(triangles):\n    return sorted(triangles, key=perimeter)\n\ndef sort_by_area(triangles):\n    return sorted(triangles, key=area)\n\ntriangles = [\n    [(0, 0), (4, 0), (2, 3)],\n    [(1, 1), (5, 1), (3, 4)],\n    [(0, 0), (8, 0), (4, 6)],\n    [(2, 2), (6, 2), (4, 5)],\n    [(1, 0), (3, 3), (0, 4)],\n]\n\nprint(\"Original triangles:\")\nfor triangle in triangles:\n    print(triangle)\n\ntriangles_by_perimeter = sort_by_perimeter(triangles)\nprint(\"\\nTriangles sorted by perimeter:\")\nfor triangle in triangles_by_perimeter:\n    print(triangle, \"Perimeter:\", perimeter(triangle))\n\ntriangles_by_area = sort_by_area(triangles)\nprint(\"\\nTriangles sorted by area:\")\nfor triangle in triangles_by_area:\n    print(triangle, \"Area:\", area(triangle))\n\ncentroids = [centroid(tri) for tri in triangles]\nsorted_centroids = sorted(centroids, key=lambda c: (c[0], c[1]))\n\nprint(\"\\nCentroids sorted by x, then y:\")\nfor c in sorted_centroids:\n    print(c)"}, {"role": "assistant", "content": "Original triangles:\n[(0, 0), (4, 0), (2, 3)]\n[(1, 1), (5, 1), (3, 4)]\n[(0, 0), (8, 0), (4, 6)]\n[(2, 2), (6, 2), (4, 5)]\n[(1, 0), (3, 3), (0, 4)]\n\nTriangles sorted by perimeter:\n[(1, 0), (3, 3), (0, 4)] Perimeter: 10.89093456125003\n[(0, 0), (4, 0), (2, 3)] Perimeter: 11.21110255092798\n[(1, 1), (5, 1), (3, 4)] Perimeter: 11.21110255092798\n[(2, 2), (6, 2), (4, 5)] Perimeter: 11.21110255092798\n[(0, 0), (8, 0), (4, 6)] Perimeter: 22.42220510185596\n\nTriangles sorted by area:\n[(1, 0), (3, 3), (0, 4)] Area: 5.5\n[(0, 0), (4, 0), (2, 3)] Area: 6.0\n[(1, 1), (5, 1), (3, 4)] Area: 6.0\n[(2, 2), (6, 2), (4, 5)] Area: 6.0\n[(0, 0), (8, 0), (4, 6)] Area: 24.0\n\nCentroids sorted by x, then y:\n(1.3333333333333333, 2.3333333333333335)\n(2.0, 1.0)\n(3.0, 2.0)\n(4.0, 2.0)\n(4.0, 3.0)\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef sort_by_digit_sum(numbers):\n    def digit_sum(n):\n        return sum(int(digit) for digit in str(abs(n)))\n\n    print(\"Original list:\", numbers)\n    sorted_numbers = sorted(numbers, key=lambda x: (digit_sum(x), x))\n    print(\"Sorted by digit sum:\", sorted_numbers)\n    return sorted_numbers\n\ndef generate_fibonacci_sequence(length):\n    fib_sequence = [0, 1]\n    while len(fib_sequence) < length:\n        fib_sequence.append(fib_sequence[-1] + fib_sequence[-2])\n    return fib_sequence[:length]\n\nfib_sequence = generate_fibonacci_sequence(15)\nprint(\"Generated Fibonacci sequence:\", fib_sequence)\n\nsorted_sequence = sort_by_digit_sum(fib_sequence)\nprint(\"Final sorted sequence:\", sorted_sequence)\n\nfor idx, number in enumerate(sorted_sequence):\n    print(f\"Position {idx + 1}: {number}\")"}, {"role": "assistant", "content": "Generated Fibonacci sequence: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377]\nOriginal list: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377]\nSorted by digit sum: [0, 1, 1, 2, 3, 21, 13, 5, 34, 8, 233, 144, 55, 89, 377]\nFinal sorted sequence: [0, 1, 1, 2, 3, 21, 13, 5, 34, 8, 233, 144, 55, 89, 377]\nPosition 1: 0\nPosition 2: 1\nPosition 3: 1\nPosition 4: 2\nPosition 5: 3\nPosition 6: 21\nPosition 7: 13\nPosition 8: 5\nPosition 9: 34\nPosition 10: 8\nPosition 11: 233\nPosition 12: 144\nPosition 13: 55\nPosition 14: 89\nPosition 15: 377\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\ndata = [\n    {\"name\": \"Alice\", \"birthdate\": \"1990-05-24\"},\n    {\"name\": \"Bob\", \"birthdate\": \"1985-07-19\"},\n    {\"name\": \"Charlie\", \"birthdate\": \"1992-12-11\"},\n    {\"name\": \"David\", \"birthdate\": \"1980-01-30\"},\n    {\"name\": \"Eve\", \"birthdate\": \"1995-08-15\"},\n    {\"name\": \"Frank\", \"birthdate\": \"1983-09-23\"},\n    {\"name\": \"Grace\", \"birthdate\": \"1989-10-29\"},\n    {\"name\": \"Heidi\", \"birthdate\": \"1975-02-25\"},\n    {\"name\": \"Ivan\", \"birthdate\": \"1993-06-01\"},\n    {\"name\": \"Judy\", \"birthdate\": \"1991-03-17\"}\n]\n\ndef calculate_age(birthdate):\n    birthdate = datetime.strptime(birthdate, \"%Y-%m-%d\")\n    today = datetime.now()\n    age = today.year - birthdate.year\n    if today.month < birthdate.month or (today.month == birthdate.month and today.day < birthdate.day):\n        age -= 1\n    return age\n\nfor entry in data:\n    entry['age'] = calculate_age(entry['birthdate'])\n\nprint(\"Data before sorting:\")\nfor person in data:\n    print(f\"{person['name']} - {person['age']} years old\")\n\nsorted_data = sorted(data, key=lambda x: x['age'], reverse=True)\n\nprint(\"\\nData after sorting by age (oldest to youngest):\")\nfor person in sorted_data:\n    print(f\"{person['name']} - {person['age']} years old\")"}, {"role": "assistant", "content": "Data before sorting:\nAlice - 34 years old\nBob - 39 years old\nCharlie - 32 years old\nDavid - 45 years old\nEve - 29 years old\nFrank - 41 years old\nGrace - 35 years old\nHeidi - 50 years old\nIvan - 31 years old\nJudy - 34 years old\n\nData after sorting by age (oldest to youngest):\nHeidi - 50 years old\nDavid - 45 years old\nFrank - 41 years old\nBob - 39 years old\nGrace - 35 years old\nAlice - 34 years old\nJudy - 34 years old\nCharlie - 32 years old\nIvan - 31 years old\nEve - 29 years old\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef caesar_cipher_encrypt(text, shift):\n    encrypted_text = \"\"\n    for char in text:\n        if char.isalpha():\n            shifted = ord(char) + shift\n            if char.islower():\n                encrypted_text += chr((shifted - ord('a')) % 26 + ord('a'))\n            else:\n                encrypted_text += chr((shifted - ord('A')) % 26 + ord('A'))\n        else:\n            encrypted_text += char\n    return encrypted_text\n\ndef binary_search_decrypt(encrypted_text, keyword):\n    low, high = 0, 25\n    while low <= high:\n        mid = (low + high) // 2\n        decrypted_text = caesar_cipher_encrypt(encrypted_text, -mid)\n        if keyword in decrypted_text:\n            return decrypted_text\n        elif keyword > decrypted_text:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return \"Decryption failed\"\n\nencrypted_message = caesar_cipher_encrypt(\"HELLO WORLD\", 5)\ndecrypted_message = binary_search_decrypt(encrypted_message, \"LO\")\nprint(decrypted_message)"}, {"role": "assistant", "content": "Decryption failed\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\nclass Player:\n    def __init__(self, name, score, last_played):\n        self.name = name\n        self.score = score\n        self.last_played = last_played\n\n    def __repr__(self):\n        return f\"{self.name}: {self.score}, Last Played: {self.last_played.strftime('%Y-%m-%d')}\"\n\nplayers = [\n    Player(\"Alice\", 100, datetime.now() - timedelta(days=2)),\n    Player(\"Bob\", 150, datetime.now() - timedelta(days=5)),\n    Player(\"Charlie\", 120, datetime.now() - timedelta(days=1)),\n    Player(\"Diana\", 180, datetime.now() - timedelta(days=3)),\n    Player(\"Eve\", 130, datetime.now() - timedelta(days=10)),\n]\n\nprint(\"Unsorted Players:\")\nfor player in players:\n    print(player)\n\ndef sorting_key(player):\n    return (-player.score, player.last_played)\n\nplayers.sort(key=sorting_key)\n\nprint(\"\\nSorted Players:\")\nfor player in players:\n    print(player)"}, {"role": "assistant", "content": "Unsorted Players:\nAlice: 100, Last Played: 2025-03-30\nBob: 150, Last Played: 2025-03-27\nCharlie: 120, Last Played: 2025-03-31\nDiana: 180, Last Played: 2025-03-29\nEve: 130, Last Played: 2025-03-22\n\nSorted Players:\nDiana: 180, Last Played: 2025-03-29\nBob: 150, Last Played: 2025-03-27\nEve: 130, Last Played: 2025-03-22\nCharlie: 120, Last Played: 2025-03-31\nAlice: 100, Last Played: 2025-03-30\n"}]}
{"messages": [{"role": "user", "content": "def generate_pattern(n):\n    pattern = []\n    for i in range(n):\n        row = []\n        for j in range(n):\n            if (i + j) % 2 == 0:\n                row.append('*')\n            else:\n                row.append(' ')\n        pattern.append(''.join(row))\n    return pattern\n\ndef diagonal_sort(pattern):\n    n = len(pattern)\n    diagonals = [[] for _ in range(2 * n - 1)]\n    for i in range(n):\n        for j in range(n):\n            diagonals[i + j].append(pattern[i][j])\n    \n    for diag in diagonals:\n        diag.sort(reverse=True)\n\n    result = [[' ']*n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            result[i][j] = diagonals[i + j].pop(0)\n\n    return [''.join(row) for row in result]\n\nn = 10\npattern = generate_pattern(n)\nsorted_pattern = diagonal_sort(pattern)\n\nfor row in sorted_pattern:\n    print(row)"}, {"role": "assistant", "content": "* * * * * \n * * * * *\n* * * * * \n * * * * *\n* * * * * \n * * * * *\n* * * * * \n * * * * *\n* * * * * \n * * * * *\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef find_friday_13ths(start_year, end_year):\n    friday_13ths = []\n    for year in range(start_year, end_year + 1):\n        for month in range(1, 13):\n            date = datetime(year, month, 13)\n            if date.weekday() == 4:  # Friday\n                friday_13ths.append(date)\n    return friday_13ths\n\ndef binary_search(date_list, target):\n    low, high = 0, len(date_list) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if date_list[mid] == target:\n            return mid\n        elif date_list[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n\nstart_year = 2000\nend_year = 2099\nfriday_13ths = find_friday_13ths(start_year, end_year)\n\nfor search_date in [datetime(2023, 1, 13), datetime(2027, 8, 13), datetime(2043, 2, 13), datetime(2063, 12, 13)]:\n    index = binary_search(friday_13ths, search_date)\n    if index != -1:\n        print(f\"{search_date.strftime('%Y-%m-%d')} is a Friday the 13th.\")\n    else:\n        print(f\"{search_date.strftime('%Y-%m-%d')} is not a Friday the 13th.\")"}, {"role": "assistant", "content": "2023-01-13 is a Friday the 13th.\n2027-08-13 is a Friday the 13th.\n2043-02-13 is a Friday the 13th.\n2063-12-13 is not a Friday the 13th.\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef cosine_similarity(vec1, vec2):\n    dot_product = sum(a * b for a, b in zip(vec1, vec2))\n    magnitude_1 = math.sqrt(sum(a * a for a in vec1))\n    magnitude_2 = math.sqrt(sum(b * b for b in vec2))\n    return dot_product / (magnitude_1 * magnitude_2)\n\ndef find_most_similar(query_vector, data_matrix):\n    similarities = [(index, cosine_similarity(query_vector, vector)) for index, vector in enumerate(data_matrix)]\n    similarities.sort(key=lambda x: x[1], reverse=True)\n    return similarities\n\ndata_matrix = [\n    [0.1, 0.3, 0.5, 0.2],\n    [0.2, 0.1, 0.6, 0.3],\n    [0.5, 0.4, 0.2, 0.9],\n    [0.9, 0.7, 0.4, 0.1],\n    [0.4, 0.5, 0.1, 0.8],\n    [0.3, 0.8, 0.2, 0.5],\n    [0.6, 0.2, 0.9, 0.4],\n    [0.7, 0.5, 0.3, 0.6],\n    [0.5, 0.5, 0.5, 0.5],\n    [0.4, 0.3, 0.8, 0.6]\n]\n\nquery_vector = [0.4, 0.5, 0.2, 0.3]\n\nmost_similar = find_most_similar(query_vector, data_matrix)\n\nprint(\"Index\\tSimilarity\")\nfor index, similarity in most_similar:\n    print(f\"{index}\\t{similarity:.4f}\")"}, {"role": "assistant", "content": "Index\tSimilarity\n7\t0.9606\n5\t0.9567\n8\t0.9526\n3\t0.9204\n4\t0.8856\n2\t0.8607\n9\t0.7912\n0\t0.7627\n6\t0.7441\n1\t0.6543\n"}]}
{"messages": [{"role": "user", "content": "from math import ceil\n\ndef char_value(c):\n    return ord(c) - ord('A') + 1\n\ndef encrypt_message(message):\n    return ''.join(chr(((char_value(c) * 2) % 26) + ord('A') - 1) for c in message)\n\ndef sort_encrypted_messages(messages):\n    return sorted(messages, key=encrypt_message)\n\ndef encode_message(message):\n    sorted_message = ''.join(sorted(message))\n    return encrypt_message(sorted_message)\n\nmessages = [\n    \"HELLO\",\n    \"WORLD\",\n    \"PYTHON\",\n    \"ADVANCED\",\n    \"ENCODING\",\n    \"ALGORITHM\",\n    \"EXAMPLE\",\n    \"SAMPLE\",\n    \"TESTING\",\n    \"CHALLENGE\"\n]\n\nencoded_messages = [encode_message(msg) for msg in messages]\nsorted_encoded_messages = sort_encrypted_messages(encoded_messages)\n\nfor encoded in sorted_encoded_messages:\n    print(encoded)"}, {"role": "assistant", "content": "BNPRX@DJN\nBBFHHJBR\nBFJJNPXXB\nBJJX@FV\nBJX@FL\nPBDFNX\nFHJNRBBD\nHXDJT\nJNRBLNN\nJPXXD\n"}]}
{"messages": [{"role": "user", "content": "from statistics import median\nimport datetime\n\ndata = [\n    (\"2023-01-01\", 10),\n    (\"2023-01-02\", 20),\n    (\"2023-01-03\", 30),\n    (\"2023-01-04\", 40),\n    (\"2023-01-05\", 50),\n    (\"2023-01-06\", 60),\n    (\"2023-01-07\", 70),\n    (\"2023-01-08\", 80),\n    (\"2023-01-09\", 90),\n    (\"2023-01-10\", 100),\n    (\"2023-01-11\", 110),\n    (\"2023-01-12\", 120),\n    (\"2023-01-13\", 130),\n    (\"2023-01-14\", 140),\n    (\"2023-01-15\", 150),\n    (\"2023-01-16\", 160),\n    (\"2023-01-17\", 170),\n    (\"2023-01-18\", 180),\n    (\"2023-01-19\", 190),\n    (\"2023-01-20\", 200),\n]\n\ndata_by_date = sorted(data, key=lambda x: datetime.datetime.strptime(x[0], \"%Y-%m-%d\"))\nvalues = [value for _, value in data_by_date]\n\nprint(\"Sorted Data:\")\nfor date, value in data_by_date:\n    print(f\"{date}: {value}\")\n\nsorted_values = sorted(values)\n\nprint(\"\\nSorted Values:\")\nprint(sorted_values)\n\nsorted_by_median_difference = sorted(data_by_date, key=lambda x: abs(x[1] - median(sorted_values)))\n\nprint(\"\\nData Sorted by Median Difference:\")\nfor date, value in sorted_by_median_difference:\n    print(f\"{date}: {value}\")"}, {"role": "assistant", "content": "Sorted Data:\n2023-01-01: 10\n2023-01-02: 20\n2023-01-03: 30\n2023-01-04: 40\n2023-01-05: 50\n2023-01-06: 60\n2023-01-07: 70\n2023-01-08: 80\n2023-01-09: 90\n2023-01-10: 100\n2023-01-11: 110\n2023-01-12: 120\n2023-01-13: 130\n2023-01-14: 140\n2023-01-15: 150\n2023-01-16: 160\n2023-01-17: 170\n2023-01-18: 180\n2023-01-19: 190\n2023-01-20: 200\n\nSorted Values:\n[10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200]\n\nData Sorted by Median Difference:\n2023-01-10: 100\n2023-01-11: 110\n2023-01-09: 90\n2023-01-12: 120\n2023-01-08: 80\n2023-01-13: 130\n2023-01-07: 70\n2023-01-14: 140\n2023-01-06: 60\n2023-01-15: 150\n2023-01-05: 50\n2023-01-16: 160\n2023-01-04: 40\n2023-01-17: 170\n2023-01-03: 30\n2023-01-18: 180\n2023-01-02: 20\n2023-01-19: 190\n2023-01-01: 10\n2023-01-20: 200\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef generate_pattern(n):\n    pattern = []\n    for i in range(n):\n        pattern.append(\"\".join([\"*\" if (j % 2 != 0) else \" \" for j in range(n)]))\n    return pattern\n\ndef search_pattern(pattern, target):\n    match = re.compile(target)\n    print(f\"Searching for pattern: '{target}'\")\n    for idx, line in enumerate(pattern):\n        if match.search(line):\n            print(f\"Pattern found at line {idx}: {line}\")\n\nn = 10\npattern = generate_pattern(n)\nfor line in pattern:\n    print(line)\n\ntarget_pattern = \".*\\*\\s\\*\\s\\*\\s.*\"\nsearch_pattern(pattern, target_pattern)"}, {"role": "assistant", "content": " * * * * *\n * * * * *\n * * * * *\n * * * * *\n * * * * *\n * * * * *\n * * * * *\n * * * * *\n * * * * *\n * * * * *\nSearching for pattern: '.*\\*\\s\\*\\s\\*\\s.*'\nPattern found at line 0:  * * * * *\nPattern found at line 1:  * * * * *\nPattern found at line 2:  * * * * *\nPattern found at line 3:  * * * * *\nPattern found at line 4:  * * * * *\nPattern found at line 5:  * * * * *\nPattern found at line 6:  * * * * *\nPattern found at line 7:  * * * * *\nPattern found at line 8:  * * * * *\nPattern found at line 9:  * * * * *\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef transform_email_addresses(email_list):\n    pattern = r'(?<=@)[\\w.-]+(?=\\.)'\n    \n    def extract_domain(email):\n        match = re.search(pattern, email)\n        return match.group(0) if match else None\n\n    def binary_search(sorted_list, target):\n        low, high = 0, len(sorted_list) - 1\n        while low <= high:\n            mid = (low + high) // 2\n            if sorted_list[mid] < target:\n                low = mid + 1\n            elif sorted_list[mid] > target:\n                high = mid - 1\n            else:\n                return mid\n        return -1\n\n    domains = [extract_domain(email) for email in email_list]\n    unique_domains = sorted(set(domains))\n    \n    transformed_emails = []\n    for email in email_list:\n        domain = extract_domain(email)\n        index = binary_search(unique_domains, domain)\n        transformed_email = f\"{email.split('@')[0]}@{index}.com\"\n        transformed_emails.append(transformed_email)\n    \n    return transformed_emails\n\nemails = [\n    \"alice@example.com\", \"bob@sample.com\", \"charlie@demo.com\",\n    \"dave@sample.com\", \"eve@example.com\", \"frank@demo.com\",\n    \"grace@sample.com\", \"heidi@example.com\", \"ivy@demo.com\",\n    \"jack@sample.com\", \"karen@demo.com\", \"leo@example.com\",\n    \"mallory@sample.com\", \"nina@demo.com\", \"oscar@example.com\",\n    \"peggy@sample.com\", \"quinn@demo.com\", \"rachel@example.com\",\n    \"steve@sample.com\", \"trudy@demo.com\"\n]\n\ntransformed = transform_email_addresses(emails)\nfor email in transformed:\n    print(email)"}, {"role": "assistant", "content": "alice@1.com\nbob@2.com\ncharlie@0.com\ndave@2.com\neve@1.com\nfrank@0.com\ngrace@2.com\nheidi@1.com\nivy@0.com\njack@2.com\nkaren@0.com\nleo@1.com\nmallory@2.com\nnina@0.com\noscar@1.com\npeggy@2.com\nquinn@0.com\nrachel@1.com\nsteve@2.com\ntrudy@0.com\n"}]}
{"messages": [{"role": "user", "content": "def insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and key < arr[j]:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr\n\ndata = [\n    {\"name\": \"apple\", \"value\": 5},\n    {\"name\": \"banana\", \"value\": 2},\n    {\"name\": \"cherry\", \"value\": 8},\n    {\"name\": \"date\", \"value\": 1},\n    {\"name\": \"elderberry\", \"value\": 3},\n    {\"name\": \"fig\", \"value\": 7},\n    {\"name\": \"grape\", \"value\": 4},\n    {\"name\": \"honeydew\", \"value\": 6},\n    {\"name\": \"kiwi\", \"value\": 10},\n    {\"name\": \"lime\", \"value\": 9}\n]\n\nvalues = [item['value'] for item in data]\n\nprint(\"Original values:\", values)\n\nsorted_values = insertion_sort(values)\n\nprint(\"Sorted values:\", sorted_values)\n\nsorted_data = []\nfor value in sorted_values:\n    for item in data:\n        if item['value'] == value:\n            sorted_data.append(item)\n            break\n\nprint(\"Sorted data:\")\nfor item in sorted_data:\n    print(item['name'].capitalize(), \"-\", item['value'])"}, {"role": "assistant", "content": "Original values: [5, 2, 8, 1, 3, 7, 4, 6, 10, 9]\nSorted values: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nSorted data:\nDate - 1\nBanana - 2\nElderberry - 3\nGrape - 4\nApple - 5\nHoneydew - 6\nFig - 7\nCherry - 8\nLime - 9\nKiwi - 10\n"}]}
{"messages": [{"role": "user", "content": "import math\nfrom statistics import mean, stdev\n\ndef z_score(value, mu, sigma):\n    return (value - mu) / sigma\n\ndef binary_search_z_score(sorted_data, target_z, mu, sigma, precision=1e-5):\n    low, high = 0, len(sorted_data) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        mid_value = sorted_data[mid]\n        mid_z = z_score(mid_value, mu, sigma)\n        if abs(mid_z - target_z) < precision:\n            return mid_value\n        elif mid_z < target_z:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return None\n\ndata = [15, 21, 13, 12, 14, 19, 20, 22, 11, 18, 17, 16, 23, 24, 10]\ndata.sort()\n\nmu = mean(data)\nsigma = stdev(data)\n\ntarget_z_scores = [-1.5, -1, -0.5, 0, 0.5, 1, 1.5, 2]\nresults = []\n\nfor target_z in target_z_scores:\n    result = binary_search_z_score(data, target_z, mu, sigma)\n    results.append((target_z, result))\n\nfor target_z, value in results:\n    print(f\"Z-score: {target_z:.1f}, Closest Value: {value}\")"}, {"role": "assistant", "content": "Z-score: -1.5, Closest Value: None\nZ-score: -1.0, Closest Value: None\nZ-score: -0.5, Closest Value: None\nZ-score: 0.0, Closest Value: 17\nZ-score: 0.5, Closest Value: None\nZ-score: 1.0, Closest Value: None\nZ-score: 1.5, Closest Value: None\nZ-score: 2.0, Closest Value: None\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef create_dates():\n    base_date = datetime(2023, 1, 1)\n    dates = [base_date + timedelta(days=i*23 % 365) for i in range(50)]\n    return dates\n\ndef sort_dates_by_weekday(dates):\n    return sorted(dates, key=lambda date: date.weekday())\n\ndef format_dates(dates):\n    return [date.strftime(\"%A, %B %d, %Y\") for date in dates]\n\ndates = create_dates()\nsorted_dates = sort_dates_by_weekday(dates)\nformatted_dates = format_dates(sorted_dates)\n\nfor date in formatted_dates:\n    print(date)"}, {"role": "assistant", "content": "Monday, April 03, 2023\nMonday, September 11, 2023\nMonday, May 22, 2023\nMonday, October 30, 2023\nMonday, January 30, 2023\nMonday, July 10, 2023\nMonday, December 18, 2023\nTuesday, January 24, 2023\nTuesday, July 04, 2023\nTuesday, December 12, 2023\nTuesday, March 14, 2023\nTuesday, August 22, 2023\nTuesday, May 02, 2023\nTuesday, October 10, 2023\nTuesday, January 10, 2023\nWednesday, April 26, 2023\nWednesday, October 04, 2023\nWednesday, January 04, 2023\nWednesday, June 14, 2023\nWednesday, November 22, 2023\nWednesday, February 22, 2023\nWednesday, August 02, 2023\nThursday, February 16, 2023\nThursday, July 27, 2023\nThursday, April 06, 2023\nThursday, September 14, 2023\nThursday, May 25, 2023\nThursday, November 02, 2023\nThursday, February 02, 2023\nFriday, May 19, 2023\nFriday, October 27, 2023\nFriday, January 27, 2023\nFriday, July 07, 2023\nFriday, December 15, 2023\nFriday, March 17, 2023\nFriday, August 25, 2023\nSaturday, March 11, 2023\nSaturday, August 19, 2023\nSaturday, April 29, 2023\nSaturday, October 07, 2023\nSaturday, January 07, 2023\nSaturday, June 17, 2023\nSaturday, November 25, 2023\nSunday, January 01, 2023\nSunday, June 11, 2023\nSunday, November 19, 2023\nSunday, February 19, 2023\nSunday, July 30, 2023\nSunday, April 09, 2023\nSunday, September 17, 2023\n"}]}
{"messages": [{"role": "user", "content": "def custom_sort(num):\n    return sum(int(digit) for digit in str(num))\n\nsequence = [\n    4321, 9876, 123, 456, 789, 1357, 2468, 3579, 4650, 5738,\n    6829, 7910, 8023, 9124, 1113, 1214, 1315, 1416, 1517, 1618,\n    1729, 1820, 1921, 2032, 2143, 2254, 2365, 2476, 2587, 2698,\n    2709, 2811, 2922, 3033, 3144, 3255, 3366, 3477, 3588, 3699,\n    3701, 4812, 5923, 6034, 7145, 8256, 9367, 1048, 2159, 3260\n]\n\nsorted_sequence = sorted(sequence, key=custom_sort)\nfor num in sorted_sequence:\n    print(num)"}, {"role": "assistant", "content": "123\n1113\n2032\n1214\n3033\n4321\n1315\n2143\n1820\n3701\n3260\n1416\n2811\n3144\n8023\n1921\n2254\n6034\n1048\n1517\n456\n4650\n2922\n3255\n4812\n1357\n9124\n1618\n2365\n7910\n7145\n2159\n2709\n3366\n1729\n2476\n5923\n2468\n3477\n8256\n2587\n5738\n789\n3579\n3588\n6829\n2698\n9367\n3699\n9876\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"In the beginning, there were no words. The world was silent. Gradually, words began to appear. \nSome were simple, others complex, but all had meaning. As words multiplied, sentences formed. \nThese sentences carried thoughts, ideas, and stories. The more words there were, the richer the stories became. \nAnd so, the world was filled with words.\"\"\"\n\npattern = r'\\b\\w+\\b'\nwords = re.findall(pattern, text)\n\nsearch_word = \"words\"\n\ndef binary_search_word_occurrences(words_list, target):\n    left, right = 0, len(words_list) - 1\n    occurrences = []\n    while left <= right:\n        mid = (left + right) // 2\n        print(f\"Checking position {mid}, word: '{words_list[mid]}'\")\n        if words_list[mid] == target:\n            occurrences.append(mid)\n            print(f\"Found at position {mid}, searching for more occurrences around it.\")\n            l, r = mid - 1, mid + 1\n            while l >= 0 and words_list[l] == target:\n                occurrences.append(l)\n                l -= 1\n            while r < len(words_list) and words_list[r] == target:\n                occurrences.append(r)\n                r += 1\n            break\n        elif words_list[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return sorted(occurrences)\n\nprint(f\"Searching for occurrences of the word '{search_word}'...\")\noccurrences = binary_search_word_occurrences(words, search_word)\nprint(f\"Occurrences of the word '{search_word}': {occurrences}\")\nprint(f\"Total occurrences: {len(occurrences)}\")"}, {"role": "assistant", "content": "Searching for occurrences of the word 'words'...\nChecking position 27, word: 'multiplied'\nChecking position 41, word: 'were'\nChecking position 48, word: 'so'\nChecking position 51, word: 'was'\nChecking position 53, word: 'with'\nChecking position 54, word: 'words'\nFound at position 54, searching for more occurrences around it.\nOccurrences of the word 'words': [54]\nTotal occurrences: 1\n"}]}
{"messages": [{"role": "user", "content": "import heapq\n\ndef is_valid_move(grid, visited, x, y):\n    return 0 <= x < len(grid) and 0 <= y < len(grid[0]) and not visited[x][y] and grid[x][y] != '#'\n\ndef find_path(grid):\n    start = None\n    goal = None\n    for i in range(len(grid)):\n        for j in range(len(grid[i])):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            elif grid[i][j] == 'E':\n                goal = (i, j)\n                \n    if not start or not goal:\n        return None\n\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    visited = [[False] * len(grid[0]) for _ in range(len(grid))]\n    pq = [(0, start)]\n    heapq.heapify(pq)\n    \n    while pq:\n        current_cost, current_pos = heapq.heappop(pq)\n        x, y = current_pos\n        \n        if visited[x][y]:\n            continue\n        \n        visited[x][y] = True\n        \n        if current_pos == goal:\n            return current_cost\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if is_valid_move(grid, visited, nx, ny):\n                next_cost = current_cost + 1\n                print(f\"Visiting: ({nx}, {ny}), Cost: {next_cost}\")\n                heapq.heappush(pq, (next_cost, (nx, ny)))\n                \n    return None\n\ngrid = [\n    ['S', '.', '.', '#', '.', '.', '.'],\n    ['.', '#', '.', '.', '#', '.', '.'],\n    ['.', '#', '.', '.', '.', '#', 'E'],\n    ['.', '.', '#', '#', '.', '.', '.'],\n    ['#', '.', '.', '.', '#', '.', '.'],\n]\n\nresult = find_path(grid)\nprint(f\"Minimum steps from 'S' to 'E': {result}\")"}, {"role": "assistant", "content": "Visiting: (1, 0), Cost: 1\nVisiting: (0, 1), Cost: 1\nVisiting: (0, 2), Cost: 2\nVisiting: (2, 0), Cost: 2\nVisiting: (1, 2), Cost: 3\nVisiting: (3, 0), Cost: 3\nVisiting: (2, 2), Cost: 4\nVisiting: (1, 3), Cost: 4\nVisiting: (3, 1), Cost: 4\nVisiting: (2, 3), Cost: 5\nVisiting: (2, 3), Cost: 5\nVisiting: (4, 1), Cost: 5\nVisiting: (2, 4), Cost: 6\nVisiting: (4, 2), Cost: 6\nVisiting: (3, 4), Cost: 7\nVisiting: (4, 3), Cost: 7\nVisiting: (3, 5), Cost: 8\nVisiting: (4, 5), Cost: 9\nVisiting: (3, 6), Cost: 9\nVisiting: (2, 6), Cost: 10\nVisiting: (4, 6), Cost: 10\nVisiting: (4, 6), Cost: 10\nMinimum steps from 'S' to 'E': 10\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndata = [\n    (2023, \"Alice\", 88),\n    (2021, \"Bob\", 95),\n    (2022, \"Charlie\", 75),\n    (2023, \"David\", 92),\n    (2021, \"Eve\", 85),\n    (2022, \"Frank\", 78),\n    (2023, \"Grace\", 95),\n    (2021, \"Hannah\", 80),\n    (2022, \"Ivy\", 88),\n    (2023, \"Jack\", 90),\n    (2021, \"Ken\", 92),\n    (2022, \"Laura\", 95),\n    (2023, \"Mallory\", 85),\n    (2021, \"Niaj\", 90),\n    (2022, \"Oscar\", 75)\n]\n\ndata.sort(key=lambda x: (x[0], -x[2]))\n\nyearly_averages = {}\nfor year, _, score in data:\n    if year not in yearly_averages:\n        yearly_averages[year] = []\n    yearly_averages[year].append(score)\n\nmedian_scores = {year: statistics.median(scores) for year, scores in yearly_averages.items()}\n\nsorted_medians = sorted(median_scores.items(), key=lambda x: -x[1])\n\nresult = []\nfor year, median in sorted_medians:\n    result.append(f\"Year {year}: Median Score = {median}\")\n\nfor line in result:\n    print(line)"}, {"role": "assistant", "content": "Year 2021: Median Score = 90\nYear 2023: Median Score = 90\nYear 2022: Median Score = 78\n"}]}
{"messages": [{"role": "user", "content": "def is_goal_state(state):\n    return state == end_state\n\ndef get_possible_moves(state):\n    moves = []\n    index = state.index(0)\n    if index % 3 > 0:  # Can move left\n        moves.append(swap(state, index, index - 1))\n    if index % 3 < 2:  # Can move right\n        moves.append(swap(state, index, index + 1))\n    if index // 3 > 0:  # Can move up\n        moves.append(swap(state, index, index - 3))\n    if index // 3 < 2:  # Can move down\n        moves.append(swap(state, index, index + 3))\n    return moves\n\ndef swap(state, i, j):\n    state = list(state)\n    state[i], state[j] = state[j], state[i]\n    return tuple(state)\n\ndef bfs(start_state):\n    queue = [(start_state, [])]\n    visited = set()\n    while queue:\n        state, path = queue.pop(0)\n        if state in visited:\n            continue\n        visited.add(state)\n        print(f\"Checking state: {state}\")\n        if is_goal_state(state):\n            return path\n        for move in get_possible_moves(state):\n            queue.append((move, path + [move]))\n    return None\n\nstart_state = (1, 2, 3, 4, 5, 6, 0, 7, 8)\nend_state = (1, 2, 3, 4, 5, 6, 7, 8, 0)\n\nsolution_path = bfs(start_state)\n\nif solution_path:\n    print(\"Solution found!\")\n    for step in solution_path:\n        print(step)\nelse:\n    print(\"No solution exists.\")"}, {"role": "assistant", "content": "Checking state: (1, 2, 3, 4, 5, 6, 0, 7, 8)\nChecking state: (1, 2, 3, 4, 5, 6, 7, 0, 8)\nChecking state: (1, 2, 3, 0, 5, 6, 4, 7, 8)\nChecking state: (1, 2, 3, 4, 5, 6, 7, 8, 0)\nSolution found!\n(1, 2, 3, 4, 5, 6, 7, 0, 8)\n(1, 2, 3, 4, 5, 6, 7, 8, 0)\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef calculate_area(vertices):\n    n = len(vertices)\n    area = 0.0\n    for i in range(n):\n        j = (i + 1) % n\n        area += vertices[i][0] * vertices[j][1]\n        area -= vertices[j][0] * vertices[i][1]\n    area = abs(area) / 2.0\n    return area\n\ndef sort_polygons_by_area(polygons):\n    return sorted(polygons, key=calculate_area)\n\npolygons = [\n    [(2, 1), (4, 5), (7, 8), (6, 3)],\n    [(1, 0), (5, 0), (5, 5), (1, 5)],\n    [(0, 0), (3, 0), (3, 2)],\n    [(0, 0), (6, 0), (3, 6)],\n    [(0, 0), (2, 2), (2, 0)]\n]\n\nsorted_polygons = sort_polygons_by_area(polygons)\n\nfor i, polygon in enumerate(sorted_polygons, start=1):\n    area = calculate_area(polygon)\n    print(f\"Polygon {i}: Vertices = {polygon}, Area = {area:.2f}\")"}, {"role": "assistant", "content": "Polygon 1: Vertices = [(0, 0), (2, 2), (2, 0)], Area = 2.00\nPolygon 2: Vertices = [(0, 0), (3, 0), (3, 2)], Area = 3.00\nPolygon 3: Vertices = [(2, 1), (4, 5), (7, 8), (6, 3)], Area = 12.00\nPolygon 4: Vertices = [(0, 0), (6, 0), (3, 6)], Area = 18.00\nPolygon 5: Vertices = [(1, 0), (5, 0), (5, 5), (1, 5)], Area = 20.00\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef encrypt_message(message):\n    words = re.findall(r'\\b\\w+\\b', message)\n    sorted_words = sorted(words, key=lambda w: (sorted(w), w))\n    return ' '.join(sorted_words)\n\ndef decrypt_message(encrypted_message):\n    words = encrypted_message.split()\n    sorted_words = sorted(words, key=lambda w: (sorted(w), w))\n    original_words = [words[sorted_words.index(w)] for w in words]\n    return ' '.join(original_words)\n\nmessage = \"encryption is a fascinating topic in computer science\"\nencrypted_message = encrypt_message(message)\ndecrypted_message = decrypt_message(encrypted_message)\n\nprint(\"Original Message:\")\nprint(message)\nprint(\"\\nEncrypted Message:\")\nprint(encrypted_message)\nprint(\"\\nDecrypted Message:\")\nprint(decrypted_message)"}, {"role": "assistant", "content": "Original Message:\nencryption is a fascinating topic in computer science\n\nEncrypted Message:\na fascinating science encryption computer topic in is\n\nDecrypted Message:\na fascinating science encryption computer topic in is\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"In the land of Pythonia, there were many coders. Some were beginners, and some were experts.\nThe beginners often sought the wisdom of the experts. There were challenges and puzzles, each more\nintricate than the last. However, one particular challenge stood out, it was called the 'Sortathon'.\nThe Sortathon was an annual event where coders gathered to demonstrate their sorting prowess.\nThe challenge was to sort words based on a secret criterion that changed each year. Last year, the\ncriterion was to sort the words based on the number of vowels in descending order. This year, it was\nrevealed that the criterion was to sort the words based on the alternating sequence of consonants and\nvowels, giving priority to words starting with vowels.\"\"\"\n\ndef sort_by_alternating_consonant_vowel(word):\n    vowels = \"aeiou\"\n    max_alt = 0\n    current_alt = 0\n    last_was_vowel = None\n    for char in word:\n        if char.lower() in vowels:\n            if last_was_vowel is False:\n                current_alt += 1\n            last_was_vowel = True\n        else:\n            if last_was_vowel is True:\n                current_alt += 1\n            last_was_vowel = False\n    max_alt = max(max_alt, current_alt)\n    return -max_alt, word.lower()[0] not in vowels, word.lower()\n\nwords = re.findall(r'\\b\\w+\\b', text)\nsorted_words = sorted(words, key=sort_by_alternating_consonant_vowel)\n\nfor word in sorted_words:\n    print(word)"}, {"role": "assistant", "content": "particular\nalternating\ndemonstrate\nintricate\nbeginners\nbeginners\nchallenges\nconsonants\ncriterion\ncriterion\ncriterion\ndescending\ngathered\nHowever\nrevealed\nSortathon\nSortathon\nchallenge\nchallenge\nsequence\nbased\nbased\nbased\ncalled\nchanged\ncoders\ncoders\ngiving\nnumber\npriority\nprowess\npuzzles\nsecret\nsorting\nstarting\nvowels\nvowels\nvowels\nwisdom\nannual\nevent\nexperts\nexperts\noften\norder\nmore\nPythonia\nSome\nsome\nthere\nThere\nwere\nwere\nwere\nwere\nwhere\none\nland\nlast\nLast\nmany\nsort\nsort\nsort\nsought\nstood\nthan\nthat\nthat\ntheir\nThis\nwas\nwas\nwas\nwas\nwas\nwas\nwith\nwords\nwords\nwords\nwords\nyear\nyear\nyear\nan\nand\nand\nand\neach\neach\nIn\nin\nit\nit\nof\nof\nof\nof\non\non\non\nout\nthe\nThe\nthe\nthe\nthe\nthe\nThe\nThe\nthe\nthe\nthe\nthe\nthe\nthe\nto\nto\nto\nto\nto\na\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef search_date_in_sequence(start_date, target_date, sequence):\n    def binary_search(seq, target):\n        low, high = 0, len(seq) - 1\n        while low <= high:\n            mid = (low + high) // 2\n            if seq[mid] < target:\n                low = mid + 1\n            elif seq[mid] > target:\n                high = mid - 1\n            else:\n                return mid\n        return -1\n\n    date_list = [start_date + timedelta(days=i) for i in range(sequence)]\n    target_index = binary_search(date_list, target_date)\n    return target_index\n\nstart = datetime(2023, 1, 1)\ntarget_dates = [datetime(2023, i, 15) for i in range(1, 13)]\nsequence_length = 365\n\nresults = []\nfor target in target_dates:\n    index = search_date_in_sequence(start, target, sequence_length)\n    results.append((target.strftime('%Y-%m-%d'), index))\n\nfor result in results:\n    print(f\"Date: {result[0]}, Index: {result[1]}\")"}, {"role": "assistant", "content": "Date: 2023-01-15, Index: 14\nDate: 2023-02-15, Index: 45\nDate: 2023-03-15, Index: 73\nDate: 2023-04-15, Index: 104\nDate: 2023-05-15, Index: 134\nDate: 2023-06-15, Index: 165\nDate: 2023-07-15, Index: 195\nDate: 2023-08-15, Index: 226\nDate: 2023-09-15, Index: 257\nDate: 2023-10-15, Index: 287\nDate: 2023-11-15, Index: 318\nDate: 2023-12-15, Index: 348\n"}]}
{"messages": [{"role": "user", "content": "def minimax(board, depth, is_maximizing):\n    winner = check_winner(board)\n    if winner is not None:\n        return winner\n    if is_maximizing:\n        best_score = float('-inf')\n        for i in range(3):\n            for j in range(3):\n                if board[i][j] == ' ':\n                    board[i][j] = 'X'\n                    score = minimax(board, depth + 1, False)\n                    board[i][j] = ' '\n                    best_score = max(score, best_score)\n        return best_score\n    else:\n        best_score = float('inf')\n        for i in range(3):\n            for j in range(3):\n                if board[i][j] == ' ':\n                    board[i][j] = 'O'\n                    score = minimax(board, depth + 1, True)\n                    board[i][j] = ' '\n                    best_score = min(score, best_score)\n        return best_score\n\ndef check_winner(board):\n    for row in board:\n        if row[0] == row[1] == row[2] and row[0] != ' ':\n            return 1 if row[0] == 'X' else -1\n    for col in range(3):\n        if board[0][col] == board[1][col] == board[2][col] and board[0][col] != ' ':\n            return 1 if board[0][col] == 'X' else -1\n    if board[0][0] == board[1][1] == board[2][2] and board[0][0] != ' ':\n        return 1 if board[0][0] == 'X' else -1\n    if board[0][2] == board[1][1] == board[2][0] and board[0][2] != ' ':\n        return 1 if board[0][2] == 'X' else -1\n    if all(board[i][j] != ' ' for i in range(3) for j in range(3)):\n        return 0\n    return None\n\ndef best_move(board):\n    best_score = float('-inf')\n    move = (-1, -1)\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == ' ':\n                board[i][j] = 'X'\n                score = minimax(board, 0, False)\n                board[i][j] = ' '\n                if score > best_score:\n                    best_score = score\n                    move = (i, j)\n    return move\n\ndef play_game():\n    board = [[' ' for _ in range(3)] for _ in range(3)]\n    current_turn = 'X'\n    for _ in range(9):\n        if current_turn == 'X':\n            i, j = best_move(board)\n        else:\n            empty_cells = [(i, j) for i in range(3) for j in range(3) if board[i][j] == ' ']\n            i, j = empty_cells[0]\n        board[i][j] = current_turn\n        current_turn = 'O' if current_turn == 'X' else 'X'\n        if check_winner(board) is not None:\n            break\n    return board\n\nfor row in play_game():\n    print(' '.join(row))"}, {"role": "assistant", "content": "X O O\nX X O\nX    \n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef custom_search(data, target):\n    left, right = 0, len(data) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        mid_val = data[mid]\n        if mid_val == target:\n            return mid\n        elif mid_val < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef analyze_data(dataset, search_value):\n    sqrt_values = [math.sqrt(x) for x in dataset]\n    sqrt_mean = sum(sqrt_values) / len(sqrt_values)\n    scaled_values = [x * sqrt_mean for x in dataset]\n    return custom_search(scaled_values, search_value)\n\ndata = [i**2 for i in range(1, 50)]\nsearch_val = 25\nresult_index = analyze_data(data, search_val)\n\nfor idx in range(len(data)):\n    if idx == result_index:\n        print(f\"[{data[idx]}] \", end=\"\")\n    else:\n        print(f\"{data[idx]} \", end=\"\")"}, {"role": "assistant", "content": "[1] 4 9 16 25 36 49 64 81 100 121 144 169 196 225 256 289 324 361 400 441 484 529 576 625 676 729 784 841 900 961 1024 1089 1156 1225 1296 1369 1444 1521 1600 1681 1764 1849 1936 2025 2116 2209 2304 2401 "}]}
{"messages": [{"role": "user", "content": "from itertools import permutations\n\ndef calculate_score(sequence):\n    score = 0\n    for i in range(len(sequence) - 1):\n        score += abs(sequence[i] - sequence[i + 1])\n    return score\n\ndef find_best_move(scores):\n    max_score = max(scores)\n    return [i for i, score in enumerate(scores) if score == max_score]\n\nplayers = ['Knight', 'Archer', 'Mage', 'Rogue']\ninitial_positions = [3, 7, 2, 5]\n\npossible_moves = list(permutations(initial_positions))\nscores = [calculate_score(move) for move in possible_moves]\n\nbest_moves_indices = find_best_move(scores)\n\nfor index in best_moves_indices:\n    best_sequence = possible_moves[index]\n    print(f\"Optimal sequence: {best_sequence}, Score: {scores[index]}\")"}, {"role": "assistant", "content": "Optimal sequence: (3, 7, 2, 5), Score: 12\nOptimal sequence: (5, 2, 7, 3), Score: 12\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef calculate_variance(data):\n    mean = sum(data) / len(data)\n    variance = sum((x - mean) ** 2 for x in data) / len(data)\n    return variance\n\ndef binary_search_for_variance(data, threshold):\n    low, high = 0, max(data)\n    debug_count = 0\n    while low <= high:\n        debug_count += 1\n        mid = (low + high) / 2\n        filtered_data = [x for x in data if x <= mid]\n        if not filtered_data:\n            print(f\"Debug {debug_count}: No data points less than or equal to {mid}\")\n            break\n        \n        calculated_variance = calculate_variance(filtered_data)\n        print(f\"Debug {debug_count}: Midpoint: {mid}, Filtered Data: {filtered_data}, Variance: {calculated_variance}\")\n        \n        if calculated_variance < threshold:\n            high = mid - 1\n        else:\n            low = mid + 1\n    print(f\"Final Midpoint: {mid}, Final Variance: {calculated_variance}\")\n    return mid\n\ndata = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]\nthreshold_variance = 200\n\nresult = binary_search_for_variance(data, threshold_variance)\nprint(f\"Resulting threshold value: {result}\")"}, {"role": "assistant", "content": "Debug 1: Midpoint: 50.0, Filtered Data: [10, 20, 30, 40, 50], Variance: 200.0\nDebug 2: Midpoint: 75.5, Filtered Data: [10, 20, 30, 40, 50, 60, 70], Variance: 400.0\nDebug 3: Midpoint: 88.25, Filtered Data: [10, 20, 30, 40, 50, 60, 70, 80], Variance: 525.0\nDebug 4: Midpoint: 94.625, Filtered Data: [10, 20, 30, 40, 50, 60, 70, 80, 90], Variance: 666.6666666666666\nDebug 5: Midpoint: 97.8125, Filtered Data: [10, 20, 30, 40, 50, 60, 70, 80, 90], Variance: 666.6666666666666\nDebug 6: Midpoint: 99.40625, Filtered Data: [10, 20, 30, 40, 50, 60, 70, 80, 90], Variance: 666.6666666666666\nFinal Midpoint: 99.40625, Final Variance: 666.6666666666666\nResulting threshold value: 99.40625\n"}]}
{"messages": [{"role": "user", "content": "import math\nimport statistics\n\ndef custom_sort(data):\n    return sorted(data, key=lambda x: (x[1], -x[0]))\n\ndef calculate_mode(data):\n    freq = {}\n    for num in data:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    max_freq = max(freq.values())\n    modes = [k for k, v in freq.items() if v == max_freq]\n    return modes\n\ndef standard_deviation_sorted(data):\n    mean = statistics.mean(data)\n    return sorted(data, key=lambda x: abs(x - mean))\n\ndef statistics_analysis(data):\n    sorted_data = custom_sort(data)\n    flattened_data = [x for sublist in sorted_data for x in sublist]\n    mode = calculate_mode(flattened_data)\n    sorted_by_deviation = standard_deviation_sorted(flattened_data)\n    return mode, sorted_by_deviation\n\ndata_pairs = [(5, 2), (3, 2), (5, 3), (6, 1), (3, 3), (9, 1), (10, 2), (1, 3)]\nmode, sorted_deviation = statistics_analysis(data_pairs)\n\nprint(\"Mode of the data:\", mode)\nprint(\"Data sorted by deviation from mean:\")\nfor number in sorted_deviation:\n    print(number)"}, {"role": "assistant", "content": "Mode of the data: [3]\nData sorted by deviation from mean:\n3\n3\n3\n3\n3\n5\n5\n2\n2\n2\n6\n1\n1\n1\n9\n10\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef generate_pattern(n):\n    pattern = []\n    for i in range(n):\n        line = ' '.join(['*' if j % 2 == 0 else '-' for j in range(i + 1)])\n        pattern.append(line)\n    return pattern\n\ndef search_pattern(pattern, search_term):\n    for index, line in enumerate(pattern):\n        if re.search(search_term, line):\n            return index\n    return -1\n\ndef main():\n    n = 10\n    pattern = generate_pattern(n)\n    for line in pattern:\n        print(line)\n\n    search_term = '--'\n    result = search_pattern(pattern, search_term)\n    if result != -1:\n        print(f\"Pattern '{search_term}' found at line {result}.\")\n    else:\n        print(f\"Pattern '{search_term}' not found.\")\n\nmain()"}, {"role": "assistant", "content": "*\n* -\n* - *\n* - * -\n* - * - *\n* - * - * -\n* - * - * - *\n* - * - * - * -\n* - * - * - * - *\n* - * - * - * - * -\nPattern '--' not found.\n"}]}
{"messages": [{"role": "user", "content": "data = [\n    \"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\", \"fig\", \n    \"grape\", \"honeydew\", \"kiwi\", \"lemon\", \"mango\", \"nectarine\"\n]\n\ndef custom_sort_key(word):\n    return (len(word), word)\n\nprint(\"Original data:\")\nfor item in data:\n    print(item)\n\nprint(\"\\nSorting by length and alphabetically:\")\nsorted_data = sorted(data, key=custom_sort_key)\nfor item in sorted_data:\n    print(item)\n\nprint(\"\\nGenerating pattern:\")\n\npattern = []\nfor item in sorted_data:\n    length = len(item)\n    pattern.append(\"*\" * length)\n\nfor line in pattern:\n    print(line)\n\nprint(\"\\nSorting pattern by pattern length and reverse alphabetically of the word:\")\nsorted_pattern = sorted(zip(pattern, sorted_data), key=lambda x: (len(x[0]), x[1]), reverse=True)\nfor stars, word in sorted_pattern:\n    print(f\"{stars} - {word}\")\n\nprint(\"\\nFinal pattern:\")\nfor stars, _ in sorted_pattern:\n    print(stars)"}, {"role": "assistant", "content": "Original data:\napple\nbanana\ncherry\ndate\nelderberry\nfig\ngrape\nhoneydew\nkiwi\nlemon\nmango\nnectarine\n\nSorting by length and alphabetically:\nfig\ndate\nkiwi\napple\ngrape\nlemon\nmango\nbanana\ncherry\nhoneydew\nnectarine\nelderberry\n\nGenerating pattern:\n***\n****\n****\n*****\n*****\n*****\n*****\n******\n******\n********\n*********\n**********\n\nSorting pattern by pattern length and reverse alphabetically of the word:\n********** - elderberry\n********* - nectarine\n******** - honeydew\n****** - cherry\n****** - banana\n***** - mango\n***** - lemon\n***** - grape\n***** - apple\n**** - kiwi\n**** - date\n*** - fig\n\nFinal pattern:\n**********\n*********\n********\n******\n******\n*****\n*****\n*****\n*****\n****\n****\n***\n"}]}
{"messages": [{"role": "user", "content": "import re\nfrom collections import deque\n\ndef find_palindromic_substrings(text):\n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    palindromes = set()\n    queue = deque([(i, j) for i in range(len(text)) for j in range(i, len(text))])\n    \n    while queue:\n        start, end = queue.popleft()\n        substring = text[start:end + 1]\n        if is_palindrome(substring):\n            palindromes.add(substring)\n    \n    return sorted(palindromes, key=len, reverse=True)\n\ntext = \"Madam Arora teaches malayalam\"\ncleaned_text = re.sub(r'[^A-Za-z]', '', text).lower()\npalindromic_substrings = find_palindromic_substrings(cleaned_text)\n\nfor idx, palindrome in enumerate(palindromic_substrings, 1):\n    print(f\"{idx}: {palindrome}\")"}, {"role": "assistant", "content": "1: malayalam\n2: alayala\n3: arora\n4: madam\n5: layal\n6: ror\n7: ama\n8: aya\n9: ada\n10: ala\n11: m\n12: c\n13: h\n14: o\n15: s\n16: y\n17: d\n18: l\n19: a\n20: t\n21: e\n22: r\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef transform_data(data):\n    transformed = []\n    for item in data:\n        if not isinstance(item, str):\n            transformed.append(item)\n        else:\n            numbers = re.findall(r'\\d+', item)\n            if numbers:\n                transformed.append(sum(map(int, numbers)))\n            else:\n                transformed.append(item)\n    return transformed\n\ndef search_and_transform(data):\n    transformed_data = transform_data(data)\n    results = []\n    \n    def binary_search(arr, x):\n        l, r = 0, len(arr) - 1\n        while l <= r:\n            mid = l + (r - l) // 2\n            if arr[mid] == x:\n                return mid\n            elif arr[mid] < x:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return -1\n\n    sorted_data = sorted(transformed_data)\n    for item in transformed_data:\n        if isinstance(item, int):\n            index = binary_search(sorted_data, item)\n            if index != -1:\n                results.append((item, index))\n            else:\n                results.append((item, None))\n        else:\n            results.append((item, None))\n    \n    return results\n\ndata = ['abc123', 'def456', 789, 'ghi789', 101, 'jkl']\noutput = search_and_transform(data)\nfor line in output:\n    print(line)"}, {"role": "assistant", "content": "Traceback (most recent call last):\n  File \"<string>\", line 46, in <module>\n  File \"<string>\", line 32, in search_and_transform\nTypeError: '<' not supported between instances of 'str' and 'int'\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef is_fibonacci_number(n):\n    if n < 0:\n        return False\n    x1 = 5 * n * n + 4\n    x2 = 5 * n * n - 4\n    return math.isqrt(x1) ** 2 == x1 or math.isqrt(x2) ** 2 == x2\n\ndef find_fib_like_sequence(n, sequence_length):\n    sequence = []\n    for i in range(n, n + 1000):  # Look ahead 1000 numbers\n        if is_fibonacci_number(i):\n            sequence.append(i)\n        if len(sequence) == sequence_length:\n            break\n    return sequence\n\ndef main():\n    start_number = 100\n    sequence_length = 10\n    sequence = find_fib_like_sequence(start_number, sequence_length)\n    for num in sequence:\n        print(num)\n\nmain()"}, {"role": "assistant", "content": "144\n233\n377\n610\n987\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef custom_key(n):\n    return (sum(int(d) for d in str(n)), -n)\n\ndef generate_sequence(n):\n    sequence = [i ** 2 + 3 * i + 1 for i in range(n)]\n    return sequence\n\ndef main():\n    sequence = generate_sequence(50)\n    sorted_sequence = sorted(sequence, key=custom_key)\n    for number in sorted_sequence:\n        print(number)\n\nif __name__ == \"__main__\":\n    main()"}, {"role": "assistant", "content": "1\n11\n1121\n131\n41\n5\n1331\n701\n341\n305\n71\n2161\n1405\n811\n505\n271\n181\n109\n55\n19\n2351\n1721\n1055\n551\n461\n209\n155\n29\n2255\n1805\n1481\n419\n239\n2069\n1259\n755\n89\n2449\n1891\n1639\n1189\n991\n649\n379\n2549\n1559\n929\n869\n599\n1979\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef distance(point1, point2):\n    return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2)\n\ndef perimeter(polygon):\n    peri = 0\n    for i in range(len(polygon)):\n        peri += distance(polygon[i], polygon[(i + 1) % len(polygon)])\n    return peri\n\ndef sort_by_perimeter(polygons):\n    return sorted(polygons, key=perimeter)\n\npolygons = [\n    [(0, 0), (4, 0), (4, 3)],\n    [(0, 0), (1, 0), (1, 1), (0, 1)],\n    [(0, 0), (2, 0), (2, 2), (0, 2)],\n    [(0, 0), (3, 0), (3, 5)],\n    [(0, 0), (5, 0), (5, 5), (0, 5)],\n    [(0, 0), (1, 0), (0.5, math.sqrt(3) / 2)],\n]\n\nsorted_polygons = sort_by_perimeter(polygons)\n\nfor i, polygon in enumerate(sorted_polygons, start=1):\n    print(f\"Polygon {i}: Perimeter = {perimeter(polygon):.2f}\")"}, {"role": "assistant", "content": "Polygon 1: Perimeter = 3.00\nPolygon 2: Perimeter = 4.00\nPolygon 3: Perimeter = 8.00\nPolygon 4: Perimeter = 12.00\nPolygon 5: Perimeter = 13.83\nPolygon 6: Perimeter = 20.00\n"}]}
{"messages": [{"role": "user", "content": "def sort_words_by_length_desc(words):\n    return sorted(words, key=len)\n\ntext = \"\"\"\nSorting algorithms are interesting to study because they provide a great way\nto understand algorithmic thinking. Text processing, particularly sorting text\nbased on certain criteria, is a common task in computer science. Let's explore\nan example where we sort words by their length in descending order.\n\"\"\"\n\nwords = text.split()\nsorted_words = sort_words_by_length_desc(words)\n\nfor word in sorted_words:\n    print(word)"}, {"role": "assistant", "content": "a\na\nto\nto\non\nis\nin\nan\nwe\nby\nin\nare\nway\nthey\nText\ntext\ntask\nsort\nstudy\ngreat\nbased\nLet's\nwhere\nwords\ntheir\ncommon\nlength\norder.\nSorting\nbecause\nprovide\nsorting\ncertain\nexplore\nexample\ncomputer\nscience.\nthinking.\ncriteria,\nalgorithms\nunderstand\ndescending\ninteresting\nalgorithmic\nprocessing,\nparticularly\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef sort_by_age(birthdays):\n    today = datetime.date.today()\n    ages = [(today - datetime.datetime.strptime(birth, '%Y-%m-%d').date()).days for birth in birthdays]\n    sorted_birthdays = sorted(zip(ages, birthdays))\n    return [birth for age, birth in sorted_birthdays]\n\ndef transform_dates(birthdays):\n    sorted_birthdays = sort_by_age(birthdays)\n    return [datetime.datetime.strptime(birth, '%Y-%m-%d').strftime('%B %d, %Y') for birth in sorted_birthdays]\n\nbirthdays = [\n    \"1995-06-01\", \"2003-12-15\", \"1988-02-25\", \"1975-11-30\",\n    \"1999-08-09\", \"2001-01-01\", \"1990-05-20\", \"1985-03-30\",\n    \"1970-07-14\", \"2005-09-21\", \"1982-11-11\", \"1997-04-03\",\n    \"1992-10-10\", \"1980-12-12\", \"1996-07-23\", \"2007-03-15\",\n    \"1994-09-18\", \"1989-06-05\", \"1978-08-19\", \"2002-02-28\"\n]\n\ntransformed_dates = transform_dates(birthdays)\nfor date in transformed_dates:\n    print(date)"}, {"role": "assistant", "content": "March 15, 2007\nSeptember 21, 2005\nDecember 15, 2003\nFebruary 28, 2002\nJanuary 01, 2001\nAugust 09, 1999\nApril 03, 1997\nJuly 23, 1996\nJune 01, 1995\nSeptember 18, 1994\nOctober 10, 1992\nMay 20, 1990\nJune 05, 1989\nFebruary 25, 1988\nMarch 30, 1985\nNovember 11, 1982\nDecember 12, 1980\nAugust 19, 1978\nNovember 30, 1975\nJuly 14, 1970\n"}]}
{"messages": [{"role": "user", "content": "def compute_leaderboard(players):\n    players.sort(key=lambda x: (-x['score'], x['name']))\n    return players\n\ndef display_leaderboard(leaderboard):\n    for rank, player in enumerate(leaderboard, start=1):\n        print(f\"{rank}. {player['name']} - {player['score']} points\")\n\nplayers = [\n    {'name': 'Alice', 'score': 150},\n    {'name': 'Bob', 'score': 200},\n    {'name': 'Charlie', 'score': 180},\n    {'name': 'Diana', 'score': 200},\n    {'name': 'Eve', 'score': 150},\n    {'name': 'Fred', 'score': 190},\n    {'name': 'Grace', 'score': 170},\n    {'name': 'Heidi', 'score': 180},\n    {'name': 'Ivan', 'score': 200},\n    {'name': 'Judy', 'score': 160},\n]\n\nleaderboard = compute_leaderboard(players)\ndisplay_leaderboard(leaderboard)"}, {"role": "assistant", "content": "1. Bob - 200 points\n2. Diana - 200 points\n3. Ivan - 200 points\n4. Fred - 190 points\n5. Charlie - 180 points\n6. Heidi - 180 points\n7. Grace - 170 points\n8. Judy - 160 points\n9. Alice - 150 points\n10. Eve - 150 points\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\nclass Transaction:\n    def __init__(self, date, amount):\n        self.date = date\n        self.amount = amount\n\ndef parse_date(date_str):\n    return datetime.strptime(date_str, \"%Y-%m-%d\")\n\ndef generate_transactions():\n    dates = [\"2023-01-15\", \"2023-02-10\", \"2023-01-20\", \"2023-02-05\",\n             \"2023-01-01\", \"2023-01-28\", \"2023-02-01\", \"2023-01-18\"]\n    amounts = [150.5, 200.0, 170.25, 180.75, 160.0, 190.5, 210.0, 175.0]\n    return [Transaction(parse_date(d), a) for d, a in zip(dates, amounts)]\n\ndef sort_transactions(transactions):\n    return sorted(transactions, key=lambda x: (x.date, -x.amount))\n\ndef analyze_transactions(transactions):\n    start_date = min(t.date for t in transactions)\n    end_date = max(t.date for t in transactions)\n    current_date = start_date\n    window = timedelta(days=10)\n    results = []\n    while current_date <= end_date:\n        window_end = current_date + window\n        window_transactions = [t for t in transactions if current_date <= t.date < window_end]\n        total_amount = sum(t.amount for t in window_transactions)\n        results.append((current_date.strftime(\"%Y-%m-%d\"), total_amount))\n        current_date = window_end\n    return results\n\ntransactions = generate_transactions()\nsorted_transactions = sort_transactions(transactions)\nanalysis = analyze_transactions(sorted_transactions)\nfor date, total in analysis:\n    print(f\"Period starting {date}: Total Amount = {total:.2f}\")"}, {"role": "assistant", "content": "Period starting 2023-01-01: Total Amount = 160.00\nPeriod starting 2023-01-11: Total Amount = 495.75\nPeriod starting 2023-01-21: Total Amount = 190.50\nPeriod starting 2023-01-31: Total Amount = 390.75\nPeriod starting 2023-02-10: Total Amount = 200.00\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndata = [35, 12, 43, 8, 51, 24, 49, 17, 30, 41, 23, 19, 7, 56, 32, 28, 39, 25, 13, 46]\n\ndef find_threshold_exceeders(values, threshold):\n    exceeders = []\n    for value in values:\n        if value > threshold:\n            exceeders.append(value)\n    return exceeders\n\ndef binary_search(sorted_data, target):\n    left, right = 0, len(sorted_data) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        print(f\"Searching: left={left}, right={right}, mid={mid}, mid_value={sorted_data[mid]}\")\n        if sorted_data[mid] == target:\n            return mid\n        elif sorted_data[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\nthreshold = 20\nexceeders = find_threshold_exceeders(data, threshold)\nprint(\"Initial Data:\", data)\nprint(\"Exceeders of threshold:\", exceeders)\n\nsorted_exceeders = sorted(exceeders)\nprint(\"Sorted Exceeders:\", sorted_exceeders)\n\nsearch_target = 39\nprint(f\"Searching for {search_target} in sorted exceeders.\")\nindex = binary_search(sorted_exceeders, search_target)\n\nif index != -1:\n    print(f\"Value {search_target} found at index {index}.\")\nelse:\n    print(f\"Value {search_target} not found in sorted exceeders.\")"}, {"role": "assistant", "content": "Initial Data: [35, 12, 43, 8, 51, 24, 49, 17, 30, 41, 23, 19, 7, 56, 32, 28, 39, 25, 13, 46]\nExceeders of threshold: [35, 43, 51, 24, 49, 30, 41, 23, 56, 32, 28, 39, 25, 46]\nSorted Exceeders: [23, 24, 25, 28, 30, 32, 35, 39, 41, 43, 46, 49, 51, 56]\nSearching for 39 in sorted exceeders.\nSearching: left=0, right=13, mid=6, mid_value=35\nSearching: left=7, right=13, mid=10, mid_value=46\nSearching: left=7, right=9, mid=8, mid_value=41\nSearching: left=7, right=7, mid=7, mid_value=39\nValue 39 found at index 7.\n"}]}
{"messages": [{"role": "user", "content": "from datetime import date, timedelta\n\ndef find_next_friday_13th(start_date, count):\n    friday_13ths = []\n    current_date = start_date\n    while len(friday_13ths) < count:\n        if current_date.day == 13 and current_date.weekday() == 4:\n            friday_13ths.append(current_date)\n        current_date += timedelta(days=1)\n    return friday_13ths\n\nstart_date = date.today()\nfriday_13ths = find_next_friday_13th(start_date, 10)\n\nfor friday in friday_13ths:\n    print(friday.strftime('%Y-%m-%d'))"}, {"role": "assistant", "content": "2025-06-13\n2026-02-13\n2026-03-13\n2026-11-13\n2027-08-13\n2028-10-13\n2029-04-13\n2029-07-13\n2030-09-13\n2030-12-13\n"}]}
{"messages": [{"role": "user", "content": "from itertools import permutations\n\ndef encode_string(s, key):\n    return ''.join(chr((ord(char) - 32 + key) % 95 + 32) for char in s)\n\ndef decode_string(s, key):\n    return ''.join(chr((ord(char) - 32 - key) % 95 + 32) for char in s)\n\ndef find_key(encoded, original):\n    for key in range(95):\n        if decode_string(encoded, key) == original:\n            return key\n    return None\n\ndef generate_all_permutations(s):\n    return [''.join(p) for p in permutations(s)]\n\ndef search_encoded_permutations(encoded, key):\n    decoded = decode_string(encoded, key)\n    perms = generate_all_permutations(decoded)\n    return [encode_string(p, key) for p in perms]\n\noriginal_string = \"abc\"\nkey = 5\nencoded_string = encode_string(original_string, key)\n\nfound_key = find_key(encoded_string, original_string)\n\nif found_key is not None:\n    all_permutations_encoded = search_encoded_permutations(encoded_string, found_key)\n    for encoded_perm in all_permutations_encoded:\n        print(encoded_perm)"}, {"role": "assistant", "content": "fgh\nfhg\ngfh\nghf\nhfg\nhgf\n"}]}
{"messages": [{"role": "user", "content": "from math import sqrt\n\ndef encode_message(message, key):\n    key_length = len(key)\n    sorted_key_indices = sorted(range(key_length), key=lambda k: key[k])\n    padded_message = message + ' ' * ((key_length - len(message) % key_length) % key_length)\n    num_rows = len(padded_message) // key_length\n    grid = [padded_message[i*key_length:(i+1)*key_length] for i in range(num_rows)]\n    encrypted_message = ''.join(''.join(grid[row][i] for row in range(num_rows)) for i in sorted_key_indices)\n    return encrypted_message\n\ndef decrypt_message(encrypted_message, key):\n    key_length = len(key)\n    sorted_key_indices = sorted(range(key_length), key=lambda k: key[k])\n    num_rows = len(encrypted_message) // key_length\n    columns = [''] * key_length\n    start = 0\n    for i in sorted_key_indices:\n        columns[i] = encrypted_message[start:start+num_rows]\n        start += num_rows\n    decrypted_message = ''.join(''.join(columns[i][row] for i in range(key_length)) for row in range(num_rows))\n    return decrypted_message.strip()\n\nmessage = \"The quick brown fox jumps over the lazy dog\"\nkey = \"encryption\"\nencoded = encode_message(message, key)\ndecoded = decrypt_message(encoded, key)\n\nprint(\"Encoded Message:\")\nfor i in range(0, len(encoded), 10):\n    print(encoded[i:i+10])\n\nprint(\"\\nDecoded Message:\")\nprint(decoded)"}, {"role": "assistant", "content": "Encoded Message:\neomhgTbj d\ncovz hruto\n  r  kxey \nu  l  wpe \nifoa qns  \n\nDecoded Message:\nThe quick brown fox jumps over the lazy dog\n"}]}
{"messages": [{"role": "user", "content": "def is_safe(board, row, col, num):\n    for x in range(9):\n        if board[row][x] == num or board[x][col] == num:\n            return False\n    start_row, start_col = 3 * (row // 3), 3 * (col // 3)\n    for i in range(3):\n        for j in range(3):\n            if board[i + start_row][j + start_col] == num:\n                return False\n    return True\n\ndef solve_sudoku(board):\n    empty = find_empty_location(board)\n    if not empty:\n        return True\n    row, col = empty\n    for num in range(1, 10):\n        if is_safe(board, row, col, num):\n            board[row][col] = num\n            if solve_sudoku(board):\n                return True\n            board[row][col] = 0\n    return False\n\ndef find_empty_location(board):\n    for i in range(9):\n        for j in range(9):\n            if board[i][j] == 0:\n                return (i, j)\n    return None\n\nsudoku_board = [\n    [5, 3, 0, 0, 7, 0, 0, 0, 0],\n    [6, 0, 0, 1, 9, 5, 0, 0, 0],\n    [0, 9, 8, 0, 0, 0, 0, 6, 0],\n    [8, 0, 0, 0, 6, 0, 0, 0, 3],\n    [4, 0, 0, 8, 0, 3, 0, 0, 1],\n    [7, 0, 0, 0, 2, 0, 0, 0, 6],\n    [0, 6, 0, 0, 0, 0, 2, 8, 0],\n    [0, 0, 0, 4, 1, 9, 0, 0, 5],\n    [0, 0, 0, 0, 8, 0, 0, 7, 9]\n]\n\nsolve_sudoku(sudoku_board)\n\nfor row in sudoku_board:\n    print(' '.join(str(num) for num in row))"}, {"role": "assistant", "content": "5 3 4 6 7 8 9 1 2\n6 7 2 1 9 5 3 4 8\n1 9 8 3 4 2 5 6 7\n8 5 9 7 6 1 4 2 3\n4 2 6 8 5 3 7 9 1\n7 1 3 9 2 4 8 5 6\n9 6 1 5 3 7 2 8 4\n2 8 7 4 1 9 6 3 5\n3 4 5 2 8 6 1 7 9\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef find_median_of_top_n(data, n):\n    data_sorted = sorted(data, reverse=True)\n    print(f\"Sorted data: {data_sorted}\")\n    top_n = data_sorted[:n]\n    print(f\"Top {n} elements: {top_n}\")\n    median_top_n = statistics.median(top_n)\n    return median_top_n\n\ndata = [23, 45, 12, 67, 34, 89, 78, 56, 90, 43, 27, 33, 22, 49]\nn = 5\nmedian_value = find_median_of_top_n(data, n)\n\nprint(f\"Median of top {n} elements: {median_value}\")"}, {"role": "assistant", "content": "Sorted data: [90, 89, 78, 67, 56, 49, 45, 43, 34, 33, 27, 23, 22, 12]\nTop 5 elements: [90, 89, 78, 67, 56]\nMedian of top 5 elements: 78\n"}]}
{"messages": [{"role": "user", "content": "def generate_pattern(length):\n    pattern = []\n    for i in range(1, length + 1):\n        pattern.append(('X' * i).ljust(length))\n    return pattern\n\ndef sort_pattern(pattern):\n    return sorted(pattern)\n\ndef main():\n    length = 10\n    pattern = generate_pattern(length)\n    print(\"Generated Pattern:\")\n    for line in pattern:\n        print(line)\n\n    print(\"\\nSorted Pattern:\")\n    sorted_pattern = sort_pattern(pattern)\n    for line in sorted_pattern:\n        print(line)\n\nif __name__ == \"__main__\":\n    main()"}, {"role": "assistant", "content": "Generated Pattern:\nX         \nXX        \nXXX       \nXXXX      \nXXXXX     \nXXXXXX    \nXXXXXXX   \nXXXXXXXX  \nXXXXXXXXX \nXXXXXXXXXX\n\nSorted Pattern:\nX         \nXX        \nXXX       \nXXXX      \nXXXXX     \nXXXXXX    \nXXXXXXX   \nXXXXXXXX  \nXXXXXXXXX \nXXXXXXXXXX\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef calculate_median_mode(data):\n    data.sort()\n    median = statistics.median(data)\n    mode = statistics.mode(data)\n    return median, mode\n\ndata_points = [\n    3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 9, 7, 9, 3, 2, 3, 8, 4, 6, 2, 6, 4, 3, 3\n]\n\nmedian, mode = calculate_median_mode(data_points)\n\nsorted_data = sorted(data_points, reverse=True)\nprint(\"Sorted Data (Descending):\")\nfor value in sorted_data:\n    print(value)\n\nprint(\"\\nMedian of Data:\", mode)\nprint(\"Mode of Data:\", median)"}, {"role": "assistant", "content": "Sorted Data (Descending):\n9\n9\n9\n8\n7\n6\n6\n6\n5\n5\n5\n4\n4\n4\n3\n3\n3\n3\n3\n3\n2\n2\n2\n1\n1\n\nMedian of Data: 3\nMode of Data: 4\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef generate_spiral(n):\n    spiral = [[0] * n for _ in range(n)]\n    x, y = n // 2, n // 2\n    num = 1\n    spiral[x][y] = num\n    num += 1\n    for layer in range(1, (n // 2) + 1):\n        for i in range(y + 1, y + 1 + layer * 2):\n            if 0 <= x < n and 0 <= i < n:\n                spiral[x][i] = num\n                num += 1\n        y += layer * 2\n        for i in range(x + 1, x + 1 + layer * 2):\n            if 0 <= i < n and 0 <= y < n:\n                spiral[i][y] = num\n                num += 1\n        x += layer * 2\n        for i in range(y - 1, y - 1 - layer * 2, -1):\n            if 0 <= x < n and 0 <= i < n:\n                spiral[x][i] = num\n                num += 1\n        y -= layer * 2\n        for i in range(x - 1, x - 1 - layer * 2, -1):\n            if 0 <= i < n and 0 <= y < n:\n                spiral[i][y] = num\n                num += 1\n        x -= layer * 2\n    return spiral\n\ndef search_pattern(spiral, pattern):\n    for i in range(len(spiral)):\n        for j in range(len(spiral[i])):\n            if spiral[i][j:j + len(pattern)] == pattern:\n                return (i, j)\n    for j in range(len(spiral[0])):\n        for i in range(len(spiral) - len(pattern) + 1):\n            if all(spiral[i + k][j] == pattern[k] for k in range(len(pattern))):\n                return (i, j)\n    return None\n\nn = 11\npattern = [22, 23, 24, 25]\nspiral = generate_spiral(n)\nresult = search_pattern(spiral, pattern)\n\nfor row in spiral:\n    print(\" \".join(f\"{num:2}\" for num in row))\nprint(f\"Pattern {pattern} found at: {result}\")"}, {"role": "assistant", "content": " 0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0 58 48 49 50 51 52\n 0  0  0  0  0 57  0  4  0 14  0\n 0  0  0  0  0 56  6  5  0 15  0\n 0  0  0  0  0 55  0  0  0 16  0\n 0  0  0  0  0 54 20 19 18 17  0\n 0  0  0  0  0 53  0  0  0  0  0\nPattern [22, 23, 24, 25] found at: None\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef find_nearest_square(nums):\n    def binary_search_square(n):\n        low, high = 0, n\n        while low <= high:\n            mid = (low + high) // 2\n            square = mid * mid\n            if square == n:\n                return mid\n            elif square < n:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return high\n\n    transformed = []\n    for num in nums:\n        if num < 0:\n            transformed.append(None)\n        else:\n            nearest_square_root = binary_search_square(num)\n            transformed.append(nearest_square_root * nearest_square_root)\n    \n    return transformed\n\nnumbers = [2, 3, 10, 15, 20, 25, 30, 40, 50, 60, 70, 80, 90, 100]\nresult = find_nearest_square(numbers)\nfor num, square in zip(numbers, result):\n    print(f\"Original: {num}, Nearest Square: {square}\")"}, {"role": "assistant", "content": "Original: 2, Nearest Square: 1\nOriginal: 3, Nearest Square: 1\nOriginal: 10, Nearest Square: 9\nOriginal: 15, Nearest Square: 9\nOriginal: 20, Nearest Square: 16\nOriginal: 25, Nearest Square: 25\nOriginal: 30, Nearest Square: 25\nOriginal: 40, Nearest Square: 36\nOriginal: 50, Nearest Square: 49\nOriginal: 60, Nearest Square: 49\nOriginal: 70, Nearest Square: 64\nOriginal: 80, Nearest Square: 64\nOriginal: 90, Nearest Square: 81\nOriginal: 100, Nearest Square: 100\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef sort_words_by_vowel_count(text):\n    words = re.findall(r'\\b\\w+\\b', text)\n    print(f\"Original words: {words}\")\n    \n    def vowel_count(word):\n        vowels = \"aeiou\"\n        count = sum(1 for char in word if char in vowels)\n        print(f\"Vowel count for '{word}': {count}\")\n        return count\n\n    sorted_words = sorted(words, key=vowel_count, reverse=True)\n    print(f\"Sorted words by vowel count: {sorted_words}\")\n    return sorted_words\n\ntext = \"\"\"\nThe quick brown fox jumps over the lazy dog. An example of a text containing every letter of the English alphabet.\n\"\"\"\n\nresult = sort_words_by_vowel_count(text)\nprint(\"Final sorted list of words:\")\nfor word in result:\n    print(word)"}, {"role": "assistant", "content": "Original words: ['The', 'quick', 'brown', 'fox', 'jumps', 'over', 'the', 'lazy', 'dog', 'An', 'example', 'of', 'a', 'text', 'containing', 'every', 'letter', 'of', 'the', 'English', 'alphabet']\nVowel count for 'The': 1\nVowel count for 'quick': 2\nVowel count for 'brown': 1\nVowel count for 'fox': 1\nVowel count for 'jumps': 1\nVowel count for 'over': 2\nVowel count for 'the': 1\nVowel count for 'lazy': 1\nVowel count for 'dog': 1\nVowel count for 'An': 0\nVowel count for 'example': 3\nVowel count for 'of': 1\nVowel count for 'a': 1\nVowel count for 'text': 1\nVowel count for 'containing': 4\nVowel count for 'every': 2\nVowel count for 'letter': 2\nVowel count for 'of': 1\nVowel count for 'the': 1\nVowel count for 'English': 1\nVowel count for 'alphabet': 3\nSorted words by vowel count: ['containing', 'example', 'alphabet', 'quick', 'over', 'every', 'letter', 'The', 'brown', 'fox', 'jumps', 'the', 'lazy', 'dog', 'of', 'a', 'text', 'of', 'the', 'English', 'An']\nFinal sorted list of words:\ncontaining\nexample\nalphabet\nquick\nover\nevery\nletter\nThe\nbrown\nfox\njumps\nthe\nlazy\ndog\nof\na\ntext\nof\nthe\nEnglish\nAn\n"}]}
{"messages": [{"role": "user", "content": "def find_increasing_subsequence(sequence):\n    longest_subseq = []\n    current_subseq = []\n\n    for i in range(len(sequence)):\n        if i == 0 or sequence[i] > sequence[i - 1]:\n            current_subseq.append(sequence[i])\n        else:\n            if len(current_subseq) > len(longest_subseq):\n                longest_subseq = current_subseq\n            current_subseq = [sequence[i]]\n    \n    if len(current_subseq) > len(longest_subseq):\n        longest_subseq = current_subseq\n\n    return longest_subseq\n\nsequence = [5, 1, 2, 3, 1, 2, 3, 4, 1, 2, 3, 4, 5]\nresult = find_increasing_subsequence(sequence)\n\nfor number in result:\n    print(number)"}, {"role": "assistant", "content": "1\n2\n3\n4\n5\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndates = [\n    \"2023-09-15\", \"2023-08-02\", \"2023-07-12\", \"2023-10-01\",\n    \"2023-05-23\", \"2023-06-30\", \"2023-04-11\", \"2023-03-19\",\n    \"2023-01-01\", \"2023-02-14\", \"2023-11-30\", \"2023-12-25\"\n]\n\nparsed_dates = [datetime.strptime(date, \"%Y-%m-%d\") for date in dates]\nsorted_dates = sorted(parsed_dates, key=lambda date: date.timetuple().tm_yday)\nsorted_dates_str = [date.strftime(\"%Y-%m-%d\") for date in sorted_dates]\n\nfor date in sorted_dates_str:\n    print(date)"}, {"role": "assistant", "content": "2023-01-01\n2023-02-14\n2023-03-19\n2023-04-11\n2023-05-23\n2023-06-30\n2023-07-12\n2023-08-02\n2023-09-15\n2023-10-01\n2023-11-30\n2023-12-25\n"}]}
{"messages": [{"role": "user", "content": "def insertion_sort_descending(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and key > arr[j]:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr\n\ndef generate_fibonacci_sequence(n):\n    fibonacci = [0, 1]\n    for i in range(2, n):\n        fibonacci.append(fibonacci[i-1] + fibonacci[i-2])\n    return fibonacci\n\ndef main():\n    sequence_length = 15\n    fibonacci_sequence = generate_fibonacci_sequence(sequence_length)\n    \n    print(\"Generated Fibonacci sequence:\")\n    print(fibonacci_sequence)\n    \n    sorted_sequence = insertion_sort_descending(fibonacci_sequence)\n    \n    print(\"\\nAscending sorted Fibonacci sequence:\")\n    print(sorted_sequence)\n\nif __name__ == \"__main__\":\n    main()"}, {"role": "assistant", "content": "Generated Fibonacci sequence:\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377]\n\nAscending sorted Fibonacci sequence:\n[377, 233, 144, 89, 55, 34, 21, 13, 8, 5, 3, 2, 1, 1, 0]\n"}]}
{"messages": [{"role": "user", "content": "from math import sqrt\n\ndef is_fibonacci(n):\n    x1 = 5 * n * n + 4\n    x2 = 5 * n * n - 4\n    return int(sqrt(x1)) ** 2 == x1 or int(sqrt(x2)) ** 2 == x2\n\ndef fibonacci_index(n):\n    if n == 0:\n        return 0\n    a, b = 0, 1\n    index = 1\n    while b < n:\n        a, b = b, a + b\n        index += 1\n    return index if b == n else -1\n\ndef find_rare_fib_indices(limit):\n    rare_fib_indices = []\n    for num in range(1, limit):\n        if is_fibonacci(num):\n            index = fibonacci_index(num)\n            if index % 2 == 0 and index % 3 != 0:\n                rare_fib_indices.append(index)\n    return rare_fib_indices\n\nindices = find_rare_fib_indices(1000000)\nfor idx in indices:\n    print(idx)"}, {"role": "assistant", "content": "4\n8\n10\n14\n16\n20\n22\n26\n28\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef get_date_key(date_str):\n    return datetime.datetime.strptime(date_str, \"%Y-%m-%d\")\n\ndates = [\n    \"2023-10-01\", \"2023-09-15\", \"2023-10-23\", \"2023-06-11\",\n    \"2023-03-25\", \"2023-08-19\", \"2023-07-04\", \"2023-02-14\",\n    \"2023-12-31\", \"2023-01-01\", \"2023-04-22\", \"2023-05-29\"\n]\n\nprint(\"Original Dates:\")\nfor date in dates:\n    print(date)\n\nsorted_dates = sorted(dates, key=get_date_key)\n\nprint(\"\\nDates Sorted by Ascending:\")\nfor date in sorted_dates:\n    print(date)\n\nsorted_dates_desc = sorted(dates, key=get_date_key, reverse=True)\n\nprint(\"\\nDates Sorted by Descending:\")\nfor date in sorted_dates_desc:\n    print(date)\n\ndate_ranges = [(dates[i], dates[i+1]) for i in range(len(dates)-1)]\nsorted_ranges = sorted(date_ranges, key=lambda x: (get_date_key(x[1]) - get_date_key(x[0])).days)\n\nprint(\"\\nDate Ranges Sorted by Duration:\")\nfor start, end in sorted_ranges:\n    print(f\"{start} to {end} - Duration: {(get_date_key(end) - get_date_key(start)).days} days\")"}, {"role": "assistant", "content": "Original Dates:\n2023-10-01\n2023-09-15\n2023-10-23\n2023-06-11\n2023-03-25\n2023-08-19\n2023-07-04\n2023-02-14\n2023-12-31\n2023-01-01\n2023-04-22\n2023-05-29\n\nDates Sorted by Ascending:\n2023-01-01\n2023-02-14\n2023-03-25\n2023-04-22\n2023-05-29\n2023-06-11\n2023-07-04\n2023-08-19\n2023-09-15\n2023-10-01\n2023-10-23\n2023-12-31\n\nDates Sorted by Descending:\n2023-12-31\n2023-10-23\n2023-10-01\n2023-09-15\n2023-08-19\n2023-07-04\n2023-06-11\n2023-05-29\n2023-04-22\n2023-03-25\n2023-02-14\n2023-01-01\n\nDate Ranges Sorted by Duration:\n2023-12-31 to 2023-01-01 - Duration: -364 days\n2023-07-04 to 2023-02-14 - Duration: -140 days\n2023-10-23 to 2023-06-11 - Duration: -134 days\n2023-06-11 to 2023-03-25 - Duration: -78 days\n2023-08-19 to 2023-07-04 - Duration: -46 days\n2023-10-01 to 2023-09-15 - Duration: -16 days\n2023-04-22 to 2023-05-29 - Duration: 37 days\n2023-09-15 to 2023-10-23 - Duration: 38 days\n2023-01-01 to 2023-04-22 - Duration: 111 days\n2023-03-25 to 2023-08-19 - Duration: 147 days\n2023-02-14 to 2023-12-31 - Duration: 320 days\n"}]}
{"messages": [{"role": "user", "content": "import math\nfrom collections import namedtuple\n\nPoint = namedtuple('Point', ['x', 'y'])\n\ndef distance(p1, p2):\n    return math.hypot(p1.x - p2.x, p1.y - p2.y)\n\ndef convex_hull(points):\n    points = sorted(points, key=lambda p: (p.x, p.y))\n    if len(points) <= 1:\n        return points\n\n    def cross(o, a, b):\n        return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x)\n\n    lower = []\n    for p in points:\n        while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:\n            lower.pop()\n        lower.append(p)\n\n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:\n            upper.pop()\n        upper.append(p)\n\n    return lower[:-1] + upper[:-1]\n\ndef perimeter_of_polygon(points):\n    points = points + [points[0]]\n    return sum(distance(points[i], points[i + 1]) for i in range(len(points) - 1))\n\npoints = [\n    Point(0, 0), Point(1, 3), Point(2, 2), Point(4, 4),\n    Point(0, 5), Point(1, 1), Point(3, 3), Point(3, 1),\n    Point(5, 0), Point(4, 2)\n]\n\nhull_points = convex_hull(points)\nprint(\"Convex Hull Points:\")\nfor p in hull_points:\n    print(p)\n\nperimeter = perimeter_of_polygon(hull_points)\nprint(\"\\nPerimeter of Convex Hull:\", perimeter)"}, {"role": "assistant", "content": "Convex Hull Points:\nPoint(x=0, y=0)\nPoint(x=5, y=0)\nPoint(x=4, y=4)\nPoint(x=0, y=5)\n\nPerimeter of Convex Hull: 18.246211251235323\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef find_nearest_point(points, target):\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\n    nearest_point = None\n    min_distance = float('inf')\n\n    for point in points:\n        dist = distance(point, target)\n        if dist < min_distance:\n            min_distance = dist\n            nearest_point = point\n\n    return min_distance\n\npoints = [(1, 2), (3, 4), (5, 6), (7, 8), (9, 10), (11, 12), (13, 14), (15, 16), (17, 18), (19, 20)]\ntarget = (10, 10)\n\nresult = find_nearest_point(points, target)\n\nfor idx, point in enumerate(points):\n    print(f\"Point {idx}: {point}\")\n\nprint(f\"Distance to the nearest point: {result:.2f}\")"}, {"role": "assistant", "content": "Point 0: (1, 2)\nPoint 1: (3, 4)\nPoint 2: (5, 6)\nPoint 3: (7, 8)\nPoint 4: (9, 10)\nPoint 5: (11, 12)\nPoint 6: (13, 14)\nPoint 7: (15, 16)\nPoint 8: (17, 18)\nPoint 9: (19, 20)\nDistance to the nearest point: 1.00\n"}]}
{"messages": [{"role": "user", "content": "import string\n\ndef encrypt(message, key):\n    def shift_char(c, k):\n        if c in string.ascii_letters:\n            base = ord('A') if c.isupper() else ord('a')\n            shifted = (ord(c) - base + k) % 26 + base\n            return chr(shifted)\n        return c\n\n    return ''.join(shift_char(c, key) for c in message)\n\ndef decrypt(message, key):\n    return encrypt(message, -key)\n\ndef custom_sort(encoded_messages):\n    return sorted(encoded_messages, key=lambda x: len(set(x)))\n\nmessage = \"AdvancedEncryptionExample\"\nkey = 4\nencoded_messages = []\n\nfor i in range(1, 26):\n    encrypted_message = encrypt(message, i)\n    encoded_messages.append(encrypted_message)\n\nsorted_encoded_messages = custom_sort(encoded_messages)\n\nfor msg in sorted_encoded_messages:\n    print(msg)"}, {"role": "assistant", "content": "BewbodfeFodszqujpoFybnqmf\nCfxcpegfGpetarvkqpGzcorng\nDgydqfhgHqfubswlrqHadpsoh\nEhzergihIrgvctxmsrIbeqtpi\nFiafshjiJshwduyntsJcfruqj\nGjbgtikjKtixevzoutKdgsvrk\nHkchujlkLujyfwapvuLehtwsl\nIldivkmlMvkzgxbqwvMfiuxtm\nJmejwlnmNwlahycrxwNgjvyun\nKnfkxmonOxmbizdsyxOhkwzvo\nLoglynpoPyncjaetzyPilxawp\nMphmzoqpQzodkbfuazQjmybxq\nNqinaprqRapelcgvbaRknzcyr\nOrjobqsrSbqfmdhwcbSloadzs\nPskpcrtsTcrgneixdcTmpbeat\nQtlqdsutUdshofjyedUnqcfbu\nRumretvuVetipgkzfeVordgcv\nSvnsfuwvWfujqhlagfWpsehdw\nTwotgvxwXgvkrimbhgXqtfiex\nUxpuhwyxYhwlsjncihYrugjfy\nVyqvixzyZixmtkodjiZsvhkgz\nWzrwjyazAjynulpekjAtwilha\nXasxkzbaBkzovmqflkBuxjmib\nYbtylacbClapwnrgmlCvyknjc\nZcuzmbdcDmbqxoshnmDwzlokd\n"}]}
{"messages": [{"role": "user", "content": "from math import sqrt\n\nalphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\ndef encode(message):\n    encoded = []\n    for char in message:\n        if char in alphabet:\n            encoded.append(alphabet.index(char) + 1)\n        else:\n            encoded.append(char)\n    return encoded\n\ndef decode(encoded_message):\n    decoded = []\n    for item in encoded_message:\n        if isinstance(item, int) and 1 <= item <= 26:\n            decoded.append(alphabet[item - 1])\n        else:\n            decoded.append(item)\n    return ''.join(decoded)\n\ndef search_for_prime(encoded_message):\n    primes = []\n    for number in encoded_message:\n        if isinstance(number, int) and is_prime(number):\n            primes.append(number)\n    return primes\n\ndef is_prime(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nmessage = \"HELLO WORLD\"\nencoded_message = encode(message)\nprint(\"Encoded Message:\", encoded_message)\n\nprimes_in_message = search_for_prime(encoded_message)\nprint(\"Primes in Encoded Message:\", primes_in_message)\n\ndecoded_message = decode(encoded_message)\nprint(\"Decoded Message:\", decoded_message)"}, {"role": "assistant", "content": "Encoded Message: [8, 5, 12, 12, 15, ' ', 23, 15, 18, 12, 4]\nPrimes in Encoded Message: [5, 23]\nDecoded Message: HELLO WORLD\n"}]}
{"messages": [{"role": "user", "content": "import math\nfrom datetime import datetime\n\ndef find_closest_dates(dates, target):\n    def binary_search(array, value):\n        low, high = 0, len(array) - 1\n        best_idx = -1\n        best_diff = float('inf')\n        while low <= high:\n            mid = (low + high) // 2\n            mid_val = array[mid]\n            diff = abs((mid_val - value).days)\n            if diff < best_diff:\n                best_idx = mid\n                best_diff = diff\n            if mid_val < value:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return best_idx\n\n    sorted_dates = sorted(dates)\n    index = binary_search(sorted_dates, target)\n    results = []\n    if index != -1:\n        results.append(sorted_dates[index])\n        if index - 1 >= 0:\n            results.append(sorted_dates[index - 1])\n        if index + 1 < len(sorted_dates):\n            results.append(sorted_dates[index + 1])\n    return sorted(results)\n\ndate_list = [\n    datetime(2023, 7, 19), datetime(2023, 1, 5), datetime(2023, 11, 13),\n    datetime(2023, 5, 23), datetime(2023, 8, 10), datetime(2023, 9, 30),\n    datetime(2023, 4, 7), datetime(2023, 3, 15), datetime(2023, 12, 25),\n    datetime(2023, 6, 2), datetime(2023, 2, 14), datetime(2023, 10, 5)\n]\n\ntarget_date = datetime(2023, 6, 15)\nclosest_dates = find_closest_dates(date_list, target_date)\n\nfor date in closest_dates:\n    print(date.strftime('%Y-%m-%d'))"}, {"role": "assistant", "content": "2023-05-23\n2023-06-02\n2023-07-19\n"}]}
{"messages": [{"role": "user", "content": "def initialize_board(n):\n    return [[0] * n for _ in range(n)]\n\ndef is_valid_move(board, move, n):\n    return 0 <= move[0] < n and 0 <= move[1] < n and board[move[0]][move[1]] == 0\n\ndef apply_move(board, move, player):\n    board[move[0]][move[1]] = player\n\ndef game_logic(n, moves):\n    board = initialize_board(n)\n    player = 1\n    for move in moves:\n        if is_valid_move(board, move, n):\n            apply_move(board, move, player)\n            player = 3 - player\n    return board\n\ndef evaluate_board(board):\n    score = 0\n    for row in board:\n        score += sum(row)\n    return score\n\ndef sort_boards_by_score(boards):\n    return sorted(boards, key=evaluate_board, reverse=True)\n\ndef display_board(board):\n    for row in board:\n        print(' '.join(str(x) for x in row))\n    print()\n\nn = 5\nmoves_list = [\n    [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)],\n    [(4, 0), (3, 1), (2, 2), (1, 3), (0, 4)],\n    [(0, 4), (1, 3), (2, 2), (3, 1), (4, 0)],\n    [(2, 2), (1, 1), (3, 3), (0, 0), (4, 4)],\n    [(3, 0), (3, 1), (3, 2), (3, 3), (3, 4)]\n]\n\nboards = [game_logic(n, moves) for moves in moves_list]\nsorted_boards = sort_boards_by_score(boards)\n\nfor board in sorted_boards:\n    display_board(board)"}, {"role": "assistant", "content": "1 0 0 0 0\n0 2 0 0 0\n0 0 1 0 0\n0 0 0 2 0\n0 0 0 0 1\n\n0 0 0 0 1\n0 0 0 2 0\n0 0 1 0 0\n0 2 0 0 0\n1 0 0 0 0\n\n0 0 0 0 1\n0 0 0 2 0\n0 0 1 0 0\n0 2 0 0 0\n1 0 0 0 0\n\n2 0 0 0 0\n0 2 0 0 0\n0 0 1 0 0\n0 0 0 1 0\n0 0 0 0 1\n\n0 0 0 0 0\n0 0 0 0 0\n0 0 0 0 0\n1 2 1 2 1\n0 0 0 0 0\n\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef date_sorter(dates):\n    return sorted(dates, key=lambda date: datetime.strptime(date, '%Y-%m-%d'))\n\ntoday = datetime.now()\ndates = [(today - timedelta(days=i)).strftime('%Y-%m-%d') for i in range(30)]\n\n# Shuffle dates in a specific way\ndates = dates[5:10] + dates[0:5] + dates[20:25] + dates[10:20] + dates[25:]\n\nprint(\"Dates before sorting:\")\nfor date in dates:\n    print(date)\n\nsorted_dates = date_sorter(dates)\n\nprint(\"\\nDates after sorting:\")\nfor date in sorted_dates:\n    print(date)"}, {"role": "assistant", "content": "Dates before sorting:\n2025-03-27\n2025-03-26\n2025-03-25\n2025-03-24\n2025-03-23\n2025-04-01\n2025-03-31\n2025-03-30\n2025-03-29\n2025-03-28\n2025-03-12\n2025-03-11\n2025-03-10\n2025-03-09\n2025-03-08\n2025-03-22\n2025-03-21\n2025-03-20\n2025-03-19\n2025-03-18\n2025-03-17\n2025-03-16\n2025-03-15\n2025-03-14\n2025-03-13\n2025-03-07\n2025-03-06\n2025-03-05\n2025-03-04\n2025-03-03\n\nDates after sorting:\n2025-03-03\n2025-03-04\n2025-03-05\n2025-03-06\n2025-03-07\n2025-03-08\n2025-03-09\n2025-03-10\n2025-03-11\n2025-03-12\n2025-03-13\n2025-03-14\n2025-03-15\n2025-03-16\n2025-03-17\n2025-03-18\n2025-03-19\n2025-03-20\n2025-03-21\n2025-03-22\n2025-03-23\n2025-03-24\n2025-03-25\n2025-03-26\n2025-03-27\n2025-03-28\n2025-03-29\n2025-03-30\n2025-03-31\n2025-04-01\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef search_for_fridays(year):\n    fridays_in_year = []\n    current_date = datetime(year, 1, 1)\n    while current_date.year == year:\n        if current_date.weekday() == 4:\n            fridays_in_year.append(current_date)\n        current_date += timedelta(days=1)\n    return fridays_in_year\n\ndef find_friday_the_13ths(year):\n    fridays = search_for_fridays(year)\n    friday_13ths = [friday for friday in fridays if friday.day == 13]\n    return friday_13ths\n\nyear_to_search = 2023\nfriday_13ths = find_friday_the_13ths(year_to_search)\n\nfor friday in friday_13ths:\n    print(friday.strftime(\"%Y-%m-%d\"))"}, {"role": "assistant", "content": "2023-01-13\n2023-10-13\n"}]}
{"messages": [{"role": "user", "content": "def generate_pattern(n):\n    pattern = []\n    for i in range(1, n + 1):\n        line = \"\"\n        for j in range(1, n + 1):\n            if j == n - i + 1:\n                line += str(j)\n            else:\n                line += \" \"\n        pattern.append(line)\n    return pattern\n\ndef search_pattern(pattern, target):\n    for index, line in enumerate(pattern):\n        if target in line:\n            return index\n    return -1\n\ndef main():\n    size = 10\n    pattern = generate_pattern(size)\n    target = '5'\n    position = search_pattern(pattern, target)\n\n    for line in pattern:\n        print(line)\n\n    print(f\"Target '{target}' found at line: {position + 1}\")\n\nmain()"}, {"role": "assistant", "content": "         10\n        9 \n       8  \n      7   \n     6    \n    5     \n   4      \n  3       \n 2        \n1         \nTarget '5' found at line: 6\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef calculate_weighted_median(data, weights):\n    sorted_data = sorted(zip(data, weights), key=lambda x: x[0])\n    cumulative_weight = 0\n    total_weight = sum(weights)\n    print(f\"Total weight: {total_weight}\")\n\n    for value, weight in sorted_data:\n        cumulative_weight += weight\n        print(f\"Value: {value}, Weight: {weight}, Cumulative Weight: {cumulative_weight}\")\n        if cumulative_weight >= total_weight / 2:\n            return value\n\ndata_points = [23, 45, 12, 67, 34, 89, 78, 56, 33, 45, 29]\nweights = [1, 2, 1, 1, 4, 3, 1, 5, 2, 3, 1]\n\nweighted_median = calculate_weighted_median(data_points, weights)\nprint(f\"Weighted Median: {weighted_median}\")\n\nsorted_data = sorted(data_points)\nprint(f\"Sorted data: {sorted_data}\")\n\nmean_value = statistics.mean(data_points)\nmedian_value = statistics.median(data_points)\nmode_value = statistics.mode(data_points)\n\nprint(f\"Mean: {mean_value}\")\nprint(f\"Median: {median_value}\")\nprint(f\"Mode: {mode_value}\")\n\nfor i in range(len(data_points)):\n    if data_points[i] == weighted_median:\n        print(f\"Original Index of Weighted Median: {i}\")\n        break"}, {"role": "assistant", "content": "Total weight: 24\nValue: 12, Weight: 1, Cumulative Weight: 1\nValue: 23, Weight: 1, Cumulative Weight: 2\nValue: 29, Weight: 1, Cumulative Weight: 3\nValue: 33, Weight: 2, Cumulative Weight: 5\nValue: 34, Weight: 4, Cumulative Weight: 9\nValue: 45, Weight: 2, Cumulative Weight: 11\nValue: 45, Weight: 3, Cumulative Weight: 14\nWeighted Median: 45\nSorted data: [12, 23, 29, 33, 34, 45, 45, 56, 67, 78, 89]\nMean: 46.45454545454545\nMedian: 45\nMode: 45\nOriginal Index of Weighted Median: 1\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef transform_data(data):\n    vowels = \"aeiou\"\n    transformed = []\n    for word in data:\n        if any(v in word for v in vowels):\n            transformed.append(re.sub(r'[aeiou]', '*', word))\n        else:\n            transformed.append(word[::-1])\n    return transformed\n\ndef binary_search_transform(data, target):\n    left, right = 0, len(data) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if data[mid] == target:\n            return mid\n        elif data[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndata = [\n    \"apple\", \"sky\", \"orange\", \"blue\",\n    \"grape\", \"green\", \"peach\", \"red\",\n    \"plum\", \"yellow\", \"pear\", \"pink\"\n]\n\ntransformed_data = transform_data(data)\nsorted_transformed = sorted(transformed_data)\n\ntargets = [\"*ppl*\", \"yks\", \"*r*ng*\", \"*l**\", \"gr*p*\", \"r**\"]\nresults = []\n\nfor target in targets:\n    index = binary_search_transform(sorted_transformed, target)\n    if index != -1:\n        results.append((target, index))\n\nfor result in results:\n    print(f\"Target: {result[0]}, Index in Sorted List: {result[1]}\")"}, {"role": "assistant", "content": "Target: *ppl*, Index in Sorted List: 0\nTarget: yks, Index in Sorted List: 11\nTarget: *r*ng*, Index in Sorted List: 1\nTarget: gr*p*, Index in Sorted List: 4\n"}]}
{"messages": [{"role": "user", "content": "def generate_matrix(n):\n    matrix = [[' ' for _ in range(n)] for _ in range(n)]\n    mid = n // 2\n    for i in range(n):\n        for j in range(n):\n            if i == j or i + j == n - 1:\n                matrix[i][j] = '#'\n    return matrix\n\ndef sort_diagonals(matrix, n):\n    primary = [matrix[i][i] for i in range(n)]\n    secondary = [matrix[i][n - i - 1] for i in range(n)]\n    primary.sort()\n    secondary.sort()\n    for i in range(n):\n        matrix[i][i] = primary[i]\n        matrix[i][n - i - 1] = secondary[i]\n    return matrix\n\ndef display_matrix(matrix):\n    for row in matrix:\n        print(' '.join(row))\n\nsize = 10\nmatrix = generate_matrix(size)\nsorted_matrix = sort_diagonals(matrix, size)\ndisplay_matrix(sorted_matrix)"}, {"role": "assistant", "content": "#                 #\n  #             #  \n    #         #    \n      #     #      \n        # #        \n        # #        \n      #     #      \n    #         #    \n  #             #  \n#                 #\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef sort_dates(dates):\n    return sorted(dates, key=lambda date: datetime.datetime.strptime(date, \"%d-%m-%Y\"))\n\ndates_list = [\n    \"02-10-2023\", \"15-08-2023\", \"23-09-2023\", \"01-01-2023\",\n    \"25-12-2023\", \"14-02-2023\", \"31-07-2023\", \"04-07-2023\",\n    \"11-11-2023\", \"03-03-2023\", \"18-06-2023\", \"29-02-2024\",\n    \"28-02-2023\", \"30-04-2023\", \"10-10-2023\", \"05-05-2023\",\n    \"21-09-2023\", \"19-03-2023\", \"07-07-2023\", \"22-02-2023\",\n    \"12-12-2023\", \"17-01-2023\", \"06-06-2023\", \"09-09-2023\"\n]\n\nprint(\"Original list of dates:\")\nfor date in dates_list:\n    print(date)\n\nsorted_dates = sort_dates(dates_list)\n\nprint(\"\\nSorted list of dates:\")\nfor date in sorted_dates:\n    print(date)\n\ntransformed_dates = [datetime.datetime.strptime(date, \"%d-%m-%Y\").strftime(\"%Y-%m-%d\") for date in sorted_dates]\n\nprint(\"\\nTransformed list of dates (YYYY-MM-DD):\")\nfor date in transformed_dates:\n    print(date)"}, {"role": "assistant", "content": "Original list of dates:\n02-10-2023\n15-08-2023\n23-09-2023\n01-01-2023\n25-12-2023\n14-02-2023\n31-07-2023\n04-07-2023\n11-11-2023\n03-03-2023\n18-06-2023\n29-02-2024\n28-02-2023\n30-04-2023\n10-10-2023\n05-05-2023\n21-09-2023\n19-03-2023\n07-07-2023\n22-02-2023\n12-12-2023\n17-01-2023\n06-06-2023\n09-09-2023\n\nSorted list of dates:\n01-01-2023\n17-01-2023\n14-02-2023\n22-02-2023\n28-02-2023\n03-03-2023\n19-03-2023\n30-04-2023\n05-05-2023\n06-06-2023\n18-06-2023\n04-07-2023\n07-07-2023\n31-07-2023\n15-08-2023\n09-09-2023\n21-09-2023\n23-09-2023\n02-10-2023\n10-10-2023\n11-11-2023\n12-12-2023\n25-12-2023\n29-02-2024\n\nTransformed list of dates (YYYY-MM-DD):\n2023-01-01\n2023-01-17\n2023-02-14\n2023-02-22\n2023-02-28\n2023-03-03\n2023-03-19\n2023-04-30\n2023-05-05\n2023-06-06\n2023-06-18\n2023-07-04\n2023-07-07\n2023-07-31\n2023-08-15\n2023-09-09\n2023-09-21\n2023-09-23\n2023-10-02\n2023-10-10\n2023-11-11\n2023-12-12\n2023-12-25\n2024-02-29\n"}]}
{"messages": [{"role": "user", "content": "from math import sqrt\nfrom datetime import datetime\n\ndef is_square(n):\n    return int(sqrt(n)) ** 2 == n\n\ndef search_fibonacci_square(limit):\n    a, b = 1, 1\n    fibonacci_squares = []\n    while a <= limit:\n        if is_square(a):\n            fibonacci_squares.append(a)\n        a, b = b, a + b\n    return fibonacci_squares\n\ndef main():\n    limit = 10**12\n    start_time = datetime.now()\n    fibonacci_squares = search_fibonacci_square(limit)\n    end_time = datetime.now()\n    print(f\"Found {len(fibonacci_squares)} Fibonacci squares up to {limit}:\")\n    for num in fibonacci_squares:\n        print(num)\n    print(f\"Search completed in {end_time - start_time}\")\n\nmain()"}, {"role": "assistant", "content": "Found 3 Fibonacci squares up to 1000000000000:\n1\n1\n144\nSearch completed in 0:00:00.000021\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"\nIn a village of La Mancha, the name of which I have no desire to call to mind,\nthere lived not long since one of those gentlemen that keep a lance in the\nlance-rack, an old buckler, a lean hack, and a greyhound for coursing. An olla\nof rather more beef than mutton, a salad on most nights, scraps on Saturdays,\nlentils on Fridays, and a pigeon or so extra on Sundays, made away with three-\nquarters of his income.\n\"\"\"\n\nwords = re.findall(r'\\b\\w+\\b', text.lower())\nword_freq = {word: words.count(word) for word in set(words)}\nsorted_word_freq = sorted(word_freq.items(), key=lambda x: (-x[1], x[0]))\n\nunique_sorted_words = sorted(set(words))\nsorted_by_vowel_count = sorted(unique_sorted_words, key=lambda word: (-sum(1 for char in word if char in 'aeiou'), word))\n\nresult = [f\"{word}: {freq}\" for word, freq in sorted_word_freq] + sorted_by_vowel_count\nprint(\"\\n\".join(result))"}, {"role": "assistant", "content": "a: 6\nof: 5\non: 4\nan: 2\nand: 2\nin: 2\nlance: 2\nthe: 2\nto: 2\naway: 1\nbeef: 1\nbuckler: 1\ncall: 1\ncoursing: 1\ndesire: 1\nextra: 1\nfor: 1\nfridays: 1\ngentlemen: 1\ngreyhound: 1\nhack: 1\nhave: 1\nhis: 1\ni: 1\nincome: 1\nkeep: 1\nla: 1\nlean: 1\nlentils: 1\nlived: 1\nlong: 1\nmade: 1\nmancha: 1\nmind: 1\nmore: 1\nmost: 1\nmutton: 1\nname: 1\nnights: 1\nno: 1\nnot: 1\nold: 1\nolla: 1\none: 1\nor: 1\npigeon: 1\nquarters: 1\nrack: 1\nrather: 1\nsalad: 1\nsaturdays: 1\nscraps: 1\nsince: 1\nso: 1\nsundays: 1\nthan: 1\nthat: 1\nthere: 1\nthose: 1\nthree: 1\nvillage: 1\nwhich: 1\nwith: 1\ncoursing\ndesire\ngentlemen\ngreyhound\nincome\npigeon\nquarters\nsaturdays\nvillage\naway\nbeef\nbuckler\nextra\nfridays\nhave\nkeep\nlance\nlean\nlentils\nlived\nmade\nmancha\nmore\nmutton\nname\nolla\none\nrather\nsalad\nsince\nsundays\nthere\nthose\nthree\na\nan\nand\ncall\nfor\nhack\nhis\ni\nin\nla\nlong\nmind\nmost\nnights\nno\nnot\nof\nold\non\nor\nrack\nscraps\nso\nthan\nthat\nthe\nto\nwhich\nwith\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef calculate_polygon_area(points):\n    n = len(points)\n    area = 0\n    for i in range(n):\n        j = (i + 1) % n\n        area += points[i][0] * points[j][1]\n        area -= points[j][0] * points[i][1]\n    return abs(area) / 2\n\ndef distance(point1, point2):\n    return math.sqrt((point2[0] - point1[0]) ** 2 + (point2[1] - point1[1]) ** 2)\n\ndef sort_points_by_distance(points, ref_point):\n    return sorted(points, key=lambda p: distance(p, ref_point))\n\npolygons = [\n    [(0, 0), (4, 0), (4, 3)],\n    [(1, 1), (3, 1), (2, 2)],\n    [(0, 0), (2, 0), (1, 1)],\n    [(1, 2), (3, 3), (2, 5)],\n    [(2, 1), (4, 2), (3, 4)],\n]\n\nreference_point = (0, 0)\n\nsorted_polygons = sorted(polygons, key=lambda poly: calculate_polygon_area(poly))\nsorted_points = [sort_points_by_distance(poly, reference_point) for poly in sorted_polygons]\n\nfor idx, poly in enumerate(sorted_points):\n    print(f\"Polygon {idx + 1} sorted by distance to {reference_point}: {poly}\")"}, {"role": "assistant", "content": "Polygon 1 sorted by distance to (0, 0): [(1, 1), (2, 2), (3, 1)]\nPolygon 2 sorted by distance to (0, 0): [(0, 0), (1, 1), (2, 0)]\nPolygon 3 sorted by distance to (0, 0): [(1, 2), (3, 3), (2, 5)]\nPolygon 4 sorted by distance to (0, 0): [(2, 1), (4, 2), (3, 4)]\nPolygon 5 sorted by distance to (0, 0): [(0, 0), (4, 0), (4, 3)]\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef calculate_standard_deviation(data):\n    mean = sum(data) / len(data)\n    variance = sum((x - mean) ** 2 for x in data) / len(data)\n    return math.sqrt(variance)\n\ndef find_closest_to_average(data):\n    mean = sum(data) / len(data)\n    return min(data, key=lambda x: abs(x - mean))\n\ndata = [45, 21, 38, 92, 67, 30, 121, 56, 78, 89, 34, 65, 99, 53, 72, 81, 49, 60, 74, 102]\nstd_dev = calculate_standard_deviation(data)\nclosest_to_avg = find_closest_to_average(data)\n\nprint(f\"Standard Deviation: {std_dev:.2f}\")\nprint(f\"Value closest to average: {closest_to_avg}\")\n\ndef binary_search_closest(data, target):\n    left, right = 0, len(data) - 1\n    closest_val = data[0]\n    while left <= right:\n        mid = (left + right) // 2\n        if abs(data[mid] - target) < abs(closest_val - target):\n            closest_val = data[mid]\n        if data[mid] < target:\n            left = mid + 1\n        elif data[mid] > target:\n            right = mid - 1\n        else:\n            return data[mid]\n    return closest_val\n\nsorted_data = sorted(data)\ntarget_values = [50, 100, 70, 90, 110]\n\nfor target in target_values:\n    closest = binary_search_closest(sorted_data, target)\n    print(f\"Closest value to {target} is {closest}\")"}, {"role": "assistant", "content": "Standard Deviation: 25.74\nValue closest to average: 67\nClosest value to 50 is 49\nClosest value to 100 is 99\nClosest value to 70 is 72\nClosest value to 90 is 89\nClosest value to 110 is 102\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"Lorem ipsum dolor sit amet, consectetur adipiscing elit. \nNulla consectetur, justo a pellentesque elementum, libero orci egestas leo, sit amet congue libero ligula in nulla. \nMaecenas eu libero non erat convallis tincidunt. \nPellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas.\"\"\"\n\nsearch_words = [\"Lorem\", \"libero\", \"amet\", \"non\", \"tristique\", \"tempor\"]\n\ndef find_words_in_text(words, text):\n    found_words = {}\n    for word in words:\n        print(f\"Searching for: '{word}'\")\n        matches = re.findall(r'\\b' + re.escape(word) + r'\\b', text)\n        if matches:\n            found_words[word] = len(matches)\n            print(f\"Found '{word}' {len(matches)} times\")\n        else:\n            print(f\"'{word}' not found\")\n    return found_words\n\nword_frequencies = find_words_in_text(search_words, text)\nprint(\"\\nSummary of search results:\")\nfor word, count in word_frequencies.items():\n    print(f\"'{word}': {count} occurrence(s)\")"}, {"role": "assistant", "content": "Searching for: 'Lorem'\nFound 'Lorem' 1 times\nSearching for: 'libero'\nFound 'libero' 3 times\nSearching for: 'amet'\nFound 'amet' 2 times\nSearching for: 'non'\nFound 'non' 1 times\nSearching for: 'tristique'\nFound 'tristique' 1 times\nSearching for: 'tempor'\n'tempor' not found\n\nSummary of search results:\n'Lorem': 1 occurrence(s)\n'libero': 3 occurrence(s)\n'amet': 2 occurrence(s)\n'non': 1 occurrence(s)\n'tristique': 1 occurrence(s)\n"}]}
{"messages": [{"role": "user", "content": "from math import sqrt\n\ndef calculate_distance(p1, p2):\n    return sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\ndef sort_points_by_distance(points, reference):\n    return sorted(points, key=lambda point: calculate_distance(point, reference))\n\ndef simulate_game_logic():\n    players_positions = [\n        (5, 8), (12, 5), (3, 10), (9, 7), (10, 3),\n        (6, 6), (8, 10), (1, 4), (2, 2), (11, 9)\n    ]\n    \n    objective_position = (7, 7)\n    \n    print(\"Objective Position:\", objective_position)\n    print(\"Player Positions:\")\n    for position in players_positions:\n        print(position)\n    \n    sorted_players = sort_points_by_distance(players_positions, objective_position)\n    \n    print(\"\\nPlayers sorted by distance to the objective:\")\n    for position in sorted_players:\n        distance = calculate_distance(position, objective_position)\n        print(f\"Position: {position}, Distance: {distance:.2f}\")\n\nsimulate_game_logic()"}, {"role": "assistant", "content": "Objective Position: (7, 7)\nPlayer Positions:\n(5, 8)\n(12, 5)\n(3, 10)\n(9, 7)\n(10, 3)\n(6, 6)\n(8, 10)\n(1, 4)\n(2, 2)\n(11, 9)\n\nPlayers sorted by distance to the objective:\nPosition: (6, 6), Distance: 1.41\nPosition: (9, 7), Distance: 2.00\nPosition: (5, 8), Distance: 2.24\nPosition: (8, 10), Distance: 3.16\nPosition: (11, 9), Distance: 4.47\nPosition: (3, 10), Distance: 5.00\nPosition: (10, 3), Distance: 5.00\nPosition: (12, 5), Distance: 5.39\nPosition: (1, 4), Distance: 6.71\nPosition: (2, 2), Distance: 7.07\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef sort_dates_descending(date_list):\n    return sorted(date_list)\n\ndate_strings = [\n    \"2023-01-15\", \"2021-05-20\", \"2022-11-11\", \"2020-07-30\",\n    \"2021-12-25\", \"2023-03-01\", \"2022-06-19\", \"2020-08-09\",\n    \"2023-09-22\", \"2021-02-14\", \"2022-04-30\", \"2020-11-11\"\n]\n\ndates = [datetime.datetime.strptime(date, \"%Y-%m-%d\") for date in date_strings]\n\nsorted_dates = sort_dates_descending(dates)\n\nfor date in sorted_dates:\n    print(date.strftime(\"%Y-%m-%d\"))"}, {"role": "assistant", "content": "2020-07-30\n2020-08-09\n2020-11-11\n2021-02-14\n2021-05-20\n2021-12-25\n2022-04-30\n2022-06-19\n2022-11-11\n2023-01-15\n2023-03-01\n2023-09-22\n"}]}
{"messages": [{"role": "user", "content": "def find_possible_moves(board, player):\n    moves = []\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == ' ':\n                moves.append((i, j))\n    return moves\n\ndef check_winner(board):\n    for i in range(3):\n        if board[i][0] == board[i][1] == board[i][2] != ' ':\n            return board[i][0]\n        if board[0][i] == board[1][i] == board[2][i] != ' ':\n            return board[0][i]\n    if board[0][0] == board[1][1] == board[2][2] != ' ':\n        return board[0][0]\n    if board[0][2] == board[1][1] == board[2][0] != ' ':\n        return board[0][2]\n    return None\n\ndef minimax(board, depth, is_maximizing, player, opponent):\n    winner = check_winner(board)\n    if winner == player:\n        return 10 - depth\n    elif winner == opponent:\n        return depth - 10\n    elif not find_possible_moves(board, player):\n        return 0\n\n    if is_maximizing:\n        best_score = float('-inf')\n        for move in find_possible_moves(board, player):\n            board[move[0]][move[1]] = player\n            print(f\"Trying move {move} for player '{player}'\")\n            score = minimax(board, depth + 1, False, player, opponent)\n            board[move[0]][move[1]] = ' '\n            best_score = max(best_score, score)\n        return best_score\n    else:\n        best_score = float('inf')\n        for move in find_possible_moves(board, opponent):\n            board[move[0]][move[1]] = opponent\n            print(f\"Trying move {move} for opponent '{opponent}'\")\n            score = minimax(board, depth + 1, True, player, opponent)\n            board[move[0]][move[1]] = ' '\n            best_score = min(best_score, score)\n        return best_score\n\ndef find_best_move(board, player):\n    opponent = 'O' if player == 'X' else 'X'\n    best_move = None\n    best_value = float('-inf')\n    for move in find_possible_moves(board, player):\n        board[move[0]][move[1]] = player\n        print(f\"Evaluating move {move} for player '{player}'\")\n        move_value = minimax(board, 0, False, player, opponent)\n        board[move[0]][move[1]] = ' '\n        print(f\"Move {move} has value {move_value}\")\n        if move_value > best_value:\n            best_value = move_value\n            best_move = move\n    return best_move\n\ninitial_board = [\n    ['X', 'O', 'X'],\n    ['O', 'X', ' '],\n    [' ', ' ', 'O']\n]\n\nbest_move = find_best_move(initial_board, 'X')\nprint(f\"Best move for 'X' is at position {best_move}\")"}, {"role": "assistant", "content": "Evaluating move (1, 2) for player 'X'\nTrying move (2, 0) for opponent 'O'\nTrying move (2, 1) for player 'X'\nTrying move (2, 1) for opponent 'O'\nTrying move (2, 0) for player 'X'\nMove (1, 2) has value 0\nEvaluating move (2, 0) for player 'X'\nMove (2, 0) has value 10\nEvaluating move (2, 1) for player 'X'\nTrying move (1, 2) for opponent 'O'\nTrying move (2, 0) for player 'X'\nTrying move (2, 0) for opponent 'O'\nTrying move (1, 2) for player 'X'\nMove (2, 1) has value 0\nBest move for 'X' is at position (2, 0)\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndates = [\n    \"2022-01-15 08:45:00\",\n    \"2021-06-07 14:30:00\",\n    \"2023-03-02 07:50:00\",\n    \"2022-12-01 12:15:00\",\n    \"2021-11-19 18:45:00\",\n    \"2023-04-22 05:30:00\",\n    \"2021-09-05 23:59:00\",\n    \"2022-07-13 04:45:00\",\n    \"2023-01-01 00:00:00\",\n    \"2022-05-25 11:25:00\"\n]\n\nparsed_dates = [datetime.strptime(date, \"%Y-%m-%d %H:%M:%S\") for date in dates]\n\nweekday_sorted_dates = sorted(parsed_dates, key=lambda x: x.weekday())\nweekday_grouped_dates = {}\n\nfor date in weekday_sorted_dates:\n    wd = date.weekday()\n    if wd not in weekday_grouped_dates:\n        weekday_grouped_dates[wd] = []\n    weekday_grouped_dates[wd].append(date)\n\nresult = []\nfor wd in sorted(weekday_grouped_dates.keys()):\n    day_dates = sorted(weekday_grouped_dates[wd])\n    for date in day_dates:\n        result.append(date.strftime(\"%A, %Y-%m-%d %H:%M:%S\"))\n\nfor line in result:\n    print(line)"}, {"role": "assistant", "content": "Monday, 2021-06-07 14:30:00\nWednesday, 2022-05-25 11:25:00\nWednesday, 2022-07-13 04:45:00\nThursday, 2022-12-01 12:15:00\nThursday, 2023-03-02 07:50:00\nFriday, 2021-11-19 18:45:00\nSaturday, 2022-01-15 08:45:00\nSaturday, 2023-04-22 05:30:00\nSunday, 2021-09-05 23:59:00\nSunday, 2023-01-01 00:00:00\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef caesar_cipher(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            shift_amount = shift % 26\n            code = ord(char) + shift_amount\n            if char.islower():\n                if code > ord('z'):\n                    code -= 26\n            elif char.isupper():\n                if code > ord('Z'):\n                    code -= 26\n            result += chr(code)\n        else:\n            result += char\n    return result\n\ndef search_encoded_word(text, word):\n    encoded_versions = [caesar_cipher(word, shift) for shift in range(26)]\n    for encoded in encoded_versions:\n        if re.search(r'\\b' + re.escape(encoded) + r'\\b', text):\n            print(f\"Found encoded word '{encoded}' in text.\")\n            return True\n    return False\n\ndef main():\n    text = \"Uifsf jt b tfdsfu dpef jo uijt ufyu.\"\n    word = \"secret\"\n    print(\"Searching for encoded versions of the word in the text...\")\n    if not search_encoded_word(text, word):\n        print(\"No encoded version of the word found in the text.\")\n\nmain()"}, {"role": "assistant", "content": "Searching for encoded versions of the word in the text...\nFound encoded word 'tfdsfu' in text.\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\ndef encrypt_message(message):\n    return ''.join(chr((ord(char) + 3) % 256) for char in message)\n\ndef decrypt_message(encrypted_message):\n    return ''.join(chr((ord(char) - 3) % 256) for char in encrypted_message)\n\ndef sort_dates(dates):\n    return sorted(dates, key=lambda date: datetime.strptime(date, \"%d-%m-%Y\"))\n\nmessages = [\n    \"Meet me at the park\",\n    \"The eagle has landed\",\n    \"Bring the documents\",\n    \"Encryption is fun\",\n    \"Hide the treasure\",\n    \"The cake is a lie\",\n    \"All your base are belong to us\",\n    \"Send backup\",\n    \"Mission completed\",\n    \"Retreat immediately\"\n]\n\nencrypted_messages = [encrypt_message(msg) for msg in messages]\n\ndates = [\n    \"04-07-2023\",\n    \"12-11-2022\",\n    \"23-05-2023\",\n    \"15-01-2023\",\n    \"30-06-2022\",\n    \"01-12-2023\",\n    \"19-09-2022\",\n    \"08-03-2023\",\n    \"27-08-2023\",\n    \"10-10-2022\"\n]\n\nsorted_dates = sort_dates(dates)\n\nprint(\"Original Messages:\")\nfor message in messages:\n    print(message)\n\nprint(\"\\nEncrypted Messages:\")\nfor encrypted in encrypted_messages:\n    print(encrypted)\n\nprint(\"\\nSorted Dates:\")\nfor date in sorted_dates:\n    print(date)\n\ndecrypted_messages = [decrypt_message(enc_msg) for enc_msg in encrypted_messages]\n\nprint(\"\\nDecrypted Messages:\")\nfor decrypted in decrypted_messages:\n    print(decrypted)"}, {"role": "assistant", "content": "Original Messages:\nMeet me at the park\nThe eagle has landed\nBring the documents\nEncryption is fun\nHide the treasure\nThe cake is a lie\nAll your base are belong to us\nSend backup\nMission completed\nRetreat immediately\n\nEncrypted Messages:\nPhhw#ph#dw#wkh#sdun\nWkh#hdjoh#kdv#odqghg\nEulqj#wkh#grfxphqwv\nHqfu|swlrq#lv#ixq\nKlgh#wkh#wuhdvxuh\nWkh#fdnh#lv#d#olh\nDoo#|rxu#edvh#duh#ehorqj#wr#xv\nVhqg#edfnxs\nPlvvlrq#frpsohwhg\nUhwuhdw#lpphgldwho|\n\nSorted Dates:\n30-06-2022\n19-09-2022\n10-10-2022\n12-11-2022\n15-01-2023\n08-03-2023\n23-05-2023\n04-07-2023\n27-08-2023\n01-12-2023\n\nDecrypted Messages:\nMeet me at the park\nThe eagle has landed\nBring the documents\nEncryption is fun\nHide the treasure\nThe cake is a lie\nAll your base are belong to us\nSend backup\nMission completed\nRetreat immediately\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef is_point_inside_polygon(vertices, point):\n    x, y = point\n    n = len(vertices)\n    inside = False\n    px, py = vertices[0]\n\n    for i in range(n + 1):\n        sx, sy = vertices[i % n]\n        if min(py, sy) < y <= max(py, sy) and x <= max(px, sx):\n            if py != sy:\n                xinters = (y - py) * (sx - px) / (sy - py) + px\n            if px == sx or x <= xinters:\n                inside = not inside\n        px, py = sx, sy\n\n    return inside\n\ndef find_largest_polygon(polygons, point):\n    largest_area = 0\n    largest_polygon = None\n\n    for polygon in polygons:\n        if is_point_inside_polygon(polygon, point):\n            area = 0\n            n = len(polygon)\n            for i in range(n):\n                j = (i + 1) % n\n                area += polygon[i][0] * polygon[j][1]\n                area -= polygon[j][0] * polygon[i][1]\n            area = abs(area) / 2.0\n            if area > largest_area:\n                largest_area = area\n                largest_polygon = polygon\n\n    return largest_polygon\n\npolygons = [\n    [(0, 0), (4, 0), (4, 4), (0, 4)],\n    [(1, 1), (2, 1), (1.5, 3)],\n    [(5, 5), (7, 5), (6, 8)]\n]\n\npoint = (3, 3)\nlargest_polygon = find_largest_polygon(polygons, point)\n\nfor vertex in largest_polygon:\n    print(vertex)"}, {"role": "assistant", "content": "(0, 0)\n(4, 0)\n(4, 4)\n(0, 4)\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef search_for_sundays(year):\n    first_day_of_year = datetime(year, 1, 1)\n    last_day_of_year = datetime(year, 12, 31)\n    current_day = first_day_of_year\n    sundays = []\n\n    while current_day <= last_day_of_year:\n        if current_day.weekday() == 6:\n            sundays.append(current_day)\n        current_day += timedelta(days=1)\n\n    return sundays\n\ndef find_sundays_with_same_day_diff(start_year, end_year):\n    result_years = []\n    sundays_start = search_for_sundays(start_year)\n\n    for year in range(start_year + 1, end_year + 1):\n        sundays_current = search_for_sundays(year)\n        if len(sundays_start) == len(sundays_current):\n            days_diff = [(s2 - s1).days for s1, s2 in zip(sundays_start, sundays_current)]\n            if all(d == days_diff[0] for d in days_diff):\n                result_years.append(year)\n\n    return result_years\n\nstart_year = 2000\nend_year = 2022\nresult = find_sundays_with_same_day_diff(start_year, end_year)\nfor year in result:\n    print(f\"Year {year} has Sundays with consistent day differences as year {start_year}\")"}, {"role": "assistant", "content": "Year 2006 has Sundays with consistent day differences as year 2000\nYear 2012 has Sundays with consistent day differences as year 2000\nYear 2017 has Sundays with consistent day differences as year 2000\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef generate_pattern(n):\n    pattern = \"\"\n    for i in range(1, n + 1):\n        pattern += str(i) * i + \"\\n\"\n    return pattern\n\ndef search_pattern(pattern, search):\n    search_result = []\n    for line in pattern.strip().split(\"\\n\"):\n        if re.search(search, line):\n            search_result.append(line)\n    return search_result\n\nn = 20\npattern = generate_pattern(n)\nsearch_results = search_pattern(pattern, r'(.)\\1{1,}')\n\nfor result in search_results:\n    print(result)"}, {"role": "assistant", "content": "22\n333\n4444\n55555\n666666\n7777777\n88888888\n999999999\n1111111111111111111111\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n\ndef calculate_weighted_median(data, weights):\n    sorted_data, sorted_weights = zip(*sorted(zip(data, weights)))\n    cumulative_weight = 0\n    total_weight = sum(sorted_weights)\n    for i in range(len(sorted_data)):\n        cumulative_weight += sorted_weights[i]\n        if cumulative_weight >= total_weight / 2:\n            return sorted_data[i]\n\ndata = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]\nweights = [2, 1, 3, 1, 2, 1, 1, 3, 3, 2, 1]\n\nprint(\"Original Data:\", data)\nprint(\"Weights:\", weights)\n\nbubble_sort(data)\nprint(\"Sorted Data:\", data)\n\nmean = statistics.mean(data)\nmedian = statistics.median(data)\nweighted_median = calculate_weighted_median(data, weights)\n\nprint(\"Mean of data:\", mean)\nprint(\"Median of data:\", median)\nprint(\"Weighted Median of data:\", weighted_median)\n\nsorted_data, sorted_weights = zip(*sorted(zip(data, weights)))\nprint(\"\\nSorted Data with Weights:\")\nfor d, w in zip(sorted_data, sorted_weights):\n    print(f\"Value: {d}, Weight: {w}\")\n\nprint(\"\\nCumulative Weights and Median Check:\")\ncumulative_weight = 0\ntotal_weight = sum(sorted_weights)\nfor i in range(len(sorted_data)):\n    cumulative_weight += sorted_weights[i]\n    print(f\"Value: {sorted_data[i]}, Cumulative Weight: {cumulative_weight}\")\n    if cumulative_weight >= total_weight / 2:\n        print(f\"Weighted median occurs at: {sorted_data[i]}\")\n        break"}, {"role": "assistant", "content": "Original Data: [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]\nWeights: [2, 1, 3, 1, 2, 1, 1, 3, 3, 2, 1]\nSorted Data: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]\nMean of data: 4\nMedian of data: 4\nWeighted Median of data: 4\n\nSorted Data with Weights:\nValue: 1, Weight: 1\nValue: 1, Weight: 2\nValue: 2, Weight: 3\nValue: 3, Weight: 1\nValue: 3, Weight: 2\nValue: 4, Weight: 1\nValue: 5, Weight: 1\nValue: 5, Weight: 3\nValue: 5, Weight: 3\nValue: 6, Weight: 2\nValue: 9, Weight: 1\n\nCumulative Weights and Median Check:\nValue: 1, Cumulative Weight: 1\nValue: 1, Cumulative Weight: 3\nValue: 2, Cumulative Weight: 6\nValue: 3, Cumulative Weight: 7\nValue: 3, Cumulative Weight: 9\nValue: 4, Cumulative Weight: 10\nWeighted median occurs at: 4\n"}]}
{"messages": [{"role": "user", "content": "def generate_pattern(n):\n    pattern = []\n    for i in range(n):\n        line = [str((j + i) % 10) for j in range(n)]\n        pattern.append(''.join(line))\n    return pattern\n\ndef sort_pattern(pattern):\n    return sorted(pattern, key=lambda x: int(x[-1]), reverse=False)\n\nn = 10\npattern = generate_pattern(n)\nsorted_pattern = sort_pattern(pattern)\n\nfor line in sorted_pattern:\n    print(line)"}, {"role": "assistant", "content": "1234567890\n2345678901\n3456789012\n4567890123\n5678901234\n6789012345\n7890123456\n8901234567\n9012345678\n0123456789\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\ndef transform_data(data):\n    transformed = []\n    for item in data:\n        date_str, value = item.split(',')\n        date_obj = datetime.strptime(date_str, '%Y-%m-%d')\n        transformed.append((date_obj, int(value)))\n    return transformed\n\ndef binary_search(data, target):\n    low, high = 0, len(data) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if data[mid][1] == target:\n            return mid\n        elif data[mid][1] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n\ndef search_and_transform(data, target_value):\n    transformed_data = transform_data(data)\n    transformed_data.sort(key=lambda x: x[1])\n    print(\"Transformed and sorted data:\")\n    for item in transformed_data:\n        print(item)\n    index = binary_search(transformed_data, target_value)\n    if index != -1:\n        print(f\"\\nTarget value {target_value} found at index: {index}\")\n    else:\n        print(f\"\\nTarget value {target_value} not found.\")\n\nraw_data = [\n    '2023-10-01,55', '2023-09-21,23', '2023-08-11,9',\n    '2023-07-01,100', '2023-10-15,42', '2023-06-01,78',\n    '2023-01-01,65', '2023-12-01,33', '2023-11-01,88',\n    '2023-05-21,12', '2023-04-15,90', '2023-03-01,47'\n]\n\nsearch_and_transform(raw_data, 42)"}, {"role": "assistant", "content": "Transformed and sorted data:\n(datetime.datetime(2023, 8, 11, 0, 0), 9)\n(datetime.datetime(2023, 5, 21, 0, 0), 12)\n(datetime.datetime(2023, 9, 21, 0, 0), 23)\n(datetime.datetime(2023, 12, 1, 0, 0), 33)\n(datetime.datetime(2023, 10, 15, 0, 0), 42)\n(datetime.datetime(2023, 3, 1, 0, 0), 47)\n(datetime.datetime(2023, 10, 1, 0, 0), 55)\n(datetime.datetime(2023, 1, 1, 0, 0), 65)\n(datetime.datetime(2023, 6, 1, 0, 0), 78)\n(datetime.datetime(2023, 11, 1, 0, 0), 88)\n(datetime.datetime(2023, 4, 15, 0, 0), 90)\n(datetime.datetime(2023, 7, 1, 0, 0), 100)\n\nTarget value 42 found at index: 4\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef find_mode(data):\n    frequencies = {}\n    for num in data:\n        if num in frequencies:\n            frequencies[num] += 1\n        else:\n            frequencies[num] = 1\n    max_freq = max(frequencies.values())\n    return [key for key, value in frequencies.items() if value == max_freq]\n\ndef search_largest_median(data):\n    largest_mode = max(find_mode(data))\n    sorted_data = sorted(data)\n    n = len(sorted_data)\n    if n % 2 == 1:\n        return sorted_data[n // 2] + largest_mode\n    else:\n        return (sorted_data[n // 2 - 1] + sorted_data[n // 2]) / 2 + largest_mode\n\ndataset = [\n    [2, 2, 3, 4, 5, 5, 5, 6, 6, 7],\n    [1, 1, 2, 3, 3, 4, 4, 4, 5, 6],\n    [3, 3, 4, 5, 5, 6, 6, 7, 8, 8],\n    [7, 8, 8, 9, 9, 10, 10, 11, 12, 12],\n    [5, 5, 5, 6, 7, 8, 9, 9, 10, 10]\n]\n\nresults = []\nfor data in dataset:\n    results.append(search_largest_median(data))\n\nfor result in results:\n    print(result)"}, {"role": "assistant", "content": "10.0\n7.5\n13.5\n21.5\n12.5\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"\nIn the age of information, sorting through text data efficiently is crucial.\nSorting algorithms play a significant role in organizing and processing text.\nEach algorithm has its own strengths and weaknesses for different types of data.\nQuick sort, merge sort, and bubble sort are common sorting algorithms.\nUnderstanding these algorithms can help improve text processing tasks.\n\"\"\"\n\nwords = re.findall(r'\\b\\w+\\b', text.lower())\nunique_words = list(set(words))\nsorted_words = sorted(unique_words, key=lambda w: (len(w), w))\n\nfor word in sorted_words:\n    print(word)"}, {"role": "assistant", "content": "a\nin\nis\nof\nage\nand\nare\ncan\nfor\nhas\nits\nown\nthe\ndata\neach\nhelp\nplay\nrole\nsort\ntext\nmerge\nquick\ntasks\nthese\ntypes\nbubble\ncommon\ncrucial\nimprove\nsorting\nthrough\nalgorithm\ndifferent\nstrengths\nalgorithms\norganizing\nprocessing\nweaknesses\nefficiently\ninformation\nsignificant\nunderstanding\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef search_text(text, query):\n    words = re.findall(r'\\b\\w+\\b', text)\n    return binary_search(words, query)\n\ndef binary_search(data, target):\n    left, right = 0, len(data) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if data[mid] == target:\n            return mid\n        elif data[mid] < target:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return -1\n\ntext = (\n    \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. \"\n    \"Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. \"\n    \"Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi \"\n    \"ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit \"\n    \"in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur \"\n    \"sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt \"\n    \"mollit anim id est laborum.\"\n)\n\nqueries = [\n    \"Lorem\", \"dolor\", \"elit\", \"nisi\", \"ullamco\", \n    \"consequat\", \"reprehenderit\", \"velit\", \"occaecat\", \"proident\"\n]\n\nfor query in queries:\n    result = search_text(text, query)\n    print(f\"Query '{query}' found at position: {result}\")"}, {"role": "assistant", "content": "Query 'Lorem' found at position: -1\nQuery 'dolor' found at position: -1\nQuery 'elit' found at position: 7\nQuery 'nisi' found at position: -1\nQuery 'ullamco' found at position: -1\nQuery 'consequat' found at position: -1\nQuery 'reprehenderit' found at position: -1\nQuery 'velit' found at position: -1\nQuery 'occaecat' found at position: -1\nQuery 'proident' found at position: -1\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef calculate_polygon_area(vertices):\n    n = len(vertices)\n    area = 0.0\n    for i in range(n):\n        j = (i + 1) % n\n        area += vertices[i][0] * vertices[j][1]\n        area -= vertices[j][0] * vertices[i][1]\n    return abs(area) / 2.0\n\ndef sort_polygons_by_area(polygons):\n    return sorted(polygons, key=lambda poly: calculate_polygon_area(poly))\n\ndef create_polygon(n, radius):\n    return [(radius * math.cos(2 * math.pi * i / n), radius * math.sin(2 * math.pi * i / n)) for i in range(n)]\n\ndef main():\n    polygons = [\n        create_polygon(3, 1),\n        create_polygon(5, 1),\n        create_polygon(4, 1),\n        create_polygon(6, 1),\n        create_polygon(8, 1),\n        create_polygon(7, 1)\n    ]\n    \n    sorted_polygons = sort_polygons_by_area(polygons)\n\n    for poly in sorted_polygons:\n        print(f\"Polygon with {len(poly)} sides has area: {calculate_polygon_area(poly):.4f}\")\n\nmain()"}, {"role": "assistant", "content": "Polygon with 3 sides has area: 1.2990\nPolygon with 4 sides has area: 2.0000\nPolygon with 5 sides has area: 2.3776\nPolygon with 6 sides has area: 2.5981\nPolygon with 7 sides has area: 2.7364\nPolygon with 8 sides has area: 2.8284\n"}]}
{"messages": [{"role": "user", "content": "def sort_players_by_score(players):\n    return sorted(players, key=lambda x: x['score'], reverse=True)\n\ndef generate_scores(num_players):\n    scores = [(i + 1) * 5 for i in range(num_players)]\n    names = [f\"Player{i+1}\" for i in range(num_players)]\n    players = [{'name': name, 'score': score} for name, score in zip(names, scores)]\n    return players\n\nplayers = generate_scores(10)\nsorted_players = sort_players_by_score(players)\n\nfor player in sorted_players:\n    print(f\"{player['name']}: {player['score']}\")"}, {"role": "assistant", "content": "Player10: 50\nPlayer9: 45\nPlayer8: 40\nPlayer7: 35\nPlayer6: 30\nPlayer5: 25\nPlayer4: 20\nPlayer3: 15\nPlayer2: 10\nPlayer1: 5\n"}]}
{"messages": [{"role": "user", "content": "def linear_search_temperature_drop(temperatures):\n    longest_drop = 0\n    current_drop = 0\n\n    for i in range(1, len(temperatures)):\n        if temperatures[i] < temperatures[i - 1]:\n            current_drop += 1\n            if current_drop > longest_drop:\n                longest_drop = current_drop\n        else:\n            current_drop = 0\n\n    return longest_drop\n\ntemperatures = [\n    68, 67, 66, 65, 66, 65, 64, 63, 62, 63, 64, 65, 66, 65, 64, 63, \n    62, 61, 60, 59, 58, 57, 58, 59, 60, 59, 58, 57, 56, 55, 54, 53, \n    54, 55, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 47, 48, 49, \n    50, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, \n    36, 35, 34, 33, 32, 33, 34, 35, 34, 33, 32, 31, 30, 29, 28, 27, \n    26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, \n    10, 9, 8, 7, 6\n]\n\nprint(\"Longest continuous temperature drop:\", linear_search_temperature_drop(temperatures))"}, {"role": "assistant", "content": "Longest continuous temperature drop: 29\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef is_square(n):\n    sq = int(math.sqrt(n))\n    return sq * sq == n\n\ndef generate_fibonacci_until(n):\n    fibs = [0, 1]\n    while fibs[-1] < n:\n        fibs.append(fibs[-1] + fibs[-2])\n    return fibs[:-1]\n\ndef unique_sorted_squares():\n    fibs = generate_fibonacci_until(10000)\n    print(\"Fibonacci sequence generated:\", fibs)\n    \n    squares = [i * i for i in fibs if is_square(i)]\n    print(\"Perfect squares in Fibonacci sequence:\", squares)\n    \n    unique_squares = list(set(squares))\n    print(\"Unique squares:\", unique_squares)\n    \n    sorted_squares = sorted(unique_squares)\n    print(\"Sorted squares:\", sorted_squares)\n    \n    return sorted_squares\n\nresult = unique_sorted_squares()\nprint(\"Final Result (Sorted Unique Perfect Squares from Fibonacci):\")\nfor num in result:\n    print(num)"}, {"role": "assistant", "content": "Fibonacci sequence generated: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765]\nPerfect squares in Fibonacci sequence: [0, 1, 1, 20736]\nUnique squares: [0, 1, 20736]\nSorted squares: [0, 1, 20736]\nFinal Result (Sorted Unique Perfect Squares from Fibonacci):\n0\n1\n20736\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef is_valid_move(board, move, player):\n    x, y = move\n    n = len(board)\n    if 0 <= x < n and 0 <= y < n and board[x][y] == 0:\n        return True\n    return False\n\ndef get_available_moves(board):\n    moves = []\n    for i in range(len(board)):\n        for j in range(len(board[i])):\n            if board[i][j] == 0:\n                moves.append((i, j))\n    return moves\n\ndef evaluate_board(board, player):\n    n = len(board)\n    for row in board:\n        if all([cell == player for cell in row]):\n            return 10 if player == 1 else -10\n    for col in range(n):\n        if all([board[row][col] == player for row in range(n)]):\n            return 10 if player == 1 else -10\n    if all([board[i][i] == player for i in range(n)]) or all([board[i][n-i-1] == player for i in range(n)]):\n        return 10 if player == 1 else -10\n    return 0\n\ndef minimax(board, depth, is_maximizing, player):\n    opponent = 2 if player == 1 else 1\n    score = evaluate_board(board, player)\n    if score != 0:\n        return score\n    if not get_available_moves(board):\n        return 0\n    if is_maximizing:\n        best = -math.inf\n        for move in get_available_moves(board):\n            board[move[0]][move[1]] = player\n            best = max(best, minimax(board, depth + 1, not is_maximizing, player))\n            board[move[0]][move[1]] = 0\n        return best\n    else:\n        best = math.inf\n        for move in get_available_moves(board):\n            board[move[0]][move[1]] = opponent\n            best = min(best, minimax(board, depth + 1, not is_maximizing, player))\n            board[move[0]][move[1]] = 0\n        return best\n\ndef find_best_move(board, player):\n    best_val = -math.inf\n    best_move = None\n    for move in get_available_moves(board):\n        board[move[0]][move[1]] = player\n        move_val = minimax(board, 0, False, player)\n        board[move[0]][move[1]] = 0\n        if move_val > best_val:\n            best_move = move\n            best_val = move_val\n    return best_move\n\ndef display_board(board):\n    for row in board:\n        print(' '.join(['X' if cell == 1 else 'O' if cell == 2 else '.' for cell in row]))\n    print()\n\nn = 3\nboard = [[0] * n for _ in range(n)]\nmoves = [(0, 0), (1, 1), (0, 2), (2, 2), (1, 0), (0, 1)]\nplayer = 1\n\nfor move in moves:\n    if is_valid_move(board, move, player):\n        board[move[0]][move[1]] = player\n        player = 2 if player == 1 else 1\n\ndisplay_board(board)\n\nbest_move = find_best_move(board, player)\nif best_move:\n    board[best_move[0]][best_move[1]] = player\n\ndisplay_board(board)"}, {"role": "assistant", "content": "X O X\nX O .\n. . O\n\nX O X\nX O .\nX . O\n\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef analyze_temperature_data(temperatures):\n    sorted_temps = sorted(temperatures, reverse=True) \n    median_temp = statistics.mean(sorted_temps)\n    return median_temp\n\ntemperatures = [\n    72.4, 75.0, 71.8, 69.2, 68.5, 74.6, 70.1, 73.8, 76.0, 71.2,\n    70.0, 69.8, 72.1, 74.9, 73.4, 75.5, 70.6, 69.5, 71.5, 76.5\n]\n\nresult = analyze_temperature_data(temperatures)\n\nfor i, temp in enumerate(temperatures, start=1):\n    print(f\"Day {i}: Temperature = {temp}\")\n\nprint(\"\\nAnalyzed median temperature:\", result)"}, {"role": "assistant", "content": "Day 1: Temperature = 72.4\nDay 2: Temperature = 75.0\nDay 3: Temperature = 71.8\nDay 4: Temperature = 69.2\nDay 5: Temperature = 68.5\nDay 6: Temperature = 74.6\nDay 7: Temperature = 70.1\nDay 8: Temperature = 73.8\nDay 9: Temperature = 76.0\nDay 10: Temperature = 71.2\nDay 11: Temperature = 70.0\nDay 12: Temperature = 69.8\nDay 13: Temperature = 72.1\nDay 14: Temperature = 74.9\nDay 15: Temperature = 73.4\nDay 16: Temperature = 75.5\nDay 17: Temperature = 70.6\nDay 18: Temperature = 69.5\nDay 19: Temperature = 71.5\nDay 20: Temperature = 76.5\n\nAnalyzed median temperature: 72.32\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndata = [\n    1.5, 2.3, 4.7, 2.1, 3.8, 4.6, 2.9, 4.3, 3.2, 3.1,\n    3.5, 2.8, 4.1, 1.9, 3.0, 4.4, 2.0, 2.7, 3.4, 4.0,\n    1.6, 2.4, 4.8, 2.2, 3.9, 4.7, 2.6, 4.2, 3.3, 3.0,\n    3.6, 2.9, 4.2, 2.0, 3.2, 4.5, 2.5, 4.3, 3.1, 3.9\n]\n\nmean_value = statistics.mean(data)\nmedian_value = statistics.median(data)\nmode_value = statistics.mode(data)\nstdev_value = statistics.stdev(data)\n\nsorted_data = sorted(data)\nquartiles = [sorted_data[int(len(sorted_data) * i / 4)] for i in range(1, 4)]\n\nprint(\"Sorted Data:\")\nfor value in sorted_data:\n    print(f\"{value:.1f}\")\n\nprint(\"\\nStatistics Summary:\")\nprint(f\"Mean: {mean_value:.2f}\")\nprint(f\"Median: {median_value:.2f}\")\nprint(f\"Mode: {mode_value:.2f}\")\nprint(f\"Standard Deviation: {stdev_value:.2f}\")\nprint(f\"Quartiles: {quartiles}\")"}, {"role": "assistant", "content": "Sorted Data:\n1.5\n1.6\n1.9\n2.0\n2.0\n2.1\n2.2\n2.3\n2.4\n2.5\n2.6\n2.7\n2.8\n2.9\n2.9\n3.0\n3.0\n3.1\n3.1\n3.2\n3.2\n3.3\n3.4\n3.5\n3.6\n3.8\n3.9\n3.9\n4.0\n4.1\n4.2\n4.2\n4.3\n4.3\n4.4\n4.5\n4.6\n4.7\n4.7\n4.8\n\nStatistics Summary:\nMean: 3.28\nMedian: 3.20\nMode: 4.70\nStandard Deviation: 0.94\nQuartiles: [2.6, 3.2, 4.2]\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef create_date_list():\n    base_date = datetime(2023, 1, 1)\n    date_list = [base_date + timedelta(days=i * 50) for i in range(25)]\n    return date_list\n\ndef sort_dates_by_day_of_week(date_list):\n    return sorted(date_list, key=lambda date: date.weekday())\n\ndef format_dates(dates):\n    return [date.strftime(\"%Y-%m-%d %A\") for date in dates]\n\ndates = create_date_list()\nprint(\"Original Dates:\")\nprint(format_dates(dates))\n\nsorted_dates = sort_dates_by_day_of_week(dates)\nprint(\"\\nSorted Dates:\")\nprint(format_dates(sorted_dates))"}, {"role": "assistant", "content": "Original Dates:\n['2023-01-01 Sunday', '2023-02-20 Monday', '2023-04-11 Tuesday', '2023-05-31 Wednesday', '2023-07-20 Thursday', '2023-09-08 Friday', '2023-10-28 Saturday', '2023-12-17 Sunday', '2024-02-05 Monday', '2024-03-26 Tuesday', '2024-05-15 Wednesday', '2024-07-04 Thursday', '2024-08-23 Friday', '2024-10-12 Saturday', '2024-12-01 Sunday', '2025-01-20 Monday', '2025-03-11 Tuesday', '2025-04-30 Wednesday', '2025-06-19 Thursday', '2025-08-08 Friday', '2025-09-27 Saturday', '2025-11-16 Sunday', '2026-01-05 Monday', '2026-02-24 Tuesday', '2026-04-15 Wednesday']\n\nSorted Dates:\n['2023-02-20 Monday', '2024-02-05 Monday', '2025-01-20 Monday', '2026-01-05 Monday', '2023-04-11 Tuesday', '2024-03-26 Tuesday', '2025-03-11 Tuesday', '2026-02-24 Tuesday', '2023-05-31 Wednesday', '2024-05-15 Wednesday', '2025-04-30 Wednesday', '2026-04-15 Wednesday', '2023-07-20 Thursday', '2024-07-04 Thursday', '2025-06-19 Thursday', '2023-09-08 Friday', '2024-08-23 Friday', '2025-08-08 Friday', '2023-10-28 Saturday', '2024-10-12 Saturday', '2025-09-27 Saturday', '2023-01-01 Sunday', '2023-12-17 Sunday', '2024-12-01 Sunday', '2025-11-16 Sunday']\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef is_palindrome(s):\n    return s == s[::-1]\n\ndef generate_pattern(n):\n    pattern = []\n    for i in range(1, n + 1):\n        line = ' '.join(str(x) for x in range(1, i + 1))\n        pattern.append(line)\n    return pattern\n\ndef search_palindrome_pattern(n):\n    pattern = generate_pattern(n)\n    palindrome_patterns = []\n    for line in pattern:\n        if is_palindrome(re.sub(r'\\s+', '', line)):\n            palindrome_patterns.append(line)\n    return palindrome_patterns\n\ndef main():\n    n = 20\n    palindromes = search_palindrome_pattern(n)\n    for p in palindromes:\n        print(p)\n\nif __name__ == \"__main__\":\n    main()"}, {"role": "assistant", "content": "1\n"}]}
{"messages": [{"role": "user", "content": "import statistics as stats\n\ndata = [\n    21, 34, 55, 13, 8, 89, 144, 233, 377, 610, 987,\n    1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025\n]\n\ndef binary_search(arr, target):\n    low, high = 0, len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n\nmean = stats.mean(data)\nmedian = stats.median(data)\nstdev = stats.stdev(data)\n\nmean_index = binary_search(data, round(mean))\nmedian_index = binary_search(data, median)\nstdev_index = binary_search(data, round(stdev))\n\nindices = [mean_index, median_index, stdev_index]\n\nfor index in indices:\n    if index != -1:\n        print(f\"Value: {data[index]}, Index: {index}\")\n    else:\n        print(\"Value not found in data\")"}, {"role": "assistant", "content": "Value not found in data\nValue not found in data\nValue not found in data\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef pattern_generator(n):\n    pattern = []\n    for i in range(1, n + 1):\n        row = [(i * j) % 10 for j in range(1, n + 1)]\n        pattern.append(row)\n    return pattern\n\ndef custom_sort(row):\n    mid_index = len(row) // 2\n    return row[mid_index:]\n\ndef print_pattern(pattern):\n    for row in pattern:\n        print(' '.join(str(num) for num in row))\n\ndef sort_pattern(pattern):\n    print(\"Original pattern:\")\n    print_pattern(pattern)\n    pattern.sort(key=custom_sort)\n    print(\"\\nSorted pattern:\")\n    print_pattern(pattern)\n\nsize = 10\ngenerated_pattern = pattern_generator(size)\nsort_pattern(generated_pattern)"}, {"role": "assistant", "content": "Original pattern:\n1 2 3 4 5 6 7 8 9 0\n2 4 6 8 0 2 4 6 8 0\n3 6 9 2 5 8 1 4 7 0\n4 8 2 6 0 4 8 2 6 0\n5 0 5 0 5 0 5 0 5 0\n6 2 8 4 0 6 2 8 4 0\n7 4 1 8 5 2 9 6 3 0\n8 6 4 2 0 8 6 4 2 0\n9 8 7 6 5 4 3 2 1 0\n0 0 0 0 0 0 0 0 0 0\n\nSorted pattern:\n0 0 0 0 0 0 0 0 0 0\n5 0 5 0 5 0 5 0 5 0\n2 4 6 8 0 2 4 6 8 0\n7 4 1 8 5 2 9 6 3 0\n9 8 7 6 5 4 3 2 1 0\n4 8 2 6 0 4 8 2 6 0\n6 2 8 4 0 6 2 8 4 0\n1 2 3 4 5 6 7 8 9 0\n3 6 9 2 5 8 1 4 7 0\n8 6 4 2 0 8 6 4 2 0\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef date_to_string(date):\n    return date.strftime(\"%Y-%m-%d\")\n\ndef binary_search(dates, target):\n    low, high = 0, len(dates) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        print(f\"Searching between {date_to_string(dates[low])} and {date_to_string(dates[high])}, middle: {date_to_string(dates[mid])}\")\n        if dates[mid] == target:\n            return mid\n        elif dates[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n\nstart_date = datetime(2023, 1, 1)\nend_date = datetime(2023, 4, 1)\ndelta = timedelta(days=1)\n\ndate_list = []\ncurrent_date = start_date\nwhile current_date <= end_date:\n    date_list.append(current_date)\n    current_date += delta\n\ntarget_date = datetime(2023, 2, 15)\nindex = binary_search(date_list, target_date)\n\nif index != -1:\n    print(f\"Date {date_to_string(target_date)} found at index: {index}\")\nelse:\n    print(f\"Date {date_to_string(target_date)} not found in the list\")"}, {"role": "assistant", "content": "Searching between 2023-01-01 and 2023-04-01, middle: 2023-02-15\nDate 2023-02-15 found at index: 45\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef generate_dates(start_date, end_date):\n    current_date = start_date\n    dates = []\n    while current_date <= end_date:\n        dates.append(current_date)\n        current_date += timedelta(days=1)\n    return dates\n\ndef is_palindrome(date_str):\n    return date_str == date_str[::-1]\n\ndef find_palindrome_dates(dates):\n    palindrome_dates = []\n    for date in dates:\n        date_str = date.strftime('%Y%m%d')\n        if is_palindrome(date_str):\n            palindrome_dates.append(date)\n    return palindrome_dates\n\nstart_date = datetime(2000, 1, 1)\nend_date = datetime(2099, 12, 31)\ndates = generate_dates(start_date, end_date)\npalindrome_dates = find_palindrome_dates(dates)\n\nfor date in palindrome_dates:\n    print(date.strftime('%Y-%m-%d'))"}, {"role": "assistant", "content": "2001-10-02\n2010-01-02\n2011-11-02\n2020-02-02\n2021-12-02\n2030-03-02\n2040-04-02\n2050-05-02\n2060-06-02\n2070-07-02\n2080-08-02\n2090-09-02\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef transform_date(date_str):\n    return datetime.datetime.strptime(date_str, \"%Y-%m-%d\")\n\ndates = [\n    \"2023-01-15\", \"2022-05-23\", \"2023-11-03\", \"2022-12-25\", \"2023-07-04\",\n    \"2022-08-14\", \"2023-03-19\", \"2023-09-09\", \"2023-04-20\", \"2022-11-11\",\n    \"2023-10-10\", \"2022-03-03\", \"2023-06-06\", \"2022-01-01\", \"2023-08-08\"\n]\n\ndates_transformed = [(date, transform_date(date)) for date in dates]\n\nprint(\"Transformed Dates:\")\nfor original, transformed in dates_transformed:\n    print(f\"{original} -> {transformed}\")\n\nsorted_dates = sorted(dates_transformed, key=lambda x: x[1])\n\nprint(\"\\nSorted Dates:\")\nfor original, transformed in sorted_dates:\n    print(f\"{original} -> {transformed}\")\n\nunique_months = sorted(set(d[1].month for d in sorted_dates))\nprint(\"\\nUnique Months in Sorted Dates:\")\nfor month in unique_months:\n    print(month)\n\nprint(\"\\nDates Grouped by Month:\")\n\ngrouped_data = {}\nfor original, transformed in sorted_dates:\n    month = transformed.month\n    if month not in grouped_data:\n        grouped_data[month] = []\n    grouped_data[month].append(original)\n\nfor month in unique_months:\n    print(f\"Month {month}: {grouped_data[month]}\")"}, {"role": "assistant", "content": "Transformed Dates:\n2023-01-15 -> 2023-01-15 00:00:00\n2022-05-23 -> 2022-05-23 00:00:00\n2023-11-03 -> 2023-11-03 00:00:00\n2022-12-25 -> 2022-12-25 00:00:00\n2023-07-04 -> 2023-07-04 00:00:00\n2022-08-14 -> 2022-08-14 00:00:00\n2023-03-19 -> 2023-03-19 00:00:00\n2023-09-09 -> 2023-09-09 00:00:00\n2023-04-20 -> 2023-04-20 00:00:00\n2022-11-11 -> 2022-11-11 00:00:00\n2023-10-10 -> 2023-10-10 00:00:00\n2022-03-03 -> 2022-03-03 00:00:00\n2023-06-06 -> 2023-06-06 00:00:00\n2022-01-01 -> 2022-01-01 00:00:00\n2023-08-08 -> 2023-08-08 00:00:00\n\nSorted Dates:\n2022-01-01 -> 2022-01-01 00:00:00\n2022-03-03 -> 2022-03-03 00:00:00\n2022-05-23 -> 2022-05-23 00:00:00\n2022-08-14 -> 2022-08-14 00:00:00\n2022-11-11 -> 2022-11-11 00:00:00\n2022-12-25 -> 2022-12-25 00:00:00\n2023-01-15 -> 2023-01-15 00:00:00\n2023-03-19 -> 2023-03-19 00:00:00\n2023-04-20 -> 2023-04-20 00:00:00\n2023-06-06 -> 2023-06-06 00:00:00\n2023-07-04 -> 2023-07-04 00:00:00\n2023-08-08 -> 2023-08-08 00:00:00\n2023-09-09 -> 2023-09-09 00:00:00\n2023-10-10 -> 2023-10-10 00:00:00\n2023-11-03 -> 2023-11-03 00:00:00\n\nUnique Months in Sorted Dates:\n1\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\nDates Grouped by Month:\nMonth 1: ['2022-01-01', '2023-01-15']\nMonth 3: ['2022-03-03', '2023-03-19']\nMonth 4: ['2023-04-20']\nMonth 5: ['2022-05-23']\nMonth 6: ['2023-06-06']\nMonth 7: ['2023-07-04']\nMonth 8: ['2022-08-14', '2023-08-08']\nMonth 9: ['2023-09-09']\nMonth 10: ['2023-10-10']\nMonth 11: ['2022-11-11', '2023-11-03']\nMonth 12: ['2022-12-25']\n"}]}
{"messages": [{"role": "user", "content": "import re\nfrom collections import Counter\n\ndef sort_words_by_vowel_count(text):\n    words = re.findall(r'\\b\\w+\\b', text)\n    vowels = 'aeiou'\n    \n    def vowel_count(word):\n        return sum(word.count(v) for v in vowels)\n    \n    words_sorted = sorted(words, key=vowel_count, reverse=True)\n    return words_sorted\n\nparagraph = \"\"\"\nLorem ipsum dolor sit amet, consectetur adipiscing elit. \nVestibulum vulputate, sapien non tincidunt facilisis, eros est gravida purus, \nat fermentum libero velit ut purus. Nulla facilisi. \nPellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas.\n\"\"\"\n\nsorted_words = sort_words_by_vowel_count(paragraph)\n\nfor word, count in Counter(sorted_words).most_common():\n    print(f\"{word}: {count}\")"}, {"role": "assistant", "content": "purus: 2\net: 2\nPellentesque: 1\nmalesuada: 1\nconsectetur: 1\nadipiscing: 1\nVestibulum: 1\nvulputate: 1\nfacilisis: 1\nfacilisi: 1\ntristique: 1\nsapien: 1\ntincidunt: 1\ngravida: 1\nfermentum: 1\nlibero: 1\nhabitant: 1\nsenectus: 1\negestas: 1\nLorem: 1\nipsum: 1\ndolor: 1\namet: 1\nelit: 1\neros: 1\nvelit: 1\nNulla: 1\nmorbi: 1\nnetus: 1\nfames: 1\nturpis: 1\nsit: 1\nnon: 1\nest: 1\nat: 1\nut: 1\nac: 1\n"}]}
{"messages": [{"role": "user", "content": "def generate_fibonacci(n):\n    sequence = [0, 1]\n    for _ in range(2, n):\n        sequence.append(sequence[-1] + sequence[-2])\n    return sequence\n\ndef sort_by_last_digit(numbers):\n    print(\"Sorting by last digit...\")\n    sorted_numbers = sorted(numbers, key=lambda x: x % 10)\n    print(f\"Sorted list: {sorted_numbers}\")\n    return sorted_numbers\n\ndef main():\n    n = 50\n    print(f\"Generating first {n} Fibonacci numbers...\")\n    fibonacci_sequence = generate_fibonacci(n)\n    print(f\"Initial Fibonacci sequence: {fibonacci_sequence}\")\n    \n    sorted_sequence = sort_by_last_digit(fibonacci_sequence)\n    \n    print(\"\\nFinal sorted Fibonacci sequence by last digit:\")\n    for number in sorted_sequence:\n        print(number)\n\nmain()"}, {"role": "assistant", "content": "Generating first 50 Fibonacci numbers...\nInitial Fibonacci sequence: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073, 4807526976, 7778742049]\nSorting by last digit...\nSorted list: [0, 610, 832040, 1134903170, 1, 1, 21, 4181, 17711, 317811, 165580141, 2, 14930352, 3, 13, 233, 121393, 701408733, 1836311903, 2971215073, 34, 144, 2584, 5, 55, 6765, 75025, 9227465, 102334155, 10946, 63245986, 267914296, 4807526976, 377, 987, 1597, 28657, 5702887, 24157817, 433494437, 8, 46368, 196418, 3524578, 89, 514229, 1346269, 2178309, 39088169, 7778742049]\n\nFinal sorted Fibonacci sequence by last digit:\n0\n610\n832040\n1134903170\n1\n1\n21\n4181\n17711\n317811\n165580141\n2\n14930352\n3\n13\n233\n121393\n701408733\n1836311903\n2971215073\n34\n144\n2584\n5\n55\n6765\n75025\n9227465\n102334155\n10946\n63245986\n267914296\n4807526976\n377\n987\n1597\n28657\n5702887\n24157817\n433494437\n8\n46368\n196418\n3524578\n89\n514229\n1346269\n2178309\n39088169\n7778742049\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"The quick brown fox jumps over the lazy dog. Why does the fox jump? \nIs it because the dog is lazy, or is it just a playful nature? \nFoxes are known to be clever and quick, often outsmarting their opponents.\"\"\"\n\nsearch_terms = [\n    \"fox\",\n    \"dog\",\n    \"quick\",\n    \"lazy\",\n    \"playful\",\n    \"smart\",\n    \"nature\",\n    \"clever\",\n    \"opponents\"\n]\n\ndef search_terms_positions(text, terms):\n    positions = {}\n    for term in terms:\n        matches = [m.start() for m in re.finditer(r'\\b' + re.escape(term) + r'\\b', text)]\n        if matches:\n            positions[term] = matches\n    return positions\n\nterm_positions = search_terms_positions(text, search_terms)\nsorted_terms = sorted(term_positions.items(), key=lambda x: x[1][0])\n\nfor term, positions in sorted_terms:\n    print(f\"{term}: {positions}\")"}, {"role": "assistant", "content": "quick: [4, 166]\nfox: [16, 58]\nlazy: [35, 94]\ndog: [40, 87]\nplayful: [116]\nnature: [124]\nclever: [155]\nopponents: [197]\n"}]}
{"messages": [{"role": "user", "content": "def is_fibonacci_number(n, fib_sequence):\n    return n in fib_sequence\n\ndef generate_fibonacci_sequence(limit):\n    fib_sequence = [0, 1]\n    while True:\n        next_fib = fib_sequence[-1] + fib_sequence[-2]\n        if next_fib > limit:\n            break\n        fib_sequence.append(next_fib)\n    return fib_sequence\n\ndef search_fibonacci_like_sequence(n, limit):\n    fib_sequence = generate_fibonacci_sequence(limit)\n    print(\"Generated Fibonacci sequence up to limit:\", fib_sequence)\n    sequence = []\n    for i in range(2, n + 2):\n        sequence.append(i * i - 1)\n    print(\"Generated sequence to search:\", sequence)\n    fib_like_numbers = []\n    for number in sequence:\n        if is_fibonacci_number(number, fib_sequence):\n            fib_like_numbers.append(number)\n    return fib_like_numbers\n\nlimit = 1000\nn = 50\nfib_like_numbers = search_fibonacci_like_sequence(n, limit)\nprint(\"Numbers from the sequence that are also Fibonacci numbers:\")\nfor number in fib_like_numbers:\n    print(number)"}, {"role": "assistant", "content": "Generated Fibonacci sequence up to limit: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987]\nGenerated sequence to search: [3, 8, 15, 24, 35, 48, 63, 80, 99, 120, 143, 168, 195, 224, 255, 288, 323, 360, 399, 440, 483, 528, 575, 624, 675, 728, 783, 840, 899, 960, 1023, 1088, 1155, 1224, 1295, 1368, 1443, 1520, 1599, 1680, 1763, 1848, 1935, 2024, 2115, 2208, 2303, 2400, 2499, 2600]\nNumbers from the sequence that are also Fibonacci numbers:\n3\n8\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef analyze_data(data, target):\n    results = []\n    for i in range(len(data)):\n        for j in range(i + 1, len(data)):\n            if math.isclose(data[i] * data[j], target, rel_tol=1e-9):\n                results.append((data[i], data[j]))\n    return results\n\ndata = [\n    1.414213562, 1.732050808, 2.236067977, 2.645751311, 3.162277660,\n    3.605551275, 4.123105625, 4.472135955, 5.099019514, 5.385164807,\n    5.656854249, 5.916079783, 6.082762530, 6.324555320, 6.480740698,\n    6.708203932, 7.211102551, 7.348469228, 7.615773106, 7.810249676\n]\n\ntargets = [\n    7.0, 10.0, 12.0, 17.0, 20.0, 25.0, 30.0, 35.0, 40.0, 45.0, 50.0\n]\n\nfor target in targets:\n    pairs = analyze_data(data, target)\n    print(f\"Target {target}: {len(pairs)} pairs found - {pairs}\")"}, {"role": "assistant", "content": "Target 7.0: 0 pairs found - []\nTarget 10.0: 1 pairs found - [(2.236067977, 4.472135955)]\nTarget 12.0: 0 pairs found - []\nTarget 17.0: 0 pairs found - []\nTarget 20.0: 1 pairs found - [(3.16227766, 6.32455532)]\nTarget 25.0: 0 pairs found - []\nTarget 30.0: 1 pairs found - [(4.472135955, 6.708203932)]\nTarget 35.0: 0 pairs found - []\nTarget 40.0: 0 pairs found - []\nTarget 45.0: 0 pairs found - []\nTarget 50.0: 0 pairs found - []\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\nevents = [\n    (\"2023-11-01 15:30:00\", \"Launch Event\"),\n    (\"2023-11-01 10:00:00\", \"Team Meeting\"),\n    (\"2023-11-01 12:45:00\", \"Lunch Break\"),\n    (\"2023-11-01 09:00:00\", \"Morning Briefing\"),\n    (\"2023-11-01 14:00:00\", \"Project Update\"),\n    (\"2023-11-01 11:30:00\", \"Client Call\"),\n    (\"2023-11-01 13:15:00\", \"Code Review\"),\n    (\"2023-11-01 08:30:00\", \"Coffee\"),\n]\n\nparsed_events = [(datetime.strptime(time, \"%Y-%m-%d %H:%M:%S\"), desc) for time, desc in events]\nsorted_events = sorted(parsed_events, key=lambda event: event[0])\n\nfor event in sorted_events:\n    print(event[0].strftime(\"%Y-%m-%d %H:%M:%S\"), event[1])"}, {"role": "assistant", "content": "2023-11-01 08:30:00 Coffee\n2023-11-01 09:00:00 Morning Briefing\n2023-11-01 10:00:00 Team Meeting\n2023-11-01 11:30:00 Client Call\n2023-11-01 12:45:00 Lunch Break\n2023-11-01 13:15:00 Code Review\n2023-11-01 14:00:00 Project Update\n2023-11-01 15:30:00 Launch Event\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef distance_from_origin(point):\n    return math.sqrt(point[0] ** 2 + point[1] ** 2)\n\ndef calculate_area(points):\n    area = 0.0\n    n = len(points)\n    for i in range(n):\n        j = (i + 1) % n\n        area += points[i][0] * points[j][1]\n        area -= points[j][0] * points[i][1]\n    area = abs(area) / 2.0\n    return area\n\ndef sort_points_by_distance(points):\n    return sorted(points, key=distance_from_origin)\n\ndef format_points(points):\n    return [f\"({x}, {y})\" for x, y in points]\n\npoints = [\n    (3, 4), (1, 2), (5, 0), (0, 5), (4, 3), \n    (2, 1), (1, 1), (3, 3), (2, 2), (5, 5)\n]\n\nsorted_points = sort_points_by_distance(points)\nformatted_points = format_points(sorted_points)\n\nfor point in formatted_points:\n    print(point)\n\nprint(f\"Polygon area: {calculate_area(sorted_points)}\")"}, {"role": "assistant", "content": "(1, 1)\n(1, 2)\n(2, 1)\n(2, 2)\n(3, 3)\n(3, 4)\n(5, 0)\n(0, 5)\n(4, 3)\n(5, 5)\nPolygon area: 3.5\n"}]}
{"messages": [{"role": "user", "content": "import itertools\n\nclass MazeSolver:\n    def __init__(self, maze):\n        self.maze = maze\n        self.start = None\n        self.end = None\n        self.rows = len(maze)\n        self.cols = len(maze[0])\n        self._find_start_end()\n\n    def _find_start_end(self):\n        for i in range(self.rows):\n            for j in range(self.cols):\n                if self.maze[i][j] == 'S':\n                    self.start = (i, j)\n                elif self.maze[i][j] == 'E':\n                    self.end = (i, j)\n\n    def is_valid_move(self, x, y, visited):\n        return 0 <= x < self.rows and 0 <= y < self.cols and self.maze[x][y] != '#' and not visited[x][y]\n\n    def search_path(self):\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        visited = [[False] * self.cols for _ in range(self.rows)]\n        path = []\n\n        def dfs(x, y):\n            if (x, y) == self.end:\n                return True\n            visited[x][y] = True\n            path.append((x, y))\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if self.is_valid_move(nx, ny, visited):\n                    if dfs(nx, ny):\n                        return True\n            path.pop()\n            return False\n\n        dfs(*self.start)\n        return path\n\nmaze = [\n    ['#', '#', '#', '#', '#', '#', '#'],\n    ['#', 'S', '.', '.', '#', '.', '#'],\n    ['#', '.', '#', '.', '#', '.', '#'],\n    ['#', '.', '#', '.', '.', '.', '#'],\n    ['#', '.', '#', '#', '#', '.', '#'],\n    ['#', '.', '.', '.', '#', '.', 'E'],\n    ['#', '#', '#', '#', '#', '#', '#']\n]\n\nsolver = MazeSolver(maze)\npath = solver.search_path()\n\nfor i in range(len(maze)):\n    for j in range(len(maze[i])):\n        if (i, j) in path:\n            print('P', end=' ')\n        else:\n            print(maze[i][j], end=' ')\n    print()"}, {"role": "assistant", "content": "# # # # # # # \n# P P P # . # \n# . # P # . # \n# . # P P P # \n# . # # # P # \n# . . . # P E \n# # # # # # # \n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort(left_half)\n        merge_sort(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n\ndata = [5, 1, 9, 3, 7, 4, 2, 6, 8, 0, 10, 12, 11, 15, 13, 14]\nprint(\"Original data:\", data)\nmerge_sort(data)\nprint(\"Sorted data:\", data)\n\nmean = statistics.mean(data)\nprint(\"Mean:\", mean)\n\nvariance = statistics.variance(data)\nprint(\"Variance:\", variance)\n\ndef find_median(arr):\n    n = len(arr)\n    if n % 2 == 0:\n        median_val = (arr[n//2 - 1] + arr[n//2]) / 2\n    else:\n        median_val = arr[n//2]\n    return median_val\n\nmedian = find_median(data)\nprint(\"Median:\", median)\n\ndef find_mode(arr):\n    frequency = {}\n    for num in arr:\n        frequency[num] = frequency.get(num, 0) + 1\n\n    max_freq = max(frequency.values())\n    mode = [k for k, v in frequency.items() if v == max_freq]\n    return mode, max_freq\n\nmode, mode_freq = find_mode(data)\nprint(\"Mode(s):\", mode, \"Frequency:\", mode_freq)"}, {"role": "assistant", "content": "Original data: [5, 1, 9, 3, 7, 4, 2, 6, 8, 0, 10, 12, 11, 15, 13, 14]\nSorted data: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\nMean: 7.5\nVariance: 22.666666666666668\nMedian: 7.5\nMode(s): [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] Frequency: 1\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef encode_message(message):\n    encoded = []\n    for char in message:\n        encoded.append(ord(char) * 3)\n    return encoded\n\ndef decode_message(encoded):\n    decoded = []\n    for num in encoded:\n        decoded.append(chr(num // 3))\n    return ''.join(decoded)\n\ndef custom_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] % 10 > arr[j+1] % 10:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\n\nmessage = \"AdvancedEncryption\"\nencoded = encode_message(message)\nprint(f\"Encoded message: {encoded}\")\n\nsorted_encoded = custom_sort(encoded)\nprint(f\"Sorted encoded message: {sorted_encoded}\")\n\ndecoded_message = decode_message(sorted_encoded)\nprint(f\"Decoded message: {decoded_message}\")\n\noriginal_sorted_indices = sorted(range(len(encoded)), key=lambda k: encoded[k] % 10)\nrecovered_encoded = [sorted_encoded[i] for i in original_sorted_indices]\n\nrecovered_message = decode_message(recovered_encoded)\nprint(f\"Recovered message: {recovered_message}\")"}, {"role": "assistant", "content": "Encoded message: [195, 300, 354, 291, 330, 297, 303, 300, 207, 330, 297, 342, 363, 336, 348, 315, 333, 330]\nSorted encoded message: [300, 330, 300, 330, 330, 291, 342, 303, 363, 333, 354, 195, 315, 336, 297, 207, 297, 348]\nDecoded message: dndnnareyovAipcEct\nRecovered message: dndnnareyovAipcEct\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef is_weekend(date):\n    return date.weekday() >= 5\n\ndef find_next_n_weekends(start_date, n):\n    current_date = start_date\n    weekends = []\n    while len(weekends) < n:\n        if is_weekend(current_date):\n            weekends.append(current_date)\n        current_date += timedelta(days=1)\n    return weekends\n\ndef main():\n    start_date = datetime.strptime(\"2023-10-01\", \"%Y-%m-%d\")\n    weekends = find_next_n_weekends(start_date, 50)\n    \n    print(\"First 50 weekends starting from\", start_date.strftime(\"%Y-%m-%d\"))\n    for weekend in weekends:\n        print(weekend.strftime(\"%A, %B %d, %Y\"))\n\nif __name__ == \"__main__\":\n    main()"}, {"role": "assistant", "content": "First 50 weekends starting from 2023-10-01\nSunday, October 01, 2023\nSaturday, October 07, 2023\nSunday, October 08, 2023\nSaturday, October 14, 2023\nSunday, October 15, 2023\nSaturday, October 21, 2023\nSunday, October 22, 2023\nSaturday, October 28, 2023\nSunday, October 29, 2023\nSaturday, November 04, 2023\nSunday, November 05, 2023\nSaturday, November 11, 2023\nSunday, November 12, 2023\nSaturday, November 18, 2023\nSunday, November 19, 2023\nSaturday, November 25, 2023\nSunday, November 26, 2023\nSaturday, December 02, 2023\nSunday, December 03, 2023\nSaturday, December 09, 2023\nSunday, December 10, 2023\nSaturday, December 16, 2023\nSunday, December 17, 2023\nSaturday, December 23, 2023\nSunday, December 24, 2023\nSaturday, December 30, 2023\nSunday, December 31, 2023\nSaturday, January 06, 2024\nSunday, January 07, 2024\nSaturday, January 13, 2024\nSunday, January 14, 2024\nSaturday, January 20, 2024\nSunday, January 21, 2024\nSaturday, January 27, 2024\nSunday, January 28, 2024\nSaturday, February 03, 2024\nSunday, February 04, 2024\nSaturday, February 10, 2024\nSunday, February 11, 2024\nSaturday, February 17, 2024\nSunday, February 18, 2024\nSaturday, February 24, 2024\nSunday, February 25, 2024\nSaturday, March 02, 2024\nSunday, March 03, 2024\nSaturday, March 09, 2024\nSunday, March 10, 2024\nSaturday, March 16, 2024\nSunday, March 17, 2024\nSaturday, March 23, 2024\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\nevents = [\n    (\"Event 1\", datetime(2023, 6, 15)),\n    (\"Event 2\", datetime(2023, 5, 20)),\n    (\"Event 3\", datetime(2023, 9, 10)),\n    (\"Event 4\", datetime(2023, 8, 5)),\n    (\"Event 5\", datetime(2023, 7, 25)),\n    (\"Event 6\", datetime(2023, 11, 1)),\n    (\"Event 7\", datetime(2023, 12, 15)),\n    (\"Event 8\", datetime(2023, 1, 30)),\n    (\"Event 9\", datetime(2023, 3, 12)),\n    (\"Event 10\", datetime(2023, 4, 27)),\n    (\"Event 11\", datetime(2023, 2, 16)),\n    (\"Event 12\", datetime(2023, 10, 8))\n]\n\ntoday = datetime(2023, 4, 1)\nfuture_events = [(name, date) for name, date in events if date > today]\nsorted_events = sorted(future_events, key=lambda x: x[1])\n\nfor name, date in sorted_events:\n    days_until = (date - today).days\n    print(f\"{name} is in {days_until} days.\")"}, {"role": "assistant", "content": "Event 10 is in 26 days.\nEvent 2 is in 49 days.\nEvent 1 is in 75 days.\nEvent 5 is in 115 days.\nEvent 4 is in 126 days.\nEvent 3 is in 162 days.\nEvent 12 is in 190 days.\nEvent 6 is in 214 days.\nEvent 7 is in 258 days.\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\nclass Player:\n    def __init__(self, name, join_time):\n        self.name = name\n        self.join_time = join_time\n\ndef bubble_sort(players):\n    n = len(players)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if players[j].join_time > players[j + 1].join_time:\n                players[j], players[j + 1] = players[j + 1], players[j]\n                print(f\"Swapped: {players[j].name} with {players[j+1].name}\")\n\ndef game_logic():\n    players = [\n        Player(\"Alice\", datetime.now() - timedelta(minutes=30)),\n        Player(\"Bob\", datetime.now() - timedelta(minutes=5)),\n        Player(\"Charlie\", datetime.now() - timedelta(minutes=20)),\n        Player(\"David\", datetime.now() - timedelta(minutes=15)),\n        Player(\"Eve\", datetime.now() - timedelta(minutes=10))\n    ]\n    \n    print(\"Players before sorting by join time:\")\n    for player in players:\n        print(f\"{player.name} - {player.join_time.strftime('%H:%M:%S')}\")\n\n    bubble_sort(players)\n\n    print(\"\\nPlayers after sorting by join time:\")\n    for player in players:\n        print(f\"{player.name} - {player.join_time.strftime('%H:%M:%S')}\")\n\ngame_logic()"}, {"role": "assistant", "content": "Players before sorting by join time:\nAlice - 15:36:39\nBob - 16:01:39\nCharlie - 15:46:39\nDavid - 15:51:39\nEve - 15:56:39\nSwapped: Charlie with Bob\nSwapped: David with Bob\nSwapped: Eve with Bob\n\nPlayers after sorting by join time:\nAlice - 15:36:39\nCharlie - 15:46:39\nDavid - 15:51:39\nEve - 15:56:39\nBob - 16:01:39\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef caesar_cipher(text, shift):\n    encrypted_text = \"\"\n    for char in text:\n        if char.isalpha():\n            shift_amount = 65 if char.isupper() else 97\n            encrypted_text += chr((ord(char) - shift_amount + shift) % 26 + shift_amount)\n        else:\n            encrypted_text += char\n    return encrypted_text\n\ndef contains_substring(encrypted_text, substring):\n    return re.search(substring, encrypted_text) is not None\n\ndef search_caesar_cipher(text, substring):\n    candidates = []\n    for shift in range(26):\n        encrypted_text = caesar_cipher(text, shift)\n        if contains_substring(encrypted_text, substring):\n            candidates.append((shift, encrypted_text))\n    return candidates\n\ntext = \"Encryption is fun and secure\"\nsubstring = \"fun\"\nresults = search_caesar_cipher(text, substring)\n\nfor shift, encrypted in results:\n    print(f\"Shift: {shift}, Encrypted Text: {encrypted}\")"}, {"role": "assistant", "content": "Shift: 0, Encrypted Text: Encryption is fun and secure\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef sort_dates_by_day(dates):\n    return sorted(dates, key=lambda date: datetime.datetime.strptime(date, '%Y-%m-%d').day)\n\ndates_list = [\n    \"2021-01-20\", \"2021-02-15\", \"2021-03-25\", \"2021-04-19\", \"2021-05-05\",\n    \"2021-06-10\", \"2021-07-30\", \"2021-08-31\", \"2021-09-29\", \"2021-10-13\",\n    \"2021-11-22\", \"2021-12-07\"\n]\n\nsorted_dates = sort_dates_by_day(dates_list)\n\nfor date in sorted_dates:\n    print(date)"}, {"role": "assistant", "content": "2021-05-05\n2021-12-07\n2021-06-10\n2021-10-13\n2021-02-15\n2021-04-19\n2021-01-20\n2021-11-22\n2021-03-25\n2021-09-29\n2021-07-30\n2021-08-31\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef generate_pattern(n):\n    pattern = []\n    for i in range(n):\n        line = []\n        for j in range(n):\n            value = (i + 1) * (j + 1)\n            line.append(value)\n        pattern.append(line)\n    return pattern\n\ndef custom_sort(pattern):\n    sorted_pattern = []\n    for line in pattern:\n        even_numbers = sorted([x for x in line if x % 2 == 0])\n        odd_numbers = sorted([x for x in line if x % 2 != 0], reverse=True)\n        sorted_line = even_numbers + odd_numbers\n        sorted_pattern.append(sorted_line)\n    return sorted_pattern\n\ndef display_pattern(pattern):\n    for line in pattern:\n        print(\" \".join(f\"{x:2}\" for x in line))\n\nn = 10\nprint(\"Original Pattern:\")\noriginal_pattern = generate_pattern(n)\ndisplay_pattern(original_pattern)\n\nprint(\"\\nCustom Sorted Pattern:\")\nsorted_pattern = custom_sort(original_pattern)\ndisplay_pattern(sorted_pattern)"}, {"role": "assistant", "content": "Original Pattern:\n 1  2  3  4  5  6  7  8  9 10\n 2  4  6  8 10 12 14 16 18 20\n 3  6  9 12 15 18 21 24 27 30\n 4  8 12 16 20 24 28 32 36 40\n 5 10 15 20 25 30 35 40 45 50\n 6 12 18 24 30 36 42 48 54 60\n 7 14 21 28 35 42 49 56 63 70\n 8 16 24 32 40 48 56 64 72 80\n 9 18 27 36 45 54 63 72 81 90\n10 20 30 40 50 60 70 80 90 100\n\nCustom Sorted Pattern:\n 2  4  6  8 10  9  7  5  3  1\n 2  4  6  8 10 12 14 16 18 20\n 6 12 18 24 30 27 21 15  9  3\n 4  8 12 16 20 24 28 32 36 40\n10 20 30 40 50 45 35 25 15  5\n 6 12 18 24 30 36 42 48 54 60\n14 28 42 56 70 63 49 35 21  7\n 8 16 24 32 40 48 56 64 72 80\n18 36 54 72 90 81 63 45 27  9\n10 20 30 40 50 60 70 80 90 100\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef generate_pattern(n):\n    pattern = \"\"\n    for i in range(n):\n        pattern += (str(i % 10) + \" \") * (i + 1) + \"\\n\"\n    return pattern.strip()\n\ndef search_pattern(pattern, keyword):\n    lines = pattern.split(\"\\n\")\n    found_lines = []\n    for i, line in enumerate(lines):\n        if re.search(keyword, line):\n            found_lines.append((i + 1, line))\n    return found_lines\n\nn = 20\nkeyword = \"7\"\npattern = generate_pattern(n)\nfound = search_pattern(pattern, keyword)\n\nfor line_number, line_content in found:\n    print(f\"Line {line_number}: {line_content}\")"}, {"role": "assistant", "content": "Line 8: 7 7 7 7 7 7 7 7 \nLine 18: 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 \n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef generate_number_sequence(n):\n    sequence = []\n    for i in range(1, n + 1):\n        sequence.append(i * i + 1)\n    return sequence\n\ndef is_special_number(num):\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef find_special_numbers(sequence):\n    return [num for num in sequence if is_special_number(num)]\n\nsequence_length = 100\nsequence = generate_number_sequence(sequence_length)\nspecial_numbers = find_special_numbers(sequence)\n\nfor idx, num in enumerate(special_numbers, 1):\n    print(f\"Special Number {idx}: {num}\")"}, {"role": "assistant", "content": "Special Number 1: 2\nSpecial Number 2: 5\nSpecial Number 3: 17\nSpecial Number 4: 37\nSpecial Number 5: 101\nSpecial Number 6: 197\nSpecial Number 7: 257\nSpecial Number 8: 401\nSpecial Number 9: 577\nSpecial Number 10: 677\nSpecial Number 11: 1297\nSpecial Number 12: 1601\nSpecial Number 13: 2917\nSpecial Number 14: 3137\nSpecial Number 15: 4357\nSpecial Number 16: 5477\nSpecial Number 17: 7057\nSpecial Number 18: 8101\nSpecial Number 19: 8837\n"}]}
{"messages": [{"role": "user", "content": "import re\nfrom collections import Counter\n\ntext = \"\"\"\nIn a distant galaxy, beyond the stars, lies a planet where time flows differently. The inhabitants, known as the Chronomancers, have the unique ability to manipulate the fabric of time. They speak in a language that resonates with the rhythm of the universe, where words are formed by the celestial patterns observed in the skies. Each word is a reflection of the cosmic dance, and the sentences they construct are symphonies of temporal harmonies.\n\"\"\"\n\ndef sort_sentences_by_word_frequency(text):\n    sentences = re.split(r'[.!?]', text)\n    words = re.findall(r'\\b\\w+\\b', text.lower())\n    word_freq = Counter(words)\n\n    def sentence_score(sentence):\n        words_in_sentence = re.findall(r'\\b\\w+\\b', sentence.lower())\n        return sum(word_freq[word] for word in words_in_sentence if word in word_freq)\n\n    sorted_sentences = sorted(sentences, key=sentence_score, reverse=True)\n    return sorted_sentences\n\nsorted_sentences = sort_sentences_by_word_frequency(text)\nfor i, sentence in enumerate(sorted_sentences, 1):\n    if sentence.strip():\n        print(f\"{i}. {sentence.strip()}\")"}, {"role": "assistant", "content": "1. They speak in a language that resonates with the rhythm of the universe, where words are formed by the celestial patterns observed in the skies\n2. The inhabitants, known as the Chronomancers, have the unique ability to manipulate the fabric of time\n3. Each word is a reflection of the cosmic dance, and the sentences they construct are symphonies of temporal harmonies\n4. In a distant galaxy, beyond the stars, lies a planet where time flows differently\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef generate_number_sequence(n):\n    sequence = []\n    for i in range(1, n+1):\n        num = i * (i + 1) // 2\n        sequence.append(num)\n    return sequence\n\ndef number_sum_of_digits(num):\n    return sum(int(digit) for digit in str(num))\n\ndef sort_sequence_by_digit_sum(sequence):\n    return sorted(sequence, key=number_sum_of_digits)\n\nn = 30\nsequence = generate_number_sequence(n)\nprint(\"Original Sequence:\")\nprint(sequence)\n\nsorted_sequence = sort_sequence_by_digit_sum(sequence)\nprint(\"\\nSorted Sequence by Sum of Digits:\")\nprint(sorted_sequence)\n\nprint(\"\\nIntermediate Debug Info:\")\nfor num in sequence:\n    digit_sum = number_sum_of_digits(num)\n    print(f\"Number: {num}, Sum of Digits: {digit_sum}\")"}, {"role": "assistant", "content": "Original Sequence:\n[1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66, 78, 91, 105, 120, 136, 153, 171, 190, 210, 231, 253, 276, 300, 325, 351, 378, 406, 435, 465]\n\nSorted Sequence by Sum of Digits:\n[1, 10, 3, 21, 120, 210, 300, 6, 15, 105, 231, 36, 45, 153, 171, 351, 28, 55, 91, 136, 190, 253, 325, 406, 66, 435, 78, 276, 465, 378]\n\nIntermediate Debug Info:\nNumber: 1, Sum of Digits: 1\nNumber: 3, Sum of Digits: 3\nNumber: 6, Sum of Digits: 6\nNumber: 10, Sum of Digits: 1\nNumber: 15, Sum of Digits: 6\nNumber: 21, Sum of Digits: 3\nNumber: 28, Sum of Digits: 10\nNumber: 36, Sum of Digits: 9\nNumber: 45, Sum of Digits: 9\nNumber: 55, Sum of Digits: 10\nNumber: 66, Sum of Digits: 12\nNumber: 78, Sum of Digits: 15\nNumber: 91, Sum of Digits: 10\nNumber: 105, Sum of Digits: 6\nNumber: 120, Sum of Digits: 3\nNumber: 136, Sum of Digits: 10\nNumber: 153, Sum of Digits: 9\nNumber: 171, Sum of Digits: 9\nNumber: 190, Sum of Digits: 10\nNumber: 210, Sum of Digits: 3\nNumber: 231, Sum of Digits: 6\nNumber: 253, Sum of Digits: 10\nNumber: 276, Sum of Digits: 15\nNumber: 300, Sum of Digits: 3\nNumber: 325, Sum of Digits: 10\nNumber: 351, Sum of Digits: 9\nNumber: 378, Sum of Digits: 18\nNumber: 406, Sum of Digits: 10\nNumber: 435, Sum of Digits: 12\nNumber: 465, Sum of Digits: 15\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef calculate_area(points):\n    n = len(points)\n    area = 0.0\n    for i in range(n):\n        j = (i + 1) % n\n        area += points[i][0] * points[j][1]\n        area -= points[j][0] * points[i][1]\n    area = abs(area) / 2.0\n    return area\n\ndef polygon_angle(p1, p2, p3):\n    a = math.sqrt((p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2)\n    b = math.sqrt((p2[0] - p3[0]) ** 2 + (p2[1] - p3[1]) ** 2)\n    c = math.sqrt((p3[0] - p1[0]) ** 2 + (p3[1] - p1[1]) ** 2)\n    return math.acos((a ** 2 + b ** 2 - c ** 2) / (2 * a * b))\n\ndef sort_polygons_by_area_and_angle(polygons):\n    return sorted(polygons, key=lambda poly: (calculate_area(poly), polygon_angle(poly[0], poly[1], poly[2])))\n\npolygons = [\n    [(0, 0), (2, 0), (1, 3)],\n    [(0, 0), (5, 0), (3, 4)],\n    [(1, 1), (4, 1), (2.5, 5)],\n    [(0, 0), (1, 0), (0.5, math.sqrt(0.75))],\n    [(0, 0), (3, 0), (1.5, math.sqrt(6.75))],\n    [(0, 0), (4, 0), (2, math.sqrt(12))],\n    [(2, 1), (6, 1), (4, 5)],\n    [(3, 2), (7, 2), (5, 6)],\n    [(1, 0), (2, 3), (-1, 2)],\n    [(0, 0), (3, 0), (1.5, 1.5)]\n]\n\nsorted_polygons = sort_polygons_by_area_and_angle(polygons)\n\nfor i, poly in enumerate(sorted_polygons, start=1):\n    area = calculate_area(poly)\n    angle = polygon_angle(poly[0], poly[1], poly[2])\n    print(f\"Polygon {i}: Area = {area:.2f}, Angle = {math.degrees(angle):.2f} degrees, Points = {poly}\")"}, {"role": "assistant", "content": "Polygon 1: Area = 0.43, Angle = 60.00 degrees, Points = [(0, 0), (1, 0), (0.5, 0.8660254037844386)]\nPolygon 2: Area = 2.25, Angle = 45.00 degrees, Points = [(0, 0), (3, 0), (1.5, 1.5)]\nPolygon 3: Area = 3.00, Angle = 71.57 degrees, Points = [(0, 0), (2, 0), (1, 3)]\nPolygon 4: Area = 3.90, Angle = 60.00 degrees, Points = [(0, 0), (3, 0), (1.5, 2.598076211353316)]\nPolygon 5: Area = 4.00, Angle = 53.13 degrees, Points = [(1, 0), (2, 3), (-1, 2)]\nPolygon 6: Area = 6.00, Angle = 69.44 degrees, Points = [(1, 1), (4, 1), (2.5, 5)]\nPolygon 7: Area = 6.93, Angle = 60.00 degrees, Points = [(0, 0), (4, 0), (2, 3.4641016151377544)]\nPolygon 8: Area = 8.00, Angle = 63.43 degrees, Points = [(2, 1), (6, 1), (4, 5)]\nPolygon 9: Area = 8.00, Angle = 63.43 degrees, Points = [(3, 2), (7, 2), (5, 6)]\nPolygon 10: Area = 10.00, Angle = 63.43 degrees, Points = [(0, 0), (5, 0), (3, 4)]\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\nclass TemperatureLog:\n    def __init__(self, date, temperature):\n        self.date = date\n        self.temperature = temperature\n\n    def __lt__(self, other):\n        return self.temperature < other.temperature\n\ndef generate_temperature_data(start_date, days, initial_temp, temp_change_per_day):\n    temperature_logs = []\n    current_date = start_date\n    current_temp = initial_temp\n    for _ in range(days):\n        temperature_logs.append(TemperatureLog(current_date, current_temp))\n        current_date += timedelta(days=1)\n        current_temp += temp_change_per_day\n    return temperature_logs\n\nstart_date = datetime(2023, 1, 1)\nlogs = generate_temperature_data(start_date, 50, 20, 0.5)\n\nsorted_logs = sorted(logs)\n\nfor log in sorted_logs:\n    print(log.date.strftime(\"%Y-%m-%d\"), log.temperature)"}, {"role": "assistant", "content": "2023-01-01 20\n2023-01-02 20.5\n2023-01-03 21.0\n2023-01-04 21.5\n2023-01-05 22.0\n2023-01-06 22.5\n2023-01-07 23.0\n2023-01-08 23.5\n2023-01-09 24.0\n2023-01-10 24.5\n2023-01-11 25.0\n2023-01-12 25.5\n2023-01-13 26.0\n2023-01-14 26.5\n2023-01-15 27.0\n2023-01-16 27.5\n2023-01-17 28.0\n2023-01-18 28.5\n2023-01-19 29.0\n2023-01-20 29.5\n2023-01-21 30.0\n2023-01-22 30.5\n2023-01-23 31.0\n2023-01-24 31.5\n2023-01-25 32.0\n2023-01-26 32.5\n2023-01-27 33.0\n2023-01-28 33.5\n2023-01-29 34.0\n2023-01-30 34.5\n2023-01-31 35.0\n2023-02-01 35.5\n2023-02-02 36.0\n2023-02-03 36.5\n2023-02-04 37.0\n2023-02-05 37.5\n2023-02-06 38.0\n2023-02-07 38.5\n2023-02-08 39.0\n2023-02-09 39.5\n2023-02-10 40.0\n2023-02-11 40.5\n2023-02-12 41.0\n2023-02-13 41.5\n2023-02-14 42.0\n2023-02-15 42.5\n2023-02-16 43.0\n2023-02-17 43.5\n2023-02-18 44.0\n2023-02-19 44.5\n"}]}
{"messages": [{"role": "user", "content": "def find_winning_moves(grid, player):\n    winning_moves = []\n    directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1)]\n\n    def search(x, y, dx, dy):\n        count = 0\n        for _ in range(3):\n            x += dx\n            y += dy\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == player:\n                count += 1\n            else:\n                break\n        return count\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == player:\n                for dx, dy in directions:\n                    if search(i, j, dx, dy) == 2:\n                        if 0 <= i - dx < len(grid) and 0 <= j - dy < len(grid[0]) and grid[i-dx][j-dy] == 0:\n                            winning_moves.append((i-dx, j-dy))\n                        if 0 <= i + 3*dx < len(grid) and 0 <= j + 3*dy < len(grid[0]) and grid[i+3*dx][j+3*dy] == 0:\n                            winning_moves.append((i+3*dx, j+3*dy))\n    return winning_moves\n\ngrid = [\n    [1, 0, 2, 0, 1, 1, 0],\n    [0, 1, 0, 2, 0, 2, 0],\n    [2, 2, 1, 1, 0, 0, 0],\n    [0, 1, 0, 0, 2, 1, 0],\n    [0, 0, 0, 2, 1, 2, 0],\n    [0, 0, 0, 0, 0, 0, 0]\n]\n\nplayer = 1\nwinning_moves = find_winning_moves(grid, player)\nprint(\"Winning moves for player\", player, \":\", winning_moves)\n\nplayer = 2\nwinning_moves = find_winning_moves(grid, player)\nprint(\"Winning moves for player\", player, \":\", winning_moves)"}, {"role": "assistant", "content": "Winning moves for player 1 : [(3, 3)]\nWinning moves for player 2 : []\n"}]}
{"messages": [{"role": "user", "content": "import datetime\nimport statistics\n\ndata = [\n    {\"date\": \"2023-01-01\", \"value\": 10},\n    {\"date\": \"2023-02-01\", \"value\": 20},\n    {\"date\": \"2023-03-01\", \"value\": 15},\n    {\"date\": \"2023-04-01\", \"value\": 25},\n    {\"date\": \"2023-05-01\", \"value\": 30},\n    {\"date\": \"2023-06-01\", \"value\": 35},\n    {\"date\": \"2023-07-01\", \"value\": 40},\n    {\"date\": \"2023-08-01\", \"value\": 32},\n    {\"date\": \"2023-09-01\", \"value\": 28},\n    {\"date\": \"2023-10-01\", \"value\": 22},\n    {\"date\": \"2023-11-01\", \"value\": 18},\n    {\"date\": \"2023-12-01\", \"value\": 24}\n]\n\ndef date_to_month(date_str):\n    return datetime.datetime.strptime(date_str, \"%Y-%m-%d\").month\n\ndef binary_search_by_value(arr, target):\n    low, high = 0, len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid][\"value\"] == target:\n            return mid\n        elif arr[mid][\"value\"] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n\nsorted_data = sorted(data, key=lambda x: x[\"value\"])\nmedian_value = statistics.median([x[\"value\"] for x in sorted_data])\n\nindex = binary_search_by_value(sorted_data, median_value)\n\nanalysis_result = {\n    \"median_value\": median_value,\n    \"months_below_median\": [date_to_month(x[\"date\"]) for x in sorted_data[:index]],\n    \"months_above_median\": [date_to_month(x[\"date\"]) for x in sorted_data[index + 1:]]\n}\n\nfor key, value in analysis_result.items():\n    print(f\"{key}: {value}\")"}, {"role": "assistant", "content": "median_value: 24.5\nmonths_below_median: [1, 3, 11, 2, 10, 12, 4, 9, 5, 8, 6]\nmonths_above_median: [1, 3, 11, 2, 10, 12, 4, 9, 5, 8, 6, 7]\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef create_event_schedule(events):\n    return sorted(events, key=lambda x: x[1])\n\ndef calculate_score(event):\n    score = 0\n    for char in event:\n        score += ord(char) * 2 if char.isalpha() else ord(char)\n    return score\n\ndef rank_events(events):\n    scored_events = [(event, calculate_score(event)) for event in events]\n    return sorted(scored_events, key=lambda x: x[1], reverse=True)\n\nevents = [\n    (\"Chess Championship\", datetime.datetime(2023, 11, 25, 15, 0)),\n    (\"Puzzle Marathon\", datetime.datetime(2023, 11, 20, 10, 0)),\n    (\"Math Olympiad\", datetime.datetime(2023, 11, 22, 9, 0)),\n    (\"Code Jam\", datetime.datetime(2023, 11, 21, 14, 0)),\n    (\"Logic Quiz\", datetime.datetime(2023, 11, 23, 11, 0))\n]\n\nscheduled_events = create_event_schedule(events)\nevent_names = [event[0] for event in scheduled_events]\nranked_events = rank_events(event_names)\n\nfor i, (event, score) in enumerate(ranked_events, start=1):\n    print(f\"Rank {i}: {event} with score {score}\")"}, {"role": "assistant", "content": "Rank 1: Chess Championship with score 3538\nRank 2: Puzzle Marathon with score 2984\nRank 3: Math Olympiad with score 2482\nRank 4: Logic Quiz with score 1870\nRank 5: Code Jam with score 1350\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef encode_message(message):\n    return ''.join(format(ord(char), '08b') for char in message)\n\ndef decode_message(binary_string):\n    chars = [binary_string[i:i+8] for i in range(0, len(binary_string), 8)]\n    return ''.join(chr(int(char, 2)) for char in chars)\n\ndef find_encoded_pattern(encoded, pattern):\n    matches = []\n    pattern_len = len(pattern)\n    for i in range(len(encoded) - pattern_len + 1):\n        if encoded[i:i+pattern_len] == pattern:\n            matches.append(i)\n    return matches\n\nmessage = \"Encryption and encoding are fascinating!\"\npattern = \"01000101\"  # Binary for 'E'\n\nencoded_message = encode_message(message)\npattern_indices = find_encoded_pattern(encoded_message, pattern)\n\ndecoded_message = decode_message(encoded_message)\n\nprint(\"Original Message:\")\nprint(message)\nprint(\"\\nEncoded Message:\")\nprint(re.findall(r'.{1,8}', encoded_message))\nprint(\"\\nDecoded Message:\")\nprint(decoded_message)\nprint(\"\\nPattern Indices:\")\nprint(pattern_indices)"}, {"role": "assistant", "content": "Original Message:\nEncryption and encoding are fascinating!\n\nEncoded Message:\n['01000101', '01101110', '01100011', '01110010', '01111001', '01110000', '01110100', '01101001', '01101111', '01101110', '00100000', '01100001', '01101110', '01100100', '00100000', '01100101', '01101110', '01100011', '01101111', '01100100', '01101001', '01101110', '01100111', '00100000', '01100001', '01110010', '01100101', '00100000', '01100110', '01100001', '01110011', '01100011', '01101001', '01101110', '01100001', '01110100', '01101001', '01101110', '01100111', '00100001']\n\nDecoded Message:\nEncryption and encoding are fascinating!\n\nPattern Indices:\n[0]\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef generate_pattern(n):\n    pattern = []\n    for i in range(n):\n        row = []\n        for j in range(n):\n            if (i + j) % 2 == 0:\n                row.append('*')\n            else:\n                row.append(' ')\n        pattern.append(''.join(row))\n    return pattern\n\ndef search_pattern(pattern, target):\n    positions = []\n    for i in range(len(pattern)):\n        pos = pattern[i].find(target)\n        if pos != -1:\n            positions.append((i, pos))\n    return positions\n\ndef main():\n    size = 15\n    target = \"* *\"\n    pattern = generate_pattern(size)\n    \n    for line in pattern:\n        print(line)\n    \n    print(\"\\nSearching for pattern:\", target)\n    positions = search_pattern(pattern, target)\n    \n    if positions:\n        print(\"Pattern found at positions:\")\n        for pos in positions:\n            print(pos)\n    else:\n        print(\"Pattern not found.\")\n\nif __name__ == \"__main__\":\n    main()"}, {"role": "assistant", "content": "* * * * * * * *\n * * * * * * * \n* * * * * * * *\n * * * * * * * \n* * * * * * * *\n * * * * * * * \n* * * * * * * *\n * * * * * * * \n* * * * * * * *\n * * * * * * * \n* * * * * * * *\n * * * * * * * \n* * * * * * * *\n * * * * * * * \n* * * * * * * *\n\nSearching for pattern: * *\nPattern found at positions:\n(0, 0)\n(1, 1)\n(2, 0)\n(3, 1)\n(4, 0)\n(5, 1)\n(6, 0)\n(7, 1)\n(8, 0)\n(9, 1)\n(10, 0)\n(11, 1)\n(12, 0)\n(13, 1)\n(14, 0)\n"}]}
{"messages": [{"role": "user", "content": "def encode_message(message, shift):\n    encoded_chars = []\n    for char in message:\n        if char.isalpha():\n            shift_amount = shift % 26\n            new_char = chr((ord(char) - 65 + shift_amount) % 26 + 65) if char.isupper() else chr((ord(char) - 97 + shift_amount) % 26 + 97)\n            encoded_chars.append(new_char)\n        else:\n            encoded_chars.append(char)\n    return ''.join(encoded_chars)\n\ndef bubble_sort_encoded_messages(messages):\n    n = len(messages)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if messages[j] > messages[j+1]:\n                messages[j], messages[j+1] = messages[j+1], messages[j]\n    return messages\n\nmessages = [\n    \"HELLO WORLD\",\n    \"PYTHON CODE\",\n    \"SORTING FUN\",\n    \"ENCODE THIS\",\n    \"BUBBLE SORT\"\n]\n\nshift_values = [3, 1, 4, 2, 5]\nencoded_messages = [encode_message(msg, shift) for msg, shift in zip(messages, shift_values)]\nsorted_encoded_messages = bubble_sort_encoded_messages(encoded_messages)\n\nfor message in sorted_encoded_messages:\n    print(message)"}, {"role": "assistant", "content": "GPEQFG VJKU\nGZGGQJ XTWY\nKHOOR ZRUOG\nQZUIPO DPEF\nWSVXMRK JYR\n"}]}
{"messages": [{"role": "user", "content": "def generate_triangles(n):\n    triangles = []\n    for i in range(1, n + 1):\n        row = []\n        for j in range(1, i + 1):\n            row.append('*')\n        triangles.append(''.join(row))\n    return triangles\n\ndef sort_by_length(triangles):\n    return sorted(triangles, key=len, reverse=True)\n\ndef main():\n    n = 10\n    triangles = generate_triangles(n)\n    print(\"Generated Triangles:\")\n    for triangle in triangles:\n        print(triangle)\n    \n    print(\"\\nSorting Triangles by Length in Descending Order:\")\n    sorted_triangles = sort_by_length(triangles)\n    for triangle in sorted_triangles:\n        print(triangle)\n\nif __name__ == \"__main__\":\n    main()"}, {"role": "assistant", "content": "Generated Triangles:\n*\n**\n***\n****\n*****\n******\n*******\n********\n*********\n**********\n\nSorting Triangles by Length in Descending Order:\n**********\n*********\n********\n*******\n******\n*****\n****\n***\n**\n*\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef sort_dates_incorrectly(dates):\n    print(\"Initial dates:\", dates)\n    sorted_dates = sorted(dates, key=lambda date: date.year)\n    print(\"Dates sorted incorrectly by year:\", sorted_dates)\n    return sorted_dates\n\ndef create_dates():\n    base_date = datetime.now()\n    date_list = [base_date - timedelta(days=i*30) for i in range(1, 15)]\n    additional_dates = [\n        base_date + timedelta(days=365),\n        base_date + timedelta(days=730),\n        base_date - timedelta(days=365),\n    ]\n    date_list.extend(additional_dates)\n    return date_list\n\ndates = create_dates()\nsorted_dates = sort_dates_incorrectly(dates)\nprint(\"Final sorted dates:\")\nfor date in sorted_dates:\n    print(date.strftime(\"%Y-%m-%d\"))"}, {"role": "assistant", "content": "Initial dates: [datetime.datetime(2025, 3, 2, 16, 6, 40, 818918), datetime.datetime(2025, 1, 31, 16, 6, 40, 818918), datetime.datetime(2025, 1, 1, 16, 6, 40, 818918), datetime.datetime(2024, 12, 2, 16, 6, 40, 818918), datetime.datetime(2024, 11, 2, 16, 6, 40, 818918), datetime.datetime(2024, 10, 3, 16, 6, 40, 818918), datetime.datetime(2024, 9, 3, 16, 6, 40, 818918), datetime.datetime(2024, 8, 4, 16, 6, 40, 818918), datetime.datetime(2024, 7, 5, 16, 6, 40, 818918), datetime.datetime(2024, 6, 5, 16, 6, 40, 818918), datetime.datetime(2024, 5, 6, 16, 6, 40, 818918), datetime.datetime(2024, 4, 6, 16, 6, 40, 818918), datetime.datetime(2024, 3, 7, 16, 6, 40, 818918), datetime.datetime(2024, 2, 6, 16, 6, 40, 818918), datetime.datetime(2026, 4, 1, 16, 6, 40, 818918), datetime.datetime(2027, 4, 1, 16, 6, 40, 818918), datetime.datetime(2024, 4, 1, 16, 6, 40, 818918)]\nDates sorted incorrectly by year: [datetime.datetime(2024, 12, 2, 16, 6, 40, 818918), datetime.datetime(2024, 11, 2, 16, 6, 40, 818918), datetime.datetime(2024, 10, 3, 16, 6, 40, 818918), datetime.datetime(2024, 9, 3, 16, 6, 40, 818918), datetime.datetime(2024, 8, 4, 16, 6, 40, 818918), datetime.datetime(2024, 7, 5, 16, 6, 40, 818918), datetime.datetime(2024, 6, 5, 16, 6, 40, 818918), datetime.datetime(2024, 5, 6, 16, 6, 40, 818918), datetime.datetime(2024, 4, 6, 16, 6, 40, 818918), datetime.datetime(2024, 3, 7, 16, 6, 40, 818918), datetime.datetime(2024, 2, 6, 16, 6, 40, 818918), datetime.datetime(2024, 4, 1, 16, 6, 40, 818918), datetime.datetime(2025, 3, 2, 16, 6, 40, 818918), datetime.datetime(2025, 1, 31, 16, 6, 40, 818918), datetime.datetime(2025, 1, 1, 16, 6, 40, 818918), datetime.datetime(2026, 4, 1, 16, 6, 40, 818918), datetime.datetime(2027, 4, 1, 16, 6, 40, 818918)]\nFinal sorted dates:\n2024-12-02\n2024-11-02\n2024-10-03\n2024-09-03\n2024-08-04\n2024-07-05\n2024-06-05\n2024-05-06\n2024-04-06\n2024-03-07\n2024-02-06\n2024-04-01\n2025-03-02\n2025-01-31\n2025-01-01\n2026-04-01\n2027-04-01\n"}]}
{"messages": [{"role": "user", "content": "text = \"\"\"\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam vehicula, neque at gravida volutpat, urna nulla interdum urna, eu suscipit turpis dolor sit amet ipsum. Donec tincidunt, lorem non fringilla vehicula, turpis nisi condimentum nunc, id pretium tortor lacus ac orci. Suspendisse potenti. Duis vel est at odio consectetur facilisis. Nulla facilisi. Nam sed massa ut eros varius tincidunt. Curabitur at urna in arcu vulputate consequat. Sed a varius libero. Cras vehicula, sapien sed tempus facilisis, libero nibh malesuada leo, vitae vestibulum nisi arcu vitae orci. Phasellus vitae justo non erat dignissim gravida. Sed lacinia, sapien non fringilla vulputate, orci orci sollicitudin diam, nec laoreet mi leo non dolor.\n\"\"\"\n\nwords = text.split()\nsorted_words = sorted(words, key=lambda w: (len(w), w))\n\nfor word in sorted_words:\n    print(word)"}, {"role": "assistant", "content": "a\nac\nat\nat\nat\neu\nid\nin\nmi\nut\nNam\nSed\nSed\nest\nleo\nnec\nnon\nnon\nnon\nnon\nsed\nsed\nsit\nsit\nvel\nCras\nDuis\namet\narcu\narcu\nerat\neros\nleo,\nnibh\nnisi\nnisi\nodio\norci\norci\nurna\nurna\nDonec\nLorem\nNulla\namet,\ndiam,\ndolor\ndolor\nelit.\nipsum\njusto\nlacus\nlorem\nmassa\nneque\nnulla\nnunc,\norci.\norci.\nurna,\nvitae\nvitae\nvitae\nNullam\ndolor.\nipsum.\nlibero\nsapien\nsapien\ntempus\ntortor\nturpis\nturpis\nvarius\nvarius\ngravida\nlaoreet\nlibero.\npretium\ngravida.\ninterdum\nlacinia,\npotenti.\nsuscipit\nCurabitur\nPhasellus\ndignissim\nfacilisi.\nfringilla\nfringilla\nmalesuada\nvehicula,\nvehicula,\nvehicula,\nvolutpat,\nvulputate\nadipiscing\nconsequat.\nfacilisis,\nfacilisis.\ntincidunt,\ntincidunt.\nvestibulum\nvulputate,\nSuspendisse\ncondimentum\nconsectetur\nconsectetur\nsollicitudin\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef sort_by_digit_sum(numbers):\n    return sorted(numbers, key=lambda x: sum(int(d) for d in str(x)))\n\ndef generate_fibonacci(n):\n    fib_seq = [0, 1]\n    for _ in range(2, n):\n        fib_seq.append(fib_seq[-1] + fib_seq[-2])\n    return fib_seq\n\ndef calculate_factorials(numbers):\n    return [math.factorial(num) for num in numbers]\n\ndef process_sequence(n):\n    fibonacci_sequence = generate_fibonacci(n)\n    factorial_sequence = calculate_factorials(fibonacci_sequence)\n    return sort_by_digit_sum(factorial_sequence)\n\nnumber_of_terms = 20\nresult_sequence = process_sequence(number_of_terms)\nfor number in result_sequence:\n    print(number)"}, {"role": "assistant", "content": "Traceback (most recent call last):\n  File \"<string>\", line 21, in <module>\n  File \"<string>\", line 18, in process_sequence\n  File \"<string>\", line 4, in sort_by_digit_sum\n  File \"<string>\", line 4, in <lambda>\nValueError: Exceeds the limit (4300 digits) for integer string conversion; use sys.set_int_max_str_digits() to increase the limit\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\ndef sort_dates_by_month(dates):\n    print(\"Original dates:\", dates)\n    dates_with_parsed = [(date_str, datetime.strptime(date_str, \"%Y-%m-%d\")) for date_str in dates]\n    sorted_dates = sorted(dates_with_parsed, key=lambda x: x[1].month)\n    result = [date[0] for date in sorted_dates]\n    print(\"Sorted dates by month:\", result)\n    return result\n\ndates_list = [\n    \"2023-09-14\", \"2023-01-11\", \"2023-04-23\", \"2023-12-02\",\n    \"2023-07-19\", \"2023-03-08\", \"2023-06-30\", \"2023-10-15\",\n    \"2023-02-20\", \"2023-11-09\", \"2023-05-13\", \"2023-08-25\"\n]\n\nsorted_dates = sort_dates_by_month(dates_list)\n\nfor date in sorted_dates:\n    print(date)"}, {"role": "assistant", "content": "Original dates: ['2023-09-14', '2023-01-11', '2023-04-23', '2023-12-02', '2023-07-19', '2023-03-08', '2023-06-30', '2023-10-15', '2023-02-20', '2023-11-09', '2023-05-13', '2023-08-25']\nSorted dates by month: ['2023-01-11', '2023-02-20', '2023-03-08', '2023-04-23', '2023-05-13', '2023-06-30', '2023-07-19', '2023-08-25', '2023-09-14', '2023-10-15', '2023-11-09', '2023-12-02']\n2023-01-11\n2023-02-20\n2023-03-08\n2023-04-23\n2023-05-13\n2023-06-30\n2023-07-19\n2023-08-25\n2023-09-14\n2023-10-15\n2023-11-09\n2023-12-02\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\ndef transform_dates(date_strings):\n    formats = [\n        \"%Y-%m-%d\", \"%d-%m-%Y\", \"%m/%d/%Y\", \"%Y/%m/%d\",\n        \"%d %b %Y\", \"%b %d, %Y\", \"%B %d, %Y\"\n    ]\n    \n    def parse_date(date_str):\n        for fmt in formats:\n            try:\n                return datetime.strptime(date_str, fmt)\n            except ValueError:\n                continue\n        return None\n    \n    parsed_dates = [parse_date(ds) for ds in date_strings]\n    print(\"Parsed dates:\", parsed_dates)\n    \n    valid_dates = [d for d in parsed_dates if d is not None]\n    print(\"Valid dates:\", valid_dates)\n    \n    transformed = [d.strftime(\"%A, %d %B %Y\") for d in valid_dates]\n    print(\"Transformed dates:\", transformed)\n    return transformed\n\ndates = [\n    \"2023-10-05\", \"15-09-2021\", \"04/12/2020\", \"2022/11/30\",\n    \"11 Apr 2019\", \"Mar 10, 2018\", \"July 20, 2017\",\n    \"invalid\", \"10-20-2020\", \"20/20/2020\"\n]\n\noutput = transform_dates(dates)\nprint(\"\\nFinal output:\")\nfor line in output:\n    print(line)"}, {"role": "assistant", "content": "Parsed dates: [datetime.datetime(2023, 10, 5, 0, 0), datetime.datetime(2021, 9, 15, 0, 0), datetime.datetime(2020, 4, 12, 0, 0), datetime.datetime(2022, 11, 30, 0, 0), datetime.datetime(2019, 4, 11, 0, 0), datetime.datetime(2018, 3, 10, 0, 0), datetime.datetime(2017, 7, 20, 0, 0), None, None, None]\nValid dates: [datetime.datetime(2023, 10, 5, 0, 0), datetime.datetime(2021, 9, 15, 0, 0), datetime.datetime(2020, 4, 12, 0, 0), datetime.datetime(2022, 11, 30, 0, 0), datetime.datetime(2019, 4, 11, 0, 0), datetime.datetime(2018, 3, 10, 0, 0), datetime.datetime(2017, 7, 20, 0, 0)]\nTransformed dates: ['Thursday, 05 October 2023', 'Wednesday, 15 September 2021', 'Sunday, 12 April 2020', 'Wednesday, 30 November 2022', 'Thursday, 11 April 2019', 'Saturday, 10 March 2018', 'Thursday, 20 July 2017']\n\nFinal output:\nThursday, 05 October 2023\nWednesday, 15 September 2021\nSunday, 12 April 2020\nWednesday, 30 November 2022\nThursday, 11 April 2019\nSaturday, 10 March 2018\nThursday, 20 July 2017\n"}]}
{"messages": [{"role": "user", "content": "def fibonacci_sequence(n):\n    sequence = [0, 1]\n    for i in range(2, n):\n        sequence.append(sequence[-1] + sequence[-2])\n    return sequence\n\ndef binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\nn = 100\nfib_seq = fibonacci_sequence(n)\n\nresults = []\nfor number in range(fib_seq[10], fib_seq[15]):\n    idx = binary_search(fib_seq, number)\n    if idx != -1:\n        results.append((number, idx))\n\nfor result in results:\n    print(f\"Number {result[0]} found at index {result[1]} in the Fibonacci sequence.\")"}, {"role": "assistant", "content": "Number 55 found at index 10 in the Fibonacci sequence.\nNumber 89 found at index 11 in the Fibonacci sequence.\nNumber 144 found at index 12 in the Fibonacci sequence.\nNumber 233 found at index 13 in the Fibonacci sequence.\nNumber 377 found at index 14 in the Fibonacci sequence.\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef search_longest_word_with_vowels(text):\n    words = re.findall(r'\\b\\w+\\b', text)\n    longest_word = \"\"\n    for word in words:\n        if set('aeiou').issubset(word) and len(word) > len(longest_word):\n            longest_word = word\n    return longest_word\n\ntext = \"\"\"\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\nUt enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor\nin reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident,\nsunt in culpa qui officia deserunt mollit anim id est laborum. Supercalifragilisticexpialidocious is an example of a long word.\n\"\"\"\n\nprint(search_longest_word_with_vowels(text))"}, {"role": "assistant", "content": "Supercalifragilisticexpialidocious\n"}]}
{"messages": [{"role": "user", "content": "players_scores = {\n    'Player1': [20, 15, 40, 10],\n    'Player2': [30, 25, 20, 50],\n    'Player3': [15, 20, 25, 30],\n    'Player4': [50, 10, 40, 20],\n}\n\ndef calculate_total_score(scores):\n    return sum(scores)\n\ndef sort_players_by_score(players):\n    return sorted(players.items(), key=lambda x: calculate_total_score(x[1]), reverse=True)\n\nsorted_players = sort_players_by_score(players_scores)\n\nfor player, scores in sorted_players:\n    print(f\"{player}: Total Score = {calculate_total_score(scores)}\")\n\nprint(\"\\nSorting scores within each player...\\n\")\n\nfor player, scores in sorted_players:\n    sorted_scores = sorted(scores, reverse=True)\n    print(f\"{player}: Sorted Scores = {sorted_scores}\")\n\nprint(\"\\nChecking if each player's scores are in descending order...\\n\")\n\nfor player, scores in sorted_players:\n    sorted_scores = sorted(scores, reverse=True)\n    if scores == sorted_scores:\n        print(f\"{player}: Scores are already in descending order.\")\n    else:\n        print(f\"{player}: Scores were not in descending order.\")"}, {"role": "assistant", "content": "Player2: Total Score = 125\nPlayer4: Total Score = 120\nPlayer3: Total Score = 90\nPlayer1: Total Score = 85\n\nSorting scores within each player...\n\nPlayer2: Sorted Scores = [50, 30, 25, 20]\nPlayer4: Sorted Scores = [50, 40, 20, 10]\nPlayer3: Sorted Scores = [30, 25, 20, 15]\nPlayer1: Sorted Scores = [40, 20, 15, 10]\n\nChecking if each player's scores are in descending order...\n\nPlayer2: Scores were not in descending order.\nPlayer4: Scores were not in descending order.\nPlayer3: Scores were not in descending order.\nPlayer1: Scores were not in descending order.\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef calculate_polygon_area(points):\n    n = len(points)\n    area = 0.0\n    for i in range(n):\n        j = (i + 1) % n\n        area += points[i][0] * points[j][1]\n        area -= points[j][0] * points[i][1]\n    area = abs(area) / 2.0\n    return area\n\ndef distance(a, b):\n    return math.sqrt((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2)\n\ndef convex_hull(points):\n    points = sorted(points)\n    if len(points) <= 1:\n        return points\n\n    def cross(o, a, b):\n        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\n    lower = []\n    for p in points:\n        while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:\n            lower.pop()\n        lower.append(p)\n\n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:\n            upper.pop()\n        upper.append(p)\n\n    return lower[:-1] + upper[:-1]\n\npoints = [\n    (2, 3), (5, 5), (8, 3), (6, 7), (3, 5),\n    (5, 2), (7, 8), (4, 9), (1, 8), (9, 9)\n]\n\nhull_points = convex_hull(points)\nhull_points = sorted(hull_points, key=lambda p: (math.atan2(p[1], p[0]), distance((0, 0), p)))\narea_of_hull = calculate_polygon_area(hull_points)\n\nfor i, point in enumerate(hull_points):\n    print(f\"Point {i+1}: {point}\")\n\nprint(f\"Area of Convex Hull: {area_of_hull:.2f}\")"}, {"role": "assistant", "content": "Point 1: (8, 3)\nPoint 2: (5, 2)\nPoint 3: (9, 9)\nPoint 4: (2, 3)\nPoint 5: (4, 9)\nPoint 6: (1, 8)\nArea of Convex Hull: 2.50\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\nmessage = \"HELLO ENCRYPTED WORLD\"\nkey = \"SECRET\"\n\ndef encrypt_char(ch, key_ch):\n    return chr(((ord(ch) + ord(key_ch)) % 26) + 65)\n\ndef decrypt_char(ch, key_ch):\n    return chr(((ord(ch) - ord(key_ch) + 26) % 26) + 65)\n\ndef encrypt_message(msg, key):\n    encrypted = []\n    key_length = len(key)\n    for i, char in enumerate(msg):\n        if char.isalpha():\n            key_ch = key[i % key_length]\n            encrypted.append(encrypt_char(char, key_ch))\n        else:\n            encrypted.append(char)\n    return ''.join(encrypted)\n\ndef decrypt_message(encrypted_msg, key):\n    decrypted = []\n    key_length = len(key)\n    for i, char in enumerate(encrypted_msg):\n        if char.isalpha():\n            key_ch = key[i % key_length]\n            decrypted.append(decrypt_char(char, key_ch))\n        else:\n            decrypted.append(char)\n    return ''.join(decrypted)\n\nencrypted_msg = encrypt_message(message, key)\n\ndef sort_letters_by_date(msg):\n    today = datetime.today().strftime('%Y%m%d')\n    date_sorted = ''.join(sorted(msg, key=lambda x: (x.isalpha(), (ord(x) + int(today)) % 26)))\n    return date_sorted\n\nsorted_encrypted_msg = sort_letters_by_date(encrypted_msg)\n\noutput = decrypt_message(sorted_encrypted_msg, key)\nprint(output)"}, {"role": "assistant", "content": "  XJYJMBDQEPQEHUJWZOU\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef generate_dates(start_date, num_days, interval):\n    dates = []\n    current_date = start_date\n    for _ in range(num_days):\n        dates.append(current_date)\n        current_date += timedelta(days=interval)\n    return dates\n\ndef sort_dates(dates):\n    return sorted(dates, key=lambda date: date.toordinal() % 7)\n\nstart_date = datetime(2023, 1, 1)\nnum_days = 30\ninterval = 3\n\ndates = generate_dates(start_date, num_days, interval)\nprint(\"Generated Dates:\")\nfor date in dates:\n    print(date.strftime('%Y-%m-%d'))\n\nsorted_dates = sort_dates(dates)\nprint(\"\\nSorted Dates by Day of the Week:\")\nfor date in sorted_dates:\n    print(date.strftime('%Y-%m-%d'))"}, {"role": "assistant", "content": "Generated Dates:\n2023-01-01\n2023-01-04\n2023-01-07\n2023-01-10\n2023-01-13\n2023-01-16\n2023-01-19\n2023-01-22\n2023-01-25\n2023-01-28\n2023-01-31\n2023-02-03\n2023-02-06\n2023-02-09\n2023-02-12\n2023-02-15\n2023-02-18\n2023-02-21\n2023-02-24\n2023-02-27\n2023-03-02\n2023-03-05\n2023-03-08\n2023-03-11\n2023-03-14\n2023-03-17\n2023-03-20\n2023-03-23\n2023-03-26\n2023-03-29\n\nSorted Dates by Day of the Week:\n2023-01-01\n2023-01-22\n2023-02-12\n2023-03-05\n2023-03-26\n2023-01-16\n2023-02-06\n2023-02-27\n2023-03-20\n2023-01-10\n2023-01-31\n2023-02-21\n2023-03-14\n2023-01-04\n2023-01-25\n2023-02-15\n2023-03-08\n2023-03-29\n2023-01-19\n2023-02-09\n2023-03-02\n2023-03-23\n2023-01-13\n2023-02-03\n2023-02-24\n2023-03-17\n2023-01-07\n2023-01-28\n2023-02-18\n2023-03-11\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef vigenere_encrypt(plaintext, key):\n    key_length = len(key)\n    key_as_int = [ord(i) for i in key]\n    plaintext_int = [ord(i) for i in plaintext]\n    ciphertext = ''\n    for i in range(len(plaintext_int)):\n        value = (plaintext_int[i] + key_as_int[i % key_length]) % 256\n        ciphertext += chr(value)\n    return ciphertext\n\ndef vigenere_decrypt(ciphertext, key):\n    key_length = len(key)\n    key_as_int = [ord(i) for i in key]\n    ciphertext_int = [ord(i) for i in ciphertext]\n    plaintext = ''\n    for i in range(len(ciphertext_int)):\n        value = (ciphertext_int[i] - key_as_int[i % key_length]) % 256\n        plaintext += chr(value)\n    return plaintext\n\ndef search_for_pattern(ciphertext, pattern):\n    matches = re.search(pattern, ciphertext)\n    return matches.start() if matches else None\n\ndef main():\n    plaintext = \"Advanced level encryption with Vigenere cipher.\"\n    key = \"complexkey\"\n    ciphertext = vigenere_encrypt(plaintext, key)\n    decrypted_text = vigenere_decrypt(ciphertext, key)\n    pattern = \"encryption\"\n    pattern_position = search_for_pattern(ciphertext, pattern)\n    print(\"Original Plaintext:\\n\", plaintext)\n    print(\"Ciphertext:\\n\", ciphertext)\n    print(\"Decrypted Text:\\n\", decrypted_text)\n    print(\"Position of pattern in Ciphertext:\", pattern_position)\n\nmain()"}, {"role": "assistant", "content": "Original Plaintext:\n Advanced level encryption with Vigenere cipher.\nCiphertext:\n \u00a4\u00d3\u00e3\u00d1\u00da\u00c8\u00dd\u00cf\u0085\u00e5\u00c8\u00e5\u00d2\u00dc\u008c\u00ca\u00e6\u00ce\u00d7\u00f2\u00d3\u00e3\u00d6\u00df\u00da\u0085\u00ef\u00d4\u00d9\u00e1\u0083\u00c5\u00d6\u00d7\u00d1\u00d3\u00dd\u00dd\u00ca\u0099\u00c6\u00d8\u00dd\u00d8\u00d1\u00d7\u00a6\nDecrypted Text:\n Advanced level encryption with Vigenere cipher.\nPosition of pattern in Ciphertext: None\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef create_dates():\n    base_date = datetime(2023, 1, 1)\n    dates = [base_date + timedelta(days=i) for i in range(365)]\n    return dates\n\ndef date_to_day_of_year(date):\n    return date.timetuple().tm_yday\n\ndef find_dates_with_same_day_of_week(target_date, dates):\n    target_weekday = target_date.weekday()\n    return [date for date in dates if date.weekday() == target_weekday]\n\ndef search_target_date(dates, target_day):\n    for date in dates:\n        if date_to_day_of_year(date) == target_day:\n            return date\n    return None\n\ndates = create_dates()\ntarget_day_of_year = 256\ntarget_date = search_target_date(dates, target_day_of_year)\n\nmatching_dates = find_dates_with_same_day_of_week(target_date, dates)\n\nfor date in matching_dates:\n    print(date.strftime(\"%Y-%m-%d %A\"))"}, {"role": "assistant", "content": "2023-01-04 Wednesday\n2023-01-11 Wednesday\n2023-01-18 Wednesday\n2023-01-25 Wednesday\n2023-02-01 Wednesday\n2023-02-08 Wednesday\n2023-02-15 Wednesday\n2023-02-22 Wednesday\n2023-03-01 Wednesday\n2023-03-08 Wednesday\n2023-03-15 Wednesday\n2023-03-22 Wednesday\n2023-03-29 Wednesday\n2023-04-05 Wednesday\n2023-04-12 Wednesday\n2023-04-19 Wednesday\n2023-04-26 Wednesday\n2023-05-03 Wednesday\n2023-05-10 Wednesday\n2023-05-17 Wednesday\n2023-05-24 Wednesday\n2023-05-31 Wednesday\n2023-06-07 Wednesday\n2023-06-14 Wednesday\n2023-06-21 Wednesday\n2023-06-28 Wednesday\n2023-07-05 Wednesday\n2023-07-12 Wednesday\n2023-07-19 Wednesday\n2023-07-26 Wednesday\n2023-08-02 Wednesday\n2023-08-09 Wednesday\n2023-08-16 Wednesday\n2023-08-23 Wednesday\n2023-08-30 Wednesday\n2023-09-06 Wednesday\n2023-09-13 Wednesday\n2023-09-20 Wednesday\n2023-09-27 Wednesday\n2023-10-04 Wednesday\n2023-10-11 Wednesday\n2023-10-18 Wednesday\n2023-10-25 Wednesday\n2023-11-01 Wednesday\n2023-11-08 Wednesday\n2023-11-15 Wednesday\n2023-11-22 Wednesday\n2023-11-29 Wednesday\n2023-12-06 Wednesday\n2023-12-13 Wednesday\n2023-12-20 Wednesday\n2023-12-27 Wednesday\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef find_median(nums):\n    nums.sort()\n    n = len(nums)\n    mid = n // 2\n    if n % 2 == 0:\n        return (nums[mid - 1] + nums[mid]) / 2\n    else:\n        return nums[mid]\n\ndef binary_search_median(sorted_list, left, right, target_median):\n    while left <= right:\n        mid = (left + right) // 2\n        current_median = find_median(sorted_list[:mid + 1])\n        print(f\"Checking sublist: {sorted_list[:mid + 1]}\")\n        print(f\"Current median: {current_median}, Target median: {target_median}\")\n        if current_median == target_median:\n            return mid\n        elif current_median < target_median:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef main():\n    data = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9, 3, 2, 3]\n    sorted_data = sorted(data)\n    target_median = statistics.median(data)\n    print(f\"Original data: {data}\")\n    print(f\"Sorted data: {sorted_data}\")\n    print(f\"Target median: {target_median}\")\n\n    result_index = binary_search_median(sorted_data, 0, len(sorted_data) - 1, target_median)\n    \n    if result_index != -1:\n        print(f\"\\nSublist with target median found ending at index: {result_index}\")\n        print(f\"Sublist: {sorted_data[:result_index + 1]}\")\n        print(f\"Sublist median: {find_median(sorted_data[:result_index + 1])}\")\n    else:\n        print(\"No sublist found with the target median.\")\n\nmain()"}, {"role": "assistant", "content": "Original data: [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9, 3, 2, 3]\nSorted data: [1, 1, 2, 2, 3, 3, 3, 3, 4, 5, 5, 5, 6, 7, 8, 9, 9, 9]\nTarget median: 4.5\nChecking sublist: [1, 1, 2, 2, 3, 3, 3, 3, 4]\nCurrent median: 3, Target median: 4.5\nChecking sublist: [1, 1, 2, 2, 3, 3, 3, 3, 4, 5, 5, 5, 6, 7]\nCurrent median: 3.0, Target median: 4.5\nChecking sublist: [1, 1, 2, 2, 3, 3, 3, 3, 4, 5, 5, 5, 6, 7, 8, 9]\nCurrent median: 3.5, Target median: 4.5\nChecking sublist: [1, 1, 2, 2, 3, 3, 3, 3, 4, 5, 5, 5, 6, 7, 8, 9, 9]\nCurrent median: 4, Target median: 4.5\nChecking sublist: [1, 1, 2, 2, 3, 3, 3, 3, 4, 5, 5, 5, 6, 7, 8, 9, 9, 9]\nCurrent median: 4.5, Target median: 4.5\n\nSublist with target median found ending at index: 17\nSublist: [1, 1, 2, 2, 3, 3, 3, 3, 4, 5, 5, 5, 6, 7, 8, 9, 9, 9]\nSublist median: 4.5\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef generate_pattern(n):\n    pattern = []\n    for i in range(1, n + 1):\n        row = ''.join(['*' if j % i == 0 else '-' for j in range(1, n + 1)])\n        pattern.append(row)\n    return pattern\n\ndef sort_pattern(pattern):\n    return sorted(pattern, key=lambda x: sum(1 for c in x if c == '-'))\n\ndef print_sorted_pattern(pattern):\n    for row in pattern:\n        print(row)\n\nn = 10\npattern = generate_pattern(n)\nsorted_pattern = sort_pattern(pattern)\nprint_sorted_pattern(sorted_pattern)"}, {"role": "assistant", "content": "**********\n-*-*-*-*-*\n--*--*--*-\n---*---*--\n----*----*\n-----*----\n------*---\n-------*--\n--------*-\n---------*\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef transform_data(data):\n    transformed = []\n    for item in data:\n        matches = re.findall(r'[aeiou]', item, re.IGNORECASE)\n        transformed.append(len(matches))\n    return transformed\n\ndata = [\n    \"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\",\n    \"fig\", \"grape\", \"honeydew\", \"kiwi\", \"lime\", \"mango\",\n    \"nectarine\", \"orange\", \"papaya\", \"quince\", \"raspberry\",\n    \"strawberry\", \"tangerine\", \"ugli\", \"vanilla\", \"watermelon\",\n    \"xigua\", \"yam\", \"zucchini\"\n]\n\nresult = transform_data(data)\n\nfor word, vowel_count in zip(data, result):\n    print(f\"{word}: {vowel_count}\")"}, {"role": "assistant", "content": "apple: 2\nbanana: 3\ncherry: 1\ndate: 2\nelderberry: 3\nfig: 1\ngrape: 2\nhoneydew: 3\nkiwi: 2\nlime: 2\nmango: 2\nnectarine: 4\norange: 3\npapaya: 3\nquince: 3\nraspberry: 2\nstrawberry: 2\ntangerine: 4\nugli: 2\nvanilla: 3\nwatermelon: 4\nxigua: 3\nyam: 1\nzucchini: 3\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef bubble_sort(data):\n    for i in range(len(data)):\n        for j in range(0, len(data) - i - 1):\n            if data[j] > data[j + 1]:\n                data[j], data[j + 1] = data[j + 1], data[j]\n    return data\n\ndef calculate_median(data):\n    sorted_data = bubble_sort(data)\n    return statistics.median(sorted_data)\n\ndataset = [\n    [12, 4, 5, 3, 8, 7],\n    [5, 3, 8, 6, 2, 1],\n    [10, 9, 8, 7, 6, 5],\n    [2, 3, 5, 7, 11, 13],\n    [21, 34, 1, 2, 5, 8],\n    [3, 5, 8, 9, 10, 12]\n]\n\nmedians = [calculate_median(data) for data in dataset]\n\nfor i, data in enumerate(dataset):\n    print(f\"Dataset {i + 1} Median: {medians[i]}\")"}, {"role": "assistant", "content": "Dataset 1 Median: 6.0\nDataset 2 Median: 4.0\nDataset 3 Median: 7.5\nDataset 4 Median: 6.0\nDataset 5 Median: 6.5\nDataset 6 Median: 8.5\n"}]}
{"messages": [{"role": "user", "content": "from datetime import date, timedelta\n\ndef generate_dates_list(start_date, num_days):\n    return [start_date + timedelta(days=i) for i in range(num_days)]\n\ndef day_of_year(d):\n    return d.timetuple().tm_yday\n\ndef sort_dates_by_day_of_year(dates):\n    return sorted(dates, key=day_of_year)\n\nstart_date = date(2023, 1, 1)\nnum_days = 100\ndates = generate_dates_list(start_date, num_days)\nsorted_dates = sort_dates_by_day_of_year(dates)\n\nfor d in sorted_dates:\n    print(d.strftime(\"%Y-%m-%d\"))"}, {"role": "assistant", "content": "2023-01-01\n2023-01-02\n2023-01-03\n2023-01-04\n2023-01-05\n2023-01-06\n2023-01-07\n2023-01-08\n2023-01-09\n2023-01-10\n2023-01-11\n2023-01-12\n2023-01-13\n2023-01-14\n2023-01-15\n2023-01-16\n2023-01-17\n2023-01-18\n2023-01-19\n2023-01-20\n2023-01-21\n2023-01-22\n2023-01-23\n2023-01-24\n2023-01-25\n2023-01-26\n2023-01-27\n2023-01-28\n2023-01-29\n2023-01-30\n2023-01-31\n2023-02-01\n2023-02-02\n2023-02-03\n2023-02-04\n2023-02-05\n2023-02-06\n2023-02-07\n2023-02-08\n2023-02-09\n2023-02-10\n2023-02-11\n2023-02-12\n2023-02-13\n2023-02-14\n2023-02-15\n2023-02-16\n2023-02-17\n2023-02-18\n2023-02-19\n2023-02-20\n2023-02-21\n2023-02-22\n2023-02-23\n2023-02-24\n2023-02-25\n2023-02-26\n2023-02-27\n2023-02-28\n2023-03-01\n2023-03-02\n2023-03-03\n2023-03-04\n2023-03-05\n2023-03-06\n2023-03-07\n2023-03-08\n2023-03-09\n2023-03-10\n2023-03-11\n2023-03-12\n2023-03-13\n2023-03-14\n2023-03-15\n2023-03-16\n2023-03-17\n2023-03-18\n2023-03-19\n2023-03-20\n2023-03-21\n2023-03-22\n2023-03-23\n2023-03-24\n2023-03-25\n2023-03-26\n2023-03-27\n2023-03-28\n2023-03-29\n2023-03-30\n2023-03-31\n2023-04-01\n2023-04-02\n2023-04-03\n2023-04-04\n2023-04-05\n2023-04-06\n2023-04-07\n2023-04-08\n2023-04-09\n2023-04-10\n"}]}
{"messages": [{"role": "user", "content": "def generate_spiral_pattern(n):\n    spiral = [[0] * n for _ in range(n)]\n    x, y = 0, 0\n    dx, dy = 0, 1\n    for i in range(n * n):\n        spiral[x][y] = i + 1\n        if spiral[(x + dx) % n][(y + dy) % n]:\n            dx, dy = dy, -dx\n        x, y = x + dx, y + dy\n    return spiral\n\ndef search_for_pattern(spiral, pattern):\n    def dfs(x, y, pi):\n        if pi == len(pattern):\n            return True\n        if not (0 <= x < len(spiral) and 0 <= y < len(spiral) and spiral[x][y] == pattern[pi]):\n            return False\n        temp, spiral[x][y] = spiral[x][y], -1\n        found = any(dfs(x + dx, y + dy, pi + 1) for dx, dy in directions)\n        spiral[x][y] = temp\n        return found\n\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    for i in range(len(spiral)):\n        for j in range(len(spiral)):\n            if dfs(i, j, 0):\n                return True\n    return False\n\nn = 10\nspiral = generate_spiral_pattern(n)\npattern = [1, 2, 3, 4, 5]\n\nprint(\"Spiral Pattern:\")\nfor row in spiral:\n    print(' '.join(f\"{num:2}\" for num in row))\n\nprint(\"\\nSearching for pattern:\", pattern)\nif search_for_pattern(spiral, pattern):\n    print(\"Pattern found in the spiral.\")\nelse:\n    print(\"Pattern not found in the spiral.\")"}, {"role": "assistant", "content": "Spiral Pattern:\n 1  2  3  4  5  6  7  8  9 10\n36 37 38 39 40 41 42 43 44 11\n35 64 65 66 67 68 69 70 45 12\n34 63 84 85 86 87 88 71 46 13\n33 62 83 96 97 98 89 72 47 14\n32 61 82 95 100 99 90 73 48 15\n31 60 81 94 93 92 91 74 49 16\n30 59 80 79 78 77 76 75 50 17\n29 58 57 56 55 54 53 52 51 18\n28 27 26 25 24 23 22 21 20 19\n\nSearching for pattern: [1, 2, 3, 4, 5]\nPattern found in the spiral.\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"\nSorting algorithms are an essential part of computer science. They are used to arrange data in a specific order.\nCommon sorting algorithms include bubble sort, insertion sort, selection sort, merge sort, and quicksort.\nEach has its own advantages and disadvantages, and they are chosen based on the data characteristics.\n\"\"\"\n\nword_pattern = re.compile(r'\\b\\w+\\b')\n\nwords = word_pattern.findall(text)\nprint(f\"Extracted words: {words}\")\n\nunique_words = set(words)\nprint(f\"Unique words: {unique_words}\")\n\ndef custom_sort(word_list):\n    return sorted(word_list, key=lambda word: (len(word), word.lower()))\n\nsorted_words = custom_sort(unique_words)\nprint(f\"Sorted words by length and lexicographic order: {sorted_words}\")\n\nfor word in sorted_words:\n    print(word)"}, {"role": "assistant", "content": "Extracted words: ['Sorting', 'algorithms', 'are', 'an', 'essential', 'part', 'of', 'computer', 'science', 'They', 'are', 'used', 'to', 'arrange', 'data', 'in', 'a', 'specific', 'order', 'Common', 'sorting', 'algorithms', 'include', 'bubble', 'sort', 'insertion', 'sort', 'selection', 'sort', 'merge', 'sort', 'and', 'quicksort', 'Each', 'has', 'its', 'own', 'advantages', 'and', 'disadvantages', 'and', 'they', 'are', 'chosen', 'based', 'on', 'the', 'data', 'characteristics']\nUnique words: {'include', 'essential', 'has', 'specific', 'They', 'own', 'order', 'quicksort', 'and', 'merge', 'of', 'bubble', 'arrange', 'in', 'sorting', 'an', 'are', 'algorithms', 'a', 'data', 'insertion', 'selection', 'Each', 'advantages', 'chosen', 'the', 'disadvantages', 'to', 'based', 'science', 'on', 'sort', 'Common', 'computer', 'Sorting', 'characteristics', 'used', 'part', 'they', 'its'}\nSorted words by length and lexicographic order: ['a', 'an', 'in', 'of', 'on', 'to', 'and', 'are', 'has', 'its', 'own', 'the', 'data', 'Each', 'part', 'sort', 'They', 'they', 'used', 'based', 'merge', 'order', 'bubble', 'chosen', 'Common', 'arrange', 'include', 'science', 'sorting', 'Sorting', 'computer', 'specific', 'essential', 'insertion', 'quicksort', 'selection', 'advantages', 'algorithms', 'disadvantages', 'characteristics']\na\nan\nin\nof\non\nto\nand\nare\nhas\nits\nown\nthe\ndata\nEach\npart\nsort\nThey\nthey\nused\nbased\nmerge\norder\nbubble\nchosen\nCommon\narrange\ninclude\nscience\nsorting\nSorting\ncomputer\nspecific\nessential\ninsertion\nquicksort\nselection\nadvantages\nalgorithms\ndisadvantages\ncharacteristics\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef distance(point1, point2):\n    return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)\n\ndef is_inside_circle(point, circle_center, radius):\n    return distance(point, circle_center) < radius\n\ndef find_points_inside_circle(points, circle_center, radius):\n    return [point for point in points if is_inside_circle(point, circle_center, radius)]\n\ndef generate_circle_grid(width, height, spacing):\n    return [(x, y) for x in range(0, width, spacing) for y in range(0, height, spacing)]\n\nwidth, height, spacing = 20, 20, 2\ncircle_center = (10, 10)\ncircle_radius = 6\n\npoints = generate_circle_grid(width, height, spacing)\ninside_points = find_points_inside_circle(points, circle_center, circle_radius)\n\nfor point in inside_points:\n    print(point)"}, {"role": "assistant", "content": "(6, 6)\n(6, 8)\n(6, 10)\n(6, 12)\n(6, 14)\n(8, 6)\n(8, 8)\n(8, 10)\n(8, 12)\n(8, 14)\n(10, 6)\n(10, 8)\n(10, 10)\n(10, 12)\n(10, 14)\n(12, 6)\n(12, 8)\n(12, 10)\n(12, 12)\n(12, 14)\n(14, 6)\n(14, 8)\n(14, 10)\n(14, 12)\n(14, 14)\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef polygon_area(vertices):\n    n = len(vertices)\n    area = 0.0\n    for i in range(n):\n        j = (i + 1) % n\n        area += vertices[i][0] * vertices[j][1]\n        area -= vertices[j][0] * vertices[i][1]\n    area = abs(area) / 2.0\n    return area\n\ndef angle_from_origin(vertex):\n    x, y = vertex\n    return math.atan2(y, x)\n\ndef sort_vertices_by_angle(vertices):\n    return sorted(vertices, key=angle_from_origin)\n\ndef generate_polygon_sides(n):\n    angle_increment = 2 * math.pi / n\n    return [(math.cos(i * angle_increment), math.sin(i * angle_increment)) for i in range(n)]\n\nn_sides = 12\nvertices = generate_polygon_sides(n_sides)\nprint(\"Original vertices:\")\nfor vert in vertices:\n    print(vert)\n\nsorted_vertices = sort_vertices_by_angle(vertices)\nprint(\"\\nSorted vertices by angle:\")\nfor vert in sorted_vertices:\n    print(vert)\n\narea = polygon_area(sorted_vertices)\nprint(f\"\\nCalculated polygon area with {n_sides} sides: {area:.5f}\")\n\naltered_vertices = sorted_vertices[:]\naltered_vertices[0], altered_vertices[1] = altered_vertices[1], altered_vertices[0]\nprint(\"\\nAltered vertices by swapping first two vertices:\")\nfor vert in altered_vertices:\n    print(vert)\n\naltered_area = polygon_area(altered_vertices)\nprint(f\"\\nCalculated area after altering vertices: {altered_area:.5f}\")"}, {"role": "assistant", "content": "Original vertices:\n(1.0, 0.0)\n(0.8660254037844387, 0.49999999999999994)\n(0.5000000000000001, 0.8660254037844386)\n(6.123233995736766e-17, 1.0)\n(-0.49999999999999983, 0.8660254037844387)\n(-0.8660254037844385, 0.5000000000000003)\n(-1.0, 1.2246467991473532e-16)\n(-0.8660254037844388, -0.4999999999999998)\n(-0.5000000000000004, -0.8660254037844384)\n(-1.8369701987210297e-16, -1.0)\n(0.49999999999999933, -0.866025403784439)\n(0.8660254037844384, -0.5000000000000004)\n\nSorted vertices by angle:\n(-0.8660254037844388, -0.4999999999999998)\n(-0.5000000000000004, -0.8660254037844384)\n(-1.8369701987210297e-16, -1.0)\n(0.49999999999999933, -0.866025403784439)\n(0.8660254037844384, -0.5000000000000004)\n(1.0, 0.0)\n(0.8660254037844387, 0.49999999999999994)\n(0.5000000000000001, 0.8660254037844386)\n(6.123233995736766e-17, 1.0)\n(-0.49999999999999983, 0.8660254037844387)\n(-0.8660254037844385, 0.5000000000000003)\n(-1.0, 1.2246467991473532e-16)\n\nCalculated polygon area with 12 sides: 3.00000\n\nAltered vertices by swapping first two vertices:\n(-0.5000000000000004, -0.8660254037844384)\n(-0.8660254037844388, -0.4999999999999998)\n(-1.8369701987210297e-16, -1.0)\n(0.49999999999999933, -0.866025403784439)\n(0.8660254037844384, -0.5000000000000004)\n(1.0, 0.0)\n(0.8660254037844387, 0.49999999999999994)\n(0.5000000000000001, 0.8660254037844386)\n(6.123233995736766e-17, 1.0)\n(-0.49999999999999983, 0.8660254037844387)\n(-0.8660254037844385, 0.5000000000000003)\n(-1.0, 1.2246467991473532e-16)\n\nCalculated area after altering vertices: 2.86603\n"}]}
{"messages": [{"role": "user", "content": "from itertools import permutations\n\ndef is_valid_move(board, move):\n    return board[move[0]] is None and board[move[1]] is None\n\ndef apply_move(board, move, player):\n    board[move[0]], board[move[1]] = player, player\n\ndef undo_move(board, move):\n    board[move[0]], board[move[1]] = None, None\n\ndef check_winner(board, player):\n    win_positions = [(0, 1, 2), (3, 4, 5), (6, 7, 8),\n                     (0, 3, 6), (1, 4, 7), (2, 5, 8),\n                     (0, 4, 8), (2, 4, 6)]\n    for pos in win_positions:\n        if board[pos[0]] == board[pos[1]] == board[pos[2]] == player:\n            return True\n    return False\n\ndef find_winning_moves(board, player):\n    moves = []\n    for a, b in permutations(range(9), 2):\n        move = (a, b)\n        if is_valid_move(board, move):\n            apply_move(board, move, player)\n            if check_winner(board, player):\n                moves.append(move)\n            undo_move(board, move)\n    return moves\n\ndef print_board(board):\n    for i in range(0, 9, 3):\n        print(' '.join(board[i:i+3] or ' ' for j in range(3)))\n\ndef main():\n    board = [None] * 9\n    print(\"Initial Board:\")\n    print_board(board)\n    moves = find_winning_moves(board, 'X')\n    if moves:\n        print(\"\\nWinning Moves for 'X':\")\n        for move in moves:\n            print(f\"Move: {move}\")\n\nmain()"}, {"role": "assistant", "content": "Traceback (most recent call last):\n  File \"<string>\", line 46, in <module>\n  File \"<string>\", line 39, in main\n  File \"<string>\", line 34, in print_board\nTypeError: sequence item 0: expected str instance, list found\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndata = [\n    {'name': 'Alice', 'check_in': '2023-10-01 08:30:00'},\n    {'name': 'Bob', 'check_in': '2023-10-01 09:15:00'},\n    {'name': 'Charlie', 'check_in': '2023-10-01 07:45:00'},\n    {'name': 'David', 'check_in': '2023-10-01 08:00:00'},\n    {'name': 'Eve', 'check_in': '2023-10-01 09:05:00'},\n    {'name': 'Frank', 'check_in': '2023-10-01 08:45:00'},\n    {'name': 'Grace', 'check_in': '2023-10-01 07:50:00'},\n    {'name': 'Heidi', 'check_in': '2023-10-01 08:10:00'},\n    {'name': 'Ivan', 'check_in': '2023-10-01 09:00:00'},\n    {'name': 'Judy', 'check_in': '2023-10-01 07:55:00'},\n    {'name': 'Mallory', 'check_in': '2023-10-01 08:50:00'},\n    {'name': 'Niaj', 'check_in': '2023-10-01 09:10:00'},\n    {'name': 'Olivia', 'check_in': '2023-10-01 08:20:00'},\n    {'name': 'Peggy', 'check_in': '2023-10-01 08:40:00'},\n    {'name': 'Sybil', 'check_in': '2023-10-01 09:20:00'},\n    {'name': 'Trent', 'check_in': '2023-10-01 08:55:00'},\n    {'name': 'Victor', 'check_in': '2023-10-01 09:25:00'},\n    {'name': 'Walter', 'check_in': '2023-10-01 08:05:00'},\n]\n\ndata.sort(key=lambda x: datetime.datetime.strptime(x['check_in'], '%Y-%m-%d %H:%M:%S'))\n\nfor entry in data:\n    print(entry['name'], entry['check_in'])"}, {"role": "assistant", "content": "Charlie 2023-10-01 07:45:00\nGrace 2023-10-01 07:50:00\nJudy 2023-10-01 07:55:00\nDavid 2023-10-01 08:00:00\nWalter 2023-10-01 08:05:00\nHeidi 2023-10-01 08:10:00\nOlivia 2023-10-01 08:20:00\nAlice 2023-10-01 08:30:00\nPeggy 2023-10-01 08:40:00\nFrank 2023-10-01 08:45:00\nMallory 2023-10-01 08:50:00\nTrent 2023-10-01 08:55:00\nIvan 2023-10-01 09:00:00\nEve 2023-10-01 09:05:00\nNiaj 2023-10-01 09:10:00\nBob 2023-10-01 09:15:00\nSybil 2023-10-01 09:20:00\nVictor 2023-10-01 09:25:00\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\ndef score_calculator(records):\n    scores = []\n    for record in records:\n        date_str, score = record.split(':')\n        date_obj = datetime.strptime(date_str, '%Y-%m-%d')\n        scores.append((date_obj, int(score)))\n    return scores\n\ndef sort_by_score(records):\n    return sorted(records, key=lambda x: x[1])\n\ngame_records = [\n    \"2023-07-21:50\",\n    \"2023-06-13:40\",\n    \"2023-08-09:70\",\n    \"2023-05-01:65\",\n    \"2023-04-15:85\",\n    \"2023-09-30:55\",\n    \"2023-03-22:90\",\n    \"2023-02-11:75\",\n    \"2023-01-05:60\",\n    \"2023-10-31:45\"\n]\n\nscored_records = score_calculator(game_records)\nsorted_records = sort_by_score(scored_records)\n\nfor date_obj, score in sorted_records:\n    print(f\"{date_obj.strftime('%Y-%m-%d')} : {score}\")"}, {"role": "assistant", "content": "2023-06-13 : 40\n2023-10-31 : 45\n2023-07-21 : 50\n2023-09-30 : 55\n2023-01-05 : 60\n2023-05-01 : 65\n2023-08-09 : 70\n2023-02-11 : 75\n2023-04-15 : 85\n2023-03-22 : 90\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef find_date_with_max_gap(dates):\n    dates.sort()\n    max_gap = datetime.timedelta(days=0)\n    date_pair = (None, None)\n    \n    for i in range(1, len(dates)):\n        gap = dates[i] - dates[i - 1]\n        print(f\"Gap between {dates[i-1]} and {dates[i]}: {gap}\")\n        if gap > max_gap:\n            max_gap = gap\n            date_pair = (dates[i - 1], dates[i])\n            print(f\"New max gap found: {max_gap} between {date_pair[0]} and {date_pair[1]}\")\n    \n    return date_pair\n\ndates_list = [\n    datetime.date(2023, 1, 1),\n    datetime.date(2023, 2, 14),\n    datetime.date(2023, 3, 15),\n    datetime.date(2023, 6, 20),\n    datetime.date(2023, 7, 4),\n    datetime.date(2023, 9, 10),\n    datetime.date(2023, 12, 31),\n    datetime.date(2023, 10, 31),\n    datetime.date(2023, 11, 25),\n    datetime.date(2023, 8, 1)\n]\n\nstart, end = find_date_with_max_gap(dates_list)\nprint(\"\\nDate range with maximum gap:\")\nprint(f\"Start: {start}\")\nprint(f\"End: {end}\")"}, {"role": "assistant", "content": "Gap between 2023-01-01 and 2023-02-14: 44 days, 0:00:00\nNew max gap found: 44 days, 0:00:00 between 2023-01-01 and 2023-02-14\nGap between 2023-02-14 and 2023-03-15: 29 days, 0:00:00\nGap between 2023-03-15 and 2023-06-20: 97 days, 0:00:00\nNew max gap found: 97 days, 0:00:00 between 2023-03-15 and 2023-06-20\nGap between 2023-06-20 and 2023-07-04: 14 days, 0:00:00\nGap between 2023-07-04 and 2023-08-01: 28 days, 0:00:00\nGap between 2023-08-01 and 2023-09-10: 40 days, 0:00:00\nGap between 2023-09-10 and 2023-10-31: 51 days, 0:00:00\nGap between 2023-10-31 and 2023-11-25: 25 days, 0:00:00\nGap between 2023-11-25 and 2023-12-31: 36 days, 0:00:00\n\nDate range with maximum gap:\nStart: 2023-03-15\nEnd: 2023-06-20\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef binary_search_dates(dates, target):\n    low, high = 0, len(dates) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if dates[mid] == target:\n            return mid\n        elif dates[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n\ndef generate_dates(start_date, num_days):\n    dates = []\n    for i in range(num_days):\n        dates.append(start_date + timedelta(days=i))\n    return dates\n\nstart_date = datetime(2020, 1, 1)\ndates = generate_dates(start_date, 100)\n\nsearch_date = start_date + timedelta(days=42)\nindex = binary_search_dates(dates, search_date)\n\nfor i, date in enumerate(dates):\n    if i == index:\n        print(f\"Found {date.strftime('%Y-%m-%d')} at index {i}\")\n    else:\n        print(date.strftime('%Y-%m-%d'))"}, {"role": "assistant", "content": "2020-01-01\n2020-01-02\n2020-01-03\n2020-01-04\n2020-01-05\n2020-01-06\n2020-01-07\n2020-01-08\n2020-01-09\n2020-01-10\n2020-01-11\n2020-01-12\n2020-01-13\n2020-01-14\n2020-01-15\n2020-01-16\n2020-01-17\n2020-01-18\n2020-01-19\n2020-01-20\n2020-01-21\n2020-01-22\n2020-01-23\n2020-01-24\n2020-01-25\n2020-01-26\n2020-01-27\n2020-01-28\n2020-01-29\n2020-01-30\n2020-01-31\n2020-02-01\n2020-02-02\n2020-02-03\n2020-02-04\n2020-02-05\n2020-02-06\n2020-02-07\n2020-02-08\n2020-02-09\n2020-02-10\n2020-02-11\nFound 2020-02-12 at index 42\n2020-02-13\n2020-02-14\n2020-02-15\n2020-02-16\n2020-02-17\n2020-02-18\n2020-02-19\n2020-02-20\n2020-02-21\n2020-02-22\n2020-02-23\n2020-02-24\n2020-02-25\n2020-02-26\n2020-02-27\n2020-02-28\n2020-02-29\n2020-03-01\n2020-03-02\n2020-03-03\n2020-03-04\n2020-03-05\n2020-03-06\n2020-03-07\n2020-03-08\n2020-03-09\n2020-03-10\n2020-03-11\n2020-03-12\n2020-03-13\n2020-03-14\n2020-03-15\n2020-03-16\n2020-03-17\n2020-03-18\n2020-03-19\n2020-03-20\n2020-03-21\n2020-03-22\n2020-03-23\n2020-03-24\n2020-03-25\n2020-03-26\n2020-03-27\n2020-03-28\n2020-03-29\n2020-03-30\n2020-03-31\n2020-04-01\n2020-04-02\n2020-04-03\n2020-04-04\n2020-04-05\n2020-04-06\n2020-04-07\n2020-04-08\n2020-04-09\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef calculate_median_differences(data):\n    sorted_data = sorted(data)\n    n = len(sorted_data)\n    mid = n // 2\n    if n % 2 == 0:\n        lower_half = sorted_data[:mid]\n        upper_half = sorted_data[mid:]\n    else:\n        lower_half = sorted_data[:mid]\n        upper_half = sorted_data[mid+1:]\n    \n    q1 = statistics.median(lower_half)\n    q3 = statistics.median(upper_half)\n    \n    return q3 - q1\n\ndef find_outliers(data):\n    sorted_data = sorted(data)\n    q1 = statistics.median(sorted_data[:len(sorted_data)//2])\n    q3 = statistics.median(sorted_data[(len(sorted_data)+1)//2:])\n    iqr = q3 - q1\n    lower_bound = q1 - 1.5 * iqr\n    upper_bound = q3 + 1.5 * iqr\n    \n    outliers = [x for x in data if x < lower_bound or x > upper_bound]\n    return outliers\n\ndata_samples = [\n    [10, 12, 23, 23, 16, 23, 21, 16],\n    [12, 15, 14, 10, 8, 15, 12, 22, 18, 19],\n    [100, 102, 105, 110, 105, 103, 101, 102, 104],\n    [1, 2, 5, 7, 8, 8, 10, 10, 12, 12, 14, 15],\n    [7, 7, 8, 8, 9, 10, 10, 11, 12, 13, 14, 15],\n    [1, 2, 3, 4, 6, 9, 12, 15, 18, 21, 24, 27],\n    [30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40],\n    [5, 7, 8, 5, 3, 9, 12, 13, 45, 7, 7, 5],\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37],\n    [10, 20, 30, 40, 50, 60, 70, 80, 90, 100],\n]\n\nfor sample in data_samples:\n    iqr = calculate_median_differences(sample)\n    outliers = find_outliers(sample)\n    print(f\"Sample: {sample}\")\n    print(f\"IQR: {iqr}\")\n    print(f\"Outliers: {outliers}\\n\")"}, {"role": "assistant", "content": "Sample: [10, 12, 23, 23, 16, 23, 21, 16]\nIQR: 9.0\nOutliers: []\n\nSample: [12, 15, 14, 10, 8, 15, 12, 22, 18, 19]\nIQR: 6\nOutliers: []\n\nSample: [100, 102, 105, 110, 105, 103, 101, 102, 104]\nIQR: 3.5\nOutliers: []\n\nSample: [1, 2, 5, 7, 8, 8, 10, 10, 12, 12, 14, 15]\nIQR: 6.0\nOutliers: []\n\nSample: [7, 7, 8, 8, 9, 10, 10, 11, 12, 13, 14, 15]\nIQR: 4.5\nOutliers: []\n\nSample: [1, 2, 3, 4, 6, 9, 12, 15, 18, 21, 24, 27]\nIQR: 16.0\nOutliers: []\n\nSample: [30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40]\nIQR: 6\nOutliers: []\n\nSample: [5, 7, 8, 5, 3, 9, 12, 13, 45, 7, 7, 5]\nIQR: 5.5\nOutliers: [45]\n\nSample: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\nIQR: 20.0\nOutliers: []\n\nSample: [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]\nIQR: 50\nOutliers: []\n\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndates = [\n    \"2023-10-02 14:30:00\",\n    \"2021-07-19 09:00:00\",\n    \"2022-01-01 00:00:00\",\n    \"2023-10-02 14:30:01\",\n    \"2023-10-02 14:29:59\",\n    \"2020-12-31 23:59:59\",\n    \"2023-10-02 13:30:00\",\n    \"2023-10-03 00:00:00\",\n    \"2023-10-01 23:59:59\",\n    \"2023-10-02 14:30:00\",\n]\n\ndate_objects = [datetime.strptime(date, \"%Y-%m-%d %H:%M:%S\") for date in dates]\n\nsorted_dates = sorted(date_objects, key=lambda d: (d.date(), d.time()))\n\nunique_sorted_dates = []\nlast_date = None\nfor date in sorted_dates:\n    if last_date is None or last_date != date:\n        unique_sorted_dates.append(date)\n    last_date = date\n\nfor date in unique_sorted_dates:\n    print(date.strftime(\"%Y-%m-%d %H:%M:%S\"))"}, {"role": "assistant", "content": "2020-12-31 23:59:59\n2021-07-19 09:00:00\n2022-01-01 00:00:00\n2023-10-01 23:59:59\n2023-10-02 13:30:00\n2023-10-02 14:29:59\n2023-10-02 14:30:00\n2023-10-02 14:30:01\n2023-10-03 00:00:00\n"}]}
{"messages": [{"role": "user", "content": "import string\n\ndef caesar_cipher(text, shift):\n    def shift_char(c):\n        if c in string.ascii_lowercase:\n            return chr((ord(c) - ord('a') + shift) % 26 + ord('a'))\n        elif c in string.ascii_uppercase:\n            return chr((ord(c) - ord('A') + shift) % 26 + ord('A'))\n        else:\n            return c\n\n    return ''.join(shift_char(c) for c in text)\n\ndef binary_search_decrypt(encrypted, expected_word):\n    low, high = 0, 25\n    while low <= high:\n        mid = (low + high) // 2\n        decrypted_text = caesar_cipher(encrypted, mid)\n        if expected_word in decrypted_text:\n            return mid, decrypted_text\n        elif expected_word < decrypted_text:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return None, \"\"\n\nencrypted_message = \"Gdkkn Vnqkc\"\nexpected_word = \"Hello\"\n\nshift, decrypted_message = binary_search_decrypt(encrypted_message, expected_word)\nprint(f\"Shift: {shift}\")\nprint(\"Decrypted Message:\")\nprint(decrypted_message)"}, {"role": "assistant", "content": "Shift: 1\nDecrypted Message:\nHello World\n"}]}
{"messages": [{"role": "user", "content": "def find_pattern(l, target):\n    for i in range(len(l) - len(target) + 1):\n        match = True\n        for j in range(len(target)):\n            if l[i + j] != target[j]:\n                match = False\n                break\n        if match:\n            return i\n    return -1\n\ndef generate_spiral(n):\n    spiral = [[0] * n for _ in range(n)]\n    num = 1\n    left, right, top, bottom = 0, n - 1, 0, n - 1\n\n    while left <= right and top <= bottom:\n        for i in range(left, right + 1):\n            spiral[top][i] = num\n            num += 1\n        top += 1\n        for i in range(top, bottom + 1):\n            spiral[i][right] = num\n            num += 1\n        right -= 1\n        for i in range(right, left - 1, -1):\n            spiral[bottom][i] = num\n            num += 1\n        bottom -= 1\n        for i in range(bottom, top - 1, -1):\n            spiral[i][left] = num\n            num += 1\n        left += 1\n\n    return spiral\n\ndef print_spiral_with_pattern(n, pattern):\n    spiral = generate_spiral(n)\n    for row in spiral:\n        idx = find_pattern(row, pattern)\n        if idx != -1:\n            print(f\"Pattern {pattern} found in row {row} at index {idx}\")\n\npattern_to_find = [5, 6, 7]\nprint_spiral_with_pattern(10, pattern_to_find)"}, {"role": "assistant", "content": "Pattern [5, 6, 7] found in row [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] at index 4\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef calculate_distance(point):\n    return math.sqrt(point[0] ** 2 + point[1] ** 2)\n\ndef sort_by_distance(points):\n    return sorted(points, key=calculate_distance)\n\ndef generate_pattern(n):\n    points = [(math.cos(2 * math.pi / n * i), math.sin(2 * math.pi / n * i)) for i in range(n)]\n    sorted_points = sort_by_distance(points)\n    return sorted_points\n\ndef print_pattern(points):\n    for x, y in points:\n        print(f\"({x:.2f}, {y:.2f})\", end=' ')\n    print()\n\nn = 30\npattern_points = generate_pattern(n)\nprint_pattern(pattern_points)"}, {"role": "assistant", "content": "(0.91, 0.41) (0.31, 0.95) (-0.81, -0.59) (0.67, -0.74) (1.00, 0.00) (0.98, 0.21) (0.81, 0.59) (0.67, 0.74) (0.50, 0.87) (0.10, 0.99) (-0.10, 0.99) (-0.31, 0.95) (-0.50, 0.87) (-0.67, 0.74) (-0.81, 0.59) (-0.91, 0.41) (-0.98, 0.21) (-1.00, 0.00) (-0.98, -0.21) (-0.91, -0.41) (-0.67, -0.74) (-0.50, -0.87) (-0.31, -0.95) (-0.10, -0.99) (0.10, -0.99) (0.31, -0.95) (0.50, -0.87) (0.81, -0.59) (0.91, -0.41) (0.98, -0.21) \n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef sort_dates_wrongly(dates):\n    print(\"Original dates list:\")\n    for date in dates:\n        print(date.strftime(\"%Y-%m-%d\"))\n    \n    dates.sort(key=lambda date: date.month)\n    print(\"\\nDates sorted by month (incorrectly named function):\")\n    for date in dates:\n        print(date.strftime(\"%Y-%m-%d\"))\n\ndates_list = [\n    datetime.datetime(2023, 5, 17),\n    datetime.datetime(2022, 1, 1),\n    datetime.datetime(2023, 3, 14),\n    datetime.datetime(2021, 12, 25),\n    datetime.datetime(2022, 7, 4),\n    datetime.datetime(2023, 5, 6),\n    datetime.datetime(2021, 11, 11),\n    datetime.datetime(2023, 8, 19),\n    datetime.datetime(2022, 3, 3),\n    datetime.datetime(2021, 9, 9),\n    datetime.datetime(2023, 2, 22),\n    datetime.datetime(2023, 10, 5),\n    datetime.datetime(2022, 4, 18),\n    datetime.datetime(2021, 6, 30),\n    datetime.datetime(2023, 12, 1)\n]\n\nsort_dates_wrongly(dates_list)"}, {"role": "assistant", "content": "Original dates list:\n2023-05-17\n2022-01-01\n2023-03-14\n2021-12-25\n2022-07-04\n2023-05-06\n2021-11-11\n2023-08-19\n2022-03-03\n2021-09-09\n2023-02-22\n2023-10-05\n2022-04-18\n2021-06-30\n2023-12-01\n\nDates sorted by month (incorrectly named function):\n2022-01-01\n2023-02-22\n2023-03-14\n2022-03-03\n2022-04-18\n2023-05-17\n2023-05-06\n2021-06-30\n2022-07-04\n2023-08-19\n2021-09-09\n2023-10-05\n2021-11-11\n2021-12-25\n2023-12-01\n"}]}
{"messages": [{"role": "user", "content": "def is_happy_number(n):\n    seen = set()\n    while n != 1 and n not in seen:\n        seen.add(n)\n        n = sum(int(i) ** 2 for i in str(n))\n    return n == 1\n\ndef generate_happy_numbers(limit):\n    sequence = []\n    n = 1\n    while len(sequence) < limit:\n        if is_happy_number(n):\n            sequence.append(n)\n        n += 1\n    return sequence\n\ndef binary_search(seq, value):\n    low, high = 0, len(seq) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if seq[mid] < value:\n            low = mid + 1\n        elif seq[mid] > value:\n            high = mid - 1\n        else:\n            return mid\n    return -1\n\nhappy_numbers = generate_happy_numbers(50)\nsearch_values = [7, 10, 19, 23, 28, 31, 32, 44, 49, 50, 100]\n\nfor value in search_values:\n    idx = binary_search(happy_numbers, value)\n    if idx != -1:\n        print(f\"{value} is the {idx + 1}-th happy number.\")\n    else:\n        print(f\"{value} is not in the first 50 happy numbers.\")"}, {"role": "assistant", "content": "7 is the 2-th happy number.\n10 is the 3-th happy number.\n19 is the 5-th happy number.\n23 is the 6-th happy number.\n28 is the 7-th happy number.\n31 is the 8-th happy number.\n32 is the 9-th happy number.\n44 is the 10-th happy number.\n49 is the 11-th happy number.\n50 is not in the first 50 happy numbers.\n100 is the 20-th happy number.\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Nam malesuada, \nligula at placerat volutpat, sapien orci facilisis massa, non gravida \nnibh libero non libero. Cras a libero eu arcu interdum fermentum. Nulla \nfacilisi. Proin vehicula ligula vestibulum, volutpat turpis et, \nconsectetur lorem. Pellentesque habitant morbi tristique senectus et netus \net malesuada fames ac turpis egestas. Sed sed justo id ligula ultricies \nmalesuada. Etiam nec ligula a tortor varius posuere. Donec id ligula \nnon turpis posuere fermentum. Nam vitae ligula at justo dapibus \naccumsan. Phasellus gravida ligula a velit auctor, et feugiat lorem \nviverra. Sed a libero non libero varius malesuada.\n\"\"\"\n\nwords_to_search = ['libero', 'ligula', 'malesuada', 'varius', 'non', 'et']\n\ndef search_word_positions(text, word):\n    print(f\"Searching for word: '{word}'\")\n    positions = [match.start() for match in re.finditer(r'\\b' + re.escape(word) + r'\\b', text)]\n    print(f\"Found positions: {positions}\")\n    return positions\n\nresults = {}\n\nfor word in words_to_search:\n    positions = search_word_positions(text, word)\n    results[word] = positions\n\nprint(\"\\nFinal Results:\")\nfor word, positions in results.items():\n    print(f\"Word: '{word}' - Positions: {positions}\")"}, {"role": "assistant", "content": "Searching for word: 'libero'\nFound positions: [150, 161, 176, 651, 662]\nSearching for word: 'ligula'\nFound positions: [74, 243, 414, 453, 494, 542, 595]\nSearching for word: 'malesuada'\nFound positions: [62, 362, 432, 676]\nSearching for word: 'varius'\nFound positions: [469, 669]\nSearching for word: 'non'\nFound positions: [132, 157, 502, 658]\nSearching for word: 'et'\nFound positions: [278, 349, 359, 618]\n\nFinal Results:\nWord: 'libero' - Positions: [150, 161, 176, 651, 662]\nWord: 'ligula' - Positions: [74, 243, 414, 453, 494, 542, 595]\nWord: 'malesuada' - Positions: [62, 362, 432, 676]\nWord: 'varius' - Positions: [469, 669]\nWord: 'non' - Positions: [132, 157, 502, 658]\nWord: 'et' - Positions: [278, 349, 359, 618]\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef date_to_number(date_str):\n    date_obj = datetime.strptime(date_str, '%Y-%m-%d')\n    return date_obj.year * 10000 + date_obj.month * 100 + date_obj.day\n\ndef number_to_date(number):\n    year = number // 10000\n    month = (number % 10000) // 100\n    day = number % 100\n    return datetime(year, month, day).strftime('%Y-%m-%d')\n\ndef sort_dates(date_list):\n    date_numbers = [date_to_number(date) for date in date_list]\n    date_numbers.sort()\n    return [number_to_date(num) for num in date_numbers]\n\nstart_date = datetime(2020, 1, 1)\ndate_sequence = [(start_date + timedelta(days=i * 60)).strftime('%Y-%m-%d') for i in range(20)]\nunsorted_dates = date_sequence[::-1]\n\nsorted_dates = sort_dates(unsorted_dates)\nfor date in sorted_dates:\n    print(date)"}, {"role": "assistant", "content": "2020-01-01\n2020-03-01\n2020-04-30\n2020-06-29\n2020-08-28\n2020-10-27\n2020-12-26\n2021-02-24\n2021-04-25\n2021-06-24\n2021-08-23\n2021-10-22\n2021-12-21\n2022-02-19\n2022-04-20\n2022-06-19\n2022-08-18\n2022-10-17\n2022-12-16\n2023-02-14\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef sort_sentences_by_word_count(text):\n    sentences = re.split(r'(?<=[.!?]) +', text)\n    sentence_word_counts = [(sentence, len(sentence.split())) for sentence in sentences]\n    sentence_word_counts.sort(key=lambda x: x[1], reverse=True)\n    return [sentence for sentence, _ in sentence_word_counts]\n\ntext = (\n    \"The quick brown fox jumps over the lazy dog. \"\n    \"A journey of a thousand miles begins with a single step. \"\n    \"To be or not to be, that is the question. \"\n    \"All that glitters is not gold. \"\n    \"The only thing we have to fear is fear itself. \"\n    \"That's one small step for a man, one giant leap for mankind. \"\n    \"In the end, we will remember not the words of our enemies, \"\n    \"but the silence of our friends. \"\n    \"I think, therefore I am. \"\n    \"To err is human; to forgive, divine. \"\n    \"Time flies like an arrow; fruit flies like a banana. \"\n    \"Fortune favors the bold. \"\n    \"Knowledge is power.\"\n)\n\nsorted_sentences = sort_sentences_by_word_count(text)\noutput = \"\\n\".join(sorted_sentences)\nprint(output)"}, {"role": "assistant", "content": "In the end, we will remember not the words of our enemies, but the silence of our friends.\nThat's one small step for a man, one giant leap for mankind.\nA journey of a thousand miles begins with a single step.\nTo be or not to be, that is the question.\nThe only thing we have to fear is fear itself.\nTime flies like an arrow; fruit flies like a banana.\nThe quick brown fox jumps over the lazy dog.\nTo err is human; to forgive, divine.\nAll that glitters is not gold.\nI think, therefore I am.\nFortune favors the bold.\nKnowledge is power.\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef sort_temperatures(temps):\n    debug_sorted = sorted(temps)\n    print(\"Debug Sorted Temperatures:\", debug_sorted)\n    return debug_sorted\n\ndef find_median_temperature(temps):\n    sorted_temperatures = sort_temperatures(temps)\n    print(\"Sorted Temperatures for Median Calculation:\", sorted_temperatures)\n    return statistics.mean(sorted_temperatures)\n\ntemperatures = [\n    70, 65, 80, 90, 60, 85, 75, 95, 68, 82, 77, 88, 73, 83, 79, 91, 66, 84, 81, 78, \n    67, 86, 72, 92, 62, 89, 76, 87, 74, 69, 94, 71, 63, 93, 64, 61, 97, 96, 98, 99\n]\n\nmedian_temperature = find_median_temperature(temperatures)\nprint(\"Calculated Median Temperature:\", median_temperature)"}, {"role": "assistant", "content": "Debug Sorted Temperatures: [60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]\nSorted Temperatures for Median Calculation: [60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]\nCalculated Median Temperature: 79.5\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef date_to_days(date):\n    start_date = datetime.date(2000, 1, 1)\n    delta = date - start_date\n    return delta.days\n\ndef days_to_date(days):\n    start_date = datetime.date(2000, 1, 1)\n    return start_date + datetime.timedelta(days=days)\n\ndef binary_search(arr, target, low, high):\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n\ndates = [datetime.date(2005, 7, 14), datetime.date(2020, 5, 25), datetime.date(2012, 4, 15), \n         datetime.date(2018, 9, 9), datetime.date(2001, 12, 30), datetime.date(2010, 3, 5),\n         datetime.date(2015, 6, 19), datetime.date(2003, 11, 3), datetime.date(2008, 8, 8)]\n\ndays_list = sorted(date_to_days(date) for date in dates)\n\nsearch_dates = [datetime.date(2010, 3, 5), datetime.date(2018, 9, 9), datetime.date(2000, 1, 1)]\n\nfor search_date in search_dates:\n    search_days = date_to_days(search_date)\n    index = binary_search(days_list, search_days, 0, len(days_list) - 1)\n    if index != -1:\n        result_date = days_to_date(days_list[index])\n        print(f\"Found: {result_date} (Days since 2000-01-01: {days_list[index]})\")\n    else:\n        print(f\"Not Found: {search_date}\")"}, {"role": "assistant", "content": "Found: 2010-03-05 (Days since 2000-01-01: 3716)\nFound: 2018-09-09 (Days since 2000-01-01: 6826)\nNot Found: 2000-01-01\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\ndef closest_pair(points):\n    def recursive_search(px, py):\n        if len(px) <= 3:\n            min_dist = float('inf')\n            for i in range(len(px)):\n                for j in range(i + 1, len(px)):\n                    dist = distance(px[i], px[j])\n                    if dist < min_dist:\n                        min_dist = dist\n            return min_dist\n\n        mid = len(px) // 2\n        Qx = px[:mid]\n        Rx = px[mid:]\n\n        midpoint = px[mid][0]\n        Qy = list(filter(lambda x: x[0] <= midpoint, py))\n        Ry = list(filter(lambda x: x[0] > midpoint, py))\n\n        d1 = recursive_search(Qx, Qy)\n        d2 = recursive_search(Rx, Ry)\n        delta = min(d1, d2)\n\n        strip = [p for p in py if abs(p[0] - midpoint) < delta]\n        min_dist_strip = float('inf')\n        for i in range(len(strip)):\n            for j in range(i + 1, min(i + 7, len(strip))):\n                dist = distance(strip[i], strip[j])\n                if dist < min_dist_strip:\n                    min_dist_strip = dist\n\n        return min(delta, min_dist_strip)\n\n    px = sorted(points, key=lambda x: x[0])\n    py = sorted(points, key=lambda x: x[1])\n    return recursive_search(px, py)\n\npoints = [(2, 3), (12, 30), (40, 50), (5, 1), (12, 10), (3, 4), (7, 7), (8, 9), (10, 11), (15, 16),\n          (17, 19), (20, 25), (22, 24), (24, 25), (30, 35), (32, 31), (34, 36), (37, 39), (38, 40),\n          (45, 48)]\n\nresult = closest_pair(points)\nprint(f\"Closest distance between pairs: {result:.6f}\")"}, {"role": "assistant", "content": "Closest distance between pairs: 1.414214\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef calculate_polygon_area(vertices):\n    n = len(vertices)\n    area = 0.0\n    for i in range(n):\n        j = (i + 1) % n\n        area += vertices[i][0] * vertices[j][1]\n        area -= vertices[j][0] * vertices[i][1]\n    area = abs(area) / 2.0\n    return area\n\ndef sort_polygons_by_area(polygons):\n    areas = [(calculate_polygon_area(p), p) for p in polygons]\n    areas.sort(key=lambda x: x[0])\n    return [p for _, p in areas]\n\npolygons = [\n    [(0, 0), (4, 0), (4, 3)],\n    [(0, 0), (1, 0), (1, 1), (0, 1)],\n    [(0, 0), (0, 2), (2, 2), (2, 0)],\n    [(0, 0), (2, 0), (1, 1)],\n    [(0, 0), (3, 0), (3, 3), (0, 3)],\n    [(0, 0), (5, 0), (5, 2), (0, 2)],\n    [(0, 0), (0, 1), (1, 1), (1, 0)],\n    [(0, 0), (6, 0), (3, 3)],\n    [(0, 0), (5, 0), (2, 4)],\n    [(0, 0), (2, 0), (1, 2)],\n]\n\nsorted_polygons = sort_polygons_by_area(polygons)\n\nfor polygon in sorted_polygons:\n    area = calculate_polygon_area(polygon)\n    print(f\"Polygon with vertices {polygon} has area: {area}\")"}, {"role": "assistant", "content": "Polygon with vertices [(0, 0), (1, 0), (1, 1), (0, 1)] has area: 1.0\nPolygon with vertices [(0, 0), (2, 0), (1, 1)] has area: 1.0\nPolygon with vertices [(0, 0), (0, 1), (1, 1), (1, 0)] has area: 1.0\nPolygon with vertices [(0, 0), (2, 0), (1, 2)] has area: 2.0\nPolygon with vertices [(0, 0), (0, 2), (2, 2), (2, 0)] has area: 4.0\nPolygon with vertices [(0, 0), (4, 0), (4, 3)] has area: 6.0\nPolygon with vertices [(0, 0), (3, 0), (3, 3), (0, 3)] has area: 9.0\nPolygon with vertices [(0, 0), (6, 0), (3, 3)] has area: 9.0\nPolygon with vertices [(0, 0), (5, 0), (5, 2), (0, 2)] has area: 10.0\nPolygon with vertices [(0, 0), (5, 0), (2, 4)] has area: 10.0\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\nimport math\n\ndef generate_time_series(length):\n    start_date = datetime(2023, 1, 1)\n    series = [start_date + timedelta(days=i) for i in range(length)]\n    return series\n\ndef calculate_anomalies(series):\n    anomalies = []\n    mean_index = len(series) // 2\n    mean_date = series[mean_index]\n    print(f\"Mean date for anomaly identification: {mean_date}\")\n    for date in series:\n        days_diff = abs((mean_date - date).days)\n        if days_diff > mean_index // 2:\n            anomalies.append(date)\n    return anomalies\n\ndef search_date(target_date, series, start, end):\n    if start > end:\n        return None\n    mid = (start + end) // 2\n    if series[mid] == target_date:\n        return mid\n    elif series[mid] < target_date:\n        return search_date(target_date, series, mid + 1, end)\n    else:\n        return search_date(target_date, series, start, mid - 1)\n\nseries_length = 50\nseries = generate_time_series(series_length)\n\nprint(\"Generated time series:\")\nfor date in series:\n    print(date.strftime(\"%Y-%m-%d\"))\n\nanomalies = calculate_anomalies(series)\n\nprint(\"\\nAnomalies detected:\")\nfor anomaly in anomalies:\n    print(anomaly.strftime(\"%Y-%m-%d\"))\n\ntarget = series[25]\nprint(f\"\\nSearching for the date: {target.strftime('%Y-%m-%d')}\")\nindex = search_date(target, series, 0, len(series) - 1)\n\nif index is not None:\n    print(f\"Date {target.strftime('%Y-%m-%d')} found at index {index}.\")\nelse:\n    print(f\"Date {target.strftime('%Y-%m-%d')} not found.\")"}, {"role": "assistant", "content": "Generated time series:\n2023-01-01\n2023-01-02\n2023-01-03\n2023-01-04\n2023-01-05\n2023-01-06\n2023-01-07\n2023-01-08\n2023-01-09\n2023-01-10\n2023-01-11\n2023-01-12\n2023-01-13\n2023-01-14\n2023-01-15\n2023-01-16\n2023-01-17\n2023-01-18\n2023-01-19\n2023-01-20\n2023-01-21\n2023-01-22\n2023-01-23\n2023-01-24\n2023-01-25\n2023-01-26\n2023-01-27\n2023-01-28\n2023-01-29\n2023-01-30\n2023-01-31\n2023-02-01\n2023-02-02\n2023-02-03\n2023-02-04\n2023-02-05\n2023-02-06\n2023-02-07\n2023-02-08\n2023-02-09\n2023-02-10\n2023-02-11\n2023-02-12\n2023-02-13\n2023-02-14\n2023-02-15\n2023-02-16\n2023-02-17\n2023-02-18\n2023-02-19\nMean date for anomaly identification: 2023-01-26 00:00:00\n\nAnomalies detected:\n2023-01-01\n2023-01-02\n2023-01-03\n2023-01-04\n2023-01-05\n2023-01-06\n2023-01-07\n2023-01-08\n2023-01-09\n2023-01-10\n2023-01-11\n2023-01-12\n2023-01-13\n2023-02-08\n2023-02-09\n2023-02-10\n2023-02-11\n2023-02-12\n2023-02-13\n2023-02-14\n2023-02-15\n2023-02-16\n2023-02-17\n2023-02-18\n2023-02-19\n\nSearching for the date: 2023-01-26\nDate 2023-01-26 found at index 25.\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef encode_message(message, key):\n    key_sorted = sorted(key)\n    print(f\"Original Key: {key}\")\n    print(f\"Sorted Key: {key_sorted}\")\n    key_index = {k: i for i, k in enumerate(key_sorted)}\n    print(f\"Key Index Mapping: {key_index}\")\n\n    # Split message into blocks based on key length\n    block_size = len(key)\n    blocks = [message[i:i+block_size] for i in range(0, len(message), block_size)]\n    print(f\"Message Blocks: {blocks}\")\n\n    encoded_blocks = []\n    for block in blocks:\n        encoded_block = [''] * block_size\n        for i, char in enumerate(block):\n            encoded_block[key_index[key[i]]] = char\n        encoded_blocks.append(''.join(encoded_block))\n        print(f\"Encoded Block: {encoded_block}\")\n\n    encoded_message = ''.join(encoded_blocks)\n    return encoded_message\n\ndef decode_message(encoded_message, key):\n    key_sorted = sorted(key)\n    print(f\"Original Key: {key}\")\n    print(f\"Sorted Key: {key_sorted}\")\n    key_index = {k: i for i, k in enumerate(key)}\n    print(f\"Key Index Mapping: {key_index}\")\n\n    block_size = len(key)\n    blocks = [encoded_message[i:i+block_size] for i in range(0, len(encoded_message), block_size)]\n    print(f\"Encoded Message Blocks: {blocks}\")\n\n    decoded_blocks = []\n    for block in blocks:\n        decoded_block = [''] * block_size\n        for i, char in enumerate(block):\n            decoded_block[i] = block[key_index[key_sorted[i]]]\n        decoded_blocks.append(''.join(decoded_block))\n        print(f\"Decoded Block: {decoded_block}\")\n\n    decoded_message = ''.join(decoded_blocks)\n    return decoded_message\n\noriginal_message = \"HELLOWORLDTHISISATESTMESSAGE\"\nkey = \"CRYPTO\"\n\nprint(\"Original Message:\")\nprint(original_message)\n\nencoded = encode_message(original_message, key)\nprint(\"Encoded Message:\")\nprint(encoded)\n\ndecoded = decode_message(encoded, key)\nprint(\"Decoded Message:\")\nprint(decoded)"}, {"role": "assistant", "content": "Traceback (most recent call last):\n  File \"<string>\", line 58, in <module>\n  File \"<string>\", line 41, in decode_message\nIndexError: string index out of range\n"}]}
{"messages": [{"role": "user", "content": "class GameSolver:\n    def __init__(self, board):\n        self.board = board\n        self.rows = len(board)\n        self.cols = len(board[0])\n        self.visited = set()\n        self.path = []\n\n    def is_safe(self, x, y):\n        return 0 <= x < self.rows and 0 <= y < self.cols and self.board[x][y] == 'O' and (x, y) not in self.visited\n\n    def search_path(self, x, y):\n        if x == self.rows - 1 and y == self.cols - 1:\n            return True\n        self.visited.add((x, y))\n        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if self.is_safe(nx, ny):\n                if self.search_path(nx, ny):\n                    self.path.append((nx, ny))\n                    return True\n        return False\n\n    def solve_game(self):\n        if self.search_path(0, 0):\n            self.path.append((0, 0))\n            return self.path[::-1]\n        return \"No path found\"\n\nboard = [\n    ['O', 'O', 'X', 'O', 'O'],\n    ['X', 'O', 'X', 'O', 'X'],\n    ['O', 'O', 'O', 'X', 'O'],\n    ['O', 'X', 'O', 'O', 'O'],\n    ['O', 'O', 'X', 'X', 'O']\n]\n\nsolver = GameSolver(board)\npath = solver.solve_game()\nfor step in path:\n    print(step)"}, {"role": "assistant", "content": "(0, 0)\n(0, 1)\n(1, 1)\n(2, 1)\n(2, 2)\n(3, 2)\n(3, 3)\n(3, 4)\n(4, 4)\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef sort_games_by_release(games):\n    return sorted(games, key=lambda x: x['release_date'])\n\ndef generate_games():\n    return [\n        {'name': 'Game A', 'release_date': datetime.datetime(2023, 5, 1)},\n        {'name': 'Game B', 'release_date': datetime.datetime(2021, 3, 15)},\n        {'name': 'Game C', 'release_date': datetime.datetime(2022, 8, 30)},\n        {'name': 'Game D', 'release_date': datetime.datetime(2023, 1, 10)},\n        {'name': 'Game E', 'release_date': datetime.datetime(2020, 11, 5)},\n        {'name': 'Game F', 'release_date': datetime.datetime(2022, 12, 25)},\n        {'name': 'Game G', 'release_date': datetime.datetime(2023, 7, 17)},\n        {'name': 'Game H', 'release_date': datetime.datetime(2021, 9, 6)},\n        {'name': 'Game I', 'release_date': datetime.datetime(2020, 5, 20)},\n        {'name': 'Game J', 'release_date': datetime.datetime(2023, 4, 14)},\n    ]\n\ndef display_sorted_games(sorted_games):\n    for game in sorted_games:\n        print(f\"{game['name']} - {game['release_date'].strftime('%Y-%m-%d')}\")\n\ngames = generate_games()\nsorted_games = sort_games_by_release(games)\ndisplay_sorted_games(sorted_games)"}, {"role": "assistant", "content": "Game I - 2020-05-20\nGame E - 2020-11-05\nGame B - 2021-03-15\nGame H - 2021-09-06\nGame C - 2022-08-30\nGame F - 2022-12-25\nGame D - 2023-01-10\nGame J - 2023-04-14\nGame A - 2023-05-01\nGame G - 2023-07-17\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef calculate_pearson_correlation(x, y):\n    n = len(x)\n    sum_x = sum(x)\n    sum_y = sum(y)\n    sum_x_squared = sum(i * i for i in x)\n    sum_y_squared = sum(i * i for i in y)\n    sum_xy = sum(i * j for i, j in zip(x, y))\n    \n    numerator = n * sum_xy - sum_x * sum_y\n    denominator = math.sqrt((n * sum_x_squared - sum_x ** 2) * (n * sum_y_squared - sum_y ** 2))\n    \n    if denominator == 0:\n        return 0\n    return numerator / denominator\n\ndef generate_data():\n    return [(i * 4 + 7, i * 5 + 3) for i in range(100)]\n\ndef sort_data_by_pearson(data):\n    return sorted(data, key=lambda pair: calculate_pearson_correlation([p[0] for p in data], [pair[1]]))\n\ndata = generate_data()\nsorted_data = sort_data_by_pearson(data)\n\nfor x, y in sorted_data:\n    print(f\"x: {x}, y: {y}\")"}, {"role": "assistant", "content": "x: 15, y: 13\nx: 19, y: 18\nx: 39, y: 43\nx: 47, y: 53\nx: 51, y: 58\nx: 55, y: 63\nx: 59, y: 68\nx: 71, y: 83\nx: 75, y: 88\nx: 83, y: 98\nx: 87, y: 103\nx: 91, y: 108\nx: 99, y: 118\nx: 103, y: 123\nx: 115, y: 138\nx: 119, y: 143\nx: 127, y: 153\nx: 135, y: 163\nx: 139, y: 168\nx: 147, y: 178\nx: 151, y: 183\nx: 159, y: 193\nx: 163, y: 198\nx: 171, y: 208\nx: 179, y: 218\nx: 183, y: 223\nx: 191, y: 233\nx: 195, y: 238\nx: 203, y: 248\nx: 207, y: 253\nx: 215, y: 263\nx: 219, y: 268\nx: 223, y: 273\nx: 227, y: 278\nx: 235, y: 288\nx: 243, y: 298\nx: 247, y: 303\nx: 255, y: 313\nx: 259, y: 318\nx: 267, y: 328\nx: 271, y: 333\nx: 279, y: 343\nx: 283, y: 348\nx: 291, y: 358\nx: 295, y: 363\nx: 307, y: 378\nx: 319, y: 393\nx: 323, y: 398\nx: 331, y: 408\nx: 335, y: 413\nx: 343, y: 423\nx: 347, y: 428\nx: 355, y: 438\nx: 359, y: 443\nx: 367, y: 453\nx: 371, y: 458\nx: 379, y: 468\nx: 383, y: 473\nx: 391, y: 483\nx: 395, y: 488\nx: 403, y: 498\nx: 7, y: 3\nx: 11, y: 8\nx: 23, y: 23\nx: 27, y: 28\nx: 31, y: 33\nx: 35, y: 38\nx: 43, y: 48\nx: 63, y: 73\nx: 67, y: 78\nx: 79, y: 93\nx: 95, y: 113\nx: 107, y: 128\nx: 111, y: 133\nx: 123, y: 148\nx: 131, y: 158\nx: 143, y: 173\nx: 155, y: 188\nx: 167, y: 203\nx: 175, y: 213\nx: 187, y: 228\nx: 199, y: 243\nx: 211, y: 258\nx: 231, y: 283\nx: 239, y: 293\nx: 251, y: 308\nx: 263, y: 323\nx: 275, y: 338\nx: 287, y: 353\nx: 299, y: 368\nx: 303, y: 373\nx: 311, y: 383\nx: 315, y: 388\nx: 327, y: 403\nx: 339, y: 418\nx: 351, y: 433\nx: 363, y: 448\nx: 375, y: 463\nx: 387, y: 478\nx: 399, y: 493\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef generate_dates(start_date, days):\n    return [(start_date + timedelta(days=i)).strftime('%Y-%m-%d') for i in range(days)]\n\ndef sort_dates_by_day_of_week(dates):\n    dates_with_weekdays = [(datetime.strptime(date, '%Y-%m-%d'), date) for date in dates]\n    sorted_dates = sorted(dates_with_weekdays, key=lambda x: (x[0].weekday(), x[0]))\n    return [date_tuple[1] for date_tuple in sorted_dates]\n\nstart_date = datetime(2023, 1, 1)\nnum_days = 100\ndate_list = generate_dates(start_date, num_days)\n\nprint(\"Generated Dates:\")\nfor date in date_list:\n    print(date)\n\nsorted_dates = sort_dates_by_day_of_week(date_list)\n\nprint(\"\\nDates Sorted by Day of Week:\")\nfor date in sorted_dates:\n    print(date)"}, {"role": "assistant", "content": "Generated Dates:\n2023-01-01\n2023-01-02\n2023-01-03\n2023-01-04\n2023-01-05\n2023-01-06\n2023-01-07\n2023-01-08\n2023-01-09\n2023-01-10\n2023-01-11\n2023-01-12\n2023-01-13\n2023-01-14\n2023-01-15\n2023-01-16\n2023-01-17\n2023-01-18\n2023-01-19\n2023-01-20\n2023-01-21\n2023-01-22\n2023-01-23\n2023-01-24\n2023-01-25\n2023-01-26\n2023-01-27\n2023-01-28\n2023-01-29\n2023-01-30\n2023-01-31\n2023-02-01\n2023-02-02\n2023-02-03\n2023-02-04\n2023-02-05\n2023-02-06\n2023-02-07\n2023-02-08\n2023-02-09\n2023-02-10\n2023-02-11\n2023-02-12\n2023-02-13\n2023-02-14\n2023-02-15\n2023-02-16\n2023-02-17\n2023-02-18\n2023-02-19\n2023-02-20\n2023-02-21\n2023-02-22\n2023-02-23\n2023-02-24\n2023-02-25\n2023-02-26\n2023-02-27\n2023-02-28\n2023-03-01\n2023-03-02\n2023-03-03\n2023-03-04\n2023-03-05\n2023-03-06\n2023-03-07\n2023-03-08\n2023-03-09\n2023-03-10\n2023-03-11\n2023-03-12\n2023-03-13\n2023-03-14\n2023-03-15\n2023-03-16\n2023-03-17\n2023-03-18\n2023-03-19\n2023-03-20\n2023-03-21\n2023-03-22\n2023-03-23\n2023-03-24\n2023-03-25\n2023-03-26\n2023-03-27\n2023-03-28\n2023-03-29\n2023-03-30\n2023-03-31\n2023-04-01\n2023-04-02\n2023-04-03\n2023-04-04\n2023-04-05\n2023-04-06\n2023-04-07\n2023-04-08\n2023-04-09\n2023-04-10\n\nDates Sorted by Day of Week:\n2023-01-02\n2023-01-09\n2023-01-16\n2023-01-23\n2023-01-30\n2023-02-06\n2023-02-13\n2023-02-20\n2023-02-27\n2023-03-06\n2023-03-13\n2023-03-20\n2023-03-27\n2023-04-03\n2023-04-10\n2023-01-03\n2023-01-10\n2023-01-17\n2023-01-24\n2023-01-31\n2023-02-07\n2023-02-14\n2023-02-21\n2023-02-28\n2023-03-07\n2023-03-14\n2023-03-21\n2023-03-28\n2023-04-04\n2023-01-04\n2023-01-11\n2023-01-18\n2023-01-25\n2023-02-01\n2023-02-08\n2023-02-15\n2023-02-22\n2023-03-01\n2023-03-08\n2023-03-15\n2023-03-22\n2023-03-29\n2023-04-05\n2023-01-05\n2023-01-12\n2023-01-19\n2023-01-26\n2023-02-02\n2023-02-09\n2023-02-16\n2023-02-23\n2023-03-02\n2023-03-09\n2023-03-16\n2023-03-23\n2023-03-30\n2023-04-06\n2023-01-06\n2023-01-13\n2023-01-20\n2023-01-27\n2023-02-03\n2023-02-10\n2023-02-17\n2023-02-24\n2023-03-03\n2023-03-10\n2023-03-17\n2023-03-24\n2023-03-31\n2023-04-07\n2023-01-07\n2023-01-14\n2023-01-21\n2023-01-28\n2023-02-04\n2023-02-11\n2023-02-18\n2023-02-25\n2023-03-04\n2023-03-11\n2023-03-18\n2023-03-25\n2023-04-01\n2023-04-08\n2023-01-01\n2023-01-08\n2023-01-15\n2023-01-22\n2023-01-29\n2023-02-05\n2023-02-12\n2023-02-19\n2023-02-26\n2023-03-05\n2023-03-12\n2023-03-19\n2023-03-26\n2023-04-02\n2023-04-09\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef find_fridays_13th(start_year, end_year):\n    fridays_13th = []\n    for year in range(start_year, end_year + 1):\n        for month in range(1, 13):\n            day = datetime(year, month, 13)\n            if day.weekday() == 4:\n                fridays_13th.append(day.strftime('%Y-%m-%d'))\n    return fridays_13th\n\ndef binary_search_friday_13th(dates, target_date):\n    low, high = 0, len(dates) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        mid_date = datetime.strptime(dates[mid], '%Y-%m-%d')\n        if mid_date == target_date:\n            return dates[mid]\n        elif mid_date < target_date:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return None\n\nstart_year = 1900\nend_year = 2000\ntarget_date = datetime(1960, 5, 13)\nfridays_13th_list = find_fridays_13th(start_year, end_year)\nfound_date = binary_search_friday_13th(fridays_13th_list, target_date)\n\nfor date in fridays_13th_list:\n    print(date)\n\nprint(\"Target date found:\", found_date)"}, {"role": "assistant", "content": "1900-04-13\n1900-07-13\n1901-09-13\n1901-12-13\n1902-06-13\n1903-02-13\n1903-03-13\n1903-11-13\n1904-05-13\n1905-01-13\n1905-10-13\n1906-04-13\n1906-07-13\n1907-09-13\n1907-12-13\n1908-03-13\n1908-11-13\n1909-08-13\n1910-05-13\n1911-01-13\n1911-10-13\n1912-09-13\n1912-12-13\n1913-06-13\n1914-02-13\n1914-03-13\n1914-11-13\n1915-08-13\n1916-10-13\n1917-04-13\n1917-07-13\n1918-09-13\n1918-12-13\n1919-06-13\n1920-02-13\n1920-08-13\n1921-05-13\n1922-01-13\n1922-10-13\n1923-04-13\n1923-07-13\n1924-06-13\n1925-02-13\n1925-03-13\n1925-11-13\n1926-08-13\n1927-05-13\n1928-01-13\n1928-04-13\n1928-07-13\n1929-09-13\n1929-12-13\n1930-06-13\n1931-02-13\n1931-03-13\n1931-11-13\n1932-05-13\n1933-01-13\n1933-10-13\n1934-04-13\n1934-07-13\n1935-09-13\n1935-12-13\n1936-03-13\n1936-11-13\n1937-08-13\n1938-05-13\n1939-01-13\n1939-10-13\n1940-09-13\n1940-12-13\n1941-06-13\n1942-02-13\n1942-03-13\n1942-11-13\n1943-08-13\n1944-10-13\n1945-04-13\n1945-07-13\n1946-09-13\n1946-12-13\n1947-06-13\n1948-02-13\n1948-08-13\n1949-05-13\n1950-01-13\n1950-10-13\n1951-04-13\n1951-07-13\n1952-06-13\n1953-02-13\n1953-03-13\n1953-11-13\n1954-08-13\n1955-05-13\n1956-01-13\n1956-04-13\n1956-07-13\n1957-09-13\n1957-12-13\n1958-06-13\n1959-02-13\n1959-03-13\n1959-11-13\n1960-05-13\n1961-01-13\n1961-10-13\n1962-04-13\n1962-07-13\n1963-09-13\n1963-12-13\n1964-03-13\n1964-11-13\n1965-08-13\n1966-05-13\n1967-01-13\n1967-10-13\n1968-09-13\n1968-12-13\n1969-06-13\n1970-02-13\n1970-03-13\n1970-11-13\n1971-08-13\n1972-10-13\n1973-04-13\n1973-07-13\n1974-09-13\n1974-12-13\n1975-06-13\n1976-02-13\n1976-08-13\n1977-05-13\n1978-01-13\n1978-10-13\n1979-04-13\n1979-07-13\n1980-06-13\n1981-02-13\n1981-03-13\n1981-11-13\n1982-08-13\n1983-05-13\n1984-01-13\n1984-04-13\n1984-07-13\n1985-09-13\n1985-12-13\n1986-06-13\n1987-02-13\n1987-03-13\n1987-11-13\n1988-05-13\n1989-01-13\n1989-10-13\n1990-04-13\n1990-07-13\n1991-09-13\n1991-12-13\n1992-03-13\n1992-11-13\n1993-08-13\n1994-05-13\n1995-01-13\n1995-10-13\n1996-09-13\n1996-12-13\n1997-06-13\n1998-02-13\n1998-03-13\n1998-11-13\n1999-08-13\n2000-10-13\nTarget date found: 1960-05-13\n"}]}
{"messages": [{"role": "user", "content": "import re\nfrom datetime import datetime\n\ndef vigenere_decrypt(ciphertext, key):\n    plaintext = []\n    key_length = len(key)\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():\n            shift = ord(key[i % key_length].upper()) - ord('A')\n            if char.isupper():\n                decrypted_char = chr(((ord(char) - ord('A') - shift) % 26) + ord('A'))\n            else:\n                decrypted_char = chr(((ord(char) - ord('a') - shift) % 26) + ord('a'))\n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    return ''.join(plaintext)\n\ndef search_keyword(ciphertext):\n    keywords = ['TIME', 'DATE', 'CLOCK', 'HOUR', 'MINUTE']\n    for keyword in keywords:\n        print(f\"Trying keyword: {keyword}\")\n        decrypted_text = vigenere_decrypt(ciphertext, keyword)\n        print(f\"Decrypted text: {decrypted_text[:50]}...\")  # Print a snippet of the decrypted text\n        if re.search(r'\\b\\d{2}:\\d{2}:\\d{2}\\b', decrypted_text):\n            return keyword, decrypted_text\n    return None, None\n\nciphertext = (\n    \"Uijt jt b tfdsfu nfttbhf fodpefe xjui b wjhf\"\n    \"ofsf djqifs uibu dpoubjot ujnftupqt mjlf 23:59:59\"\n)\n\nkey, decrypted_message = search_keyword(ciphertext)\nif key:\n    print(f\"Keyword found: {key}\")\n    print(\"Decrypted message:\")\n    print(decrypted_message)\nelse:\n    print(\"No keyword matched.\")"}, {"role": "assistant", "content": "Trying keyword: TIME\nDecrypted text: Baxp bh i hbkktq ftpatvb xczwwta pxqp p dbvbvxgb v...\nKeyword found: TIME\nDecrypted message:\nBaxp bh i hbkktq ftpatvb xczwwta pxqp p dbvbvxgb vxmpxg bapq vdkbtxka ifuxhqwih tbzb 23:59:59\n"}]}
{"messages": [{"role": "user", "content": "def sort_and_generate_pattern(n):\n    pattern = []\n    for i in range(1, n + 1):\n        pattern.append(' '.join(str(i) for _ in range(i)))\n    \n    sorted_pattern = sorted(pattern, key=lambda x: len(x), reverse=True)\n    return sorted_pattern\n\noutput = sort_and_generate_pattern(10)\nfor line in output:\n    print(line)"}, {"role": "assistant", "content": "10 10 10 10 10 10 10 10 10 10\n9 9 9 9 9 9 9 9 9\n8 8 8 8 8 8 8 8\n7 7 7 7 7 7 7\n6 6 6 6 6 6\n5 5 5 5 5\n4 4 4 4\n3 3 3\n2 2\n1\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef transform_dates(dates):\n    def date_to_ordinal(date_str):\n        return datetime.datetime.strptime(date_str, '%Y-%m-%d').toordinal()\n\n    def ordinal_to_date(ordinal):\n        return datetime.date.fromordinal(ordinal).strftime('%Y-%m-%d')\n\n    print(\"Original dates:\", dates)\n    \n    ordinals = list(map(date_to_ordinal, dates))\n    print(\"Dates as ordinals:\", ordinals)\n    \n    sorted_ordinals = sorted(ordinals)\n    print(\"Sorted ordinals:\", sorted_ordinals)\n    \n    sorted_dates = list(map(ordinal_to_date, sorted_ordinals))\n    print(\"Sorted dates:\", sorted_dates)\n    \n    return sorted_dates\n\ndate_list = [\n    \"2023-10-12\", \"2023-05-21\", \"2023-08-14\", \"2023-09-30\",\n    \"2023-01-01\", \"2023-07-04\", \"2023-12-31\", \"2023-03-15\",\n    \"2023-11-11\", \"2023-06-25\", \"2023-02-28\", \"2023-04-18\"\n]\n\nsorted_dates = transform_dates(date_list)\n\nfor date in sorted_dates:\n    print(date)"}, {"role": "assistant", "content": "Original dates: ['2023-10-12', '2023-05-21', '2023-08-14', '2023-09-30', '2023-01-01', '2023-07-04', '2023-12-31', '2023-03-15', '2023-11-11', '2023-06-25', '2023-02-28', '2023-04-18']\nDates as ordinals: [738805, 738661, 738746, 738793, 738521, 738705, 738885, 738594, 738835, 738696, 738579, 738628]\nSorted ordinals: [738521, 738579, 738594, 738628, 738661, 738696, 738705, 738746, 738793, 738805, 738835, 738885]\nSorted dates: ['2023-01-01', '2023-02-28', '2023-03-15', '2023-04-18', '2023-05-21', '2023-06-25', '2023-07-04', '2023-08-14', '2023-09-30', '2023-10-12', '2023-11-11', '2023-12-31']\n2023-01-01\n2023-02-28\n2023-03-15\n2023-04-18\n2023-05-21\n2023-06-25\n2023-07-04\n2023-08-14\n2023-09-30\n2023-10-12\n2023-11-11\n2023-12-31\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef transform_word(word):\n    return ''.join(chr((ord(char) - 97 + 3) % 26 + 97) for char in word)\n\ndef search_and_transform(text, pattern):\n    matches = re.findall(pattern, text)\n    results = []\n    for match in matches:\n        transformed = transform_word(match)\n        print(f\"Transforming '{match}' to '{transformed}'\")\n        results.append(transformed)\n    return results\n\ntext = \"\"\"lorem ipsum dolor sit amet consectetur adipiscing elit sed do\neiusmod tempor incididunt ut labore et dolore magna aliqua\"\"\"\n\n# Incorrect pattern, expecting it to match words of certain length\npattern = r'\\b\\w{5}\\b'\n\ntransformed_words = search_and_transform(text, pattern)\nprint(\"Final transformed words:\")\nfor word in transformed_words:\n    print(word)"}, {"role": "assistant", "content": "Transforming 'lorem' to 'oruhp'\nTransforming 'ipsum' to 'lsvxp'\nTransforming 'dolor' to 'groru'\nTransforming 'magna' to 'pdjqd'\nFinal transformed words:\noruhp\nlsvxp\ngroru\npdjqd\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef generate_pattern(n):\n    pattern = []\n    for i in range(n):\n        line = []\n        for j in range(n):\n            if (i + j) % 2 == 0:\n                line.append('*')\n            else:\n                line.append(' ')\n        pattern.append(''.join(line))\n    return pattern\n\ndef search_pattern(pattern, search):\n    results = []\n    for i, line in enumerate(pattern):\n        if search in line:\n            results.append((i, line.index(search)))\n    return results\n\nn = 10\npattern = generate_pattern(n)\nprint(\"Generated Pattern:\")\nfor line in pattern:\n    print(line)\n\nsearch_term = re.escape('* *')\nprint(\"\\nSearching for pattern:\", search_term)\nfound_positions = search_pattern(pattern, search_term)\n\nprint(\"\\nPattern found at:\")\nfor pos in found_positions:\n    print(f\"Line {pos[0] + 1}, Position {pos[1] + 1}\")"}, {"role": "assistant", "content": "Generated Pattern:\n* * * * * \n * * * * *\n* * * * * \n * * * * *\n* * * * * \n * * * * *\n* * * * * \n * * * * *\n* * * * * \n * * * * *\n\nSearching for pattern: \\*\\ \\*\n\nPattern found at:\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndata = [15, 19, 25, 30, 22, 18, 45, 33, 29, 17, 35, 40]\n\nmean = sum(data) / len(data)\nvariances = [(x - mean) ** 2 for x in data]\nvariance = sum(variances) / len(data)\nstd_dev = math.sqrt(variance)\n\ndef binary_search(arr, target, low, high):\n    if low > high:\n        return False\n    mid = (low + high) // 2\n    if arr[mid] == target:\n        return True\n    elif arr[mid] < target:\n        return binary_search(arr, target, mid + 1, high)\n    else:\n        return binary_search(arr, target, low, mid - 1)\n\nsorted_data = sorted(data)\ntargets = [mean, mean + std_dev, mean - std_dev]\n\noutput_data = []\nfor target in targets:\n    rounded_target = round(target, 2)\n    found = binary_search(sorted_data, rounded_target, 0, len(sorted_data) - 1)\n    status = \"found\" if found else \"not found\"\n    output_data.append((rounded_target, status))\n\nfor target, status in output_data:\n    print(f\"Value {target} is {status} in the dataset.\")"}, {"role": "assistant", "content": "Value 27.33 is not found in the dataset.\nValue 36.56 is not found in the dataset.\nValue 18.1 is not found in the dataset.\n"}]}
{"messages": [{"role": "user", "content": "def lucas(n):\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        return lucas(n - 1) + lucas(n - 2)\n\ndef binary_search(arr, x):\n    low = 0\n    high = len(arr) - 1\n    while low <= high:\n        mid = (high + low) // 2\n        print(f\"Searching... low: {low}, mid: {mid}, high: {high}\")\n        if arr[mid] == x:\n            return mid\n        elif arr[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n\nlucas_sequence = [lucas(i) for i in range(20)]\nprint(\"Lucas Sequence:\", lucas_sequence)\n\ntarget_numbers = [11, 18, 29, 47, 76, 123]\nfor target in target_numbers:\n    print(f\"\\nSearching for {target} in the Lucas sequence:\")\n    result = binary_search(lucas_sequence, target)\n    if result != -1:\n        print(f\"Found {target} at index {result}\")\n    else:\n        print(f\"{target} is not in the Lucas sequence\")"}, {"role": "assistant", "content": "Lucas Sequence: [2, 1, 3, 4, 7, 11, 18, 29, 47, 76, 123, 199, 322, 521, 843, 1364, 2207, 3571, 5778, 9349]\n\nSearching for 11 in the Lucas sequence:\nSearching... low: 0, mid: 9, high: 19\nSearching... low: 0, mid: 4, high: 8\nSearching... low: 5, mid: 6, high: 8\nSearching... low: 5, mid: 5, high: 5\nFound 11 at index 5\n\nSearching for 18 in the Lucas sequence:\nSearching... low: 0, mid: 9, high: 19\nSearching... low: 0, mid: 4, high: 8\nSearching... low: 5, mid: 6, high: 8\nFound 18 at index 6\n\nSearching for 29 in the Lucas sequence:\nSearching... low: 0, mid: 9, high: 19\nSearching... low: 0, mid: 4, high: 8\nSearching... low: 5, mid: 6, high: 8\nSearching... low: 7, mid: 7, high: 8\nFound 29 at index 7\n\nSearching for 47 in the Lucas sequence:\nSearching... low: 0, mid: 9, high: 19\nSearching... low: 0, mid: 4, high: 8\nSearching... low: 5, mid: 6, high: 8\nSearching... low: 7, mid: 7, high: 8\nSearching... low: 8, mid: 8, high: 8\nFound 47 at index 8\n\nSearching for 76 in the Lucas sequence:\nSearching... low: 0, mid: 9, high: 19\nFound 76 at index 9\n\nSearching for 123 in the Lucas sequence:\nSearching... low: 0, mid: 9, high: 19\nSearching... low: 10, mid: 14, high: 19\nSearching... low: 10, mid: 11, high: 13\nSearching... low: 10, mid: 10, high: 10\nFound 123 at index 10\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef number_spiral_diagonal_sum(size):\n    return 1 + sum(4 * i**2 - 6 * i + 6 for i in range(3, size + 1, 2))\n\ndef generate_spiral(size):\n    spiral = [[0] * size for _ in range(size)]\n    x, y = size // 2, size // 2\n    num = 1\n    spiral[y][x] = num\n    for layer in range(1, size // 2 + 1):\n        x += 1\n        num += 1\n        spiral[y][x] = num\n        for _ in range(2 * layer - 1):\n            y += 1\n            num += 1\n            spiral[y][x] = num\n        for _ in range(2 * layer):\n            x -= 1\n            num += 1\n            spiral[y][x] = num\n        for _ in range(2 * layer):\n            y -= 1\n            num += 1\n            spiral[y][x] = num\n        for _ in range(2 * layer):\n            x += 1\n            num += 1\n            spiral[y][x] = num\n    return spiral\n\ndef sorted_spiral_diagonal_sum(size):\n    spiral = generate_spiral(size)\n    diagonals = [spiral[i][i] for i in range(size)] + [spiral[i][size - i - 1] for i in range(size)]\n    return sum(sorted(diagonals))\n\nsize = 21\nprint(\"Number Spiral Diagonal Sum:\", number_spiral_diagonal_sum(size))\nprint(\"Sorted Spiral Diagonal Sum:\", sorted_spiral_diagonal_sum(size))"}, {"role": "assistant", "content": "Number Spiral Diagonal Sum: 6421\nSorted Spiral Diagonal Sum: 6422\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef distance(point1, point2):\n    return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2)\n\ndef area_of_triangle(p1, p2, p3):\n    a = distance(p1, p2)\n    b = distance(p2, p3)\n    c = distance(p3, p1)\n    s = (a + b + c) / 2\n    return math.sqrt(s * (s - a) * (s - b) * (s - c))\n\ndef perimeter_of_polygon(points):\n    return sum(distance(points[i], points[(i + 1) % len(points)]) for i in range(len(points)))\n\ndef sort_triangles_by_area(triangles):\n    return sorted(triangles, key=lambda tri: area_of_triangle(*tri))\n\ndef sort_polygons_by_perimeter(polygons):\n    return sorted(polygons, key=lambda poly: perimeter_of_polygon(poly))\n\ntriangles = [\n    [(0, 0), (1, 0), (0, 1)],\n    [(0, 0), (3, 0), (0, 4)],\n    [(0, 0), (2, 2), (2, 0)],\n    [(1, 1), (2, 5), (5, 2)],\n    [(1, 0), (2, 3), (3, 1)]\n]\n\npolygons = [\n    [(0, 0), (4, 0), (4, 3)],\n    [(1, 1), (4, 1), (4, 5), (1, 5)],\n    [(0, 0), (1, 0), (1, 1), (0, 1)],\n    [(0, 0), (2, 0), (2, 2), (0, 2)],\n    [(0, 0), (4, 0), (4, 4), (0, 4)]\n]\n\nsorted_triangles = sort_triangles_by_area(triangles)\nsorted_polygons = sort_polygons_by_perimeter(polygons)\n\nfor idx, tri in enumerate(sorted_triangles, 1):\n    a = area_of_triangle(*tri)\n    print(f\"Triangle {idx}: {tri}, Area: {a:.2f}\")\n\nprint(\"\\n\")\n\nfor idx, poly in enumerate(sorted_polygons, 1):\n    p = perimeter_of_polygon(poly)\n    print(f\"Polygon {idx}: {poly}, Perimeter: {p:.2f}\")"}, {"role": "assistant", "content": "Triangle 1: [(0, 0), (1, 0), (0, 1)], Area: 0.50\nTriangle 2: [(0, 0), (2, 2), (2, 0)], Area: 2.00\nTriangle 3: [(1, 0), (2, 3), (3, 1)], Area: 2.50\nTriangle 4: [(0, 0), (3, 0), (0, 4)], Area: 6.00\nTriangle 5: [(1, 1), (2, 5), (5, 2)], Area: 7.50\n\n\nPolygon 1: [(0, 0), (1, 0), (1, 1), (0, 1)], Perimeter: 4.00\nPolygon 2: [(0, 0), (2, 0), (2, 2), (0, 2)], Perimeter: 8.00\nPolygon 3: [(0, 0), (4, 0), (4, 3)], Perimeter: 12.00\nPolygon 4: [(1, 1), (4, 1), (4, 5), (1, 5)], Perimeter: 14.00\nPolygon 5: [(0, 0), (4, 0), (4, 4), (0, 4)], Perimeter: 16.00\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef find_longest_word_with_vowels(text):\n    words = re.findall(r'\\b\\w+\\b', text)\n    longest_word = \"\"\n    for word in words:\n        if set(\"aeiou\").issubset(word.lower()):\n            if len(word) < len(longest_word):\n                longest_word = word\n    return longest_word\n\ntext = \"\"\"\nIn an extraordinary display of tenacity and resilience, the ancient tree stood tall amidst the ferocious storm, its branches swaying gracefully. Despite the relentless winds that howled through the night, the tree's deep roots held firm, grounding it steadfastly to the earth. The spectacle of nature's strength and the tree's unwavering resolve to withstand the tempest served as a poignant reminder of the enduring power and beauty inherent in the world around us.\n\"\"\"\n\nprint(find_longest_word_with_vowels(text))"}, {"role": "assistant", "content": "\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef calculate_mean(data):\n    return sum(data) / len(data)\n\ndef calculate_sd(data, mean):\n    variance = sum((x - mean) ** 2 for x in data) / len(data)\n    return math.sqrt(variance)\n\ndef find_closest(data, target):\n    left, right = 0, len(data) - 1\n    closest_index = -1\n    closest_diff = float('inf')\n    \n    while left <= right:\n        mid = (left + right) // 2\n        current_diff = abs(data[mid] - target)\n        \n        if current_diff < closest_diff:\n            closest_diff = current_diff\n            closest_index = mid\n        \n        if data[mid] < target:\n            left = mid + 1\n        elif data[mid] > target:\n            right = mid - 1\n        else:\n            return mid\n    \n    return closest_index\n\ndata = [15, 22, 8, 41, 9, 16, 23, 14, 5, 30, 18, 7, 42, 39, 17]\ndata.sort()\n\nmean = calculate_mean(data)\nprint(f\"Mean of data: {mean}\")\n\nsd = calculate_sd(data, mean)\nprint(f\"Standard Deviation of data: {sd}\")\n\ntarget_values = [10, 20, 25, 35, 40]\n\nfor target in target_values:\n    print(f\"\\nSearching closest value to: {target}\")\n    closest_index = find_closest(data, target)\n    if closest_index != -1:\n        print(f\"Closest value to {target} is {data[closest_index]} at index {closest_index}\")"}, {"role": "assistant", "content": "Mean of data: 20.4\nStandard Deviation of data: 11.959933110180842\n\nSearching closest value to: 10\nClosest value to 10 is 9 at index 3\n\nSearching closest value to: 20\nClosest value to 20 is 22 at index 9\n\nSearching closest value to: 25\nClosest value to 25 is 23 at index 10\n\nSearching closest value to: 35\nClosest value to 35 is 39 at index 12\n\nSearching closest value to: 40\nClosest value to 40 is 41 at index 13\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"\nLorem ipsum dolor sit amet, consectetur adipiscing elit.\nVestibulum vehicula ex nec nisl dapibus, at finibus libero lacinia.\nSuspendisse potenti. Donec ac sem ultrices, auctor est id, hendrerit erat.\nNullam quis est nec libero tristique facilisis. Proin quis ipsum nec nisi interdum elementum.\nPellentesque euismod arcu eget libero venenatis, ac dapibus justo dignissim.\nSed auctor augue ut malesuada suscipit. Nam vel lacus et augue faucibus imperdiet.\nMauris placerat lorem vel arcu ultrices, eu tincidunt neque commodo.\n\"\"\"\n\nsentences = re.split(r'(?<=[.!?]) +', text.strip())\nsentence_lengths = [(sentence, len(sentence.split())) for sentence in sentences]\nsorted_sentences = sorted(sentence_lengths, key=lambda x: x[1], reverse=True)\nsorted_text = ' '.join(sentence for sentence, _ in sorted_sentences)\n\nprint(sorted_text)"}, {"role": "assistant", "content": "Proin quis ipsum nec nisi interdum elementum.\nPellentesque euismod arcu eget libero venenatis, ac dapibus justo dignissim.\nSed auctor augue ut malesuada suscipit. Lorem ipsum dolor sit amet, consectetur adipiscing elit.\nVestibulum vehicula ex nec nisl dapibus, at finibus libero lacinia.\nSuspendisse potenti. Nam vel lacus et augue faucibus imperdiet.\nMauris placerat lorem vel arcu ultrices, eu tincidunt neque commodo. Donec ac sem ultrices, auctor est id, hendrerit erat.\nNullam quis est nec libero tristique facilisis.\n"}]}
{"messages": [{"role": "user", "content": "import datetime\nimport statistics\n\ndef analyze_dates(dates):\n    date_objects = [datetime.datetime.strptime(date, '%Y-%m-%d') for date in dates]\n    sorted_dates = sorted(date_objects)\n    median_date = sorted_dates[len(sorted_dates) // 2]\n    return median_date.strftime('%Y-%m-%d')\n\ndef days_difference(date1, date2):\n    return abs((date2 - date1).days)\n\ndates = [\n    '2023-01-15', '2023-03-22', '2023-07-11', '2023-09-30',\n    '2023-02-10', '2023-06-25', '2023-08-09', '2023-04-18',\n    '2023-11-15', '2023-12-01', '2023-05-19', '2023-10-05'\n]\n\nmedian_date = analyze_dates(dates)\ndate_objects = [datetime.datetime.strptime(date, '%Y-%m-%d') for date in dates]\nmedian_date_obj = datetime.datetime.strptime(median_date, '%Y-%m-%d')\n\ndifferences = [days_difference(median_date_obj, date) for date in date_objects]\nsorted_differences = sorted(differences)\n\nfor diff in sorted_differences:\n    print(diff)"}, {"role": "assistant", "content": "0\n16\n29\n53\n81\n84\n86\n111\n127\n143\n151\n177\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef is_point_inside_polygon(px, py, polygon):\n    n = len(polygon)\n    inside = False\n    xints = 0\n    p1x, p1y = polygon[0]\n    for i in range(n + 1):\n        p2x, p2y = polygon[i % n]\n        if py > min(p1y, p2y):\n            if py <= max(p1y, p2y):\n                if px <= max(p1x, p2x):\n                    if p1y != p2y:\n                        xints = (py - p1y) * (p2x - p1x) / (p2y - p1y) + p1x\n                    if p1x == p2x or px <= xints:\n                        inside = not inside\n        p1x, p1y = p2x, p2y\n    return inside\n\ndef search_polygon_with_point(points, polygons):\n    results = []\n    for px, py in points:\n        for i, polygon in enumerate(polygons):\n            if is_point_inside_polygon(px, py, polygon):\n                results.append((px, py, i))\n                break\n    return results\n\npoints = [(5, 5), (15, 15), (25, 5), (7, 8), (12, 12), (30, 30)]\npolygons = [\n    [(0, 0), (10, 0), (10, 10), (0, 10)],\n    [(20, 0), (30, 0), (30, 10), (20, 10)],\n    [(5, 5), (15, 5), (15, 15), (5, 15)]\n]\n\nresult = search_polygon_with_point(points, polygons)\nfor px, py, poly_index in result:\n    print(f\"Point ({px}, {py}) is inside polygon {poly_index}\")"}, {"role": "assistant", "content": "Point (5, 5) is inside polygon 0\nPoint (15, 15) is inside polygon 2\nPoint (25, 5) is inside polygon 1\nPoint (7, 8) is inside polygon 0\nPoint (12, 12) is inside polygon 2\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ncipher_text = \"\"\"\nGnve7icXl,F4d3cyQ3b9yo0T7heR5V3e,F3d3yQ3c7b8yo0T7heR5W3e,F4d3yZ3b9yo0T7heR5V3e,\nG3d3yX3b9yo0T7heR5V3e,F4d3yX3b9yo0T7heR5W3e,F3d3yQ3b9yo0T7heR5W3e,G4d3yZ3b9yo0T7heR5V3e,\nG4d3yY3b9yo0T7heR5V3e,F4d3yX3b9yo0T7heR5V3e,G4d3yY3b9yo0T7heR5W3e,F4d3yQ3b9yo0T7heR5V3e,\nG4d3yY3b9yo0T7heR5W3e,F4d3yQ3b9yo0T7heR5V3e,G4d3yZ3b9yo0T7heR5W3e,F4d3yX3b9yo0T7heR5V3e,\n\"\"\"\n\ndecoded_message = \"\"\npattern = r\"([A-Z])(\\d)y([A-Z])(\\d)([a-z]+)(\\d)\"\n\nmatches = re.findall(pattern, cipher_text)\n\nfor match in matches:\n    char1, shift1, char2, shift2, text, _ = match\n    primary_shift = ord(char1) - ord('A') + int(shift1)\n    secondary_shift = ord(char2) - ord('A') + int(shift2)\n    for i, ch in enumerate(text):\n        shift = primary_shift if i % 2 == 0 else secondary_shift\n        decoded_message += chr(((ord(ch) - ord('a') + shift) % 26) + ord('a'))\n    decoded_message += \" \"\n\nprint(decoded_message.strip())"}, {"role": "assistant", "content": "\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef generate_dates():\n    start_date = datetime(2023, 1, 1)\n    return [start_date + timedelta(days=i) for i in range(365)]\n\ndef search_for_weekends(dates):\n    weekends = []\n    for date in dates:\n        if date.weekday() >= 5:  # 5 = Saturday, 6 = Sunday\n            weekends.append(date)\n    return weekends\n\ndef format_dates(dates):\n    return [date.strftime('%Y-%m-%d (%A)') for date in dates]\n\ndates = generate_dates()\nweekends = search_for_weekends(dates)\nformatted_weekends = format_dates(weekends)\n\nfor date in formatted_weekends:\n    print(date)"}, {"role": "assistant", "content": "2023-01-01 (Sunday)\n2023-01-07 (Saturday)\n2023-01-08 (Sunday)\n2023-01-14 (Saturday)\n2023-01-15 (Sunday)\n2023-01-21 (Saturday)\n2023-01-22 (Sunday)\n2023-01-28 (Saturday)\n2023-01-29 (Sunday)\n2023-02-04 (Saturday)\n2023-02-05 (Sunday)\n2023-02-11 (Saturday)\n2023-02-12 (Sunday)\n2023-02-18 (Saturday)\n2023-02-19 (Sunday)\n2023-02-25 (Saturday)\n2023-02-26 (Sunday)\n2023-03-04 (Saturday)\n2023-03-05 (Sunday)\n2023-03-11 (Saturday)\n2023-03-12 (Sunday)\n2023-03-18 (Saturday)\n2023-03-19 (Sunday)\n2023-03-25 (Saturday)\n2023-03-26 (Sunday)\n2023-04-01 (Saturday)\n2023-04-02 (Sunday)\n2023-04-08 (Saturday)\n2023-04-09 (Sunday)\n2023-04-15 (Saturday)\n2023-04-16 (Sunday)\n2023-04-22 (Saturday)\n2023-04-23 (Sunday)\n2023-04-29 (Saturday)\n2023-04-30 (Sunday)\n2023-05-06 (Saturday)\n2023-05-07 (Sunday)\n2023-05-13 (Saturday)\n2023-05-14 (Sunday)\n2023-05-20 (Saturday)\n2023-05-21 (Sunday)\n2023-05-27 (Saturday)\n2023-05-28 (Sunday)\n2023-06-03 (Saturday)\n2023-06-04 (Sunday)\n2023-06-10 (Saturday)\n2023-06-11 (Sunday)\n2023-06-17 (Saturday)\n2023-06-18 (Sunday)\n2023-06-24 (Saturday)\n2023-06-25 (Sunday)\n2023-07-01 (Saturday)\n2023-07-02 (Sunday)\n2023-07-08 (Saturday)\n2023-07-09 (Sunday)\n2023-07-15 (Saturday)\n2023-07-16 (Sunday)\n2023-07-22 (Saturday)\n2023-07-23 (Sunday)\n2023-07-29 (Saturday)\n2023-07-30 (Sunday)\n2023-08-05 (Saturday)\n2023-08-06 (Sunday)\n2023-08-12 (Saturday)\n2023-08-13 (Sunday)\n2023-08-19 (Saturday)\n2023-08-20 (Sunday)\n2023-08-26 (Saturday)\n2023-08-27 (Sunday)\n2023-09-02 (Saturday)\n2023-09-03 (Sunday)\n2023-09-09 (Saturday)\n2023-09-10 (Sunday)\n2023-09-16 (Saturday)\n2023-09-17 (Sunday)\n2023-09-23 (Saturday)\n2023-09-24 (Sunday)\n2023-09-30 (Saturday)\n2023-10-01 (Sunday)\n2023-10-07 (Saturday)\n2023-10-08 (Sunday)\n2023-10-14 (Saturday)\n2023-10-15 (Sunday)\n2023-10-21 (Saturday)\n2023-10-22 (Sunday)\n2023-10-28 (Saturday)\n2023-10-29 (Sunday)\n2023-11-04 (Saturday)\n2023-11-05 (Sunday)\n2023-11-11 (Saturday)\n2023-11-12 (Sunday)\n2023-11-18 (Saturday)\n2023-11-19 (Sunday)\n2023-11-25 (Saturday)\n2023-11-26 (Sunday)\n2023-12-02 (Saturday)\n2023-12-03 (Sunday)\n2023-12-09 (Saturday)\n2023-12-10 (Sunday)\n2023-12-16 (Saturday)\n2023-12-17 (Sunday)\n2023-12-23 (Saturday)\n2023-12-24 (Sunday)\n2023-12-30 (Saturday)\n2023-12-31 (Sunday)\n"}]}
{"messages": [{"role": "user", "content": "import string\n\ndef encrypt_message(message):\n    key = 3\n    shift = len(message) % 26\n    encoded_chars = []\n\n    for char in message:\n        if char in string.ascii_letters:\n            shifted = ord(char) + key + shift\n            if char.islower():\n                if shifted > ord('z'):\n                    shifted -= 26\n            else:\n                if shifted > ord('Z'):\n                    shifted -= 26\n            encoded_chars.append(chr(shifted))\n        else:\n            encoded_chars.append(char)\n\n    return ''.join(encoded_chars)\n\ndef custom_sort(encoded_messages):\n    encoded_messages.sort(key=lambda x: (len(x), x))\n    return encoded_messages\n\nmessages = [\n    \"Cryptography can be fun!\",\n    \"Sorting is key to many algorithms.\",\n    \"Keep your secrets safe.\",\n    \"Python is a powerful language.\",\n    \"Encryption adds a layer of security.\",\n    \"Algorithms are the backbone of computer science.\",\n    \"Data encryption is essential for privacy.\",\n    \"The quick brown fox jumps over the lazy dog.\"\n]\n\nencrypted_messages = [encrypt_message(msg) for msg in messages]\nsorted_encrypted_messages = custom_sort(encrypted_messages)\n\nfor encrypted_message in sorted_encrypted_messages:\n    print(encrypted_message)"}, {"role": "assistant", "content": "Keep your secrets safe.\nDszquphsbqiz dbo cf gvo!\nWfaovu pz h wvdlymbs shunbhnl.\nDzcetyr td vpj ez xlyj lwrzctesxd.\nRapelcgvba nqqf n ynlre bs frphevgl.\nVsls wfujqhlagf ak wkkwflasd xgj hjansuq.\nOcz lpdxf wmjri ajs ephkn jqzm ocz gvut yjb.\nZkfnqhsglr zqd sgd azbjanmd ne bnlotsdq rbhdmbd.\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\nfrom itertools import product\n\ndef generate_board():\n    board = []\n    for i in range(5):\n        row = []\n        for j in range(5):\n            row.append((i * 5) + j + 1)\n        board.append(row)\n    return board\n\ndef search_path(board, start, end, path=None):\n    if path is None:\n        path = [start]\n    if start == end:\n        return path\n    x, y = start\n    neighbors = [(x-1, y), (x+1, y), (x, y-1), (x, y+1)]\n    for nx, ny in neighbors:\n        if 0 <= nx < len(board) and 0 <= ny < len(board[0]) and (nx, ny) not in path:\n            result = search_path(board, (nx, ny), end, path + [(nx, ny)])\n            if result is not None:\n                return result\n    return None\n\ndef play_game():\n    board = generate_board()\n    start_time = datetime.now()\n    for start, end in product([(0, 0), (2, 2)], [(4, 4), (1, 1)]):\n        path = search_path(board, start, end)\n        if path:\n            print(f\"Path from {start} to {end}: {path}\")\n    end_time = datetime.now()\n    print(f\"Game Duration: {end_time - start_time}\")\n\nplay_game()"}, {"role": "assistant", "content": "Path from (0, 0) to (4, 4): [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (4, 1), (3, 1), (2, 1), (1, 1), (0, 1), (0, 2), (1, 2), (2, 2), (3, 2), (4, 2), (4, 3), (3, 3), (2, 3), (1, 3), (0, 3), (0, 4), (1, 4), (2, 4), (3, 4), (4, 4)]\nPath from (0, 0) to (1, 1): [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (4, 1), (3, 1), (2, 1), (1, 1)]\nPath from (2, 2) to (4, 4): [(2, 2), (1, 2), (0, 2), (0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (4, 2), (3, 2), (3, 3), (2, 3), (1, 3), (0, 3), (0, 4), (1, 4), (2, 4), (3, 4), (4, 4)]\nPath from (2, 2) to (1, 1): [(2, 2), (1, 2), (0, 2), (0, 1), (1, 1)]\nGame Duration: 0:00:00.000191\n"}]}
{"messages": [{"role": "user", "content": "players = [\n    (\"Alice\", 3, 1, 4),\n    (\"Bob\", 2, 3, 5),\n    (\"Charlie\", 5, 2, 1),\n    (\"Dave\", 4, 5, 2),\n    (\"Eve\", 1, 4, 3),\n    (\"Frank\", 3, 2, 4),\n    (\"Grace\", 2, 5, 3),\n    (\"Heidi\", 4, 3, 2),\n    (\"Ivan\", 5, 1, 4),\n    (\"Judy\", 1, 4, 3)\n]\n\ndef player_score(player):\n    return player[1] * 3 + player[2] * 2 + player[3] * 1\n\nsorted_players = sorted(players, key=player_score, reverse=True)\n\nfor rank, player in enumerate(sorted_players, start=1):\n    print(f\"Rank {rank}: {player[0]} with score {player_score(player)}\")"}, {"role": "assistant", "content": "Rank 1: Dave with score 24\nRank 2: Ivan with score 21\nRank 3: Charlie with score 20\nRank 4: Heidi with score 20\nRank 5: Grace with score 19\nRank 6: Bob with score 17\nRank 7: Frank with score 17\nRank 8: Alice with score 15\nRank 9: Eve with score 14\nRank 10: Judy with score 14\n"}]}
{"messages": [{"role": "user", "content": "def generate_pattern(n):\n    pattern = []\n    for i in range(1, n + 1):\n        line = []\n        for j in range(1, i + 1):\n            line.append(str(j))\n        pattern.append(' '.join(line))\n    return pattern\n\ndef custom_sort(pattern):\n    return sorted(pattern, key=lambda x: (len(x), x))\n\ndef main():\n    n = 10\n    pattern = generate_pattern(n)\n    sorted_pattern = custom_sort(pattern)\n    for line in sorted_pattern:\n        print(line)\n\nmain()"}, {"role": "assistant", "content": "1\n1 2\n1 2 3\n1 2 3 4\n1 2 3 4 5\n1 2 3 4 5 6\n1 2 3 4 5 6 7\n1 2 3 4 5 6 7 8\n1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9 10\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef bubble_sort(data):\n    n = len(data)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if data[j] > data[j+1]:\n                data[j], data[j+1] = data[j+1], data[j]\n\ndef calculate_median(data):\n    bubble_sort(data)\n    return statistics.median(data)\n\ndef calculate_mode(data):\n    bubble_sort(data)\n    return statistics.mode(data)\n\ndef calculate_mean(data):\n    bubble_sort(data)\n    return statistics.mean(data)\n\ndata = [\n    45, 21, 78, 89, 34, 23, 78, 90, 12, 45, 56, 78, 89, 90, 34, 56, 67, 89, 90, 23,\n    45, 34, 12, 90, 78, 56, 45, 23, 34, 67, 56, 78, 89, 90, 21, 67, 78, 56, 89, 23,\n    12, 34, 56, 78, 90, 89, 67, 45, 23, 12, 34, 78, 56, 89, 90, 23, 34, 78, 90, 56,\n    45, 23, 12, 34, 67, 89, 90, 23, 78, 45, 56, 89, 90, 12, 34, 34, 78, 45, 23, 67,\n    56, 90, 89, 45, 23, 78, 56, 34, 67, 89, 90, 12, 23, 45, 78, 56, 34, 67, 89, 90\n]\n\nsorted_data = data[:]\nbubble_sort(sorted_data)\n\nprint(\"Sorted Data:\")\nfor i in range(0, len(sorted_data), 10):\n    print(sorted_data[i:i+10])\n\nprint(\"\\nMedian:\", calculate_median(data))\nprint(\"Mode:\", calculate_mode(data))\nprint(\"Mean:\", calculate_mean(data))"}, {"role": "assistant", "content": "Sorted Data:\n[12, 12, 12, 12, 12, 12, 12, 21, 21, 23]\n[23, 23, 23, 23, 23, 23, 23, 23, 23, 23]\n[34, 34, 34, 34, 34, 34, 34, 34, 34, 34]\n[34, 34, 45, 45, 45, 45, 45, 45, 45, 45]\n[45, 45, 56, 56, 56, 56, 56, 56, 56, 56]\n[56, 56, 56, 56, 67, 67, 67, 67, 67, 67]\n[67, 67, 78, 78, 78, 78, 78, 78, 78, 78]\n[78, 78, 78, 78, 78, 89, 89, 89, 89, 89]\n[89, 89, 89, 89, 89, 89, 89, 90, 90, 90]\n[90, 90, 90, 90, 90, 90, 90, 90, 90, 90]\n\nMedian: 56.0\nMode: 78\nMean: 56.97\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef find_threshold_value(data, target_median):\n    left, right = min(data), max(data)\n    threshold = right\n    \n    while left <= right:\n        mid = (left + right) / 2\n        filtered_data = [x for x in data if x <= mid]\n        \n        if not filtered_data:\n            right = mid - 1\n            continue\n        \n        current_median = statistics.median(filtered_data)\n        \n        print(f\"Trying threshold: {mid:.2f}, Filtered Data: {filtered_data}, Median: {current_median}\")\n        \n        if current_median < target_median:\n            left = mid + 0.01\n        else:\n            threshold = mid\n            right = mid - 0.01\n    \n    return threshold\n\ndata = [15, 22, 9, 32, 45, 37, 10, 25, 18, 5, 30, 12, 40]\ntarget_median = 20\n\nthreshold_value = find_threshold_value(data, target_median)\nprint(f\"Calculated threshold to achieve median {target_median} is: {threshold_value:.2f}\")"}, {"role": "assistant", "content": "Trying threshold: 25.00, Filtered Data: [15, 22, 9, 10, 25, 18, 5, 12], Median: 13.5\nTrying threshold: 35.01, Filtered Data: [15, 22, 9, 32, 10, 25, 18, 5, 30, 12], Median: 16.5\nTrying threshold: 40.01, Filtered Data: [15, 22, 9, 32, 37, 10, 25, 18, 5, 30, 12, 40], Median: 20.0\nTrying threshold: 37.51, Filtered Data: [15, 22, 9, 32, 37, 10, 25, 18, 5, 30, 12], Median: 18\nTrying threshold: 38.76, Filtered Data: [15, 22, 9, 32, 37, 10, 25, 18, 5, 30, 12], Median: 18\nTrying threshold: 39.38, Filtered Data: [15, 22, 9, 32, 37, 10, 25, 18, 5, 30, 12], Median: 18\nTrying threshold: 39.69, Filtered Data: [15, 22, 9, 32, 37, 10, 25, 18, 5, 30, 12], Median: 18\nTrying threshold: 39.85, Filtered Data: [15, 22, 9, 32, 37, 10, 25, 18, 5, 30, 12], Median: 18\nTrying threshold: 39.93, Filtered Data: [15, 22, 9, 32, 37, 10, 25, 18, 5, 30, 12], Median: 18\nTrying threshold: 39.97, Filtered Data: [15, 22, 9, 32, 37, 10, 25, 18, 5, 30, 12], Median: 18\nTrying threshold: 39.99, Filtered Data: [15, 22, 9, 32, 37, 10, 25, 18, 5, 30, 12], Median: 18\nCalculated threshold to achieve median 20 is: 40.01\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef date_to_ordinal(d):\n    return d.toordinal()\n\ndef ordinal_to_date(o):\n    return datetime.date.fromordinal(o)\n\ndef parse_dates(date_strings):\n    return [datetime.datetime.strptime(date_str, \"%Y-%m-%d\").date() for date_str in date_strings]\n\ndef transform_dates(dates):\n    ordinals = list(map(date_to_ordinal, dates))\n    sorted_ordinals = sorted(ordinals)\n    return list(map(ordinal_to_date, sorted_ordinals))\n\ndate_strings = [\n    \"2023-11-15\", \"2022-01-01\", \"2025-06-30\", \"2024-02-29\",\n    \"2023-12-31\", \"2021-05-15\", \"2022-08-22\", \"2020-07-04\",\n    \"2024-12-25\", \"2023-03-20\", \"2021-10-10\", \"2023-07-07\",\n    \"2025-12-31\", \"2023-01-01\", \"2022-12-12\", \"2024-01-01\",\n    \"2023-11-05\", \"2021-12-31\", \"2023-09-09\", \"2020-06-01\"\n]\n\nparsed_dates = parse_dates(date_strings)\ntransformed_dates = transform_dates(parsed_dates)\n\nfor date in transformed_dates:\n    print(date.strftime(\"%Y-%m-%d\"))"}, {"role": "assistant", "content": "2020-06-01\n2020-07-04\n2021-05-15\n2021-10-10\n2021-12-31\n2022-01-01\n2022-08-22\n2022-12-12\n2023-01-01\n2023-03-20\n2023-07-07\n2023-09-09\n2023-11-05\n2023-11-15\n2023-12-31\n2024-01-01\n2024-02-29\n2024-12-25\n2025-06-30\n2025-12-31\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef sort_words_by_vowel_count(text):\n    words = re.findall(r'\\b\\w+\\b', text)\n    sorted_words = sorted(words, key=lambda word: sum(1 for letter in word if letter.lower() in 'aeiou'))\n    return sorted_words\n\ntext = \"\"\"\nAmidst the mist and coldest frost,\nWith stoutest wrist and loudest boast,\nHe thrusts his fists against the posts,\nAnd still insists he sees the ghosts.\n\"\"\"\n\nsorted_words = sort_words_by_vowel_count(text)\n\nfor word in sorted_words:\n    print(word)"}, {"role": "assistant", "content": "the\nmist\nand\nfrost\nWith\nwrist\nand\nHe\nthrusts\nhis\nfists\nthe\nposts\nAnd\nstill\nhe\nthe\nghosts\nAmidst\ncoldest\nboast\ninsists\nsees\nstoutest\nloudest\nagainst\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef find_earliest_date(dates):\n    def date_to_tuple(date):\n        return tuple(map(int, date.split('-')))\n    \n    def binary_search(arr, target_tuple):\n        low, high = 0, len(arr) - 1\n        while low <= high:\n            mid = (low + high) // 2\n            mid_tuple = date_to_tuple(arr[mid])\n            if mid_tuple < target_tuple:\n                low = mid + 1\n            elif mid_tuple > target_tuple:\n                high = mid - 1\n            else:\n                return mid\n        return low\n\n    dates.sort(key=date_to_tuple)\n    random_date = '2023-05-17'\n    position = binary_search(dates, date_to_tuple(random_date))\n    \n    return dates[:position]\n\ndates = [\n    '2023-05-18', '2023-05-16', '2023-04-25', '2023-05-19', '2023-03-12',\n    '2023-05-17', '2023-05-15', '2023-04-30', '2023-05-10', '2023-04-01'\n]\n\nearliest_dates = find_earliest_date(dates)\nfor date in earliest_dates:\n    print(date)"}, {"role": "assistant", "content": "2023-03-12\n2023-04-01\n2023-04-25\n2023-04-30\n2023-05-10\n2023-05-15\n2023-05-16\n"}]}
{"messages": [{"role": "user", "content": "import re\nfrom datetime import datetime\n\ntext = \"\"\"In the year 2023, a remarkable event occurred. By 2025, predictions indicate a significant shift.\nBack in 2020, the world faced unprecedented challenges. In 2021, recovery began slowly.\nThe years 2022 and 2024 have been projected to bring changes in technology.\"\"\"\n\npattern = r\"\\b\\d{4}\\b\"\n\nyears = re.findall(pattern, text)\nyears = list(map(int, years))\n\ndef binary_search(arr, target):\n    low = 0\n    high = len(arr) - 1\n    steps = 0\n    while low <= high:\n        mid = (low + high) // 2\n        steps += 1\n        print(f\"Step {steps}: low={low}, high={high}, mid={mid}, mid_value={arr[mid]}\")\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n\ncurrent_year = datetime.now().year\nprint(f\"Current Year: {current_year}\")\nprint(f\"Years extracted from text: {years}\")\n\nindex = binary_search(sorted(years), current_year)\nif index != -1:\n    print(f\"Current year {current_year} found in text at index {index}.\")\nelse:\n    print(f\"Current year {current_year} not found in text.\")\n\nfor target in range(2020, 2026):\n    index = binary_search(sorted(years), target)\n    if index != -1:\n        print(f\"Year {target} found at index {index}.\")\n    else:\n        print(f\"Year {target} not found.\")"}, {"role": "assistant", "content": "Current Year: 2025\nYears extracted from text: [2023, 2025, 2020, 2021, 2022, 2024]\nStep 1: low=0, high=5, mid=2, mid_value=2022\nStep 2: low=3, high=5, mid=4, mid_value=2024\nStep 3: low=5, high=5, mid=5, mid_value=2025\nCurrent year 2025 found in text at index 5.\nStep 1: low=0, high=5, mid=2, mid_value=2022\nStep 2: low=0, high=1, mid=0, mid_value=2020\nYear 2020 found at index 0.\nStep 1: low=0, high=5, mid=2, mid_value=2022\nStep 2: low=0, high=1, mid=0, mid_value=2020\nStep 3: low=1, high=1, mid=1, mid_value=2021\nYear 2021 found at index 1.\nStep 1: low=0, high=5, mid=2, mid_value=2022\nYear 2022 found at index 2.\nStep 1: low=0, high=5, mid=2, mid_value=2022\nStep 2: low=3, high=5, mid=4, mid_value=2024\nStep 3: low=3, high=3, mid=3, mid_value=2023\nYear 2023 found at index 3.\nStep 1: low=0, high=5, mid=2, mid_value=2022\nStep 2: low=3, high=5, mid=4, mid_value=2024\nYear 2024 found at index 4.\nStep 1: low=0, high=5, mid=2, mid_value=2022\nStep 2: low=3, high=5, mid=4, mid_value=2024\nStep 3: low=5, high=5, mid=5, mid_value=2025\nYear 2025 found at index 5.\n"}]}
{"messages": [{"role": "user", "content": "def is_magic_number(num):\n    digits = list(map(int, str(num)))\n    return sum(digits) == 10\n\ndef find_magic_numbers(limit):\n    magic_numbers = []\n    for i in range(19, limit):\n        if is_magic_number(i):\n            magic_numbers.append(i)\n    return magic_numbers\n\ndef binary_search_magic(numbers, target):\n    low, high = 0, len(numbers) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        print(f\"Searching between index {low} and {high}. Middle index: {mid}\")\n        if numbers[mid] == target:\n            return mid\n        elif numbers[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n\nlimit = 200\nmagic_numbers = find_magic_numbers(limit)\nprint(\"Magic numbers:\", magic_numbers)\n\nsearch_number = 73\nindex = binary_search_magic(magic_numbers, search_number)\nprint(f\"Index of magic number {search_number}:\", index)"}, {"role": "assistant", "content": "Magic numbers: [19, 28, 37, 46, 55, 64, 73, 82, 91, 109, 118, 127, 136, 145, 154, 163, 172, 181, 190]\nSearching between index 0 and 18. Middle index: 9\nSearching between index 0 and 8. Middle index: 4\nSearching between index 5 and 8. Middle index: 6\nIndex of magic number 73: 6\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef generate_pattern(n):\n    pattern = []\n    for i in range(1, n + 1):\n        line = \"\"\n        for j in range(1, i + 1):\n            line += str(j % 10)\n        pattern.append(line)\n    return pattern\n\ndef search_pattern(pattern_list, regex):\n    results = []\n    for line in pattern_list:\n        if re.match(regex, line):\n            results.append(line)\n    return results\n\ndef main():\n    n = 15\n    pattern = generate_pattern(n)\n    regex = r\"^1.*2.*3.*$\"\n    found_patterns = search_pattern(pattern, regex)\n    for line in found_patterns:\n        print(line)\n\nmain()"}, {"role": "assistant", "content": "123\n1234\n12345\n123456\n1234567\n12345678\n123456789\n1234567890\n12345678901\n123456789012\n1234567890123\n12345678901234\n123456789012345\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef cross_product(o, a, b):\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\ndef convex_hull(points):\n    points = sorted(set(points))\n    if len(points) <= 1:\n        return points\n\n    lower = []\n    for p in points:\n        while len(lower) >= 2 and cross_product(lower[-2], lower[-1], p) <= 0:\n            lower.pop()\n        lower.append(p)\n\n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and cross_product(upper[-2], upper[-1], p) <= 0:\n            upper.pop()\n        upper.append(p)\n\n    return lower[:-1] + upper[:-1]\n\ndef polygon_area(vertices):\n    area = 0\n    n = len(vertices)\n    for i in range(n):\n        j = (i + 1) % n\n        area += vertices[i][0] * vertices[j][1]\n        area -= vertices[j][0] * vertices[i][1]\n    return abs(area) / 2\n\nvertices = [\n    (3, 4), (5, 11), (12, 8), (9, 5), (5, 6),\n    (7, 3), (2, 2), (8, 12), (6, 6), (1, 10),\n    (10, 2), (4, 7), (11, 9), (13, 3)\n]\n\nhull = convex_hull(vertices)\nhull_area = polygon_area(hull)\nsorted_vertices = sorted(hull, key=lambda p: (p[0], p[1]))\nsorted_vertices_area = polygon_area(sorted_vertices)\n\nprint(\"Convex Hull Vertices:\")\nfor v in sorted_vertices:\n    print(v)\n\nprint(\"\\nArea of Convex Hull:\", hull_area)\nprint(\"Area of Sorted Convex Hull Vertices:\", sorted_vertices_area)"}, {"role": "assistant", "content": "Convex Hull Vertices:\n(1, 10)\n(2, 2)\n(8, 12)\n(10, 2)\n(12, 8)\n(13, 3)\n\nArea of Convex Hull: 93.0\nArea of Sorted Convex Hull Vertices: 0.5\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndata = [\n    (datetime.datetime(2023, 10, 5), 120),\n    (datetime.datetime(2023, 8, 15), 85),\n    (datetime.datetime(2023, 9, 10), 95),\n    (datetime.datetime(2023, 7, 22), 105),\n    (datetime.datetime(2023, 6, 30), 115),\n    (datetime.datetime(2023, 5, 20), 130),\n    (datetime.datetime(2023, 4, 25), 90),\n    (datetime.datetime(2023, 3, 14), 100),\n    (datetime.datetime(2023, 2, 28), 110),\n    (datetime.datetime(2023, 1, 10), 125)\n]\n\ndef analyze_data(data):\n    print(\"Original Data:\")\n    for date, value in data:\n        print(date.strftime(\"%Y-%m-%d\"), value)\n\n    data_sorted_by_date = sorted(data, key=lambda x: x[0])\n    print(\"\\nData Sorted by Date:\")\n    for date, value in data_sorted_by_date:\n        print(date.strftime(\"%Y-%m-%d\"), value)\n\n    data_sorted_by_value = sorted(data, key=lambda x: x[1], reverse=True)\n    print(\"\\nData Sorted by Value (Descending):\")\n    for date, value in data_sorted_by_value:\n        print(date.strftime(\"%Y-%m-%d\"), value)\n\n    value_differences = [data_sorted_by_value[i][1] - data_sorted_by_value[i+1][1] for i in range(len(data_sorted_by_value)-1)]\n    print(\"\\nValue Differences:\")\n    for diff in value_differences:\n        print(diff)\n\nanalyze_data(data)"}, {"role": "assistant", "content": "Original Data:\n2023-10-05 120\n2023-08-15 85\n2023-09-10 95\n2023-07-22 105\n2023-06-30 115\n2023-05-20 130\n2023-04-25 90\n2023-03-14 100\n2023-02-28 110\n2023-01-10 125\n\nData Sorted by Date:\n2023-01-10 125\n2023-02-28 110\n2023-03-14 100\n2023-04-25 90\n2023-05-20 130\n2023-06-30 115\n2023-07-22 105\n2023-08-15 85\n2023-09-10 95\n2023-10-05 120\n\nData Sorted by Value (Descending):\n2023-05-20 130\n2023-01-10 125\n2023-10-05 120\n2023-06-30 115\n2023-02-28 110\n2023-07-22 105\n2023-03-14 100\n2023-09-10 95\n2023-04-25 90\n2023-08-15 85\n\nValue Differences:\n5\n5\n5\n5\n5\n5\n5\n5\n5\n"}]}
{"messages": [{"role": "user", "content": "from itertools import permutations\n\ndef calculate_score(order):\n    score = 0\n    for i in range(len(order)):\n        if i < len(order) - 1:\n            if order[i] < order[i + 1]:\n                score += 1\n        if i > 0:\n            if order[i] > order[i - 1]:\n                score += 1\n    return score\n\ndef find_best_order(players):\n    best_order = None\n    best_score = -1\n    for order in permutations(players):\n        current_score = calculate_score(order)\n        print(f\"Order: {order}, Score: {current_score}\")\n        if current_score > best_score:\n            best_score = current_score\n            best_order = order\n    return best_order, best_score\n\nplayers = ['Alice', 'Bob', 'Charlie', 'David']\nbest_order, best_score = find_best_order(players)\n\nprint(\"\\nBest Order:\")\nfor player in best_order:\n    print(player)\nprint(f\"Best Score: {best_score}\")"}, {"role": "assistant", "content": "Order: ('Alice', 'Bob', 'Charlie', 'David'), Score: 6\nOrder: ('Alice', 'Bob', 'David', 'Charlie'), Score: 4\nOrder: ('Alice', 'Charlie', 'Bob', 'David'), Score: 4\nOrder: ('Alice', 'Charlie', 'David', 'Bob'), Score: 4\nOrder: ('Alice', 'David', 'Bob', 'Charlie'), Score: 4\nOrder: ('Alice', 'David', 'Charlie', 'Bob'), Score: 2\nOrder: ('Bob', 'Alice', 'Charlie', 'David'), Score: 4\nOrder: ('Bob', 'Alice', 'David', 'Charlie'), Score: 2\nOrder: ('Bob', 'Charlie', 'Alice', 'David'), Score: 4\nOrder: ('Bob', 'Charlie', 'David', 'Alice'), Score: 4\nOrder: ('Bob', 'David', 'Alice', 'Charlie'), Score: 4\nOrder: ('Bob', 'David', 'Charlie', 'Alice'), Score: 2\nOrder: ('Charlie', 'Alice', 'Bob', 'David'), Score: 4\nOrder: ('Charlie', 'Alice', 'David', 'Bob'), Score: 2\nOrder: ('Charlie', 'Bob', 'Alice', 'David'), Score: 2\nOrder: ('Charlie', 'Bob', 'David', 'Alice'), Score: 2\nOrder: ('Charlie', 'David', 'Alice', 'Bob'), Score: 4\nOrder: ('Charlie', 'David', 'Bob', 'Alice'), Score: 2\nOrder: ('David', 'Alice', 'Bob', 'Charlie'), Score: 4\nOrder: ('David', 'Alice', 'Charlie', 'Bob'), Score: 2\nOrder: ('David', 'Bob', 'Alice', 'Charlie'), Score: 2\nOrder: ('David', 'Bob', 'Charlie', 'Alice'), Score: 2\nOrder: ('David', 'Charlie', 'Alice', 'Bob'), Score: 2\nOrder: ('David', 'Charlie', 'Bob', 'Alice'), Score: 0\n\nBest Order:\nAlice\nBob\nCharlie\nDavid\nBest Score: 6\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef flawed_encrypt(text):\n    def encrypt_char(c):\n        return chr(ord(c) + 3)\n\n    def decrypt_char(c):\n        return chr(ord(c) - 3)\n\n    def sort_encrypt(word):\n        return ''.join(sorted(word, key=encrypt_char))\n\n    words = re.findall(r'\\b\\w+\\b', text)\n    encrypted_words = []\n\n    for word in words:\n        encrypted_word = ''.join(encrypt_char(c) for c in word)\n        encrypted_words.append(sort_encrypt(encrypted_word))\n        print(f\"Debug: Original word: {word} -> Encrypted and sorted: {encrypted_words[-1]}\")\n\n    return ' '.join(encrypted_words)\n\ntext = \"Advanced sorting encryption challenge\"\nresult = flawed_encrypt(text)\nprint(\"\\nFinal Encrypted Output:\")\nprint(result)"}, {"role": "assistant", "content": "Debug: Original word: Advanced -> Encrypted and sorted: Ddfgghqy\nDebug: Original word: sorting -> Encrypted and sorted: jlqruvw\nDebug: Original word: encryption -> Encrypted and sorted: fhlqqrsuw|\nDebug: Original word: challenge -> Encrypted and sorted: dfhhjkooq\n\nFinal Encrypted Output:\nDdfgghqy jlqruvw fhlqqrsuw| dfhhjkooq\n"}]}
{"messages": [{"role": "user", "content": "import string\n\ndef caesar_cipher_encrypt(text, shift):\n    encrypted_text = []\n    for char in text:\n        if char.isalpha():\n            shifted = ord(char) + shift\n            if char.islower():\n                if shifted > ord('z'):\n                    shifted -= 26\n                encrypted_text.append(chr(shifted))\n            elif char.isupper():\n                if shifted > ord('Z'):\n                    shifted -= 26\n                encrypted_text.append(chr(shifted))\n        else:\n            encrypted_text.append(char)\n    return ''.join(encrypted_text)\n\ndef caesar_cipher_decrypt(text, shift):\n    return caesar_cipher_encrypt(text, -shift)\n\ndef search_encoded_message(encoded_list, keyword, shift):\n    for encoded in encoded_list:\n        if keyword in caesar_cipher_decrypt(encoded, shift):\n            return encoded\n    return None\n\nmessages = [\n    \"Nkrru cuxrj!\",\n    \"Fqjc ewjfq!\",\n    \"Gdkkn zrrg!\",\n    \"Khoor zruog!\",\n    \"Vgzg qh ozhg!\"\n]\n\nshift = 2\nkeyword = \"hello\"\nencoded_message = search_encoded_message(messages, keyword, shift)\nif encoded_message:\n    print(\"Encoded Message Found:\", encoded_message)\n    print(\"Original Message:\", caesar_cipher_decrypt(encoded_message, shift))\nelse:\n    print(\"Keyword not found in any encoded message.\")"}, {"role": "assistant", "content": "Keyword not found in any encoded message.\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\n# Generate a list of 20 dates, starting from today, with random days added\ndates = [datetime.now() + timedelta(days=i) for i in range(20)]\n\n# Randomly shuffle the dates by applying a transformation on days\ndates = [date + timedelta(days=(date.day % 5) * (date.weekday() - 2)) for date in dates]\n\nprint(\"Original dates list:\")\nfor date in dates:\n    print(date.strftime(\"%Y-%m-%d %H:%M:%S\"))\n\n# Custom sorting based on day of the year and weekday (Monday is 0, Sunday is 6)\ndef custom_sort(date):\n    return (date.timetuple().tm_yday, date.weekday())\n\nprint(\"\\nSorting dates based on day of the year and then weekday:\")\nsorted_dates = sorted(dates, key=custom_sort)\n\nfor date in sorted_dates:\n    print(date.strftime(\"%Y-%m-%d %H:%M:%S\"))"}, {"role": "assistant", "content": "Original dates list:\n2025-03-31 16:06:44\n2025-04-02 16:06:44\n2025-04-06 16:06:44\n2025-04-12 16:06:44\n2025-04-05 16:06:44\n2025-04-10 16:06:44\n2025-04-03 16:06:44\n2025-04-05 16:06:44\n2025-04-09 16:06:44\n2025-04-10 16:06:44\n2025-04-13 16:06:44\n2025-04-18 16:06:44\n2025-04-25 16:06:44\n2025-04-06 16:06:44\n2025-04-15 16:06:44\n2025-04-16 16:06:44\n2025-04-19 16:06:44\n2025-04-24 16:06:44\n2025-05-01 16:06:44\n2025-04-20 16:06:44\n\nSorting dates based on day of the year and then weekday:\n2025-03-31 16:06:44\n2025-04-02 16:06:44\n2025-04-03 16:06:44\n2025-04-05 16:06:44\n2025-04-05 16:06:44\n2025-04-06 16:06:44\n2025-04-06 16:06:44\n2025-04-09 16:06:44\n2025-04-10 16:06:44\n2025-04-10 16:06:44\n2025-04-12 16:06:44\n2025-04-13 16:06:44\n2025-04-15 16:06:44\n2025-04-16 16:06:44\n2025-04-18 16:06:44\n2025-04-19 16:06:44\n2025-04-20 16:06:44\n2025-04-24 16:06:44\n2025-04-25 16:06:44\n2025-05-01 16:06:44\n"}]}
{"messages": [{"role": "user", "content": "from itertools import permutations\n\ndef is_valid_move(pos, n):\n    return 0 <= pos[0] < n and 0 <= pos[1] < n\n\ndef knight_tour(n):\n    moves = [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    board = [[-1 for _ in range(n)] for _ in range(n)]\n    board[0][0] = 0\n    path = [(0, 0)]\n    \n    def solve(pos, move_i):\n        if move_i == n * n:\n            return True\n        for dx, dy in permutations(moves, 1):\n            next_pos = (pos[0] + dx[0], pos[1] + dy[1])\n            if is_valid_move(next_pos, n) and board[next_pos[0]][next_pos[1]] == -1:\n                board[next_pos[0]][next_pos[1]] = move_i\n                path.append(next_pos)\n                print(f\"Trying move {move_i} to {next_pos}\")\n                if solve(next_pos, move_i + 1):\n                    return True\n                board[next_pos[0]][next_pos[1]] = -1\n                path.pop()\n                print(f\"Backtracking from {next_pos}\")\n        return False\n\n    if solve((0, 0), 1):\n        for row in board:\n            print(' '.join(f'{x:2}' for x in row))\n        return True\n    else:\n        print(\"No solution found!\")\n        return False\n\nknight_tour(5)"}, {"role": "assistant", "content": "Traceback (most recent call last):\n  File \"<string>\", line 36, in <module>\n  File \"<string>\", line 28, in knight_tour\n  File \"<string>\", line 15, in solve\nValueError: not enough values to unpack (expected 2, got 1)\n"}]}
{"messages": [{"role": "user", "content": "def find_longest_pattern(s):\n    max_pattern = \"\"\n    max_length = 0\n    for i in range(len(s)):\n        for j in range(i + max_length + 1, len(s) + 1):\n            current_pattern = s[i:j]\n            if s.count(current_pattern) > 1:\n                max_length = len(current_pattern)\n                max_pattern = current_pattern\n    return max_pattern\n\ndef generate_pattern():\n    base_string = \"abacabadabacaba\"\n    pattern = []\n    for i in range(1, len(base_string) + 1):\n        pattern.append(find_longest_pattern(base_string[:i]))\n    return pattern\n\ndef main():\n    pattern = generate_pattern()\n    for line in pattern:\n        print(line)\n\nmain()"}, {"role": "assistant", "content": "\n\na\na\na\nab\naba\naba\naba\naba\naba\nabac\nabaca\nabacab\nabacaba\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\nimport statistics\n\ndates = [datetime(2023, 1, 3), datetime(2023, 2, 1), datetime(2023, 2, 15),\n         datetime(2023, 3, 5), datetime(2023, 3, 18), datetime(2023, 4, 9),\n         datetime(2023, 5, 1), datetime(2023, 5, 20), datetime(2023, 6, 15),\n         datetime(2023, 7, 4), datetime(2023, 7, 22), datetime(2023, 8, 8)]\ntoday = datetime(2023, 10, 1)\n\nprint(\"Original Dates:\")\nfor date in dates:\n    print(date.strftime(\"%Y-%m-%d\"))\n\ndate_diffs = [(today - date).days for date in dates]\nprint(\"\\nDate Differences in Days from Today:\")\nprint(date_diffs)\n\nsorted_diffs = sorted(date_diffs)\nprint(\"\\nSorted Date Differences:\")\nprint(sorted_diffs)\n\nmedian_diff = statistics.median(sorted_diffs)\nprint(\"\\nMedian of Date Differences:\", median_diff)\n\nmode_diff = statistics.mode(sorted_diffs)\nprint(\"Mode of Date Differences:\", mode_diff)\n\nmean_diff = statistics.mean(sorted_diffs)\nprint(\"Mean of Date Differences:\", mean_diff)\n\nstddev_diff = statistics.stdev(sorted_diffs)\nprint(\"Standard Deviation of Date Differences:\", stddev_diff)\n\nmid_date = today - timedelta(days=int(median_diff))\nprint(\"\\nCorresponding Date for Median Difference:\", mid_date.strftime(\"%Y-%m-%d\"))"}, {"role": "assistant", "content": "Original Dates:\n2023-01-03\n2023-02-01\n2023-02-15\n2023-03-05\n2023-03-18\n2023-04-09\n2023-05-01\n2023-05-20\n2023-06-15\n2023-07-04\n2023-07-22\n2023-08-08\n\nDate Differences in Days from Today:\n[271, 242, 228, 210, 197, 175, 153, 134, 108, 89, 71, 54]\n\nSorted Date Differences:\n[54, 71, 89, 108, 134, 153, 175, 197, 210, 228, 242, 271]\n\nMedian of Date Differences: 164.0\nMode of Date Differences: 54\nMean of Date Differences: 161\nStandard Deviation of Date Differences: 70.95324965330084\n\nCorresponding Date for Median Difference: 2023-04-20\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef generate_pattern(n):\n    pattern = []\n    for i in range(1, n + 1):\n        row = ''.join('*' if j % 2 == 0 else ' ' for j in range(i))\n        pattern.append(row)\n    return pattern\n\ndef sort_pattern(pattern):\n    def custom_key(row):\n        return (row.count('*'), -len(row))\n    \n    pattern.sort(key=custom_key, reverse=True)\n    return pattern\n\ndef print_pattern(pattern):\n    max_len = max(len(row) for row in pattern)\n    for row in pattern:\n        print(row.center(max_len))\n\nn = 10\nprint(\"Generating pattern...\")\npattern = generate_pattern(n)\nprint(\"\\nInitial Pattern:\")\nprint_pattern(pattern)\n\nprint(\"\\nSorting pattern...\")\nsorted_pattern = sort_pattern(pattern)\nprint(\"\\nSorted Pattern:\")\nprint_pattern(sorted_pattern)"}, {"role": "assistant", "content": "Generating pattern...\n\nInitial Pattern:\n    *     \n    *     \n   * *    \n   * *    \n  * * *   \n  * * *   \n * * * *  \n * * * *  \n* * * * * \n* * * * * \n\nSorting pattern...\n\nSorted Pattern:\n* * * * * \n* * * * * \n * * * *  \n * * * *  \n  * * *   \n  * * *   \n   * *    \n   * *    \n    *     \n    *     \n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef transform_data(data):\n    vowels = 'aeiou'\n    return ''.join(c if c not in vowels else '*' for c in data)\n\ndef binary_search(data, target):\n    left, right = 0, len(data) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if data[mid] == target:\n            return mid\n        elif data[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndata = [\n    \"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\",\n    \"fig\", \"grape\", \"honeydew\", \"kiwi\", \"lemon\",\n    \"mango\", \"nectarine\", \"orange\", \"papaya\", \"quince\",\n    \"raspberry\", \"strawberry\", \"tangerine\", \"ugli\", \"voavanga\"\n]\n\ntransformed_data = [transform_data(word) for word in data]\nsorted_transformed_data = sorted(transformed_data, key=lambda s: re.sub(r'[^a-z]+', '', s))\n\nsearch_targets = [\"b*n*n*\", \"m*ng*\", \"gr*p*\", \"k*w*\"]\n\nfor target in search_targets:\n    index = binary_search(sorted_transformed_data, target)\n    original_index = data.index(data[index]) if index != -1 else -1\n    print(f\"Target '{target}' found at index {original_index} in original data.\")"}, {"role": "assistant", "content": "Target 'b*n*n*' found at index -1 in original data.\nTarget 'm*ng*' found at index 10 in original data.\nTarget 'gr*p*' found at index 5 in original data.\nTarget 'k*w*' found at index 7 in original data.\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef generate_sequence(n):\n    return [math.floor((i ** 2 + 3 * i + 5) / 2) for i in range(1, n+1)]\n\ndef custom_sort(sequence):\n    return sorted(sequence, key=lambda x: (x % 5, -x))\n\nsequence = generate_sequence(50)\nsorted_sequence = custom_sort(sequence)\n\nfor num in sorted_sequence:\n    print(num)"}, {"role": "assistant", "content": "1276\n1226\n1036\n991\n821\n781\n631\n596\n466\n436\n326\n301\n211\n191\n121\n106\n56\n46\n16\n11\n1327\n1177\n1082\n947\n862\n742\n667\n562\n497\n407\n352\n277\n232\n172\n137\n92\n67\n37\n22\n7\n1129\n904\n704\n529\n379\n254\n154\n79\n29\n4\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\ndef sort_dates(date_strings):\n    dates = [datetime.strptime(date, '%d-%m-%Y') for date in date_strings]\n    sorted_dates = sorted(dates)\n    return [date.strftime('%d-%m-%Y') for date in sorted_dates]\n\ndate_list = [\n    \"15-04-2023\", \"23-12-2021\", \"01-01-2022\", \"11-09-2020\", \"30-07-2022\",\n    \"05-05-2021\", \"14-02-2023\", \"22-11-2021\", \"19-06-2022\", \"21-08-2020\",\n    \"03-03-2023\", \"28-10-2021\", \"13-07-2022\", \"07-04-2021\", \"29-09-2022\",\n    \"10-01-2021\", \"17-08-2022\", \"25-12-2020\", \"09-06-2021\", \"31-12-2020\"\n]\n\nsorted_dates = sort_dates(date_list)\nprint(\"\\n\".join(sorted_dates))"}, {"role": "assistant", "content": "21-08-2020\n11-09-2020\n25-12-2020\n31-12-2020\n10-01-2021\n07-04-2021\n05-05-2021\n09-06-2021\n28-10-2021\n22-11-2021\n23-12-2021\n01-01-2022\n19-06-2022\n13-07-2022\n30-07-2022\n17-08-2022\n29-09-2022\n14-02-2023\n03-03-2023\n15-04-2023\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef find_all_words(text, word_list):\n    found_words = []\n    for word in word_list:\n        if re.search(r'\\b' + re.escape(word) + r'\\b', text):\n            found_words.append(word)\n    return found_words\n\ntext = \"\"\"\nPython is a widely used high-level programming language for general-purpose programming.\nCreated by Guido van Rossum and first released in 1991, Python has a design philosophy\nthat emphasizes code readability, notably using significant whitespace.\nIt provides constructs that enable clear programming on both small and large scales.\n\"\"\"\n\nword_list = [\n    \"Python\", \"programming\", \"language\", \"Guido\", \"clear\", \"scales\",\n    \"design\", \"whitespace\", \"enable\", \"constructs\", \"large\", \"small\",\n    \"readability\", \"notable\", \"released\", \"general-purpose\", \"high-level\"\n]\n\nfound_words = find_all_words(text, word_list)\n\nfor word in sorted(found_words):\n    print(word)"}, {"role": "assistant", "content": "Guido\nPython\nclear\nconstructs\ndesign\nenable\ngeneral-purpose\nhigh-level\nlanguage\nlarge\nprogramming\nreadability\nreleased\nscales\nsmall\nwhitespace\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef is_perfect_square(x):\n    s = int(math.sqrt(x))\n    return s * s == x\n\ndef is_fibonacci(n):\n    return is_perfect_square(5 * n * n + 4) or is_perfect_square(5 * n * n - 4)\n\ndef search_fibonacci_in_sequence(sequence):\n    fibonacci_indices = []\n    for i, num in enumerate(sequence):\n        if is_fibonacci(num):\n            fibonacci_indices.append(i)\n    return fibonacci_indices\n\ndef generate_sequence(n):\n    seq = [int((i**2 + i + 41) % 100) for i in range(n)]\n    return seq\n\nsequence = generate_sequence(100)\nfibonacci_indices = search_fibonacci_in_sequence(sequence)\n\nfor index in fibonacci_indices:\n    print(f\"Index: {index}, Number: {sequence[index]}\")"}, {"role": "assistant", "content": "Index: 8, Number: 13\nIndex: 16, Number: 13\nIndex: 19, Number: 21\nIndex: 21, Number: 3\nIndex: 35, Number: 1\nIndex: 39, Number: 1\nIndex: 44, Number: 21\nIndex: 46, Number: 3\nIndex: 53, Number: 3\nIndex: 55, Number: 21\nIndex: 60, Number: 1\nIndex: 64, Number: 1\nIndex: 78, Number: 3\nIndex: 80, Number: 21\nIndex: 83, Number: 13\nIndex: 91, Number: 13\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\ndef closest_pair(points):\n    def recursive_search(px, py):\n        if len(px) <= 3:\n            return min((distance(px[i], px[j]), (px[i], px[j])) \n                       for i in range(len(px)) for j in range(i + 1, len(px)))\n        \n        mid = len(px) // 2\n        midpoint = px[mid][0]\n        Qx = px[:mid]\n        Rx = px[mid:]\n        Qy = list(filter(lambda x: x[0] <= midpoint, py))\n        Ry = list(filter(lambda x: x[0] > midpoint, py))\n        \n        (d1, pair1) = recursive_search(Qx, Qy)\n        (d2, pair2) = recursive_search(Rx, Ry)\n        \n        d = min(d1, d2)\n        min_pair = pair1 if d1 < d2 else pair2\n\n        strip = [p for p in py if abs(p[0] - midpoint) < d]\n        for i in range(len(strip)):\n            for j in range(i + 1, min(i + 7, len(strip))):\n                if (d_new := distance(strip[i], strip[j])) < d:\n                    d = d_new\n                    min_pair = (strip[i], strip[j])\n        \n        return d, min_pair\n    \n    px = sorted(points, key=lambda x: x[0])\n    py = sorted(points, key=lambda x: x[1])\n    return recursive_search(px, py)\n\npoints = [(2, 3), (12, 30), (40, 50), (5, 1), (12, 10), (3, 4), (15, 15), (7, 8), (9, 6), (11, 3)]\nresult_distance, result_pair = closest_pair(points)\n\nprint(\"Closest pair of points are:\", result_pair)\nprint(\"Distance between them is:\", result_distance)"}, {"role": "assistant", "content": "Closest pair of points are: ((2, 3), (3, 4))\nDistance between them is: 1.4142135623730951\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef distance_from_origin(point):\n    return math.sqrt(point[0]**2 + point[1]**2)\n\ndef calculate_angles(points):\n    angles = []\n    for p in points:\n        angle = math.degrees(math.atan2(p[1], p[0]))\n        angles.append(angle)\n    return angles\n\ndef sort_points_by_angle(points):\n    angles = calculate_angles(points)\n    points_with_angles = list(zip(points, angles))\n    points_with_angles.sort(key=lambda x: x[1])\n    return [p[0] for p in points_with_angles]\n\ndef print_points(points):\n    for point in points:\n        print(f\"Point: {point}, Distance from origin: {distance_from_origin(point):.2f}\")\n\ndef print_angles(points):\n    angles = calculate_angles(points)\n    for point, angle in zip(points, angles):\n        print(f\"Point: {point}, Angle: {angle:.2f}\")\n\npoints = [(3, 4), (1, 2), (-2, -1), (4, 3), (0, -4), (5, 0), (-3, 3), (2, 2)]\nprint(\"Original Points:\")\nprint_points(points)\nprint(\"\\nPoints sorted by angle from origin:\")\nsorted_points = sort_points_by_angle(points)\nprint_points(sorted_points)\nprint(\"\\nAngles of Points:\")\nprint_angles(sorted_points)"}, {"role": "assistant", "content": "Original Points:\nPoint: (3, 4), Distance from origin: 5.00\nPoint: (1, 2), Distance from origin: 2.24\nPoint: (-2, -1), Distance from origin: 2.24\nPoint: (4, 3), Distance from origin: 5.00\nPoint: (0, -4), Distance from origin: 4.00\nPoint: (5, 0), Distance from origin: 5.00\nPoint: (-3, 3), Distance from origin: 4.24\nPoint: (2, 2), Distance from origin: 2.83\n\nPoints sorted by angle from origin:\nPoint: (-2, -1), Distance from origin: 2.24\nPoint: (0, -4), Distance from origin: 4.00\nPoint: (5, 0), Distance from origin: 5.00\nPoint: (4, 3), Distance from origin: 5.00\nPoint: (2, 2), Distance from origin: 2.83\nPoint: (3, 4), Distance from origin: 5.00\nPoint: (1, 2), Distance from origin: 2.24\nPoint: (-3, 3), Distance from origin: 4.24\n\nAngles of Points:\nPoint: (-2, -1), Angle: -153.43\nPoint: (0, -4), Angle: -90.00\nPoint: (5, 0), Angle: 0.00\nPoint: (4, 3), Angle: 36.87\nPoint: (2, 2), Angle: 45.00\nPoint: (3, 4), Angle: 53.13\nPoint: (1, 2), Angle: 63.43\nPoint: (-3, 3), Angle: 135.00\n"}]}
{"messages": [{"role": "user", "content": "import re\nfrom collections import Counter\n\ntext = \"\"\"\nIn the heart of the forest, the river flowed with a gentle murmur. The trees stood tall, their leaves\nwhispering in a language only the wind could understand. Birds flitted from branch to branch, their\nsongs weaving an intricate tapestry of sound. The sun filtered through the canopy, casting dappled\nshadows on the forest floor where flowers bloomed in splashes of color. The forest was alive with\nthe hum of nature, a symphony of life that played day and night.\n\"\"\"\n\nwords = re.findall(r'\\b\\w+\\b', text.lower())\nword_count = Counter(words)\nsorted_words = sorted(word_count.items(), key=lambda x: (-len(x[0]), x[1], x[0]))\n\nfor word, count in sorted_words:\n    print(f\"{word}: {count}\")"}, {"role": "assistant", "content": "understand: 1\nwhispering: 1\nintricate: 1\nfiltered: 1\nlanguage: 1\nsplashes: 1\nsymphony: 1\ntapestry: 1\nbloomed: 1\ncasting: 1\ndappled: 1\nflitted: 1\nflowers: 1\nshadows: 1\nthrough: 1\nweaving: 1\ncanopy: 1\nflowed: 1\ngentle: 1\nleaves: 1\nmurmur: 1\nnature: 1\nplayed: 1\nbranch: 2\nforest: 3\nalive: 1\nbirds: 1\ncolor: 1\ncould: 1\nfloor: 1\nheart: 1\nnight: 1\nriver: 1\nsongs: 1\nsound: 1\nstood: 1\ntrees: 1\nwhere: 1\ntheir: 2\nfrom: 1\nlife: 1\nonly: 1\ntall: 1\nthat: 1\nwind: 1\nwith: 2\nand: 1\nday: 1\nhum: 1\nsun: 1\nwas: 1\nthe: 10\nan: 1\non: 1\nto: 1\nin: 3\nof: 5\na: 3\n"}]}
{"messages": [{"role": "user", "content": "def find_path(maze, start, end):\n    width, height = len(maze[0]), len(maze)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = [(start, [start])]\n    visited = set()\n\n    while queue:\n        (x, y), path = queue.pop(0)\n        if (x, y) == end:\n            return path\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < width and 0 <= ny < height and maze[ny][nx] == 0 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append(((nx, ny), path + [(nx, ny)]))\n    return []\n\nmaze = [\n    [0, 1, 0, 0, 0, 0],\n    [0, 1, 0, 1, 1, 0],\n    [0, 0, 0, 1, 0, 0],\n    [1, 1, 0, 1, 0, 1],\n    [0, 0, 0, 0, 0, 0]\n]\n\nstart = (0, 0)\nend = (5, 4)\npath = find_path(maze, start, end)\n\nmaze_with_path = [row[:] for row in maze]\nfor x, y in path:\n    maze_with_path[y][x] = '.'\n\nfor row in maze_with_path:\n    print(' '.join(str(cell) for cell in row))"}, {"role": "assistant", "content": ". 1 0 0 0 0\n. 1 0 1 1 0\n. . . 1 0 0\n1 1 . 1 0 1\n0 0 . . . .\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef caesar_cipher(text, shift):\n    result = []\n    for char in text:\n        if char.isupper():\n            shifted = chr((ord(char) + shift - 65) % 26 + 65)\n            result.append(shifted)\n        elif char.islower():\n            shifted = chr((ord(char) + shift - 97) % 26 + 97)\n            result.append(shifted)\n        else:\n            result.append(char)\n    return ''.join(result)\n\ndef search_keyword(encoded_text, keyword):\n    keyword_pattern = re.compile(re.escape(keyword), re.IGNORECASE)\n    for shift in range(26):\n        decoded_text = caesar_cipher(encoded_text, -shift)\n        if keyword_pattern.search(decoded_text):\n            return shift, decoded_text\n    return None, None\n\nencoded_message = \"Uif xpset jt dbtfbs djqifs jt b tfdsfu!\"\nkeyword = \"secret\"\nshift, decoded_message = search_keyword(encoded_message, keyword)\n\noutput = []\noutput.append(f\"Encoded Message: {encoded_message}\")\noutput.append(f\"Keyword: {keyword}\")\nif shift is not None:\n    output.append(f\"Shift Found: {shift}\")\n    output.append(f\"Decoded Message: {decoded_message}\")\nelse:\n    output.append(\"Keyword not found in any decoded message.\")\n    \nfor line in output:\n    print(line)"}, {"role": "assistant", "content": "Encoded Message: Uif xpset jt dbtfbs djqifs jt b tfdsfu!\nKeyword: secret\nShift Found: 1\nDecoded Message: The words is casear cipher is a secret!\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef binary_search_closest_dates(dates, target_date):\n    low, high = 0, len(dates) - 1\n    closest_date = dates[0]\n    \n    while low <= high:\n        mid = (low + high) // 2\n        mid_date = dates[mid]\n        \n        print(f\"Checking middle date: {mid_date.strftime('%Y-%m-%d')}\")\n        \n        if abs((mid_date - target_date).days) < abs((closest_date - target_date).days):\n            closest_date = mid_date\n            print(f\"New closest date found: {closest_date.strftime('%Y-%m-%d')}\")\n        \n        if mid_date < target_date:\n            low = mid + 1\n        elif mid_date > target_date:\n            high = mid - 1\n        else:\n            return mid_date\n    \n    return closest_date\n\ndates = [datetime(2023, 1, 1) + timedelta(days=i) for i in range(0, 366, 7)]\ntarget_dates = [datetime(2023, 2, 15), datetime(2023, 5, 1), datetime(2023, 8, 20), datetime(2023, 11, 10)]\n\nresults = []\nfor target in target_dates:\n    print(f\"Finding closest date to: {target.strftime('%Y-%m-%d')}\")\n    closest = binary_search_closest_dates(dates, target)\n    results.append((target, closest))\n\nfor target, closest in results:\n    print(f\"Target date: {target.strftime('%Y-%m-%d')}, Closest date: {closest.strftime('%Y-%m-%d')}\")"}, {"role": "assistant", "content": "Finding closest date to: 2023-02-15\nChecking middle date: 2023-07-02\nChecking middle date: 2023-03-26\nNew closest date found: 2023-03-26\nChecking middle date: 2023-02-05\nNew closest date found: 2023-02-05\nChecking middle date: 2023-02-26\nChecking middle date: 2023-02-12\nNew closest date found: 2023-02-12\nChecking middle date: 2023-02-19\nFinding closest date to: 2023-05-01\nChecking middle date: 2023-07-02\nNew closest date found: 2023-07-02\nChecking middle date: 2023-03-26\nNew closest date found: 2023-03-26\nChecking middle date: 2023-05-14\nNew closest date found: 2023-05-14\nChecking middle date: 2023-04-16\nChecking middle date: 2023-04-30\nNew closest date found: 2023-04-30\nChecking middle date: 2023-05-07\nFinding closest date to: 2023-08-20\nChecking middle date: 2023-07-02\nNew closest date found: 2023-07-02\nChecking middle date: 2023-10-01\nNew closest date found: 2023-10-01\nChecking middle date: 2023-08-13\nNew closest date found: 2023-08-13\nChecking middle date: 2023-09-03\nChecking middle date: 2023-08-20\nNew closest date found: 2023-08-20\nFinding closest date to: 2023-11-10\nChecking middle date: 2023-07-02\nNew closest date found: 2023-07-02\nChecking middle date: 2023-10-01\nNew closest date found: 2023-10-01\nChecking middle date: 2023-11-19\nNew closest date found: 2023-11-19\nChecking middle date: 2023-10-22\nChecking middle date: 2023-11-05\nNew closest date found: 2023-11-05\nChecking middle date: 2023-11-12\nNew closest date found: 2023-11-12\nTarget date: 2023-02-15, Closest date: 2023-02-12\nTarget date: 2023-05-01, Closest date: 2023-04-30\nTarget date: 2023-08-20, Closest date: 2023-08-20\nTarget date: 2023-11-10, Closest date: 2023-11-12\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndates = [\n    \"2023-01-15 14:23:45\",\n    \"2022-12-11 11:55:00\",\n    \"2023-02-05 09:12:34\",\n    \"2021-08-20 17:45:29\",\n    \"2022-07-01 06:22:18\",\n    \"2023-03-23 19:00:00\",\n    \"2021-11-15 08:30:55\",\n    \"2023-04-10 12:40:00\",\n    \"2022-05-25 13:15:16\",\n    \"2021-12-31 20:45:50\"\n]\n\nparsed_dates = [datetime.strptime(date, \"%Y-%m-%d %H:%M:%S\") for date in dates]\nweekdays = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n\ndef custom_sort_key(date):\n    return (date.weekday(), date.hour, date.minute, date.second)\n\nsorted_dates = sorted(parsed_dates, key=custom_sort_key)\n\nfor date in sorted_dates:\n    print(f\"{weekdays[date.weekday()]} {date.strftime('%Y-%m-%d %H:%M:%S')}\")"}, {"role": "assistant", "content": "Monday 2021-11-15 08:30:55\nMonday 2023-04-10 12:40:00\nWednesday 2022-05-25 13:15:16\nThursday 2023-03-23 19:00:00\nFriday 2022-07-01 06:22:18\nFriday 2021-08-20 17:45:29\nFriday 2021-12-31 20:45:50\nSunday 2023-02-05 09:12:34\nSunday 2022-12-11 11:55:00\nSunday 2023-01-15 14:23:45\n"}]}
{"messages": [{"role": "user", "content": "def encode_message(message):\n    return ''.join(chr((ord(char) + 3) % 256) for char in message)\n\ndef decode_message(encoded_message):\n    return ''.join(chr((ord(char) - 3) % 256) for char in encoded_message)\n\ndef sort_encoded_messages(messages):\n    return sorted(messages, key=lambda m: sum(ord(c) for c in m))\n\nmessages = [\n    \"Hello, World!\",\n    \"Python is fun.\",\n    \"Sorting algorithms.\",\n    \"Encode this message.\",\n    \"Data encryption.\"\n]\n\nencoded_messages = [encode_message(msg) for msg in messages]\nsorted_encoded_messages = sort_encoded_messages(encoded_messages)\ndecoded_sorted_messages = [decode_message(msg) for msg in sorted_encoded_messages]\n\nfor msg in decoded_sorted_messages:\n    print(msg)"}, {"role": "assistant", "content": "Hello, World!\nPython is fun.\nData encryption.\nEncode this message.\nSorting algorithms.\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"\nIn the realm of programming, patterns often emerge. These patterns can be subtle or overt, \nbut recognizing them can lead to more efficient solutions. For instance, consider the \nclassic 'Hello World' program. At a glance, it may seem trivial, but it marks the beginning \nof every programmer's journey. As such, it is an important pattern in the tapestry of code.\n\"\"\"\n\ndef find_longest_word(sentence):\n    words = re.findall(r'\\b\\w+\\b', sentence)\n    return max(words, key=len)\n\ndef search_pattern(text, keyword):\n    sentences = re.split(r'(?<=[.!?]) +', text)\n    return [sentence for sentence in sentences if keyword in find_longest_word(sentence)]\n\nkeyword = 'programming'\nmatched_sentences = search_pattern(text, keyword)\n\nfor i, sentence in enumerate(matched_sentences, 1):\n    print(f\"Sentence {i}: {sentence}\")"}, {"role": "assistant", "content": "Sentence 1: \nIn the realm of programming, patterns often emerge.\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\ndata = [\n    {\"name\": \"Alice\", \"timestamp\": \"2023-09-01 08:45:00\"},\n    {\"name\": \"Bob\", \"timestamp\": \"2023-09-01 09:15:00\"},\n    {\"name\": \"Charlie\", \"timestamp\": \"2023-09-01 08:30:00\"},\n    {\"name\": \"Diana\", \"timestamp\": \"2023-09-01 09:00:00\"},\n    {\"name\": \"Eve\", \"timestamp\": \"2023-09-01 08:50:00\"},\n    {\"name\": \"Frank\", \"timestamp\": \"2023-09-01 09:05:00\"},\n    {\"name\": \"Grace\", \"timestamp\": \"2023-09-01 09:10:00\"},\n    {\"name\": \"Heidi\", \"timestamp\": \"2023-09-01 08:35:00\"},\n    {\"name\": \"Ivan\", \"timestamp\": \"2023-09-01 09:20:00\"},\n    {\"name\": \"Judy\", \"timestamp\": \"2023-09-01 08:55:00\"},\n]\n\nsorted_data = sorted(\n    data, key=lambda x: datetime.strptime(x[\"timestamp\"], \"%Y-%m-%d %H:%M:%S\")\n)\n\nfor entry in sorted_data:\n    print(f\"{entry['name']} arrived at {entry['timestamp']}\")"}, {"role": "assistant", "content": "Charlie arrived at 2023-09-01 08:30:00\nHeidi arrived at 2023-09-01 08:35:00\nAlice arrived at 2023-09-01 08:45:00\nEve arrived at 2023-09-01 08:50:00\nJudy arrived at 2023-09-01 08:55:00\nDiana arrived at 2023-09-01 09:00:00\nFrank arrived at 2023-09-01 09:05:00\nGrace arrived at 2023-09-01 09:10:00\nBob arrived at 2023-09-01 09:15:00\nIvan arrived at 2023-09-01 09:20:00\n"}]}
{"messages": [{"role": "user", "content": "def generate_wave_pattern(n):\n    wave_pattern = []\n    for i in range(n):\n        line = []\n        for j in range(n):\n            line.append((i + j) % n)\n        wave_pattern.append(line)\n    return wave_pattern\n\ndef sort_wave_pattern(wave_pattern):\n    sorted_pattern = []\n    for line in wave_pattern:\n        sorted_line = sorted(line)\n        sorted_pattern.append(sorted_line)\n    return sorted_pattern\n\ndef format_wave_pattern(wave_pattern):\n    formatted_lines = []\n    for line in wave_pattern:\n        formatted_lines.append(' '.join(str(num) for num in line))\n    return formatted_lines\n\nn = 10\nwave_pattern = generate_wave_pattern(n)\nsorted_pattern = sort_wave_pattern(wave_pattern)\nformatted_lines = format_wave_pattern(sorted_pattern)\n\nfor line in formatted_lines:\n    print(line)"}, {"role": "assistant", "content": "0 1 2 3 4 5 6 7 8 9\n0 1 2 3 4 5 6 7 8 9\n0 1 2 3 4 5 6 7 8 9\n0 1 2 3 4 5 6 7 8 9\n0 1 2 3 4 5 6 7 8 9\n0 1 2 3 4 5 6 7 8 9\n0 1 2 3 4 5 6 7 8 9\n0 1 2 3 4 5 6 7 8 9\n0 1 2 3 4 5 6 7 8 9\n0 1 2 3 4 5 6 7 8 9\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef generate_pattern(n):\n    pattern = []\n    for i in range(1, n + 1):\n        pattern.append(''.join(str((i+j) % 10) for j in range(n)))\n    return pattern\n\ndef search_pattern(pattern, search_for):\n    found_indices = []\n    for index, line in enumerate(pattern):\n        if re.search(search_for, line):\n            found_indices.append(index)\n    return found_indices\n\ndef print_pattern_with_highlight(pattern, indices):\n    for i, line in enumerate(pattern):\n        if i in indices:\n            print(line.replace(search_for, f\"[{search_for}]\"))\n        else:\n            print(line)\n\npattern_size = 10\nsearch_for = \"345\"\n\npattern = generate_pattern(pattern_size)\nprint(\"Generated Pattern:\")\nfor line in pattern:\n    print(line)\n\nprint(\"\\nSearching for pattern...\")\nindices = search_pattern(pattern, search_for)\n\nprint(\"\\nPattern found at lines (incorrect):\")\nprint_pattern_with_highlight(pattern, indices)"}, {"role": "assistant", "content": "Generated Pattern:\n1234567890\n2345678901\n3456789012\n4567890123\n5678901234\n6789012345\n7890123456\n8901234567\n9012345678\n0123456789\n\nSearching for pattern...\n\nPattern found at lines (incorrect):\n12[345]67890\n2[345]678901\n[345]6789012\n4567890123\n5678901234\n6789012[345]\n789012[345]6\n89012[345]67\n9012[345]678\n012[345]6789\n"}]}
{"messages": [{"role": "user", "content": "import statistics\nimport math\n\ndata = [\n    12, 15, 23, 42, 58, 67, 89, 90, 95, 102, 110, 123, 147, 150, 159, 167, \n    173, 181, 193, 200, 205, 210, 223, 230, 240, 250, 260, 270, 280, 290, 300\n]\n\ndef custom_sort(arr):\n    n = len(arr)\n    for i in range(1, n):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr\n\nmean = statistics.mean(data)\nstandard_deviation = statistics.stdev(data)\nthreshold = mean + standard_deviation\n\nprint(f\"Mean: {mean}\")\nprint(f\"Standard Deviation: {standard_deviation}\")\nprint(f\"Threshold for filtering: {threshold}\")\n\nfiltered_data = [x for x in data if x < threshold]\nprint(f\"Filtered Data (below threshold): {filtered_data}\")\n\nsorted_filtered_data = custom_sort(filtered_data)\nprint(\"Sorted Filtered Data:\")\nfor value in sorted_filtered_data:\n    print(value)\n\noutliers = [x for x in data if x >= threshold]\nprint(f\"Outliers (above threshold): {outliers}\")\n\nsorted_outliers = custom_sort(outliers)\nprint(\"Sorted Outliers:\")\nfor value in sorted_outliers:\n    print(value)"}, {"role": "assistant", "content": "Mean: 159.80645161290323\nStandard Deviation: 85.74863239136381\nThreshold for filtering: 245.55508400426703\nFiltered Data (below threshold): [12, 15, 23, 42, 58, 67, 89, 90, 95, 102, 110, 123, 147, 150, 159, 167, 173, 181, 193, 200, 205, 210, 223, 230, 240]\nSorted Filtered Data:\n12\n15\n23\n42\n58\n67\n89\n90\n95\n102\n110\n123\n147\n150\n159\n167\n173\n181\n193\n200\n205\n210\n223\n230\n240\nOutliers (above threshold): [250, 260, 270, 280, 290, 300]\nSorted Outliers:\n250\n260\n270\n280\n290\n300\n"}]}
{"messages": [{"role": "user", "content": "def can_move(board, player, direction):\n    size = len(board)\n    for i in range(size):\n        for j in range(size):\n            if board[i][j] == player:\n                if direction == 'up' and i > 0 and board[i-1][j] == 0:\n                    return True\n                if direction == 'down' and i < size-1 and board[i+1][j] == 0:\n                    return True\n                if direction == 'left' and j > 0 and board[i][j-1] == 0:\n                    return True\n                if direction == 'right' and j < size-1 and board[i][j+1] == 0:\n                    return True\n    return False\n\ndef search_moves(board, player):\n    moves = ['up', 'down', 'left', 'right']\n    possible_moves = []\n    for move in moves:\n        if can_move(board, player, move):\n            possible_moves.append(move)\n    return possible_moves\n\ndef display_board(board):\n    for row in board:\n        print(' '.join(str(x) for x in row))\n    print()\n\ndef play_game():\n    board = [\n        [1, 0, 0, 2],\n        [1, 0, 0, 2],\n        [1, 0, 0, 2],\n        [1, 0, 0, 2]\n    ]\n    display_board(board)\n    current_player = 1\n    rounds = 10\n    for _ in range(rounds):\n        moves = search_moves(board, current_player)\n        if moves:\n            direction = moves[0]\n            if direction == 'up':\n                for i in range(1, len(board)):\n                    for j in range(len(board[i])):\n                        if board[i][j] == current_player:\n                            board[i-1][j] = current_player\n                            board[i][j] = 0\n            elif direction == 'down':\n                for i in range(len(board)-2, -1, -1):\n                    for j in range(len(board[i])):\n                        if board[i][j] == current_player:\n                            board[i+1][j] = current_player\n                            board[i][j] = 0\n            elif direction == 'left':\n                for i in range(len(board)):\n                    for j in range(1, len(board[i])):\n                        if board[i][j] == current_player:\n                            board[i][j-1] = current_player\n                            board[i][j] = 0\n            elif direction == 'right':\n                for i in range(len(board)):\n                    for j in range(len(board[i])-2, -1, -1):\n                        if board[i][j] == current_player:\n                            board[i][j+1] = current_player\n                            board[i][j] = 0\n        display_board(board)\n        current_player = 3 - current_player\n\nplay_game()"}, {"role": "assistant", "content": "1 0 0 2\n1 0 0 2\n1 0 0 2\n1 0 0 2\n\n0 1 0 2\n0 1 0 2\n0 1 0 2\n0 1 0 2\n\n0 1 2 0\n0 1 2 0\n0 1 2 0\n0 1 2 0\n\n1 0 2 0\n1 0 2 0\n1 0 2 0\n1 0 2 0\n\n1 2 0 0\n1 2 0 0\n1 2 0 0\n1 2 0 0\n\n1 2 0 0\n1 2 0 0\n1 2 0 0\n1 2 0 0\n\n1 0 2 0\n1 0 2 0\n1 0 2 0\n1 0 2 0\n\n0 1 2 0\n0 1 2 0\n0 1 2 0\n0 1 2 0\n\n0 1 0 2\n0 1 0 2\n0 1 0 2\n0 1 0 2\n\n1 0 0 2\n1 0 0 2\n1 0 0 2\n1 0 0 2\n\n1 0 2 0\n1 0 2 0\n1 0 2 0\n1 0 2 0\n\n"}]}
{"messages": [{"role": "user", "content": "from itertools import permutations\n\ndef is_arithmetic_sequence(seq):\n    if len(seq) < 2:\n        return False\n    diff = seq[1] - seq[0]\n    for i in range(2, len(seq)):\n        if seq[i] - seq[i - 1] != diff:\n            return False\n    return True\n\ndef unique_permutations(numbers):\n    return sorted(set(permutations(numbers)))\n\ndef find_arithmetic_sequences(numbers):\n    perms = unique_permutations(numbers)\n    arithmetic_seqs = []\n    for perm in perms:\n        if is_arithmetic_sequence(perm):\n            arithmetic_seqs.append(perm)\n    return arithmetic_seqs\n\nnumbers = [1, 2, 3, 4, 5]\narithmetic_sequences = find_arithmetic_sequences(numbers)\n\nfor seq in arithmetic_sequences:\n    print(seq)"}, {"role": "assistant", "content": "(1, 2, 3, 4, 5)\n(5, 4, 3, 2, 1)\n"}]}
{"messages": [{"role": "user", "content": "text = \"\"\"In the world of Python programming, there are many things to learn.\nFrom syntax and data structures to algorithms and libraries, the possibilities\nare endless. Whether you're building a small script or a large application,\nunderstanding how to organize and manipulate data is crucial. Sorting, for\ninstance, is a fundamental skill. It allows you to efficiently manage and\nretrieve information. Let's explore some text processing with sorting.\"\"\"\n\nwords = text.split()\nunique_words = set(words)\nsorted_words = sorted(unique_words, key=lambda w: (len(w), w))\nfor word in sorted_words:\n    print(word)"}, {"role": "assistant", "content": "a\nIn\nIt\nis\nof\nor\nto\nand\nare\nfor\nhow\nthe\nyou\nFrom\ndata\nmany\nsome\ntext\nwith\nLet's\nlarge\nsmall\nthere\nworld\nPython\nallows\nlearn.\nmanage\nscript\nskill.\nsyntax\nthings\nyou're\nWhether\nexplore\nSorting,\nbuilding\ncrucial.\nendless.\norganize\nretrieve\nsorting.\ninstance,\nalgorithms\nlibraries,\nmanipulate\nprocessing\nstructures\nefficiently\nfundamental\napplication,\ninformation.\nprogramming,\npossibilities\nunderstanding\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef search_most_frequent(nums):\n    frequency = {}\n    for num in nums:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    \n    print(\"Frequency of each number:\", frequency)\n    \n    max_freq = 0\n    most_frequent_numbers = []\n    \n    for num, freq in frequency.items():\n        if freq > max_freq:\n            max_freq = freq\n            most_frequent_numbers = [num]\n        elif freq == max_freq:\n            most_frequent_numbers.append(num)\n    \n    print(\"Most frequent numbers:\", most_frequent_numbers)\n    \n    return search_nearest_square(most_frequent_numbers)\n\ndef search_nearest_square(numbers):\n    nearest_square = []\n    for num in numbers:\n        root = math.isqrt(num)\n        square = root * root\n        if square == num:\n            nearest_square.append(num)\n        else:\n            nearest_square.append(square)\n        print(f\"Nearest square to {num} is {square}\")\n    return nearest_square\n\ndata = [\n    4, 6, 8, 6, 7, 9, 6, 5, 3, 5, 5, 5, 9, 7, 8, 6, \n    5, 7, 5, 3, 9, 4, 6, 5, 5, 6, 4, 5, 8, 7, 9, 5, \n    4, 4, 4, 4, 4, 4, 4, 7, 8, 9, 5, 6, 5, 4, 4, 4\n]\n\nresult = search_most_frequent(data)\nprint(\"Result of nearest square search:\", result)"}, {"role": "assistant", "content": "Frequency of each number: {4: 13, 6: 7, 8: 4, 7: 5, 9: 5, 5: 12, 3: 2}\nMost frequent numbers: [4]\nNearest square to 4 is 4\nResult of nearest square search: [4]\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef distance(point1, point2):\n    return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)\n\ndef perimeter(triangle):\n    return (distance(triangle[0], triangle[1]) +\n            distance(triangle[1], triangle[2]) +\n            distance(triangle[2], triangle[0]))\n\ndef area(triangle):\n    a = distance(triangle[0], triangle[1])\n    b = distance(triangle[1], triangle[2])\n    c = distance(triangle[2], triangle[0])\n    s = (a + b + c) / 2\n    return math.sqrt(s * (s - a) * (s - b) * (s - c))\n\ndef sort_triangles_by_perimeter(triangles):\n    return sorted(triangles, key=area)\n\ntriangles = [\n    [(0, 0), (3, 0), (0, 4)],\n    [(0, 0), (1, 0), (0, 1)],\n    [(0, 0), (3, 0), (0, 3)],\n    [(0, 0), (2, 0), (0, 2)],\n    [(0, 0), (1, 0), (0, 2)],\n]\n\nsorted_triangles = sort_triangles_by_perimeter(triangles)\nfor triangle in sorted_triangles:\n    print(f\"Triangle: {triangle}, Perimeter: {perimeter(triangle)}, Area: {area(triangle)}\")"}, {"role": "assistant", "content": "Triangle: [(0, 0), (1, 0), (0, 1)], Perimeter: 3.414213562373095, Area: 0.49999999999999983\nTriangle: [(0, 0), (1, 0), (0, 2)], Perimeter: 5.23606797749979, Area: 1.0\nTriangle: [(0, 0), (2, 0), (0, 2)], Perimeter: 6.82842712474619, Area: 1.9999999999999993\nTriangle: [(0, 0), (3, 0), (0, 3)], Perimeter: 10.242640687119284, Area: 4.499999999999997\nTriangle: [(0, 0), (3, 0), (0, 4)], Perimeter: 12.0, Area: 6.0\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef find_standard_deviation(numbers):\n    if not numbers:\n        return 0\n    \n    mean = sum(numbers) / len(numbers)\n    variance = sum((x - mean) ** 2 for x in numbers) / len(numbers)\n    return math.sqrt(variance)\n\ndef linear_search(numbers, target_std_dev):\n    for index, value in enumerate(numbers):\n        print(f\"Checking index {index}: {value}\")\n        if find_standard_deviation(numbers[:index + 1]) == target_std_dev:\n            return index\n    return -1\n\ndata = [\n    [10, 23, 12, 7, 5, 18, 14],\n    [1, 3, 5, 7, 9, 11],\n    [4, 8, 15, 16, 23, 42],\n    [21, 13, 19, 8, 3, 11, 5],\n    [2, 4, 6, 8, 10, 12, 14],\n    [15, 25, 35, 45, 55, 65]\n]\n\ntarget_std_devs = [5, 2.5, 3.5, 4, 1.5, 20]\n\nfor i, numbers in enumerate(data):\n    print(f\"Dataset {i + 1}: {numbers}\")\n    target_std_dev = target_std_devs[i]\n    print(f\"Target Standard Deviation: {target_std_dev}\")\n    index = linear_search(numbers, target_std_dev)\n    if index == -1:\n        print(\"Target standard deviation not found within the dataset.\")\n    else:\n        print(f\"Target standard deviation found at index: {index}\")\n    print(\"\\n\" + \"-\" * 40 + \"\\n\")"}, {"role": "assistant", "content": "Dataset 1: [10, 23, 12, 7, 5, 18, 14]\nTarget Standard Deviation: 5\nChecking index 0: 10\nChecking index 1: 23\nChecking index 2: 12\nChecking index 3: 7\nChecking index 4: 5\nChecking index 5: 18\nChecking index 6: 14\nTarget standard deviation not found within the dataset.\n\n----------------------------------------\n\nDataset 2: [1, 3, 5, 7, 9, 11]\nTarget Standard Deviation: 2.5\nChecking index 0: 1\nChecking index 1: 3\nChecking index 2: 5\nChecking index 3: 7\nChecking index 4: 9\nChecking index 5: 11\nTarget standard deviation not found within the dataset.\n\n----------------------------------------\n\nDataset 3: [4, 8, 15, 16, 23, 42]\nTarget Standard Deviation: 3.5\nChecking index 0: 4\nChecking index 1: 8\nChecking index 2: 15\nChecking index 3: 16\nChecking index 4: 23\nChecking index 5: 42\nTarget standard deviation not found within the dataset.\n\n----------------------------------------\n\nDataset 4: [21, 13, 19, 8, 3, 11, 5]\nTarget Standard Deviation: 4\nChecking index 0: 21\nChecking index 1: 13\nTarget standard deviation found at index: 1\n\n----------------------------------------\n\nDataset 5: [2, 4, 6, 8, 10, 12, 14]\nTarget Standard Deviation: 1.5\nChecking index 0: 2\nChecking index 1: 4\nChecking index 2: 6\nChecking index 3: 8\nChecking index 4: 10\nChecking index 5: 12\nChecking index 6: 14\nTarget standard deviation not found within the dataset.\n\n----------------------------------------\n\nDataset 6: [15, 25, 35, 45, 55, 65]\nTarget Standard Deviation: 20\nChecking index 0: 15\nChecking index 1: 25\nChecking index 2: 35\nChecking index 3: 45\nChecking index 4: 55\nChecking index 5: 65\nTarget standard deviation not found within the dataset.\n\n----------------------------------------\n\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef point_in_polygon(polygon, point):\n    x, y = point\n    crossings = 0\n    for i in range(len(polygon)):\n        x1, y1 = polygon[i]\n        x2, y2 = polygon[(i + 1) % len(polygon)]\n        if ((y1 <= y < y2) or (y2 <= y < y1)):\n            if x < (x2 - x1) * (y - y1) / (y2 - y1) + x1:\n                crossings += 1\n    return crossings % 2 == 0\n\ndef find_unoccupied_space(polygon, points):\n    unoccupied = []\n    for point in points:\n        if not point_in_polygon(polygon, point):\n            unoccupied.append(point)\n    return unoccupied\n\npolygon = [\n    (0, 0), (4, 0), (4, 4), (0, 4)\n]\n\npoints = [\n    (2, 2), (1, 1), (3, 3), (5, 5), (2, 3), (3, 2), (0, 0), (4, 4)\n]\n\nunoccupied_spaces = find_unoccupied_space(polygon, points)\nfor point in unoccupied_spaces:\n    print(f\"Unoccupied: {point}\")"}, {"role": "assistant", "content": "Unoccupied: (2, 2)\nUnoccupied: (1, 1)\nUnoccupied: (3, 3)\nUnoccupied: (2, 3)\nUnoccupied: (3, 2)\nUnoccupied: (0, 0)\n"}]}
{"messages": [{"role": "user", "content": "from collections import defaultdict\n\ndef custom_sort(cards):\n    ranks = '23456789TJQKA'\n    suits = 'CDHS'\n    return sorted(cards, key=lambda card: (ranks.index(card[0]), suits.index(card[1])))\n\ndef evaluate_hand(cards):\n    ranks = [card[0] for card in cards]\n    suits = [card[1] for card in cards]\n    rank_count = defaultdict(int)\n    suit_count = defaultdict(int)\n    for rank in ranks:\n        rank_count[rank] += 1\n    for suit in suits:\n        suit_count[suit] += 1\n    rank_vals = sorted(rank_count.values(), reverse=True)\n    if len(suit_count) == 1 and ranks == list('TJQKA'):\n        return ('Royal Flush', 10)\n    elif len(suit_count) == 1 and all(ranks[i+1] == ranks[i] + 1 for i in range(4)):\n        return ('Straight Flush', 9)\n    elif rank_vals[0] == 4:\n        return ('Four of a Kind', 8)\n    elif rank_vals[0] == 3 and rank_vals[1] == 2:\n        return ('Full House', 7)\n    elif len(suit_count) == 1:\n        return ('Flush', 6)\n    elif all(ranks[i+1] == ranks[i] + 1 for i in range(4)):\n        return ('Straight', 5)\n    elif rank_vals[0] == 3:\n        return ('Three of a Kind', 4)\n    elif rank_vals[0] == 2 and rank_vals[1] == 2:\n        return ('Two Pair', 3)\n    elif rank_vals[0] == 2:\n        return ('One Pair', 2)\n    return ('High Card', 1)\n\ndef simulate_game():\n    hands = [\n        ['2C', '3D', '4H', '5S', '6C'],\n        ['TD', 'JD', 'QD', 'KD', 'AD'],\n        ['2H', '2D', '4C', '4D', '4S'],\n        ['3C', '3H', '3S', '3D', '8H'],\n        ['2S', '3S', '4S', '5S', '7S']\n    ]\n    for hand in hands:\n        sorted_hand = custom_sort(hand)\n        result, score = evaluate_hand(sorted_hand)\n        print(f\"Hand: {sorted_hand} -> {result}\")\n\nsimulate_game()"}, {"role": "assistant", "content": "Traceback (most recent call last):\n  File \"<string>\", line 51, in <module>\n  File \"<string>\", line 48, in simulate_game\n  File \"<string>\", line 28, in evaluate_hand\n  File \"<string>\", line 28, in <genexpr>\nTypeError: can only concatenate str (not \"int\") to str\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef generate_pattern(length):\n    return ''.join(chr(65 + (i % 26)) for i in range(length))\n\ndef search_pattern(text, pattern):\n    index = text.find(pattern)\n    if index != -1:\n        return index\n    else:\n        return -1\n\ndef pattern_search_algorithm():\n    pattern = \"HELLO\"\n    text_length = 100\n    text = generate_pattern(text_length)\n    \n    print(f\"Generated Text: {text}\")\n    print(f\"Searching for pattern: {pattern}\")\n    \n    index = search_pattern(text, pattern)\n    if index != -1:\n        print(f\"Pattern '{pattern}' found at index {index}\")\n    else:\n        print(f\"Pattern '{pattern}' not found\")\n\n    all_matches = [m.start() for m in re.finditer(pattern, text)]\n    print(\"All Matches Found:\", all_matches)\n\npattern_search_algorithm()"}, {"role": "assistant", "content": "Generated Text: ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUV\nSearching for pattern: HELLO\nPattern 'HELLO' not found\nAll Matches Found: []\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef day_of_year(date):\n    return (date - datetime(date.year, 1, 1)).days + 1\n\ndates = [\n    datetime(2023, 5, 15),\n    datetime(2023, 1, 1),\n    datetime(2023, 12, 31),\n    datetime(2023, 7, 4),\n    datetime(2023, 3, 11),\n    datetime(2023, 8, 23),\n    datetime(2023, 10, 31),\n    datetime(2023, 6, 30),\n    datetime(2023, 11, 15),\n    datetime(2023, 9, 9)\n]\n\nsorted_dates = sorted(dates, key=day_of_year)\n\nfor date in sorted_dates:\n    next_weekday = date + timedelta(days=(7 - date.weekday()))\n    print(f\"Original: {date.strftime('%Y-%m-%d')}, Day of Year: {day_of_year(date)}, Next Monday: {next_weekday.strftime('%Y-%m-%d')}\")"}, {"role": "assistant", "content": "Original: 2023-01-01, Day of Year: 1, Next Monday: 2023-01-02\nOriginal: 2023-03-11, Day of Year: 70, Next Monday: 2023-03-13\nOriginal: 2023-05-15, Day of Year: 135, Next Monday: 2023-05-22\nOriginal: 2023-06-30, Day of Year: 181, Next Monday: 2023-07-03\nOriginal: 2023-07-04, Day of Year: 185, Next Monday: 2023-07-10\nOriginal: 2023-08-23, Day of Year: 235, Next Monday: 2023-08-28\nOriginal: 2023-09-09, Day of Year: 252, Next Monday: 2023-09-11\nOriginal: 2023-10-31, Day of Year: 304, Next Monday: 2023-11-06\nOriginal: 2023-11-15, Day of Year: 319, Next Monday: 2023-11-20\nOriginal: 2023-12-31, Day of Year: 365, Next Monday: 2024-01-01\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef find_friday_the_13th(year):\n    friday_the_13ths = []\n    for month in range(1, 13):\n        date = datetime(year, month, 13)\n        if date.weekday() == 4:\n            friday_the_13ths.append(date)\n    return friday_the_13ths\n\ndef is_palindrome_date(date):\n    date_str = date.strftime('%m%d%Y')\n    return date_str == date_str[::-1]\n\ndef find_friday_the_13th_palindrome(year):\n    all_dates = find_friday_the_13th(year)\n    palindromes = []\n    for date in all_dates:\n        if is_palindrome_date(date):\n            palindromes.append(date)\n    return all_dates  # Bug: Should return palindromes\n\ndates = find_friday_the_13th_palindrome(2023)\nfor d in dates:\n    print(d.strftime('%Y-%m-%d'))"}, {"role": "assistant", "content": "2023-01-13\n2023-10-13\n"}]}
{"messages": [{"role": "user", "content": "def generate_fibonacci_sequence(n):\n    sequence = [0, 1]\n    for i in range(2, n):\n        sequence.append(sequence[i - 1] + sequence[i - 2])\n    return sequence[:n]\n\ndef calculate_divisors(num):\n    divisors = []\n    for i in range(1, num + 1):\n        if num % i == 0:\n            divisors.append(i)\n    return divisors\n\ndef sort_sequences_by_divisors(sequences):\n    return sorted(sequences, key=lambda x: len(calculate_divisors(x)))\n\nfibonacci_sequence = generate_fibonacci_sequence(20)\nsorted_sequence = sort_sequences_by_divisors(fibonacci_sequence)\n\nfor number in sorted_sequence:\n    divisors = calculate_divisors(number)\n    print(f\"{number}: {len(divisors)} divisors -> {divisors}\")"}, {"role": "assistant", "content": "0: 0 divisors -> []\n1: 1 divisors -> [1]\n1: 1 divisors -> [1]\n2: 2 divisors -> [1, 2]\n3: 2 divisors -> [1, 3]\n5: 2 divisors -> [1, 5]\n13: 2 divisors -> [1, 13]\n89: 2 divisors -> [1, 89]\n233: 2 divisors -> [1, 233]\n1597: 2 divisors -> [1, 1597]\n8: 4 divisors -> [1, 2, 4, 8]\n21: 4 divisors -> [1, 3, 7, 21]\n34: 4 divisors -> [1, 2, 17, 34]\n55: 4 divisors -> [1, 5, 11, 55]\n377: 4 divisors -> [1, 13, 29, 377]\n4181: 4 divisors -> [1, 37, 113, 4181]\n610: 8 divisors -> [1, 2, 5, 10, 61, 122, 305, 610]\n987: 8 divisors -> [1, 3, 7, 21, 47, 141, 329, 987]\n144: 15 divisors -> [1, 2, 3, 4, 6, 8, 9, 12, 16, 18, 24, 36, 48, 72, 144]\n2584: 16 divisors -> [1, 2, 4, 8, 17, 19, 34, 38, 68, 76, 136, 152, 323, 646, 1292, 2584]\n"}]}
{"messages": [{"role": "user", "content": "def is_happy_number(n):\n    seen = set()\n    while n != 1 and n not in seen:\n        seen.add(n)\n        n = sum(int(digit) ** 2 for digit in str(n))\n    return n == 1\n\ndef generate_arithmetic_sequence(a, d, n):\n    return [a + i * d for i in range(n)]\n\ndef find_happy_numbers_in_sequence(sequence):\n    happy_numbers = []\n    for number in sequence:\n        if is_happy_number(number):\n            happy_numbers.append(number)\n    return happy_numbers\n\na = 10\nd = 3\nn = 40\nsequence = generate_arithmetic_sequence(a, d, n)\nhappy_numbers = find_happy_numbers_in_sequence(sequence)\n\nfor number in happy_numbers:\n    print(number)"}, {"role": "assistant", "content": "10\n13\n19\n28\n31\n49\n70\n79\n82\n91\n94\n97\n100\n103\n109\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef sort_scores(scores):\n    sorted_scores = sorted(scores, key=lambda x: (-x[1], x[0]))\n    return sorted_scores\n\ndef calculate_score(word):\n    return sum(ord(c) - ord('a') + 1 for c in word.lower() if c.isalpha())\n\ndef evaluate_words(word_list):\n    scores = []\n    for word in word_list:\n        score = calculate_score(word)\n        scores.append((word, score))\n        print(f\"Word: {word}, Score: {score}\")\n    return scores\n\ndef main():\n    text = \"\"\"\n    Quidditch is the most popular sport in the wizarding world.\n    Players ride flying broomsticks and try to score points by getting a ball called the Quaffle through one of the opponent's three hoops.\n    The team with the most points wins.\n    \"\"\"\n    \n    words = re.findall(r'\\b\\w+\\b', text)\n    scores = evaluate_words(words)\n    sorted_scores = sort_scores(scores)\n    \n    print(\"\\nTop scoring words:\")\n    for word, score in sorted_scores[:10]:\n        print(f\"{word}: {score}\")\n\nmain()"}, {"role": "assistant", "content": "Word: Quidditch, Score: 95\nWord: is, Score: 28\nWord: the, Score: 33\nWord: most, Score: 67\nWord: popular, Score: 99\nWord: sport, Score: 88\nWord: in, Score: 23\nWord: the, Score: 33\nWord: wizarding, Score: 111\nWord: world, Score: 72\nWord: Players, Score: 96\nWord: ride, Score: 36\nWord: flying, Score: 73\nWord: broomsticks, Score: 144\nWord: and, Score: 19\nWord: try, Score: 63\nWord: to, Score: 35\nWord: score, Score: 60\nWord: points, Score: 93\nWord: by, Score: 27\nWord: getting, Score: 82\nWord: a, Score: 1\nWord: ball, Score: 27\nWord: called, Score: 37\nWord: the, Score: 33\nWord: Quaffle, Score: 68\nWord: through, Score: 97\nWord: one, Score: 34\nWord: of, Score: 21\nWord: the, Score: 33\nWord: opponent, Score: 115\nWord: s, Score: 19\nWord: three, Score: 56\nWord: hoops, Score: 73\nWord: The, Score: 33\nWord: team, Score: 39\nWord: with, Score: 60\nWord: the, Score: 33\nWord: most, Score: 67\nWord: points, Score: 93\nWord: wins, Score: 65\n\nTop scoring words:\nbroomsticks: 144\nopponent: 115\nwizarding: 111\npopular: 99\nthrough: 97\nPlayers: 96\nQuidditch: 95\npoints: 93\npoints: 93\nsport: 88\n"}]}
{"messages": [{"role": "user", "content": "from math import sqrt\n\ndef encode_message(message):\n    prime_numbers = [2]\n    num = 3\n    \n    while len(prime_numbers) < len(message):\n        if all(num % p != 0 for p in prime_numbers if p <= sqrt(num)):\n            prime_numbers.append(num)\n        num += 2\n    \n    encoded_message = [(ord(ch) + prime) % 126 for ch, prime in zip(message, prime_numbers)]\n    return encoded_message\n\ndef sort_encoded(encoded_message):\n    return sorted(encoded_message, reverse=True)\n\ndef decode_message(encoded_message, original_length):\n    prime_numbers = [2]\n    num = 3\n    \n    while len(prime_numbers) < original_length:\n        if all(num % p != 0 for p in prime_numbers if p <= sqrt(num)):\n            prime_numbers.append(num)\n        num += 2\n    \n    decoded_message = ''.join(chr((ch - prime) % 126) for ch, prime in zip(encoded_message, prime_numbers))\n    return decoded_message\n\nmessage = \"Hello, World! This is an encoded message with primes.\"\nencoded = encode_message(message)\nsorted_encoded = sort_encoded(encoded)\ndecoded = decode_message(sorted_encoded, len(message))\n\nprint(\"Original Message:\", message)\nprint(\"Encoded Message:\", encoded)\nprint(\"Sorted Encoded:\", sorted_encoded)\nprint(\"Decoded Message:\", decoded)"}, {"role": "assistant", "content": "Original Message: Hello, World! This is an encoded message with primes.\nEncoded Message: [74, 104, 113, 115, 122, 57, 49, 106, 8, 17, 13, 11, 74, 75, 5, 31, 38, 50, 99, 50, 62, 111, 54, 73, 3, 76, 87, 80, 94, 87, 102, 105, 43, 122, 124, 14, 20, 8, 18, 22, 85, 48, 44, 57, 49, 105, 71, 85, 80, 86, 82, 102, 35]\nSorted Encoded: [124, 122, 122, 115, 113, 111, 106, 105, 105, 104, 102, 102, 99, 94, 87, 87, 86, 85, 85, 82, 80, 80, 76, 75, 74, 74, 73, 71, 62, 57, 57, 54, 50, 50, 49, 49, 48, 44, 43, 38, 35, 31, 22, 20, 18, 17, 14, 13, 11, 8, 8, 5, 3]\nDecoded Message: zwulfbYVRKGA:3(\"\u001b\u0018\u0012\u000b\u0007\u0001wpgc`ZOF81'%\u001a\u0018\u0011\u0007\u0002ulfSOIF7*$\u001f\u001b\u0012\u000e\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"\nPython is an interpreted, high-level, general-purpose programming language. Created by Guido van Rossum and first released \nin 1991, Python's design philosophy emphasizes code readability with its notable use of significant whitespace. Its language\nconstructs and object-oriented approach aim to help programmers write clear, logical code for small and large-scale \nprojects. Python is dynamically typed and garbage-collected. It supports multiple programming paradigms, including \nstructured (particularly, procedural), object-oriented, and functional programming. Python is often described as a \n\"batteries included\" language due to its comprehensive standard library.\n\"\"\"\n\nwords = re.findall(r'\\b\\w+\\b', text.lower())\nunique_words = list(set(words))\nunique_words.sort(key=lambda w: (len(w), w))\nprint(\"\\n\".join(unique_words))"}, {"role": "assistant", "content": "a\ns\nan\nas\nby\nin\nis\nit\nof\nto\naim\nand\ndue\nfor\nits\nuse\nvan\n1991\ncode\nhelp\nhigh\nwith\nclear\nfirst\nguido\nlarge\nlevel\noften\nscale\nsmall\ntyped\nwrite\ndesign\nobject\npython\nrossum\ncreated\ngarbage\ngeneral\nlibrary\nlogical\nnotable\npurpose\napproach\nincluded\nlanguage\nmultiple\noriented\nprojects\nreleased\nstandard\nsupports\nbatteries\ncollected\ndescribed\nincluding\nparadigms\nconstructs\nemphasizes\nfunctional\nphilosophy\nprocedural\nstructured\nwhitespace\ndynamically\ninterpreted\nprogrammers\nprogramming\nreadability\nsignificant\nparticularly\ncomprehensive\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"\nPython is powerful... and fast; plays well with others; runs everywhere; is friendly & easy to learn; is Open. These are some of the reasons people who use Python would rather not use anything else.\n\"\"\"\n\ndef search_longest_word(text):\n    words = re.findall(r'\\b\\w+\\b', text)\n    max_length = 0\n    longest_words = []\n    for word in words:\n        word_length = sum(1 for _ in word)\n        if word_length > max_length:\n            max_length = word_length\n            longest_words = [word]\n        elif word_length == max_length:\n            longest_words.append(word)\n    return longest_words\n\nresult = search_longest_word(text)\n\nfor idx, word in enumerate(result, 1):\n    print(f\"{idx}. {word}\")"}, {"role": "assistant", "content": "1. everywhere\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndata = [\n    ('2023-05-15', 'Tom', 72),\n    ('2023-05-17', 'Jerry', 85),\n    ('2023-05-16', 'Spike', 78),\n    ('2023-05-18', 'Tom', 90),\n    ('2023-05-14', 'Jerry', 95),\n    ('2023-05-19', 'Spike', 82),\n    ('2023-05-20', 'Tom', 88),\n]\n\ndef parse_date(date_str):\n    return datetime.strptime(date_str, '%Y-%m-%d')\n\ndef transform_data(data):\n    data_by_name = {}\n    for date_str, name, score in data:\n        if name not in data_by_name:\n            data_by_name[name] = []\n        data_by_name[name].append((parse_date(date_str), score))\n\n    transformed_data = []\n    for name, entries in data_by_name.items():\n        entries.sort()\n        cumulative_scores = []\n        score_sum = 0\n        for date, score in entries:\n            score_sum += score\n            cumulative_scores.append((date, score_sum))\n        transformed_data.append((name, cumulative_scores))\n\n    return transformed_data\n\ndef format_output(transformed_data):\n    result = []\n    for name, entries in transformed_data:\n        result.append(f\"Name: {name}\")\n        for date, cum_score in entries:\n            result.append(f\"Date: {date.strftime('%Y-%m-%d')}, Cumulative Score: {cum_score}\")\n        result.append(\"\")\n    return result\n\ntransformed_data = transform_data(data)\nformatted_output = format_output(transformed_data)\n\nfor line in formatted_output:\n    print(line)"}, {"role": "assistant", "content": "Name: Tom\nDate: 2023-05-15, Cumulative Score: 72\nDate: 2023-05-18, Cumulative Score: 162\nDate: 2023-05-20, Cumulative Score: 250\n\nName: Jerry\nDate: 2023-05-14, Cumulative Score: 95\nDate: 2023-05-17, Cumulative Score: 180\n\nName: Spike\nDate: 2023-05-16, Cumulative Score: 78\nDate: 2023-05-19, Cumulative Score: 160\n\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef calculate_polygon_area(vertices):\n    n = len(vertices)\n    area = 0.0\n    for i in range(n):\n        j = (i + 1) % n\n        area += vertices[i][0] * vertices[j][1]\n        area -= vertices[j][0] * vertices[i][1]\n    area = abs(area) / 2.0\n    return area\n\ndef convex_hull(points):\n    points = sorted(points)\n    if len(points) <= 1:\n        return points\n\n    def cross(o, a, b):\n        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\n    lower = []\n    for p in points:\n        while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:\n            lower.pop()\n        lower.append(p)\n\n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:\n            upper.pop()\n        upper.append(p)\n\n    return lower[:-1] + upper[:-1]\n\ndef main():\n    points = [(2, 3), (3, 5), (1, 2), (5, 3), (3, 2), (4, 4), (2, 4), (6, 2), (5, 5), (7, 3)]\n    hull_points = convex_hull(points)\n    area = calculate_polygon_area(hull_points)\n    \n    print(\"Convex Hull Points:\")\n    for point in hull_points:\n        print(point)\n    print(\"\\nArea of Convex Hull:\", round(area, 2))\n\nmain()"}, {"role": "assistant", "content": "Convex Hull Points:\n(1, 2)\n(6, 2)\n(7, 3)\n(5, 5)\n(3, 5)\n(2, 4)\n\nArea of Convex Hull: 13.0\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef sort_and_calculate_median(values):\n    sorted_values = sorted(values)\n    median = sorted_values[len(values) // 2]\n    return median\n\ndata = [12, 15, 10, 11, 14, 13, 10, 16, 19, 18, 17, 15, 11, 20]\n\nmedian = sort_and_calculate_median(data)\n\nprint(\"Data:\", data)\nprint(\"Sorted Data:\", sorted(data))\nprint(\"Calculated Median:\", median)\nprint(\"Actual Median:\", statistics.median(data))"}, {"role": "assistant", "content": "Data: [12, 15, 10, 11, 14, 13, 10, 16, 19, 18, 17, 15, 11, 20]\nSorted Data: [10, 10, 11, 11, 12, 13, 14, 15, 15, 16, 17, 18, 19, 20]\nCalculated Median: 15\nActual Median: 14.5\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef day_of_year(date):\n    return date.timetuple().tm_yday\n\ndef sort_dates_by_day_of_year(dates):\n    return sorted(dates, key=day_of_year)\n\ndates = [\n    datetime(2023, 2, 1),\n    datetime(2023, 11, 15),\n    datetime(2023, 3, 14),\n    datetime(2023, 9, 23),\n    datetime(2023, 6, 10),\n    datetime(2023, 1, 1),\n    datetime(2023, 12, 31),\n    datetime(2023, 7, 4),\n    datetime(2023, 5, 5),\n    datetime(2023, 10, 10)\n]\n\nsorted_dates = sort_dates_by_day_of_year(dates)\n\nfor date in sorted_dates:\n    print(date.strftime(\"%B %d, %Y\"))"}, {"role": "assistant", "content": "January 01, 2023\nFebruary 01, 2023\nMarch 14, 2023\nMay 05, 2023\nJune 10, 2023\nJuly 04, 2023\nSeptember 23, 2023\nOctober 10, 2023\nNovember 15, 2023\nDecember 31, 2023\n"}]}
{"messages": [{"role": "user", "content": "from math import sqrt\n\ndef prime_factors(n):\n    factors = []\n    while n % 2 == 0:\n        factors.append(2)\n        n = n // 2\n    for i in range(3, int(sqrt(n)) + 1, 2):\n        while n % i == 0:\n            factors.append(i)\n            n = n // i\n    if n > 2:\n        factors.append(n)\n    return factors\n\ndef pattern_generator(numbers):\n    patterns = []\n    for number in numbers:\n        factors = prime_factors(number)\n        pattern = ''.join(sorted(set(str(f) for f in factors)))\n        patterns.append((pattern, number))\n    print(\"Patterns before sorting:\", patterns)\n    patterns.sort()\n    print(\"Patterns after sorting:\", patterns)\n    return patterns\n\nnumbers = [45, 100, 259, 33, 60, 77, 210, 84, 91, 143]\nsorted_patterns = pattern_generator(numbers)\n\nfor pattern, number in sorted_patterns:\n    print(f\"Number: {number} -> Pattern: {pattern}\")"}, {"role": "assistant", "content": "Patterns before sorting: [('35', 45), ('25', 100), ('377', 259), ('113', 33), ('235', 60), ('117', 77), ('2357', 210), ('237', 84), ('137', 91), ('1113', 143)]\nPatterns after sorting: [('1113', 143), ('113', 33), ('117', 77), ('137', 91), ('235', 60), ('2357', 210), ('237', 84), ('25', 100), ('35', 45), ('377', 259)]\nNumber: 143 -> Pattern: 1113\nNumber: 33 -> Pattern: 113\nNumber: 77 -> Pattern: 117\nNumber: 91 -> Pattern: 137\nNumber: 60 -> Pattern: 235\nNumber: 210 -> Pattern: 2357\nNumber: 84 -> Pattern: 237\nNumber: 100 -> Pattern: 25\nNumber: 45 -> Pattern: 35\nNumber: 259 -> Pattern: 377\n"}]}
{"messages": [{"role": "user", "content": "import string\n\ndef caesar_cipher(word, shift):\n    alphabets = string.ascii_lowercase\n    shifted_word = ''.join(alphabets[(alphabets.index(c) + shift) % 26] for c in word)\n    return shifted_word\n\ndef vigenere_cipher(text, key):\n    alphabets = string.ascii_lowercase\n    key_indices = [alphabets.index(k) for k in key]\n    encrypted_text = ''.join(\n        alphabets[(alphabets.index(c) + key_indices[i % len(key)]) % 26] for i, c in enumerate(text)\n    )\n    return encrypted_text\n\ndef search_encoded(word, encoded_list):\n    for encoded in encoded_list:\n        if caesar_cipher(encoded, 3) == word:\n            return encoded\n    return None\n\noriginal_text = \"advancedsearchingexample\"\nkey = \"complex\"\nencoded_text = vigenere_cipher(original_text, key)\nencoded_list = [encoded_text]\n\nfound_word = search_encoded(\"searching\", encoded_list)\n\nprint(f\"Original text: {original_text}\")\nprint(f\"Encoded text: {encoded_text}\")\nprint(f\"Found word: {found_word}\")"}, {"role": "assistant", "content": "Original text: advancedsearchingexample\nEncoded text: crhpygbfgqpcgekbstiejrzq\nFound word: None\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndates = [\n    \"2023-06-15 14:30:00\",\n    \"2023-01-01 00:00:00\",\n    \"2023-12-31 23:59:59\",\n    \"2023-03-10 09:15:00\",\n    \"2023-07-04 12:00:00\",\n    \"2023-11-11 16:45:00\",\n    \"2023-08-08 08:08:08\",\n    \"2023-05-05 05:05:05\",\n    \"2023-02-02 02:02:02\",\n    \"2023-04-01 01:01:01\"\n]\n\ndate_objects = [datetime.strptime(date, \"%Y-%m-%d %H:%M:%S\") for date in dates]\n\nweekday_sorted_dates = sorted(date_objects, key=lambda x: (x.weekday(), x))\n\nfor date in weekday_sorted_dates:\n    print(date.strftime(\"%A, %Y-%m-%d %H:%M:%S\"))"}, {"role": "assistant", "content": "Tuesday, 2023-07-04 12:00:00\nTuesday, 2023-08-08 08:08:08\nThursday, 2023-02-02 02:02:02\nThursday, 2023-06-15 14:30:00\nFriday, 2023-03-10 09:15:00\nFriday, 2023-05-05 05:05:05\nSaturday, 2023-04-01 01:01:01\nSaturday, 2023-11-11 16:45:00\nSunday, 2023-01-01 00:00:00\nSunday, 2023-12-31 23:59:59\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndata = [\n    [65, 78, 89, 92, 70],\n    [88, 94, 77, 85, 91],\n    [81, 79, 82, 88, 76],\n    [71, 85, 78, 89, 92],\n    [90, 86, 79, 81, 84],\n    [67, 71, 88, 90, 83],\n    [84, 77, 69, 73, 91],\n    [75, 83, 78, 81, 89],\n    [89, 76, 81, 85, 90],\n    [80, 82, 79, 77, 88]\n]\n\ndef median_of_medians(data):\n    medians = [statistics.median(group) for group in data]\n    medians.sort()\n    return statistics.median(medians)\n\nprint(\"Data:\")\nfor group in data:\n    print(group)\n\nprint(\"\\nSorted Medians of Groups:\")\nsorted_medians = sorted(statistics.median(group) for group in data)\nfor median in sorted_medians:\n    print(median)\n\noverall_median = median_of_medians(data)\nprint(\"\\nOverall Median of Medians:\", overall_median)"}, {"role": "assistant", "content": "Data:\n[65, 78, 89, 92, 70]\n[88, 94, 77, 85, 91]\n[81, 79, 82, 88, 76]\n[71, 85, 78, 89, 92]\n[90, 86, 79, 81, 84]\n[67, 71, 88, 90, 83]\n[84, 77, 69, 73, 91]\n[75, 83, 78, 81, 89]\n[89, 76, 81, 85, 90]\n[80, 82, 79, 77, 88]\n\nSorted Medians of Groups:\n77\n78\n80\n81\n81\n83\n84\n85\n85\n88\n\nOverall Median of Medians: 82.0\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef encrypt_sort(message):\n    def custom_key(char):\n        return ord(char) * (1 if char.islower() else 2)\n    \n    encrypted_chars = [chr((ord(char) + 3) % 256) for char in message]\n    sorted_chars = sorted(encrypted_chars, key=custom_key, reverse=True)\n    \n    return ''.join(sorted_chars)\n\ndef main():\n    text = \"AdvancedEncryption\"\n    encrypted_message = encrypt_sort(text)\n    print(encrypted_message)\n\nif __name__ == \"__main__\":\n    main()"}, {"role": "assistant", "content": "|HDywusrqqqlhggffd\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef custom_sort(data):\n    return sorted(data, key=lambda x: statistics.median(x))\n\ndatasets = [\n    [3, 1, 4, 1, 5],\n    [9, 2, 6, 5, 3],\n    [5, 8, 9, 7],\n    [3, 2, 3],\n    [8, 4, 7, 1],\n    [2, 7, 1, 8, 2],\n    [1, 6, 1, 8, 0],\n    [5, 9, 3, 2],\n    [6, 5, 3, 5],\n    [8, 9, 7, 9]\n]\n\nsorted_datasets = custom_sort(datasets)\n\nfor dataset in sorted_datasets:\n    print(dataset)"}, {"role": "assistant", "content": "[1, 6, 1, 8, 0]\n[2, 7, 1, 8, 2]\n[3, 1, 4, 1, 5]\n[3, 2, 3]\n[5, 9, 3, 2]\n[9, 2, 6, 5, 3]\n[6, 5, 3, 5]\n[8, 4, 7, 1]\n[5, 8, 9, 7]\n[8, 9, 7, 9]\n"}]}
{"messages": [{"role": "user", "content": "def find_pattern(grid, pattern):\n    rows, cols = len(grid), len(grid[0])\n    pat_len = len(pattern)\n    results = []\n\n    def search_direction(r, c, dr, dc):\n        for i in range(pat_len):\n            nr, nc = r + i * dr, c + i * dc\n            if not (0 <= nr < rows and 0 <= nc < cols) or grid[nr][nc] != pattern[i]:\n                return False\n        return True\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == pattern[0]:\n                if search_direction(r, c, 0, 1):  # horizontal\n                    results.append((r, c, \"horizontal\"))\n                if search_direction(r, c, 1, 0):  # vertical\n                    results.append((r, c, \"vertical\"))\n                if search_direction(r, c, 1, 1):  # diagonal down-right\n                    results.append((r, c, \"diagonal down-right\"))\n                if search_direction(r, c, 1, -1):  # diagonal down-left\n                    results.append((r, c, \"diagonal down-left\"))\n\n    return results\n\ngrid = [\n    ['a', 'b', 'c', 'd', 'e'],\n    ['f', 'g', 'h', 'i', 'j'],\n    ['k', 'l', 'm', 'n', 'o'],\n    ['p', 'q', 'r', 's', 't'],\n    ['u', 'v', 'w', 'x', 'y']\n]\n\npattern = \"mno\"\nmatches = find_pattern(grid, pattern)\n\nfor match in matches:\n    print(f\"Pattern found at row {match[0]}, col {match[1]} in {match[2]} direction\")"}, {"role": "assistant", "content": "Pattern found at row 2, col 2 in horizontal direction\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef find_highest_value_expression(expressions):\n    def evaluate_expression(expr):\n        return eval(expr)\n    \n    max_value = float('-inf')\n    max_expr = \"\"\n    \n    for expr in expressions:\n        value = evaluate_expression(expr)\n        if value > max_value:\n            max_value = value\n            max_expr = expr\n            \n    return max_expr, max_value\n\ndata = \"\"\"\n3 + 5 * 2\n8 / 2 - 1\n7 * 3 + 4\n(9 - 4) * 3\n12 / (2 + 1)\n8 + 6 / 2\n\"\"\"\n\nexpressions = re.findall(r'[\\d+\\-*/\\(\\)\\s]+', data)\nresult_expr, result_value = find_highest_value_expression(expressions)\n\nprint(f\"The expression with the highest value is: {result_expr.strip()} = {result_value}\")"}, {"role": "assistant", "content": "Traceback (most recent call last):\n  File \"<string>\", line 28, in <module>\n  File \"<string>\", line 11, in find_highest_value_expression\n  File \"<string>\", line 5, in evaluate_expression\n  File \"<string>\", line 3\n    8 / 2 - 1\n    ^\nSyntaxError: invalid syntax\n"}]}
{"messages": [{"role": "user", "content": "from math import gcd\n\ndef caesar_cipher(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            shift_amount = shift % 26\n            code = ord(char) + shift_amount\n            if char.islower():\n                if code > ord('z'):\n                    code -= 26\n            elif char.isupper():\n                if code > ord('Z'):\n                    code -= 26\n            result += chr(code)\n        else:\n            result += char\n    return result\n\ndef brute_force_caesar(text):\n    potential_messages = []\n    for shift in range(1, 26):\n        potential_messages.append(caesar_cipher(text, shift))\n    return potential_messages\n\ndef encode_message(message, key):\n    return ''.join(chr((ord(char) + key) % 256) for char in message)\n\ndef search_encoded_message(encoded_messages, target):\n    for message in encoded_messages:\n        if target in message:\n            return message\n    return None\n\noriginal_message = \"This is a secret message.\"\nkey = 5\nencoded_message = encode_message(original_message, key)\nencoded_messages = brute_force_caesar(encoded_message)\ntarget = encode_message(\"secret\", key)\nfound_message = search_encoded_message(encoded_messages, target)\n\nfor idx, message in enumerate(encoded_messages):\n    print(f\"Shift {idx + 1}: {message}\")\n\nprint(\"\\nTarget found in: \", found_message)"}, {"role": "assistant", "content": "Shift 1: Znoy%oy%g%ykixkz%skyygmk3\nShift 2: Aopz%pz%h%zljyla%tlzzhnl3\nShift 3: Bpqa%qa%i%amkzmb%umaaiom3\nShift 4: Cqrb%rb%j%bnlanc%vnbbjpn3\nShift 5: Drsc%sc%k%combod%wocckqo3\nShift 6: Estd%td%l%dpncpe%xpddlrp3\nShift 7: Ftue%ue%m%eqodqf%yqeemsq3\nShift 8: Guvf%vf%n%frperg%zrffntr3\nShift 9: Hvwg%wg%o%gsqfsh%asggous3\nShift 10: Iwxh%xh%p%htrgti%bthhpvt3\nShift 11: Jxyi%yi%q%iushuj%cuiiqwu3\nShift 12: Kyzj%zj%r%jvtivk%dvjjrxv3\nShift 13: Lzak%ak%s%kwujwl%ewkksyw3\nShift 14: Mabl%bl%t%lxvkxm%fxlltzx3\nShift 15: Nbcm%cm%u%mywlyn%gymmuay3\nShift 16: Ocdn%dn%v%nzxmzo%hznnvbz3\nShift 17: Pdeo%eo%w%oaynap%iaoowca3\nShift 18: Qefp%fp%x%pbzobq%jbppxdb3\nShift 19: Rfgq%gq%y%qcapcr%kcqqyec3\nShift 20: Sghr%hr%z%rdbqds%ldrrzfd3\nShift 21: This%is%a%secret%message3\nShift 22: Uijt%jt%b%tfdsfu%nfttbhf3\nShift 23: Vjku%ku%c%ugetgv%oguucig3\nShift 24: Wklv%lv%d%vhfuhw%phvvdjh3\nShift 25: Xlmw%mw%e%wigvix%qiwweki3\n\nTarget found in:  None\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef is_palindrome(number):\n    return str(number) == str(number)[::-1]\n\ndef generate_special_numbers(limit):\n    special_numbers = []\n    for num in range(1, limit):\n        if num % 7 == 0 and is_palindrome(num):\n            special_numbers.append(num)\n    return special_numbers\n\ndef digit_sum(number):\n    return sum(int(digit) for digit in str(number))\n\ndef custom_sort(numbers):\n    return sorted(numbers, key=lambda x: (digit_sum(x), -x))\n\nlimit = 3000\nspecial_numbers = generate_special_numbers(limit)\nsorted_numbers = custom_sort(special_numbers)\n\nfor number in sorted_numbers:\n    print(number)"}, {"role": "assistant", "content": "1001\n2002\n7\n161\n252\n343\n434\n525\n616\n707\n77\n1771\n2772\n595\n686\n777\n868\n959\n"}]}
{"messages": [{"role": "user", "content": "import math\nfrom statistics import mean, stdev\n\ndef calculate_z_score(data, target):\n    avg = mean(data)\n    std_dev = stdev(data)\n    return (target - avg) / std_dev\n\ndef binary_search_z_score(data, z_score):\n    left, right = 0, len(data) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        mid_z_score = calculate_z_score(data, data[mid])\n        if math.isclose(mid_z_score, z_score, rel_tol=1e-9):\n            return data[mid]\n        elif mid_z_score < z_score:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return None\n\ndata = [3, 7, 5, 13, 23, 11, 17, 19, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83]\ndata.sort()\n\ntarget_z_scores = [0.5, 1.0, 1.5, 2.0, 2.5, 3.0]\nresults = []\n\nfor z in target_z_scores:\n    result = binary_search_z_score(data, z)\n    results.append((z, result))\n\nfor z, value in results:\n    print(f\"Z-Score: {z}, Closest Value: {value}\")"}, {"role": "assistant", "content": "Z-Score: 0.5, Closest Value: None\nZ-Score: 1.0, Closest Value: None\nZ-Score: 1.5, Closest Value: None\nZ-Score: 2.0, Closest Value: None\nZ-Score: 2.5, Closest Value: None\nZ-Score: 3.0, Closest Value: None\n"}]}
{"messages": [{"role": "user", "content": "def rank_players(players, scores):\n    return sorted(players, key=lambda x: scores[x], reverse=True)\n\ndef get_teams(players, scores):\n    ranked_players = rank_players(players, scores)\n    team_count = 3\n    teams = [[] for _ in range(team_count)]\n    \n    for i, player in enumerate(ranked_players):\n        teams[i % team_count].append(player)\n    \n    return teams\n\nplayers = ['Alice', 'Bob', 'Charlie', 'Dave', 'Eve', 'Frank', 'Grace', 'Hector', 'Ivy', 'Jack']\nscores = {\n    'Alice': 85,\n    'Bob': 92,\n    'Charlie': 88,\n    'Dave': 90,\n    'Eve': 87,\n    'Frank': 91,\n    'Grace': 89,\n    'Hector': 86,\n    'Ivy': 84,\n    'Jack': 93\n}\n\nteams = get_teams(players, scores)\n\nfor i, team in enumerate(teams):\n    print(f\"Team {i + 1}:\")\n    for player in team:\n        print(f\"{player} - {scores[player]}\")\n    print()"}, {"role": "assistant", "content": "Team 1:\nJack - 93\nDave - 90\nEve - 87\nIvy - 84\n\nTeam 2:\nBob - 92\nGrace - 89\nHector - 86\n\nTeam 3:\nFrank - 91\nCharlie - 88\nAlice - 85\n\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef distance(point1, point2):\n    return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2)\n\ndef perimeter(polygon):\n    peri = 0\n    for i in range(len(polygon)):\n        peri += distance(polygon[i], polygon[(i + 1) % len(polygon)])\n    return peri\n\ndef sort_polygons_by_perimeter(polygons):\n    return sorted(polygons, key=perimeter)\n\npolygons = [\n    [(0, 0), (4, 0), (4, 3), (0, 3)],  # Rectangle\n    [(0, 0), (3, 0), (3, 3), (0, 3)],  # Square\n    [(0, 0), (2, 0), (1, math.sqrt(3))],  # Equilateral Triangle\n    [(0, 0), (0, 1), (1, 0)],  # Right Triangle\n    [(1, 1), (5, 1), (5, 5), (1, 5)],  # Bigger square\n    [(0, 0), (2, 2), (4, 0)]  # Isosceles Triangle\n]\n\nsorted_polygons = sort_polygons_by_perimeter(polygons)\n\nfor i, polygon in enumerate(sorted_polygons, 1):\n    print(f\"Polygon {i}: {polygon}, Perimeter: {perimeter(polygon):.2f}\")"}, {"role": "assistant", "content": "Polygon 1: [(0, 0), (0, 1), (1, 0)], Perimeter: 3.41\nPolygon 2: [(0, 0), (2, 0), (1, 1.7320508075688772)], Perimeter: 6.00\nPolygon 3: [(0, 0), (2, 2), (4, 0)], Perimeter: 9.66\nPolygon 4: [(0, 0), (3, 0), (3, 3), (0, 3)], Perimeter: 12.00\nPolygon 5: [(0, 0), (4, 0), (4, 3), (0, 3)], Perimeter: 14.00\nPolygon 6: [(1, 1), (5, 1), (5, 5), (1, 5)], Perimeter: 16.00\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef generate_pattern(n):\n    pattern = []\n    for i in range(n):\n        line = ''.join(['*' if (i + j) % 2 == 0 else '-' for j in range(n)])\n        pattern.append(line)\n    return pattern\n\ndef custom_sort_criteria(line):\n    return sum(1 for char in line if char == '*')\n\ndef sort_pattern(pattern):\n    return sorted(pattern, key=custom_sort_criteria)\n\ndef main():\n    size = 10\n    pattern = generate_pattern(size)\n    print(\"Generated Pattern:\")\n    for line in pattern:\n        print(line)\n\n    print(\"\\nSorted Pattern by Number of '*':\")\n    sorted_pattern = sort_pattern(pattern)\n    for line in sorted_pattern:\n        print(line)\n\nmain()"}, {"role": "assistant", "content": "Generated Pattern:\n*-*-*-*-*-\n-*-*-*-*-*\n*-*-*-*-*-\n-*-*-*-*-*\n*-*-*-*-*-\n-*-*-*-*-*\n*-*-*-*-*-\n-*-*-*-*-*\n*-*-*-*-*-\n-*-*-*-*-*\n\nSorted Pattern by Number of '*':\n*-*-*-*-*-\n-*-*-*-*-*\n*-*-*-*-*-\n-*-*-*-*-*\n*-*-*-*-*-\n-*-*-*-*-*\n*-*-*-*-*-\n-*-*-*-*-*\n*-*-*-*-*-\n-*-*-*-*-*\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndata = [\n    (\"2023-10-01\", 120),\n    (\"2023-09-15\", 95),\n    (\"2023-10-12\", 130),\n    (\"2023-09-20\", 110),\n    (\"2023-10-05\", 115),\n    (\"2023-09-25\", 100),\n    (\"2023-10-15\", 140),\n    (\"2023-09-30\", 105)\n]\n\ndata = [(datetime.strptime(date, \"%Y-%m-%d\"), value) for date, value in data]\n\nstart_date = datetime(2023, 9, 15)\nend_date = datetime(2023, 10, 15)\n\nfiltered_data = [entry for entry in data if start_date <= entry[0] <= end_date]\n\nsorted_data = sorted(filtered_data, key=lambda x: x[1], reverse=True)\n\nranked_data = [(i + 1, date.strftime(\"%Y-%m-%d\"), value) for i, (date, value) in enumerate(sorted_data)]\n\nfor rank, date, value in ranked_data:\n    print(f\"{rank}. Date: {date}, Value: {value}\")"}, {"role": "assistant", "content": "1. Date: 2023-10-15, Value: 140\n2. Date: 2023-10-12, Value: 130\n3. Date: 2023-10-01, Value: 120\n4. Date: 2023-10-05, Value: 115\n5. Date: 2023-09-20, Value: 110\n6. Date: 2023-09-30, Value: 105\n7. Date: 2023-09-25, Value: 100\n8. Date: 2023-09-15, Value: 95\n"}]}
{"messages": [{"role": "user", "content": "class GameBoard:\n    def __init__(self, size):\n        self.size = size\n        self.board = [['.' for _ in range(size)] for _ in range(size)]\n        self.positions = []\n        self.path = []\n\n    def place_piece(self, pos):\n        if 0 <= pos[0] < self.size and 0 <= pos[1] < self.size:\n            self.board[pos[0]][pos[1]] = 'P'\n            self.positions.append(pos)\n\n    def is_valid_path(self, current, target):\n        if current == target:\n            return True\n        x, y = current\n        if not (0 <= x < self.size and 0 <= y < self.size):\n            return False\n        if (x, y) in self.path:\n            return False\n        self.path.append((x, y))\n        for dx, dy in [(-2, 1), (-1, 2), (1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1)]:\n            if self.is_valid_path((x + dx, y + dy), target):\n                return True\n        self.path.pop()\n        return False\n\n    def find_paths(self):\n        for start in self.positions:\n            for end in self.positions:\n                if start != end:\n                    self.path = []\n                    if self.is_valid_path(start, end):\n                        print(f\"Path exists between {start} and {end}\")\n                    else:\n                        print(f\"No path between {start} and {end}\")\n\nboard = GameBoard(5)\nboard.place_piece((0, 0))\nboard.place_piece((1, 2))\nboard.place_piece((3, 3))\nboard.place_piece((4, 4))\nboard.place_piece((0, 3))\nboard.place_piece((2, 1))\nboard.find_paths()"}, {"role": "assistant", "content": "Path exists between (0, 0) and (1, 2)\nPath exists between (0, 0) and (3, 3)\nPath exists between (0, 0) and (4, 4)\nPath exists between (0, 0) and (0, 3)\nPath exists between (0, 0) and (2, 1)\nPath exists between (1, 2) and (0, 0)\nPath exists between (1, 2) and (3, 3)\nPath exists between (1, 2) and (4, 4)\nPath exists between (1, 2) and (0, 3)\nPath exists between (1, 2) and (2, 1)\nPath exists between (3, 3) and (0, 0)\nPath exists between (3, 3) and (1, 2)\nPath exists between (3, 3) and (4, 4)\nPath exists between (3, 3) and (0, 3)\nPath exists between (3, 3) and (2, 1)\nPath exists between (4, 4) and (0, 0)\nPath exists between (4, 4) and (1, 2)\nPath exists between (4, 4) and (3, 3)\nPath exists between (4, 4) and (0, 3)\nPath exists between (4, 4) and (2, 1)\nPath exists between (0, 3) and (0, 0)\nPath exists between (0, 3) and (1, 2)\nPath exists between (0, 3) and (3, 3)\nPath exists between (0, 3) and (4, 4)\nPath exists between (0, 3) and (2, 1)\nPath exists between (2, 1) and (0, 0)\nPath exists between (2, 1) and (1, 2)\nPath exists between (2, 1) and (3, 3)\nPath exists between (2, 1) and (4, 4)\nPath exists between (2, 1) and (0, 3)\n"}]}
{"messages": [{"role": "user", "content": "def solve_puzzle(words, target):\n    puzzle = [list(word) for word in words]\n    target = list(target)\n    rows = len(puzzle)\n    cols = len(puzzle[0])\n    result = []\n\n    def search(row, col, direction, idx):\n        if idx == len(target):\n            return True\n        if (row < 0 or row >= rows or col < 0 or col >= cols or \n            puzzle[row][col] != target[idx]):\n            return False\n        next_row, next_col = row, col\n        if direction == \"right\":\n            next_col += 1\n        elif direction == \"down\":\n            next_row += 1\n        return search(next_row, next_col, direction, idx + 1)\n\n    for row in range(rows):\n        for col in range(cols):\n            if puzzle[row][col] == target[0]:\n                if search(row, col, \"right\", 0):\n                    result.append((row, col, \"right\"))\n                if search(row, col, \"down\", 0):\n                    result.append((row, col, \"down\"))\n\n    return result\n\nwords = [\n    \"game\",\n    \"play\",\n    \"aims\",\n    \"maze\"\n]\n\ntarget_word = \"game\"\nsolutions = solve_puzzle(words, target_word)\nfor solution in solutions:\n    print(f\"Found '{target_word}' starting at row {solution[0]}, col {solution[1]}, direction: {solution[2]}\")"}, {"role": "assistant", "content": "Found 'game' starting at row 0, col 0, direction: right\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef distance(point1, point2):\n    return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2)\n\ndef find_point_within_circle(circle_center, radius, points):\n    results = []\n    for point in points:\n        dist = distance(circle_center, point)\n        print(f\"Checking point {point}: Distance from center = {dist}\")\n        if dist <= radius:\n            results.append(point)\n            print(f\"Point {point} is within the circle.\")\n        else:\n            print(f\"Point {point} is outside the circle.\")\n    return results\n\ncircle_center = (5, 5)\nradius = 5\npoints = [(2, 3), (8, 8), (5, 10), (1, 1), (7, 4), (4, 5), (5, 4), (10, 10)]\n\npoints_within_circle = find_point_within_circle(circle_center, radius, points)\n\nprint(\"\\nPoints within the circle:\")\nfor point in points_within_circle:\n    print(point)"}, {"role": "assistant", "content": "Checking point (2, 3): Distance from center = 3.605551275463989\nPoint (2, 3) is within the circle.\nChecking point (8, 8): Distance from center = 4.242640687119285\nPoint (8, 8) is within the circle.\nChecking point (5, 10): Distance from center = 5.0\nPoint (5, 10) is within the circle.\nChecking point (1, 1): Distance from center = 5.656854249492381\nPoint (1, 1) is outside the circle.\nChecking point (7, 4): Distance from center = 2.23606797749979\nPoint (7, 4) is within the circle.\nChecking point (4, 5): Distance from center = 1.0\nPoint (4, 5) is within the circle.\nChecking point (5, 4): Distance from center = 1.0\nPoint (5, 4) is within the circle.\nChecking point (10, 10): Distance from center = 7.0710678118654755\nPoint (10, 10) is outside the circle.\n\nPoints within the circle:\n(2, 3)\n(8, 8)\n(5, 10)\n(7, 4)\n(4, 5)\n(5, 4)\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndata = [\n    2.5, 3.6, 5.1, 7.2, 8.0, 2.8, 4.9, 6.4, 9.1, 1.7,\n    3.2, 5.5, 7.7, 8.9, 2.3, 4.4, 6.6, 9.8, 1.2, 3.3,\n    5.0, 7.0, 8.2, 2.9, 4.5, 6.8, 9.5, 1.0, 3.0, 5.6\n]\n\ndef mean(data):\n    return sum(data) / len(data)\n\ndef variance(data, mean):\n    return sum((x - mean) ** 2 for x in data) / len(data)\n\ndef standard_deviation(data, mean):\n    return math.sqrt(variance(data, mean))\n\ndef z_score(value, mean, std_dev):\n    return (value - mean) / std_dev\n\nmean_value = mean(data)\nstd_dev_value = standard_deviation(data, mean_value)\n\nz_scores = [z_score(x, mean_value, std_dev_value) for x in data]\n\nthreshold = 1.5\noutliers = [x for x, z in zip(data, z_scores) if abs(z) > threshold]\n\noutliers.sort()\n\nfor outlier in outliers:\n    print(f\"Outlier: {outlier:.2f}\")"}, {"role": "assistant", "content": "Outlier: 1.00\nOutlier: 1.20\nOutlier: 9.10\nOutlier: 9.50\nOutlier: 9.80\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef generate_dates(start_date, num_days):\n    return [start_date + timedelta(days=i) for i in range(num_days)]\n\ndef sort_dates_by_day_of_week(dates):\n    return sorted(dates, key=lambda date: date.weekday())\n\ndef main():\n    start_date = datetime(2023, 1, 1)  # Starting from January 1, 2023\n    num_days = 50  # Total number of days to generate\n    dates = generate_dates(start_date, num_days)\n    \n    print(\"Generated Dates:\")\n    for date in dates:\n        print(date.strftime(\"%Y-%m-%d %A\"))\n    \n    sorted_dates = sort_dates_by_day_of_week(dates)\n    \n    print(\"\\nSorted Dates by Day of Week:\")\n    for date in sorted_dates:\n        print(date.strftime(\"%Y-%m-%d %A\"))\n\nif __name__ == \"__main__\":\n    main()"}, {"role": "assistant", "content": "Generated Dates:\n2023-01-01 Sunday\n2023-01-02 Monday\n2023-01-03 Tuesday\n2023-01-04 Wednesday\n2023-01-05 Thursday\n2023-01-06 Friday\n2023-01-07 Saturday\n2023-01-08 Sunday\n2023-01-09 Monday\n2023-01-10 Tuesday\n2023-01-11 Wednesday\n2023-01-12 Thursday\n2023-01-13 Friday\n2023-01-14 Saturday\n2023-01-15 Sunday\n2023-01-16 Monday\n2023-01-17 Tuesday\n2023-01-18 Wednesday\n2023-01-19 Thursday\n2023-01-20 Friday\n2023-01-21 Saturday\n2023-01-22 Sunday\n2023-01-23 Monday\n2023-01-24 Tuesday\n2023-01-25 Wednesday\n2023-01-26 Thursday\n2023-01-27 Friday\n2023-01-28 Saturday\n2023-01-29 Sunday\n2023-01-30 Monday\n2023-01-31 Tuesday\n2023-02-01 Wednesday\n2023-02-02 Thursday\n2023-02-03 Friday\n2023-02-04 Saturday\n2023-02-05 Sunday\n2023-02-06 Monday\n2023-02-07 Tuesday\n2023-02-08 Wednesday\n2023-02-09 Thursday\n2023-02-10 Friday\n2023-02-11 Saturday\n2023-02-12 Sunday\n2023-02-13 Monday\n2023-02-14 Tuesday\n2023-02-15 Wednesday\n2023-02-16 Thursday\n2023-02-17 Friday\n2023-02-18 Saturday\n2023-02-19 Sunday\n\nSorted Dates by Day of Week:\n2023-01-02 Monday\n2023-01-09 Monday\n2023-01-16 Monday\n2023-01-23 Monday\n2023-01-30 Monday\n2023-02-06 Monday\n2023-02-13 Monday\n2023-01-03 Tuesday\n2023-01-10 Tuesday\n2023-01-17 Tuesday\n2023-01-24 Tuesday\n2023-01-31 Tuesday\n2023-02-07 Tuesday\n2023-02-14 Tuesday\n2023-01-04 Wednesday\n2023-01-11 Wednesday\n2023-01-18 Wednesday\n2023-01-25 Wednesday\n2023-02-01 Wednesday\n2023-02-08 Wednesday\n2023-02-15 Wednesday\n2023-01-05 Thursday\n2023-01-12 Thursday\n2023-01-19 Thursday\n2023-01-26 Thursday\n2023-02-02 Thursday\n2023-02-09 Thursday\n2023-02-16 Thursday\n2023-01-06 Friday\n2023-01-13 Friday\n2023-01-20 Friday\n2023-01-27 Friday\n2023-02-03 Friday\n2023-02-10 Friday\n2023-02-17 Friday\n2023-01-07 Saturday\n2023-01-14 Saturday\n2023-01-21 Saturday\n2023-01-28 Saturday\n2023-02-04 Saturday\n2023-02-11 Saturday\n2023-02-18 Saturday\n2023-01-01 Sunday\n2023-01-08 Sunday\n2023-01-15 Sunday\n2023-01-22 Sunday\n2023-01-29 Sunday\n2023-02-05 Sunday\n2023-02-12 Sunday\n2023-02-19 Sunday\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef sort_dates_and_times(date_time_strs):\n    date_times = [datetime.datetime.strptime(d, \"%Y-%m-%d %H:%M:%S\") for d in date_time_strs]\n    sorted_date_times = sorted(date_times, key=lambda x: x.time())\n    return [dt.strftime(\"%Y-%m-%d %H:%M:%S\") for dt in sorted_date_times]\n\ndate_time_list = [\n    \"2023-01-01 12:30:00\", \"2023-01-01 08:45:00\", \"2023-01-01 18:00:00\",\n    \"2023-01-01 06:22:00\", \"2023-01-01 22:10:00\", \"2023-01-01 14:45:00\",\n    \"2023-01-01 09:15:00\", \"2023-01-01 23:59:00\", \"2023-01-01 00:01:00\",\n    \"2023-01-01 16:30:00\", \"2023-01-01 05:59:00\", \"2023-01-01 11:11:00\",\n    \"2023-01-01 10:10:00\", \"2023-01-01 19:19:00\", \"2023-01-01 13:13:00\",\n    \"2023-01-01 07:07:00\", \"2023-01-01 17:17:00\", \"2023-01-01 03:03:00\",\n    \"2023-01-01 02:02:00\", \"2023-01-01 01:01:00\"\n]\n\nsorted_dates = sort_dates_and_times(date_time_list)\nfor date in sorted_dates:\n    print(date)"}, {"role": "assistant", "content": "2023-01-01 00:01:00\n2023-01-01 01:01:00\n2023-01-01 02:02:00\n2023-01-01 03:03:00\n2023-01-01 05:59:00\n2023-01-01 06:22:00\n2023-01-01 07:07:00\n2023-01-01 08:45:00\n2023-01-01 09:15:00\n2023-01-01 10:10:00\n2023-01-01 11:11:00\n2023-01-01 12:30:00\n2023-01-01 13:13:00\n2023-01-01 14:45:00\n2023-01-01 16:30:00\n2023-01-01 17:17:00\n2023-01-01 18:00:00\n2023-01-01 19:19:00\n2023-01-01 22:10:00\n2023-01-01 23:59:00\n"}]}
{"messages": [{"role": "user", "content": "from math import exp, sqrt, pi\nfrom statistics import mean, median\n\ndef gaussian(x, mu, sigma):\n    return (1 / (sigma * sqrt(2 * pi))) * exp(-0.5 * ((x - mu) / sigma) ** 2)\n\ndef calculate_probability_density(data):\n    mu = mean(data)\n    sigma = sqrt(mean([(x - mu) ** 2 for x in data]))\n    return [gaussian(x, mu, sigma) for x in data]\n\ndef sort_by_density(data, densities):\n    combined = list(zip(data, densities))\n    combined.sort(key=lambda x: x[1])\n    sorted_data, sorted_densities = zip(*combined)\n    return list(sorted_data), list(sorted_densities)\n\ndata = [15, 21, 22, 24, 15, 15, 24, 29, 30, 21, 22, 31, 32, 29, 15, 30, 22, 24, 30, 31]\nprobability_densities = calculate_probability_density(data)\nsorted_data, sorted_densities = sort_by_density(data, probability_densities)\n\nfor d, p in zip(sorted_data, sorted_densities):\n    print(f\"Value: {d}, Density: {p:.5f}\")"}, {"role": "assistant", "content": "Value: 15, Density: 0.02011\nValue: 15, Density: 0.02011\nValue: 15, Density: 0.02011\nValue: 15, Density: 0.02011\nValue: 32, Density: 0.02722\nValue: 31, Density: 0.03391\nValue: 31, Density: 0.03391\nValue: 30, Density: 0.04100\nValue: 30, Density: 0.04100\nValue: 30, Density: 0.04100\nValue: 29, Density: 0.04813\nValue: 29, Density: 0.04813\nValue: 21, Density: 0.05960\nValue: 21, Density: 0.05960\nValue: 22, Density: 0.06438\nValue: 22, Density: 0.06438\nValue: 22, Density: 0.06438\nValue: 24, Density: 0.06872\nValue: 24, Density: 0.06872\nValue: 24, Density: 0.06872\n"}]}
{"messages": [{"role": "user", "content": "from math import sqrt\n\ndef is_perfect_square(x):\n    s = int(sqrt(x))\n    return s * s == x\n\ndef is_fibonacci(n):\n    return is_perfect_square(5 * n * n + 4) or is_perfect_square(5 * n * n - 4)\n\ndef find_fibonacci_in_arithmetic_sequence(a, d, limit):\n    sequence = [a + i * d for i in range(limit)]\n    print(\"Arithmetic Sequence:\", sequence)\n    fib_numbers = []\n    for num in sequence:\n        print(f\"Checking if {num} is a Fibonacci number...\")\n        if is_fibonacci(num):\n            print(f\"Found Fibonacci number: {num}\")\n            fib_numbers.append(num)\n    return fib_numbers\n\na = 3\nd = 7\nlimit = 30\nfibonacci_in_sequence = find_fibonacci_in_arithmetic_sequence(a, d, limit)\nprint(\"Fibonacci numbers in the sequence:\", fibonacci_in_sequence)"}, {"role": "assistant", "content": "Arithmetic Sequence: [3, 10, 17, 24, 31, 38, 45, 52, 59, 66, 73, 80, 87, 94, 101, 108, 115, 122, 129, 136, 143, 150, 157, 164, 171, 178, 185, 192, 199, 206]\nChecking if 3 is a Fibonacci number...\nFound Fibonacci number: 3\nChecking if 10 is a Fibonacci number...\nChecking if 17 is a Fibonacci number...\nChecking if 24 is a Fibonacci number...\nChecking if 31 is a Fibonacci number...\nChecking if 38 is a Fibonacci number...\nChecking if 45 is a Fibonacci number...\nChecking if 52 is a Fibonacci number...\nChecking if 59 is a Fibonacci number...\nChecking if 66 is a Fibonacci number...\nChecking if 73 is a Fibonacci number...\nChecking if 80 is a Fibonacci number...\nChecking if 87 is a Fibonacci number...\nChecking if 94 is a Fibonacci number...\nChecking if 101 is a Fibonacci number...\nChecking if 108 is a Fibonacci number...\nChecking if 115 is a Fibonacci number...\nChecking if 122 is a Fibonacci number...\nChecking if 129 is a Fibonacci number...\nChecking if 136 is a Fibonacci number...\nChecking if 143 is a Fibonacci number...\nChecking if 150 is a Fibonacci number...\nChecking if 157 is a Fibonacci number...\nChecking if 164 is a Fibonacci number...\nChecking if 171 is a Fibonacci number...\nChecking if 178 is a Fibonacci number...\nChecking if 185 is a Fibonacci number...\nChecking if 192 is a Fibonacci number...\nChecking if 199 is a Fibonacci number...\nChecking if 206 is a Fibonacci number...\nFibonacci numbers in the sequence: [3]\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef find_next_friday_13th(start_date):\n    fridays_13th = []\n    current_date = start_date\n\n    while len(fridays_13th) < 10:\n        if current_date.day == 13 and current_date.weekday() == 4:\n            fridays_13th.append(current_date)\n            print(f\"Found Friday 13th: {current_date.strftime('%Y-%m-%d')}\")\n        current_date += timedelta(days=1)\n    \n    return fridays_13th\n\nstart_date = datetime(year=2023, month=1, day=1)\nfridays_13th = find_next_friday_13th(start_date)\n\nfor date in fridays_13th:\n    print(date.strftime('%A, %B %d, %Y'))"}, {"role": "assistant", "content": "Found Friday 13th: 2023-01-13\nFound Friday 13th: 2023-10-13\nFound Friday 13th: 2024-09-13\nFound Friday 13th: 2024-12-13\nFound Friday 13th: 2025-06-13\nFound Friday 13th: 2026-02-13\nFound Friday 13th: 2026-03-13\nFound Friday 13th: 2026-11-13\nFound Friday 13th: 2027-08-13\nFound Friday 13th: 2028-10-13\nFriday, January 13, 2023\nFriday, October 13, 2023\nFriday, September 13, 2024\nFriday, December 13, 2024\nFriday, June 13, 2025\nFriday, February 13, 2026\nFriday, March 13, 2026\nFriday, November 13, 2026\nFriday, August 13, 2027\nFriday, October 13, 2028\n"}]}
{"messages": [{"role": "user", "content": "def create_pattern(n):\n    pattern = []\n    for i in range(1, n + 1):\n        pattern.append(' '.join(str(x) for x in range(1, i + 1)))\n    return pattern\n\ndef sort_pattern(pattern):\n    return sorted(pattern, key=lambda x: (len(x), x))\n\ndef main():\n    n = 10\n    pattern = create_pattern(n)\n    sorted_pattern = sort_pattern(pattern)\n    \n    for line in sorted_pattern:\n        print(line)\n\nmain()"}, {"role": "assistant", "content": "1\n1 2\n1 2 3\n1 2 3 4\n1 2 3 4 5\n1 2 3 4 5 6\n1 2 3 4 5 6 7\n1 2 3 4 5 6 7 8\n1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9 10\n"}]}
{"messages": [{"role": "user", "content": "def encrypt_message(message):\n    sorted_message = sorted(message)\n    shifted_message = []\n    for char in sorted_message:\n        shifted_message.append(chr((ord(char) + 3) % 256))\n    return ''.join(shifted_message)\n\nmessage = \"EncryptionTest\"\nencrypted_message = encrypt_message(message)\n\ndef decrypt_message(encrypted_message):\n    sorted_encrypted = sorted(encrypted_message)\n    original_message = []\n    for char in sorted_encrypted:\n        original_message.append(chr((ord(char) - 3) % 256))\n    return ''.join(original_message)\n\ndecrypted_message = decrypt_message(encrypted_message)\n\nprint(\"Original Message:\", message)\nprint(\"Encrypted Message:\", encrypted_message)\nprint(\"Decrypted Message:\", decrypted_message)"}, {"role": "assistant", "content": "Original Message: EncryptionTest\nEncrypted Message: HWfhlqqrsuvww|\nDecrypted Message: ETceinnoprstty\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef is_point_in_circle(x, y, cx, cy, r):\n    return (x - cx) ** 2 + (y - cy) ** 2 <= r ** 2\n\ndef binary_search_radius(points, cx, cy):\n    low, high = 0, max(\n        math.sqrt((x - cx) ** 2 + (y - cy) ** 2) for x, y in points\n    )\n    best_radius = high\n\n    while high - low > 1e-6:\n        mid = (low + high) / 2\n        if all(is_point_in_circle(x, y, cx, cy, mid) for x, y in points):\n            best_radius = mid\n            high = mid\n        else:\n            low = mid\n\n        print(f\"Low: {low:.6f}, High: {high:.6f}, Mid: {mid:.6f}, Radius: {best_radius:.6f}\")\n\n    return best_radius\n\npoints = [\n    (1, 2), (2, 1), (3, 3), (5, 1),\n    (4, 4), (6, 3), (7, 5), (8, 6),\n    (5, 7), (3, 8), (9, 9), (10, 10)\n]\n\ncx, cy = 5, 5\nradius = binary_search_radius(points, cx, cy)\nprint(f\"Minimum enclosing circle radius: {radius:.6f}\")"}, {"role": "assistant", "content": "Low: 3.535534, High: 7.071068, Mid: 3.535534, Radius: 7.071068\nLow: 5.303301, High: 7.071068, Mid: 5.303301, Radius: 7.071068\nLow: 6.187184, High: 7.071068, Mid: 6.187184, Radius: 7.071068\nLow: 6.629126, High: 7.071068, Mid: 6.629126, Radius: 7.071068\nLow: 6.850097, High: 7.071068, Mid: 6.850097, Radius: 7.071068\nLow: 6.960582, High: 7.071068, Mid: 6.960582, Radius: 7.071068\nLow: 7.015825, High: 7.071068, Mid: 7.015825, Radius: 7.071068\nLow: 7.043446, High: 7.071068, Mid: 7.043446, Radius: 7.071068\nLow: 7.057257, High: 7.071068, Mid: 7.057257, Radius: 7.071068\nLow: 7.064162, High: 7.071068, Mid: 7.064162, Radius: 7.071068\nLow: 7.067615, High: 7.071068, Mid: 7.067615, Radius: 7.071068\nLow: 7.069341, High: 7.071068, Mid: 7.069341, Radius: 7.071068\nLow: 7.070205, High: 7.071068, Mid: 7.070205, Radius: 7.071068\nLow: 7.070636, High: 7.071068, Mid: 7.070636, Radius: 7.071068\nLow: 7.070852, High: 7.071068, Mid: 7.070852, Radius: 7.071068\nLow: 7.070960, High: 7.071068, Mid: 7.070960, Radius: 7.071068\nLow: 7.071014, High: 7.071068, Mid: 7.071014, Radius: 7.071068\nLow: 7.071041, High: 7.071068, Mid: 7.071041, Radius: 7.071068\nLow: 7.071054, High: 7.071068, Mid: 7.071054, Radius: 7.071068\nLow: 7.071061, High: 7.071068, Mid: 7.071061, Radius: 7.071068\nLow: 7.071064, High: 7.071068, Mid: 7.071064, Radius: 7.071068\nLow: 7.071066, High: 7.071068, Mid: 7.071066, Radius: 7.071068\nLow: 7.071067, High: 7.071068, Mid: 7.071067, Radius: 7.071068\nMinimum enclosing circle radius: 7.071068\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef complex_transformation(lst):\n    return [math.sin(x) * math.cos(x) + math.tan(x) for x in lst]\n\ndef is_transformed_sorted(transformed):\n    return all(transformed[i] <= transformed[i + 1] for i in range(len(transformed) - 1))\n\ndef find_unsorted_subarray(transformed):\n    n = len(transformed)\n    start, end = 0, n - 1\n    while start < n - 1 and transformed[start] <= transformed[start + 1]:\n        start += 1\n    if start == n - 1:\n        return 0, 0\n    while end > 0 and transformed[end] >= transformed[end - 1]:\n        end -= 1\n    sub_min = min(transformed[start:end + 1])\n    sub_max = max(transformed[start:end + 1])\n    while start > 0 and transformed[start - 1] > sub_min:\n        start -= 1\n    while end < n - 1 and transformed[end + 1] < sub_max:\n        end += 1\n    return start, end\n\noriginal_data = [0.2 * i for i in range(1, 101)]\ntransformed_data = complex_transformation(original_data)\nif not is_transformed_sorted(transformed_data):\n    start, end = find_unsorted_subarray(transformed_data)\n    result = transformed_data[start:end + 1]\nelse:\n    result = transformed_data\n\nfor value in result:\n    print(f\"{value:.4f}\")"}, {"role": "assistant", "content": "0.3974\n0.7815\n1.1502\n1.5294\n2.0121\n2.9099\n5.9654\n-34.2617\n-4.5075\n-2.5634\n-1.8496\n-1.4141\n-1.0433\n-0.6712\n-0.2823\n0.1167\n0.5114\n0.8903\n1.2575\n1.6525\n2.2051\n3.3888\n8.9716\n-11.4720\n-3.6525\n-2.2996\n-1.7080\n-1.3035\n-0.9361\n-0.5593\n-0.1662\n0.2331\n0.6239\n0.9979\n1.3668\n1.7874\n2.4434\n4.0955\n18.5607\n-6.9437\n-3.0928\n-2.0895\n-1.5805\n-1.1956\n-0.8278\n-0.4459\n-0.0496\n0.3487\n0.7349\n1.1048\n1.4797\n1.9401\n2.7503\n5.2384\n-225.9553\n-5.0222\n-2.6981\n-1.9155\n-1.4623\n-1.0886\n-0.7181\n-0.3312\n0.0672\n0.4632\n0.8443\n1.2118\n1.5991\n2.1187\n3.1648\n7.3801\n-15.9569\n-3.9676\n-2.4036\n-1.7660\n-1.3500\n-0.9817\n-0.6069\n-0.2155\n0.1838\n0.5763\n0.9524\n1.3201\n1.7284\n2.3355\n3.7585\n12.7490\n-8.3277\n-3.3047\n-2.1734\n-1.6332\n-1.2412\n-0.8739\n-0.4942\n-0.0991\n0.2998\n0.6880\n1.0595\n1.4312\n1.8727\n2.6097\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef encode_message(message, shift):\n    encoded = []\n    for char in message:\n        if char.isalpha():\n            shift_amount = shift if char.islower() else -shift\n            new_char = chr((ord(char) + shift_amount - 97) % 26 + 97)\n            encoded.append(new_char)\n        else:\n            encoded.append(char)\n    return ''.join(encoded)\n\ndef search_for_pattern(encoded_message, pattern):\n    matches = re.findall(pattern, encoded_message)\n    return matches\n\nmessage = \"The quick brown fox jumps over the lazy dog\"\nshift = 5\npattern = r'[aeiou]'\n\nencoded_message = encode_message(message, shift)\nfound_patterns = search_for_pattern(encoded_message, pattern)\n\nprint(f\"Encoded Message: {encoded_message}\")\nprint(f\"Found Patterns: {found_patterns}\")"}, {"role": "assistant", "content": "Encoded Message: imj vznhp gwtbs ktc ozrux tajw ymj qfed itl\nFound Patterns: ['i', 'o', 'u', 'a', 'e', 'i']\n"}]}
{"messages": [{"role": "user", "content": "def is_fibonacci(num):\n    x, y = 0, 1\n    while x < num:\n        x, y = y, x + y\n    return x == num\n\ndef fibonacci_search(arr, x):\n    fib_m2 = 0\n    fib_m1 = 1\n    fib_m = fib_m2 + fib_m1\n    while fib_m < len(arr):\n        fib_m2 = fib_m1\n        fib_m1 = fib_m\n        fib_m = fib_m2 + fib_m1\n    offset = -1\n    while fib_m > 1:\n        i = min(offset + fib_m2, len(arr) - 1)\n        if arr[i] < x:\n            fib_m = fib_m1\n            fib_m1 = fib_m2\n            fib_m2 = fib_m - fib_m1\n            offset = i\n        elif arr[i] > x:\n            fib_m = fib_m2\n            fib_m1 = fib_m1 - fib_m2\n            fib_m2 = fib_m - fib_m1\n        else:\n            return i\n    if fib_m1 and arr[offset + 1] == x:\n        return offset + 1\n    return -1\n\nsequence = [i for i in range(1, 101) if is_fibonacci(i)]\ntargets = [3, 8, 21, 34, 55, 89, 144, 233, 377, 610]\n\nfor num in targets:\n    index = fibonacci_search(sequence, num)\n    if index != -1:\n        print(f\"Fibonacci number {num} found at index {index}\")\n    else:\n        print(f\"Fibonacci number {num} not found in the sequence\")"}, {"role": "assistant", "content": "Traceback (most recent call last):\n  File \"<string>\", line 37, in <module>\n  File \"<string>\", line 29, in fibonacci_search\nIndexError: list index out of range\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"\nIn a village of La Mancha, the name of which I have no desire to call to mind,\nthere lived not long since one of those gentlemen that keep a lance in the lance-rack,\nan old buckler, a lean hack, and a greyhound for coursing.\n\"\"\"\n\npattern = r'\\b[a-zA-Z]{5}\\b'\nmatches = re.findall(pattern, text)\n\nprint(\"Words with exactly 5 letters:\")\nprint(matches)\n\ndef binary_search(lst, target):\n    low, high = 0, len(lst) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        print(f\"Searching between {low} and {high}, middle: {mid}\")\n        if lst[mid] == target:\n            print(f\"Found target '{target}' at index {mid}\")\n            return mid\n        elif lst[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    print(f\"Target '{target}' not found\")\n    return -1\n\nsorted_matches = sorted(matches)\nprint(\"\\nSorted words with 5 letters:\")\nprint(sorted_matches)\n\nsearch_word = \"lived\"\nprint(f\"\\nSearching for the word '{search_word}':\")\nindex = binary_search(sorted_matches, search_word)\n\nsearch_word = \"lance\"\nprint(f\"\\nSearching for the word '{search_word}':\")\nindex = binary_search(sorted_matches, search_word)"}, {"role": "assistant", "content": "Words with exactly 5 letters:\n['which', 'there', 'lived', 'since', 'those', 'lance', 'lance']\n\nSorted words with 5 letters:\n['lance', 'lance', 'lived', 'since', 'there', 'those', 'which']\n\nSearching for the word 'lived':\nSearching between 0 and 6, middle: 3\nSearching between 0 and 2, middle: 1\nSearching between 2 and 2, middle: 2\nFound target 'lived' at index 2\n\nSearching for the word 'lance':\nSearching between 0 and 6, middle: 3\nSearching between 0 and 2, middle: 1\nFound target 'lance' at index 1\n"}]}
{"messages": [{"role": "user", "content": "import re\nfrom datetime import datetime\n\ndef find_longest_word_with_vowel(text):\n    words = re.findall(r'\\b\\w+\\b', text)\n    longest_word = ''\n    \n    def has_vowel(word):\n        return any(c in \"aeiou\" for c in word)\n    \n    for word in words:\n        print(f\"Checking word: {word}\")\n        if has_vowel(word):\n            print(f\"Word has vowel: {word}\")\n            if len(word) > len(longest_word):\n                print(f\"New longest word found: {word}\")\n                longest_word = word\n\n    return longest_word\n\ntext_data = \"\"\"\nThe quick brown fox jumps over the lazy dog. Lorem ipsum dolor sit amet, consectetur \nadipiscing elit. Phasellus imperdiet, nulla et dictum interdum, nisi lorem egestas odio, \nvitae scelerisque enim ligula venenatis dolor. Maecenas nisl est, ultrices nec congue eget.\n\"\"\"\n\nstart_time = datetime.now()\nlongest_word = find_longest_word_with_vowel(text_data)\nend_time = datetime.now()\n\nprint(\"\\nFinal longest word:\", longest_word)\nprint(\"Time taken:\", end_time - start_time)"}, {"role": "assistant", "content": "Checking word: The\nWord has vowel: The\nNew longest word found: The\nChecking word: quick\nWord has vowel: quick\nNew longest word found: quick\nChecking word: brown\nWord has vowel: brown\nChecking word: fox\nWord has vowel: fox\nChecking word: jumps\nWord has vowel: jumps\nChecking word: over\nWord has vowel: over\nChecking word: the\nWord has vowel: the\nChecking word: lazy\nWord has vowel: lazy\nChecking word: dog\nWord has vowel: dog\nChecking word: Lorem\nWord has vowel: Lorem\nChecking word: ipsum\nWord has vowel: ipsum\nChecking word: dolor\nWord has vowel: dolor\nChecking word: sit\nWord has vowel: sit\nChecking word: amet\nWord has vowel: amet\nChecking word: consectetur\nWord has vowel: consectetur\nNew longest word found: consectetur\nChecking word: adipiscing\nWord has vowel: adipiscing\nChecking word: elit\nWord has vowel: elit\nChecking word: Phasellus\nWord has vowel: Phasellus\nChecking word: imperdiet\nWord has vowel: imperdiet\nChecking word: nulla\nWord has vowel: nulla\nChecking word: et\nWord has vowel: et\nChecking word: dictum\nWord has vowel: dictum\nChecking word: interdum\nWord has vowel: interdum\nChecking word: nisi\nWord has vowel: nisi\nChecking word: lorem\nWord has vowel: lorem\nChecking word: egestas\nWord has vowel: egestas\nChecking word: odio\nWord has vowel: odio\nChecking word: vitae\nWord has vowel: vitae\nChecking word: scelerisque\nWord has vowel: scelerisque\nChecking word: enim\nWord has vowel: enim\nChecking word: ligula\nWord has vowel: ligula\nChecking word: venenatis\nWord has vowel: venenatis\nChecking word: dolor\nWord has vowel: dolor\nChecking word: Maecenas\nWord has vowel: Maecenas\nChecking word: nisl\nWord has vowel: nisl\nChecking word: est\nWord has vowel: est\nChecking word: ultrices\nWord has vowel: ultrices\nChecking word: nec\nWord has vowel: nec\nChecking word: congue\nWord has vowel: congue\nChecking word: eget\nWord has vowel: eget\n\nFinal longest word: consectetur\nTime taken: 0:00:00.000114\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef find_saturdays(start_year, end_year):\n    current_date = datetime(start_year, 1, 1)\n    end_date = datetime(end_year, 12, 31)\n    saturdays = []\n\n    while current_date <= end_date:\n        if current_date.weekday() == 5:\n            saturdays.append(current_date)\n        current_date += timedelta(days=1)\n\n    return saturdays\n\ndef is_palindrome(date_str):\n    return date_str == date_str[::-1]\n\ndef search_palindrome_saturdays(start_year, end_year):\n    saturdays = find_saturdays(start_year, end_year)\n    palindrome_saturdays = []\n\n    for saturday in saturdays:\n        date_str = saturday.strftime('%Y%m%d')\n        if is_palindrome(date_str):\n            palindrome_saturdays.append(date_str)\n            print(f\"Found palindrome Saturday: {saturday} -> {date_str}\")\n\n    return palindrome_saturdays\n\nstart_year = 2000\nend_year = 2100\npalindrome_saturdays = search_palindrome_saturdays(start_year, end_year)\n\nprint(f\"Total Palindrome Saturdays between {start_year} and {end_year}: {len(palindrome_saturdays)}\")\nprint(\"Palindrome Saturdays:\")\nfor date in palindrome_saturdays:\n    print(date)"}, {"role": "assistant", "content": "Found palindrome Saturday: 2010-01-02 00:00:00 -> 20100102\nFound palindrome Saturday: 2030-03-02 00:00:00 -> 20300302\nFound palindrome Saturday: 2090-09-02 00:00:00 -> 20900902\nTotal Palindrome Saturdays between 2000 and 2100: 3\nPalindrome Saturdays:\n20100102\n20300302\n20900902\n"}]}
{"messages": [{"role": "user", "content": "def distinct_substring_patterns(s, length):\n    patterns = set()\n    for i in range(len(s) - length + 1):\n        patterns.add(s[i:i + length])\n    return patterns\n\ndef find_pattern_occurrence(main_string, pattern_length):\n    def search_for_patterns(search_space, pattern_length):\n        occurrences = {}\n        for substring in distinct_substring_patterns(search_space, pattern_length):\n            pos = -1\n            occurrence = []\n            while True:\n                pos = search_space.find(substring, pos + 1)\n                if pos == -1:\n                    break\n                occurrence.append(pos)\n            if len(occurrence) > 1:\n                occurrences[substring] = occurrence\n        return occurrences\n\n    return search_for_patterns(main_string, pattern_length)\n\nstring = \"abacabadabacaba\"\npattern_length = 3\npattern_occurrences = find_pattern_occurrence(string, pattern_length)\n\nfor pattern, positions in pattern_occurrences.items():\n    print(f\"Pattern '{pattern}' found at positions: {positions}\")"}, {"role": "assistant", "content": "Pattern 'bac' found at positions: [1, 9]\nPattern 'aba' found at positions: [0, 4, 8, 12]\nPattern 'aca' found at positions: [2, 10]\nPattern 'cab' found at positions: [3, 11]\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef get_prime_factors(n):\n    factors = []\n    while n % 2 == 0:\n        factors.append(2)\n        n = n // 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            factors.append(i)\n            n = n // i\n    if n > 2:\n        factors.append(n)\n    return factors\n\ndef find_number_with_most_prime_factors(numbers):\n    max_factors = 0\n    number_with_max_factors = None\n    for number in numbers:\n        factors = get_prime_factors(number)\n        if len(factors) > max_factors:\n            max_factors = len(factors)\n            number_with_max_factors = number\n    return number_with_max_factors, max_factors\n\nnumbers = [1001, 1234, 5678, 91011, 121314, 151617, 181920, 212223, 242526, 272829]\nnumber, factor_count = find_number_with_most_prime_factors(numbers)\n\nprint(f\"Number with most prime factors: {number}\")\nprint(f\"Prime factors count: {factor_count}\")\nprint(\"Prime factors of each number:\")\nfor num in numbers:\n    print(f\"{num}: {get_prime_factors(num)}\")"}, {"role": "assistant", "content": "Number with most prime factors: 181920\nPrime factors count: 8\nPrime factors of each number:\n1001: [7, 11, 13]\n1234: [2, 617]\n5678: [2, 17, 167]\n91011: [3, 23, 1319]\n121314: [2, 3, 20219]\n151617: [3, 50539]\n181920: [2, 2, 2, 2, 2, 3, 5, 379]\n212223: [3, 11, 59, 109]\n242526: [2, 3, 83, 487]\n272829: [3, 199, 457]\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef is_perfect_square(n):\n    return int(math.isqrt(n))**2 == n\n\ndef generate_sequence(n):\n    sequence = []\n    for i in range(1, n + 1):\n        if is_perfect_square(i):\n            sequence.append(i)\n    return sequence\n\ndef incorrect_sort(sequence):\n    return sorted(sequence, key=lambda x: -x)\n\nn = 100\nsequence = generate_sequence(n)\nsorted_sequence = incorrect_sort(sequence)\n\nfor num in sorted_sequence:\n    print(num)"}, {"role": "assistant", "content": "100\n81\n64\n49\n36\n25\n16\n9\n4\n1\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef search_dates(dates, target_date):\n    left, right = 0, len(dates) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if dates[mid] == target_date:\n            return mid\n        elif dates[mid] < target_date:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef transform_dates(date_strings):\n    return [datetime.datetime.strptime(date, \"%Y-%m-%d\") for date in date_strings]\n\ndate_list = [\n    \"2023-01-01\", \"2023-01-05\", \"2023-02-14\", \"2023-03-20\", \"2023-04-25\",\n    \"2023-05-30\", \"2023-06-15\", \"2023-07-22\", \"2023-08-19\", \"2023-09-09\",\n    \"2023-10-01\", \"2023-11-11\", \"2023-12-31\"\n]\n\ntarget_date_str = \"2023-06-15\"\ntarget_date = datetime.datetime.strptime(target_date_str, \"%Y-%m-%d\")\n\ndates = transform_dates(date_list)\nindex = search_dates(dates, target_date)\n\noutput = [\"{} - Found\".format(date.strftime(\"%Y-%m-%d\")) if i == index else date.strftime(\"%Y-%m-%d\") for i, date in enumerate(dates)]\nfor line in output:\n    print(line)"}, {"role": "assistant", "content": "2023-01-01\n2023-01-05\n2023-02-14\n2023-03-20\n2023-04-25\n2023-05-30\n2023-06-15 - Found\n2023-07-22\n2023-08-19\n2023-09-09\n2023-10-01\n2023-11-11\n2023-12-31\n"}]}
{"messages": [{"role": "user", "content": "import re\nfrom datetime import datetime\n\ndef custom_sort_key(word):\n    vowels = 'aeiou'\n    vowel_count = sum(1 for char in word if char.lower() in vowels)\n    return (vowel_count, len(word), word.lower())\n\ntext = \"\"\"\nIn an ancient time, there existed a magical land called Eldoria. In Eldoria, the trees whispered secrets to the winds, and the rivers sang songs of forgotten ages. It was a place where dreams came alive, and every creature, big or small, had a story to tell.\n\"\"\"\n\nwords = re.findall(r'\\b\\w+\\b', text)\nprint(f\"Extracted words: {words}\")\n\nsorted_words = sorted(words, key=custom_sort_key)\nprint(\"Sorting words based on vowel count, length, and lexicographical order:\")\nfor word in sorted_words:\n    print(word)\n\ncurrent_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\nprint(f\"Sorting completed at: {current_time}\")"}, {"role": "assistant", "content": "Extracted words: ['In', 'an', 'ancient', 'time', 'there', 'existed', 'a', 'magical', 'land', 'called', 'Eldoria', 'In', 'Eldoria', 'the', 'trees', 'whispered', 'secrets', 'to', 'the', 'winds', 'and', 'the', 'rivers', 'sang', 'songs', 'of', 'forgotten', 'ages', 'It', 'was', 'a', 'place', 'where', 'dreams', 'came', 'alive', 'and', 'every', 'creature', 'big', 'or', 'small', 'had', 'a', 'story', 'to', 'tell']\nSorting words based on vowel count, length, and lexicographical order:\na\na\na\nan\nIn\nIn\nIt\nof\nor\nto\nto\nand\nand\nbig\nhad\nthe\nthe\nthe\nwas\nland\nsang\ntell\nsmall\nsongs\nstory\nwinds\nages\ncame\ntime\nevery\nplace\nthere\ntrees\nwhere\ncalled\ndreams\nrivers\nsecrets\nalive\nancient\nexisted\nmagical\nforgotten\nwhispered\nEldoria\nEldoria\ncreature\nSorting completed at: 2025-04-01 16:07:12\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndata = [\n    (datetime(2023, 1, 1) + timedelta(days=i), i % 5) for i in range(100)\n]\n\ndef linear_search(data, target_date):\n    for date, value in data:\n        if date == target_date:\n            return value\n    return None\n\ndef binary_search(data, target_date):\n    low, high = 0, len(data) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        mid_date = data[mid][0]\n        print(f\"Checking date: {mid_date}\")\n        if mid_date == target_date:\n            return data[mid][1]\n        elif mid_date < target_date:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return None\n\ntarget_date = datetime(2023, 1, 50)\nprint(\"Linear Search Result:\")\nprint(linear_search(data, target_date))\n\nprint(\"\\nBinary Search Result:\")\nprint(binary_search(data, target_date))\n\nprint(\"\\nData:\")\nfor entry in data:\n    print(entry)"}, {"role": "assistant", "content": "Traceback (most recent call last):\n  File \"<string>\", line 27, in <module>\nValueError: day is out of range for month\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef custom_sort(dates):\n    return sorted(dates, key=lambda date: (date.month, -date.day, date.year))\n\ndef generate_dates():\n    base_date = datetime(2023, 1, 1)\n    date_list = [base_date + timedelta(days=i*31 + j) for i in range(12) for j in range(15)]\n    return date_list\n\ndef format_dates(dates):\n    return [date.strftime(\"%Y-%m-%d\") for date in dates]\n\ndates = generate_dates()\nsorted_dates = custom_sort(dates)\nformatted_dates = format_dates(sorted_dates)\n\nfor date in formatted_dates:\n    print(date)"}, {"role": "assistant", "content": "2023-01-15\n2023-01-14\n2023-01-13\n2023-01-12\n2023-01-11\n2023-01-10\n2023-01-09\n2023-01-08\n2023-01-07\n2023-01-06\n2023-01-05\n2023-01-04\n2023-01-03\n2023-01-02\n2023-01-01\n2023-02-15\n2023-02-14\n2023-02-13\n2023-02-12\n2023-02-11\n2023-02-10\n2023-02-09\n2023-02-08\n2023-02-07\n2023-02-06\n2023-02-05\n2023-02-04\n2023-02-03\n2023-02-02\n2023-02-01\n2023-03-18\n2023-03-17\n2023-03-16\n2023-03-15\n2023-03-14\n2023-03-13\n2023-03-12\n2023-03-11\n2023-03-10\n2023-03-09\n2023-03-08\n2023-03-07\n2023-03-06\n2023-03-05\n2023-03-04\n2023-04-18\n2023-04-17\n2023-04-16\n2023-04-15\n2023-04-14\n2023-04-13\n2023-04-12\n2023-04-11\n2023-04-10\n2023-04-09\n2023-04-08\n2023-04-07\n2023-04-06\n2023-04-05\n2023-04-04\n2023-05-19\n2023-05-18\n2023-05-17\n2023-05-16\n2023-05-15\n2023-05-14\n2023-05-13\n2023-05-12\n2023-05-11\n2023-05-10\n2023-05-09\n2023-05-08\n2023-05-07\n2023-05-06\n2023-05-05\n2023-06-19\n2023-06-18\n2023-06-17\n2023-06-16\n2023-06-15\n2023-06-14\n2023-06-13\n2023-06-12\n2023-06-11\n2023-06-10\n2023-06-09\n2023-06-08\n2023-06-07\n2023-06-06\n2023-06-05\n2023-07-20\n2023-07-19\n2023-07-18\n2023-07-17\n2023-07-16\n2023-07-15\n2023-07-14\n2023-07-13\n2023-07-12\n2023-07-11\n2023-07-10\n2023-07-09\n2023-07-08\n2023-07-07\n2023-07-06\n2023-08-20\n2023-08-19\n2023-08-18\n2023-08-17\n2023-08-16\n2023-08-15\n2023-08-14\n2023-08-13\n2023-08-12\n2023-08-11\n2023-08-10\n2023-08-09\n2023-08-08\n2023-08-07\n2023-08-06\n2023-09-20\n2023-09-19\n2023-09-18\n2023-09-17\n2023-09-16\n2023-09-15\n2023-09-14\n2023-09-13\n2023-09-12\n2023-09-11\n2023-09-10\n2023-09-09\n2023-09-08\n2023-09-07\n2023-09-06\n2023-10-21\n2023-10-20\n2023-10-19\n2023-10-18\n2023-10-17\n2023-10-16\n2023-10-15\n2023-10-14\n2023-10-13\n2023-10-12\n2023-10-11\n2023-10-10\n2023-10-09\n2023-10-08\n2023-10-07\n2023-11-21\n2023-11-20\n2023-11-19\n2023-11-18\n2023-11-17\n2023-11-16\n2023-11-15\n2023-11-14\n2023-11-13\n2023-11-12\n2023-11-11\n2023-11-10\n2023-11-09\n2023-11-08\n2023-11-07\n2023-12-22\n2023-12-21\n2023-12-20\n2023-12-19\n2023-12-18\n2023-12-17\n2023-12-16\n2023-12-15\n2023-12-14\n2023-12-13\n2023-12-12\n2023-12-11\n2023-12-10\n2023-12-09\n2023-12-08\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef find_sundays(start_year, end_year, weekday_name):\n    weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n    if weekday_name not in weekdays:\n        return []\n\n    weekday_index = weekdays.index(weekday_name)\n    current_date = datetime(start_year, 1, 1)\n    end_date = datetime(end_year + 1, 1, 1)\n    results = []\n\n    while current_date < end_date:\n        if current_date.weekday() == weekday_index:\n            results.append(current_date.strftime('%Y-%m-%d'))\n        current_date += timedelta(days=1)\n    \n    return results\n\nsundays = find_sundays(2020, 2021, 'Sunday')\nfor sunday in sundays:\n    print(sunday)"}, {"role": "assistant", "content": "2020-01-05\n2020-01-12\n2020-01-19\n2020-01-26\n2020-02-02\n2020-02-09\n2020-02-16\n2020-02-23\n2020-03-01\n2020-03-08\n2020-03-15\n2020-03-22\n2020-03-29\n2020-04-05\n2020-04-12\n2020-04-19\n2020-04-26\n2020-05-03\n2020-05-10\n2020-05-17\n2020-05-24\n2020-05-31\n2020-06-07\n2020-06-14\n2020-06-21\n2020-06-28\n2020-07-05\n2020-07-12\n2020-07-19\n2020-07-26\n2020-08-02\n2020-08-09\n2020-08-16\n2020-08-23\n2020-08-30\n2020-09-06\n2020-09-13\n2020-09-20\n2020-09-27\n2020-10-04\n2020-10-11\n2020-10-18\n2020-10-25\n2020-11-01\n2020-11-08\n2020-11-15\n2020-11-22\n2020-11-29\n2020-12-06\n2020-12-13\n2020-12-20\n2020-12-27\n2021-01-03\n2021-01-10\n2021-01-17\n2021-01-24\n2021-01-31\n2021-02-07\n2021-02-14\n2021-02-21\n2021-02-28\n2021-03-07\n2021-03-14\n2021-03-21\n2021-03-28\n2021-04-04\n2021-04-11\n2021-04-18\n2021-04-25\n2021-05-02\n2021-05-09\n2021-05-16\n2021-05-23\n2021-05-30\n2021-06-06\n2021-06-13\n2021-06-20\n2021-06-27\n2021-07-04\n2021-07-11\n2021-07-18\n2021-07-25\n2021-08-01\n2021-08-08\n2021-08-15\n2021-08-22\n2021-08-29\n2021-09-05\n2021-09-12\n2021-09-19\n2021-09-26\n2021-10-03\n2021-10-10\n2021-10-17\n2021-10-24\n2021-10-31\n2021-11-07\n2021-11-14\n2021-11-21\n2021-11-28\n2021-12-05\n2021-12-12\n2021-12-19\n2021-12-26\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"\nSorting is an important algorithm in computer science.\nIt is used in various applications like searching, merging, and analyzing data.\nThere are different types of sorting algorithms: Bubble Sort, Insertion Sort, Selection Sort, Merge Sort, Quick Sort, etc.\nEach algorithm has its own merits and demerits.\nSome algorithms are more efficient, while others are easier to implement.\n\"\"\"\n\nwords = re.findall(r'\\b\\w+\\b', text.lower())\nunique_words = list(set(words))\nsorted_words = sorted(unique_words, key=lambda w: (len(w), w))\n\nfor word in sorted_words:\n    print(word)"}, {"role": "assistant", "content": "an\nin\nis\nit\nof\nto\nand\nare\netc\nhas\nits\nown\ndata\neach\nlike\nmore\nsome\nsort\nused\nmerge\nquick\nthere\ntypes\nwhile\nbubble\neasier\nmerits\nothers\nmerging\nscience\nsorting\nvarious\ncomputer\ndemerits\nalgorithm\nanalyzing\ndifferent\nefficient\nimplement\nimportant\ninsertion\nsearching\nselection\nalgorithms\napplications\n"}]}
{"messages": [{"role": "user", "content": "from statistics import mean\n\ndef selection_sort(arr):\n    for i in range(len(arr)):\n        min_index = i\n        for j in range(i+1, len(arr)):\n            if arr[min_index] > arr[j]:\n                min_index = j\n        arr[i], arr[min_index] = arr[min_index], arr[i]\n    return arr\n\ndata = [8, 3, 5, 12, 7, 9, 4, 15, 10, 6, 1, 11, 14, 13, 2]\nprint(\"Original data:\", data)\n\nsorted_data = selection_sort(data.copy())\nprint(\"Sorted data:\", sorted_data)\n\nmedian_index = len(sorted_data) // 2\nmedian = sorted_data[median_index] if len(sorted_data) % 2 != 0 else (sorted_data[median_index - 1] + sorted_data[median_index]) / 2\nprint(\"Median:\", median)\n\nmean_value = mean(sorted_data)\nprint(\"Mean:\", mean_value)\n\ndifferences_from_mean = [abs(x - mean_value) for x in sorted_data]\nprint(\"Differences from mean:\", differences_from_mean)\n\nsorted_differences = selection_sort(differences_from_mean)\nprint(\"Sorted differences from mean:\", sorted_differences)\n\nmost_common_difference = sorted_differences[len(sorted_differences) // 2]\nprint(\"Most common difference from mean:\", most_common_difference)\n\nfor i, diff in enumerate(sorted_differences):\n    print(f\"Index {i}: Difference {diff}\")"}, {"role": "assistant", "content": "Original data: [8, 3, 5, 12, 7, 9, 4, 15, 10, 6, 1, 11, 14, 13, 2]\nSorted data: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\nMedian: 8\nMean: 8\nDifferences from mean: [7, 6, 5, 4, 3, 2, 1, 0, 1, 2, 3, 4, 5, 6, 7]\nSorted differences from mean: [0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7]\nMost common difference from mean: 4\nIndex 0: Difference 0\nIndex 1: Difference 1\nIndex 2: Difference 1\nIndex 3: Difference 2\nIndex 4: Difference 2\nIndex 5: Difference 3\nIndex 6: Difference 3\nIndex 7: Difference 4\nIndex 8: Difference 4\nIndex 9: Difference 5\nIndex 10: Difference 5\nIndex 11: Difference 6\nIndex 12: Difference 6\nIndex 13: Difference 7\nIndex 14: Difference 7\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndata_points = [\n    15, 21, 11, 29, 23, 19, 18, 22, 17, 28,\n    24, 16, 20, 25, 13, 12, 14, 27, 30, 26\n]\n\ndef calculate_variance(data):\n    mean = sum(data) / len(data)\n    return sum((x - mean) ** 2 for x in data) / len(data)\n\ndef binary_search(sorted_data, target, tolerance=0.01):\n    left, right = 0, len(sorted_data) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        mid_value = sorted_data[mid]\n        if math.isclose(mid_value, target, abs_tol=tolerance):\n            return mid\n        elif mid_value < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\nmean_value = sum(data_points) / len(data_points)\nvariance = calculate_variance(data_points)\n\nsorted_data = sorted(data_points)\nstd_deviation = math.sqrt(variance)\n\nsearch_value = mean_value + std_deviation\nindex_of_search_value = binary_search(sorted_data, search_value)\n\nprint(\"Data Points:\", data_points)\nprint(\"Sorted Data Points:\", sorted_data)\nprint(\"Mean:\", mean_value)\nprint(\"Variance:\", variance)\nprint(\"Standard Deviation:\", std_deviation)\nprint(\"Search Value (Mean + Std Dev):\", search_value)\nprint(\"Index of Search Value in Sorted Data:\", index_of_search_value)\n\nprint(\"\\nSearching for values close to mean and standard deviation combined:\")\nfor i in range(-5, 6):\n    adjusted_search_value = search_value + i * 0.1\n    index = binary_search(sorted_data, adjusted_search_value)\n    print(f\"Adjusted Search Value: {adjusted_search_value:.2f}, Index: {index}\")"}, {"role": "assistant", "content": "Data Points: [15, 21, 11, 29, 23, 19, 18, 22, 17, 28, 24, 16, 20, 25, 13, 12, 14, 27, 30, 26]\nSorted Data Points: [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]\nMean: 20.5\nVariance: 33.25\nStandard Deviation: 5.766281297335398\nSearch Value (Mean + Std Dev): 26.266281297335397\nIndex of Search Value in Sorted Data: -1\n\nSearching for values close to mean and standard deviation combined:\nAdjusted Search Value: 25.77, Index: -1\nAdjusted Search Value: 25.87, Index: -1\nAdjusted Search Value: 25.97, Index: -1\nAdjusted Search Value: 26.07, Index: -1\nAdjusted Search Value: 26.17, Index: -1\nAdjusted Search Value: 26.27, Index: -1\nAdjusted Search Value: 26.37, Index: -1\nAdjusted Search Value: 26.47, Index: -1\nAdjusted Search Value: 26.57, Index: -1\nAdjusted Search Value: 26.67, Index: -1\nAdjusted Search Value: 26.77, Index: -1\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef generate_points(n):\n    return [(math.cos(2 * math.pi / n * x), math.sin(2 * math.pi / n * x)) for x in range(n)]\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\ndef perimeter(points):\n    return sum(distance(points[i], points[(i + 1) % len(points)]) for i in range(len(points)))\n\ndef print_star_pattern(points):\n    scale = 15\n    grid = [[' ' for _ in range(scale * 2)] for _ in range(scale)]\n\n    for x, y in points:\n        grid_x = int((x + 1) * scale)\n        grid_y = int((1 - y) * scale / 2)\n        if 0 <= grid_x < scale * 2 and 0 <= grid_y < scale:\n            grid[grid_y][grid_x] = '*'\n\n    for row in grid:\n        print(''.join(row))\n\nn = 7\npoints = generate_points(n)\nprint(\"Generated Points:\", points)\n\nsorted_points = sorted(points, key=lambda p: math.atan2(p[1], p[0]), reverse=True)\nprint(\"Sorted Points by Angle:\", sorted_points)\n\nprint(\"Perimeter of the Star:\", perimeter(sorted_points))\n\nprint_star_pattern(sorted_points)"}, {"role": "assistant", "content": "Generated Points: [(1.0, 0.0), (0.6234898018587336, 0.7818314824680298), (-0.22252093395631434, 0.9749279121818236), (-0.900968867902419, 0.43388373911755823), (-0.9009688679024191, -0.433883739117558), (-0.2225209339563146, -0.9749279121818236), (0.6234898018587334, -0.7818314824680299)]\nSorted Points by Angle: [(-0.900968867902419, 0.43388373911755823), (-0.22252093395631434, 0.9749279121818236), (0.6234898018587336, 0.7818314824680298), (1.0, 0.0), (0.6234898018587334, -0.7818314824680299), (-0.2225209339563146, -0.9749279121818236), (-0.9009688679024191, -0.433883739117558)]\nPerimeter of the Star: 6.074372347645814\n           *                  \n                        *     \n                              \n                              \n *                            \n                              \n                              \n                              \n                              \n                              \n *                            \n                              \n                              \n                        *     \n           *                  \n"}]}
{"messages": [{"role": "user", "content": "import math\n\nplayers = [\n    {\"name\": \"Alice\", \"score\": 67, \"level\": 3},\n    {\"name\": \"Bob\", \"score\": 82, \"level\": 2},\n    {\"name\": \"Charlie\", \"score\": 91, \"level\": 5},\n    {\"name\": \"David\", \"score\": 54, \"level\": 1},\n    {\"name\": \"Eve\", \"score\": 73, \"level\": 4},\n    {\"name\": \"Frank\", \"score\": 85, \"level\": 6},\n    {\"name\": \"Grace\", \"score\": 60, \"level\": 2},\n    {\"name\": \"Heidi\", \"score\": 77, \"level\": 3},\n    {\"name\": \"Ivan\", \"score\": 92, \"level\": 5},\n    {\"name\": \"Judy\", \"score\": 59, \"level\": 1}\n]\n\ndef tie_breaker(player):\n    return player['score'] + math.log(player['level'] + 1)\n\nsorted_players = sorted(players, key=lambda player: (player['score'], tie_breaker(player)), reverse=True)\n\nfor idx, player in enumerate(sorted_players):\n    print(f\"Rank {idx + 1}: {player['name']} with score {player['score']} and level {player['level']}\")\n\nprint(\"\\nIntermediate Debug Prints:\")\n\nfor player in sorted_players:\n    debug_value = tie_breaker(player)\n    print(f\"{player['name']} -> Score with tie breaker: {debug_value:.2f}\")"}, {"role": "assistant", "content": "Rank 1: Ivan with score 92 and level 5\nRank 2: Charlie with score 91 and level 5\nRank 3: Frank with score 85 and level 6\nRank 4: Bob with score 82 and level 2\nRank 5: Heidi with score 77 and level 3\nRank 6: Eve with score 73 and level 4\nRank 7: Alice with score 67 and level 3\nRank 8: Grace with score 60 and level 2\nRank 9: Judy with score 59 and level 1\nRank 10: David with score 54 and level 1\n\nIntermediate Debug Prints:\nIvan -> Score with tie breaker: 93.79\nCharlie -> Score with tie breaker: 92.79\nFrank -> Score with tie breaker: 86.95\nBob -> Score with tie breaker: 83.10\nHeidi -> Score with tie breaker: 78.39\nEve -> Score with tie breaker: 74.61\nAlice -> Score with tie breaker: 68.39\nGrace -> Score with tie breaker: 61.10\nJudy -> Score with tie breaker: 59.69\nDavid -> Score with tie breaker: 54.69\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef custom_sort_key(date_str):\n    return datetime.strptime(date_str, \"%Y/%m/%d\")\n\ndates = [\n    \"2023/10/05\", \"2022/05/20\", \"2021/12/25\", \"2023/01/01\",\n    \"2020/07/07\", \"2019/01/15\", \"2018/03/30\", \"2024/06/18\",\n    \"2021/09/09\", \"2020/11/11\", \"2022/08/08\", \"2023/04/04\"\n]\n\nsorted_dates = sorted(dates, key=custom_sort_key)\n\ndef days_between_dates(start_date, end_date):\n    start = datetime.strptime(start_date, \"%Y/%m/%d\")\n    end = datetime.strptime(end_date, \"%Y/%m/%d\")\n    return (end - start).days\n\ndate_differences = [\n    (sorted_dates[i], sorted_dates[i+1], days_between_dates(sorted_dates[i], sorted_dates[i+1]))\n    for i in range(len(sorted_dates) - 1)\n]\n\nfor start, end, diff in date_differences:\n    print(f\"Days between {start} and {end}: {diff}\")"}, {"role": "assistant", "content": "Days between 2018/03/30 and 2019/01/15: 291\nDays between 2019/01/15 and 2020/07/07: 539\nDays between 2020/07/07 and 2020/11/11: 127\nDays between 2020/11/11 and 2021/09/09: 302\nDays between 2021/09/09 and 2021/12/25: 107\nDays between 2021/12/25 and 2022/05/20: 146\nDays between 2022/05/20 and 2022/08/08: 80\nDays between 2022/08/08 and 2023/01/01: 146\nDays between 2023/01/01 and 2023/04/04: 93\nDays between 2023/04/04 and 2023/10/05: 184\nDays between 2023/10/05 and 2024/06/18: 257\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef calculate_distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\ndef quicksort_distance(points, origin):\n    if len(points) <= 1:\n        return points\n    pivot = points[len(points) // 2]\n    pivot_distance = calculate_distance(pivot, origin)\n    less = [p for p in points if calculate_distance(p, origin) < pivot_distance]\n    equal = [p for p in points if calculate_distance(p, origin) == pivot_distance]\n    greater = [p for p in points if calculate_distance(p, origin) > pivot_distance]\n    return quicksort_distance(less, origin) + equal + quicksort_distance(greater, origin)\n\npoints = [(2, 3), (5, 4), (3, 7), (6, 1), (7, 8), (1, 1), (9, 6), (8, 3), (0, 5), (4, 2)]\norigin = (0, 0)\n\nprint(\"Original points:\", points)\nsorted_points = quicksort_distance(points, origin)\nprint(\"Sorted points by distance from origin:\", sorted_points)\n\nfor point in sorted_points:\n    dist = calculate_distance(point, origin)\n    print(f\"Point: {point}, Distance from origin: {dist:.2f}\")"}, {"role": "assistant", "content": "Original points: [(2, 3), (5, 4), (3, 7), (6, 1), (7, 8), (1, 1), (9, 6), (8, 3), (0, 5), (4, 2)]\nSorted points by distance from origin: [(1, 1), (2, 3), (4, 2), (0, 5), (6, 1), (5, 4), (3, 7), (8, 3), (7, 8), (9, 6)]\nPoint: (1, 1), Distance from origin: 1.41\nPoint: (2, 3), Distance from origin: 3.61\nPoint: (4, 2), Distance from origin: 4.47\nPoint: (0, 5), Distance from origin: 5.00\nPoint: (6, 1), Distance from origin: 6.08\nPoint: (5, 4), Distance from origin: 6.40\nPoint: (3, 7), Distance from origin: 7.62\nPoint: (8, 3), Distance from origin: 8.54\nPoint: (7, 8), Distance from origin: 10.63\nPoint: (9, 6), Distance from origin: 10.82\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef is_perfect_square(n):\n    root = int(math.sqrt(n))\n    return n == root * root\n\ndef fibonacci(n):\n    fib_seq = [0, 1]\n    while len(fib_seq) < n:\n        fib_seq.append(fib_seq[-1] + fib_seq[-2])\n    return fib_seq\n\ndef find_fib_square(n):\n    fib_nums = fibonacci(n)\n    fib_squares = []\n    for num in fib_nums:\n        if is_perfect_square(num):\n            fib_squares.append(num)\n    return fib_squares\n\nn = 100\nprint(\"Finding Fibonacci numbers that are perfect squares up to the 100th Fibonacci number:\")\nresult = find_fib_square(n)\nfor i, value in enumerate(result):\n    print(f\"Fibonacci square {i+1}: {value}\")"}, {"role": "assistant", "content": "Finding Fibonacci numbers that are perfect squares up to the 100th Fibonacci number:\nFibonacci square 1: 0\nFibonacci square 2: 1\nFibonacci square 3: 1\nFibonacci square 4: 144\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef date_sorter(dates):\n    return sorted(dates, key=lambda date: datetime.datetime.strptime(date, \"%Y-%m-%d\"))\n\ndef transform_dates(dates):\n    sorted_dates = date_sorter(dates)\n    transformed = []\n    for date in sorted_dates:\n        year, month, day = map(int, date.split('-'))\n        transformed.append(f\"{month}/{day}/{year}\")\n    return transformed\n\ndates_list = [\n    '2023-07-25', '2021-12-31', '2022-01-01', '2023-03-15', '2021-06-30',\n    '2022-11-11', '2023-01-01', '2021-09-09', '2022-08-08', '2023-05-05',\n    '2021-02-28', '2022-07-04', '2023-04-01', '2021-03-15', '2022-10-10',\n    '2023-06-06', '2021-11-11', '2022-02-22', '2023-02-02', '2021-07-07',\n    '2022-05-05', '2023-09-09', '2021-10-10', '2022-03-03', '2023-08-08',\n    '2021-08-08', '2022-06-06', '2023-11-11', '2021-05-05', '2022-04-04',\n    '2023-12-12', '2021-04-04', '2022-09-09', '2023-10-10', '2021-01-01',\n    '2022-12-31', '2023-07-07', '2021-12-01', '2022-11-01', '2023-06-01',\n    '2021-11-01', '2022-10-01', '2023-05-01', '2021-10-01', '2022-09-01',\n    '2023-04-01', '2021-09-01', '2022-08-01', '2023-03-01', '2021-08-01',\n    '2022-07-01', '2023-02-01', '2021-07-01', '2022-06-01', '2023-01-01',\n    '2021-06-01', '2022-05-01', '2023-12-01', '2021-05-01', '2022-04-01',\n    '2023-11-01', '2021-04-01', '2022-03-01', '2023-10-01', '2021-03-01',\n    '2022-02-01', '2023-09-01', '2021-02-01', '2022-01-01', '2023-08-01',\n    '2021-01-01', '2023-07-01', '2022-12-01', '2023-06-01', '2021-12-01',\n    '2022-11-01', '2023-05-01', '2021-11-01', '2022-10-01', '2023-04-01',\n    '2021-10-01', '2022-09-01', '2023-03-01', '2021-09-01', '2022-08-01',\n    '2023-02-01', '2021-08-01', '2022-07-01', '2023-01-01', '2021-07-01',\n    '2022-06-01', '2023-12-01', '2021-06-01', '2022-05-01', '2023-11-01'\n]\n\nresult = transform_dates(dates_list)\nfor date in result:\n    print(date)"}, {"role": "assistant", "content": "1/1/2021\n1/1/2021\n2/1/2021\n2/28/2021\n3/1/2021\n3/15/2021\n4/1/2021\n4/4/2021\n5/1/2021\n5/5/2021\n6/1/2021\n6/1/2021\n6/30/2021\n7/1/2021\n7/1/2021\n7/7/2021\n8/1/2021\n8/1/2021\n8/8/2021\n9/1/2021\n9/1/2021\n9/9/2021\n10/1/2021\n10/1/2021\n10/10/2021\n11/1/2021\n11/1/2021\n11/11/2021\n12/1/2021\n12/1/2021\n12/31/2021\n1/1/2022\n1/1/2022\n2/1/2022\n2/22/2022\n3/1/2022\n3/3/2022\n4/1/2022\n4/4/2022\n5/1/2022\n5/1/2022\n5/5/2022\n6/1/2022\n6/1/2022\n6/6/2022\n7/1/2022\n7/1/2022\n7/4/2022\n8/1/2022\n8/1/2022\n8/8/2022\n9/1/2022\n9/1/2022\n9/9/2022\n10/1/2022\n10/1/2022\n10/10/2022\n11/1/2022\n11/1/2022\n11/11/2022\n12/1/2022\n12/31/2022\n1/1/2023\n1/1/2023\n1/1/2023\n2/1/2023\n2/1/2023\n2/2/2023\n3/1/2023\n3/1/2023\n3/15/2023\n4/1/2023\n4/1/2023\n4/1/2023\n5/1/2023\n5/1/2023\n5/5/2023\n6/1/2023\n6/1/2023\n6/6/2023\n7/1/2023\n7/7/2023\n7/25/2023\n8/1/2023\n8/8/2023\n9/1/2023\n9/9/2023\n10/1/2023\n10/10/2023\n11/1/2023\n11/1/2023\n11/11/2023\n12/1/2023\n12/1/2023\n12/12/2023\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"\nPython is an interpreted, high-level and general-purpose programming language.\nPython's design philosophy emphasizes code readability with its notable use of significant whitespace.\nIts language constructs and object-oriented approach aim to help programmers write clear, logical code for small and large-scale projects.\nPython is dynamically typed and garbage-collected. It supports multiple programming paradigms, including structured, object-oriented, and functional programming.\nPython is often described as a \"batteries included\" language due to its comprehensive standard library.\n\"\"\"\n\npattern = re.compile(r'\\b\\w{6}\\b')\nmatches = pattern.findall(text)\n\ndef binary_search(arr, target):\n    low, high = 0, len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return None\n\nmatches = sorted(set(matches))\nsearch_terms = [\"Python\", \"object\", \"design\", \"language\", \"project\"]\n\nprint(\"Matches found:\", matches)\nprint(\"Searching for specific terms...\")\n\nfor term in search_terms:\n    index = binary_search(matches, term)\n    if index is not None:\n        print(f\"Term '{term}' found at index {index} in matches.\")\n    else:\n        print(f\"Term '{term}' not found in matches.\")\n\nprint(\"\\nAll matches:\")\nfor match in matches:\n    print(match)"}, {"role": "assistant", "content": "Matches found: ['Python', 'design', 'object']\nSearching for specific terms...\nTerm 'Python' found at index 0 in matches.\nTerm 'object' found at index 2 in matches.\nTerm 'design' found at index 1 in matches.\nTerm 'language' not found in matches.\nTerm 'project' not found in matches.\n\nAll matches:\nPython\ndesign\nobject\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\nclass Player:\n    def __init__(self, name, score, last_played):\n        self.name = name\n        self.score = score\n        self.last_played = last_played\n\n    def __repr__(self):\n        return f\"{self.name}: {self.score}, {self.last_played.strftime('%Y-%m-%d')}\"\n\nplayers = [\n    Player(\"Alice\", 50, datetime(2023, 9, 12)),\n    Player(\"Bob\", 75, datetime(2023, 9, 10)),\n    Player(\"Charlie\", 50, datetime(2023, 9, 14)),\n    Player(\"David\", 90, datetime(2023, 9, 9)),\n    Player(\"Eve\", 75, datetime(2023, 9, 12)),\n    Player(\"Frank\", 60, datetime(2023, 9, 11)),\n    Player(\"Grace\", 80, datetime(2023, 9, 13)),\n    Player(\"Heidi\", 60, datetime(2023, 9, 10)),\n    Player(\"Ivan\", 90, datetime(2023, 9, 8)),\n    Player(\"Judy\", 100, datetime(2023, 9, 15))\n]\n\nsorted_players = sorted(players, key=lambda p: (-p.score, p.last_played))\n\nfor player in sorted_players:\n    print(player)"}, {"role": "assistant", "content": "Judy: 100, 2023-09-15\nIvan: 90, 2023-09-08\nDavid: 90, 2023-09-09\nGrace: 80, 2023-09-13\nBob: 75, 2023-09-10\nEve: 75, 2023-09-12\nHeidi: 60, 2023-09-10\nFrank: 60, 2023-09-11\nAlice: 50, 2023-09-12\nCharlie: 50, 2023-09-14\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef is_point_inside_circle(circle_center, circle_radius, point):\n    return math.dist(circle_center, point) < circle_radius\n\ndef calculate_area_inside_circle(circle_center, circle_radius, grid_size, grid_precision):\n    points_inside = 0\n    total_points = 0\n    step = grid_size / grid_precision\n    \n    for x in range(grid_precision + 1):\n        for y in range(grid_precision + 1):\n            point = (x * step, y * step)\n            if is_point_inside_circle(circle_center, circle_radius, point):\n                points_inside += 1\n            total_points += 1\n    \n    return (points_inside / total_points) * (grid_size ** 2)\n\ncircle_center = (5, 5)\ncircle_radius = 3\ngrid_size = 10\ngrid_precision = 100\n\narea = calculate_area_inside_circle(circle_center, circle_radius, grid_size, grid_precision)\n\nprint(f\"Estimated area inside the circle: {area:.2f}\")"}, {"role": "assistant", "content": "Estimated area inside the circle: 27.54\n"}]}
{"messages": [{"role": "user", "content": "data = [\n    {'name': 'Alice', 'age': 30, 'city': 'New York'},\n    {'name': 'Bob', 'age': 25, 'city': 'Los Angeles'},\n    {'name': 'Charlie', 'age': 35, 'city': 'Chicago'},\n    {'name': 'David', 'age': 30, 'city': 'Miami'},\n    {'name': 'Eve', 'age': 40, 'city': 'Dallas'},\n    {'name': 'Frank', 'age': 25, 'city': 'Denver'},\n    {'name': 'Grace', 'age': 35, 'city': 'Boston'},\n    {'name': 'Hannah', 'age': 28, 'city': 'Austin'},\n    {'name': 'Ivy', 'age': 40, 'city': 'Phoenix'},\n    {'name': 'Jack', 'age': 22, 'city': 'Seattle'},\n    {'name': 'Kathy', 'age': 29, 'city': 'Philadelphia'},\n    {'name': 'Leo', 'age': 35, 'city': 'San Francisco'},\n    {'name': 'Mona', 'age': 31, 'city': 'Detroit'},\n    {'name': 'Nina', 'age': 36, 'city': 'Houston'},\n    {'name': 'Oscar', 'age': 45, 'city': 'Las Vegas'}\n]\n\ncity_count = {}\nfor entry in data:\n    city = entry['city']\n    city_count[city] = city_count.get(city, 0) + 1\n\nsorted_cities = sorted(city_count.items(), key=lambda x: (-x[1], x[0]))\n\nfor city, count in sorted_cities:\n    print(f\"{city}: {count}\")"}, {"role": "assistant", "content": "Austin: 1\nBoston: 1\nChicago: 1\nDallas: 1\nDenver: 1\nDetroit: 1\nHouston: 1\nLas Vegas: 1\nLos Angeles: 1\nMiami: 1\nNew York: 1\nPhiladelphia: 1\nPhoenix: 1\nSan Francisco: 1\nSeattle: 1\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\ndef sort_by_area(triangles):\n    def area(tri):\n        a, b, c = (distance(tri[0], tri[1]), distance(tri[1], tri[2]), distance(tri[2], tri[0]))\n        s = (a + b + c) / 2\n        return math.sqrt(s * (s - a) * (s - b) * (s - c))\n\n    return sorted(triangles, key=area)\n\ntriangles = [\n    ((0, 0), (1, 0), (0, 1)),\n    ((0, 0), (2, 0), (1, 3)),\n    ((-1, -1), (1, 1), (1, -1)),\n    ((0, 0), (3, 0), (0, 4)),\n    ((0, 0), (1, 2), (2, 1))\n]\n\nsorted_triangles = sort_by_area(triangles)\n\nfor triangle in sorted_triangles:\n    print(triangle)"}, {"role": "assistant", "content": "((0, 0), (1, 0), (0, 1))\n((0, 0), (1, 2), (2, 1))\n((-1, -1), (1, 1), (1, -1))\n((0, 0), (2, 0), (1, 3))\n((0, 0), (3, 0), (0, 4))\n"}]}
{"messages": [{"role": "user", "content": "from collections import deque\n\ndef find_path_in_maze(maze, start, end):\n    rows, cols = len(maze), len(maze[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set([start])\n\n    while queue:\n        (current, path) = queue.popleft()\n        if current == end:\n            return path\n        for d in directions:\n            next_cell = (current[0] + d[0], current[1] + d[1])\n            if (0 <= next_cell[0] < rows and\n                0 <= next_cell[1] < cols and\n                maze[next_cell[0]][next_cell[1]] == 0 and\n                next_cell not in visited):\n                queue.append((next_cell, path + [next_cell]))\n                visited.add(next_cell)\n    return []\n\nmaze = [\n    [0, 1, 0, 0, 0],\n    [0, 1, 0, 1, 0],\n    [0, 0, 0, 1, 0],\n    [1, 1, 1, 1, 0],\n    [0, 0, 0, 0, 0]\n]\n\nstart = (0, 0)\nend = (4, 4)\n\npath = find_path_in_maze(maze, start, end)\n\nfor idx, step in enumerate(path):\n    print(f\"Step {idx + 1}: Move to {step}\")"}, {"role": "assistant", "content": "Step 1: Move to (0, 0)\nStep 2: Move to (1, 0)\nStep 3: Move to (2, 0)\nStep 4: Move to (2, 1)\nStep 5: Move to (2, 2)\nStep 6: Move to (1, 2)\nStep 7: Move to (0, 2)\nStep 8: Move to (0, 3)\nStep 9: Move to (0, 4)\nStep 10: Move to (1, 4)\nStep 11: Move to (2, 4)\nStep 12: Move to (3, 4)\nStep 13: Move to (4, 4)\n"}]}
{"messages": [{"role": "user", "content": "def encrypt_sort(message, key):\n    encrypted = []\n    for i, char in enumerate(message):\n        encrypted.append((ord(char) + ord(key[i % len(key)])) % 256)\n    return encrypted\n\ndef decrypt_sort(encrypted, key):\n    decrypted = []\n    for i, char in enumerate(encrypted):\n        decrypted.append(chr((char - ord(key[i % len(key)])) % 256))\n    return ''.join(decrypted)\n\ndef custom_sort(encoded):\n    return sorted(encoded, key=lambda x: (x % 13, -x))\n\nmessage = \"IntermediateEncryptionChallenge\"\nkey = \"SecureKey\"\n\nencrypted_message = encrypt_sort(message, key)\nsorted_encrypted = custom_sort(encrypted_message)\ndecrypted_message = decrypt_sort(sorted_encrypted, key)\n\nprint(\"Original Message:\")\nprint(message)\nprint(\"\\nEncrypted & Sorted Message:\")\nprint(sorted_encrypted)\nprint(\"\\nDecrypted Message:\")\nprint(decrypted_message)"}, {"role": "assistant", "content": "Original Message:\nIntermediateEncryptionChallenge\n\nEncrypted & Sorted Message:\n[156, 222, 209, 210, 210, 184, 224, 211, 211, 172, 199, 186, 226, 200, 200, 227, 201, 228, 215, 202, 189, 176, 229, 217, 218, 218, 205, 206, 180, 233, 181]\n\nDecrypted Message:\nIyn]`S\u0095nZYbWmVc\u0098dk\u0084eZ;st\u008fuT{O\u0086@\n"}]}
{"messages": [{"role": "user", "content": "def generate_board(size):\n    return [['.' for _ in range(size)] for _ in range(size)]\n\ndef is_valid_position(board, row, col):\n    for i in range(len(board)):\n        if board[row][i] == 'Q' or board[i][col] == 'Q':\n            return False\n    for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n        if board[i][j] == 'Q':\n            return False\n    for i, j in zip(range(row, -1, -1), range(col, len(board))):\n        if board[i][j] == 'Q':\n            return False\n    return True\n\ndef solve_n_queens_util(board, col):\n    if col >= len(board):\n        return [list(''.join(row) for row in board)]\n    solutions = []\n    for i in range(len(board)):\n        if is_valid_position(board, i, col):\n            board[i][col] = 'Q'\n            solutions.extend(solve_n_queens_util(board, col + 1))\n            board[i][col] = '.'\n    return solutions\n\ndef solve_n_queens(size):\n    board = generate_board(size)\n    return solve_n_queens_util(board, 0)\n\nsolutions = solve_n_queens(5)\nfor solution in solutions:\n    for row in solution:\n        print(row)\n    print()"}, {"role": "assistant", "content": "Q....\n...Q.\n.Q...\n....Q\n..Q..\n\nQ....\n..Q..\n....Q\n.Q...\n...Q.\n\nQ....\n....Q\n...Q.\n..Q..\n.Q...\n\n.Q...\nQ....\n....Q\n...Q.\n..Q..\n\n..Q..\nQ....\n...Q.\n.Q...\n....Q\n\n...Q.\nQ....\n..Q..\n....Q\n.Q...\n\n.Q...\n...Q.\nQ....\n..Q..\n....Q\n\n..Q..\n.Q...\nQ....\n....Q\n...Q.\n\n..Q..\n....Q\nQ....\n...Q.\n.Q...\n\n....Q\n..Q..\nQ....\n...Q.\n.Q...\n\n....Q\n...Q.\nQ....\n..Q..\n.Q...\n\n.Q...\n....Q\n..Q..\nQ....\n...Q.\n\n...Q.\n.Q...\n....Q\nQ....\n..Q..\n\n....Q\n.Q...\n...Q.\nQ....\n..Q..\n\n...Q.\n..Q..\n.Q...\nQ....\n....Q\n\n....Q\n...Q.\n.Q...\nQ....\n..Q..\n\n...Q.\n.Q...\n....Q\n..Q..\nQ....\n\n....Q\n.Q...\n...Q.\n..Q..\nQ....\n\n..Q..\n....Q\n.Q...\n...Q.\nQ....\n\n....Q\n..Q..\n.Q...\n...Q.\nQ....\n\n..Q..\n....Q\n...Q.\n.Q...\nQ....\n\n...Q.\n..Q..\n....Q\n.Q...\nQ....\n\n....Q\n...Q.\n..Q..\n.Q...\nQ....\n\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef sort_words_by_unique_vowels(sentence):\n    words = re.findall(r'\\b\\w+\\b', sentence.lower())\n    words = sorted(words, key=lambda word: sorted(set(re.findall(r'[aeiou]', word))))\n    return words\n\nparagraph = \"\"\"\nThe quick brown fox jumps over the lazy dog. A journey of a thousand miles begins with a single step. To be or not to be, that is the question.\nWhether 'tis nobler in the mind to suffer the slings and arrows of outrageous fortune.\n\"\"\"\n\nsorted_words = sort_words_by_unique_vowels(paragraph)\nfor word in sorted_words:\n    print(word)"}, {"role": "assistant", "content": "lazy\na\na\na\nthat\nand\noutrageous\narrows\nthousand\nthe\nthe\nstep\nbe\nbe\nthe\nwhether\nthe\nthe\nmiles\nbegins\nsingle\nquestion\nover\nnobler\njourney\nfortune\nsuffer\nwith\nis\ntis\nin\nmind\nslings\nquick\nbrown\nfox\ndog\nof\nto\nor\nnot\nto\nto\nof\njumps\n"}]}
{"messages": [{"role": "user", "content": "import string\n\ndef encrypt_message(message, key):\n    def shift_char(c, k):\n        if c in string.ascii_letters:\n            base = ord('A') if c.isupper() else ord('a')\n            return chr((ord(c) - base + k) % 26 + base)\n        return c\n\n    return ''.join(shift_char(c, key) for c in message)\n\ndef sort_by_encryption_strength(messages):\n    def encryption_strength(message):\n        return sum(ord(c) for c in message if c.isalpha())\n\n    return sorted(messages, key=lambda msg: encryption_strength(encrypt_message(msg, 3)))\n\nmessages = [\n    \"Hello World!\",\n    \"Advanced Encryption\",\n    \"Sorting Algorithms\",\n    \"Python Programming\",\n    \"Data Security\",\n    \"Artificial Intelligence\",\n    \"Machine Learning\",\n    \"Neural Networks\",\n    \"Cryptographic Techniques\",\n    \"Quantum Computing\"\n]\n\nsorted_messages = sort_by_encryption_strength(messages)\n\nfor msg in sorted_messages:\n    print(encrypt_message(msg, 3))"}, {"role": "assistant", "content": "Khoor Zruog!\nGdwd Vhfxulwb\nQhxudo Qhwzrunv\nPdfklqh Ohduqlqj\nTxdqwxp Frpsxwlqj\nSbwkrq Surjudpplqj\nVruwlqj Dojrulwkpv\nDgydqfhg Hqfubswlrq\nDuwlilfldo Lqwhooljhqfh\nFubswrjudsklf Whfkqltxhv\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef caesar_cipher_encode(text, shift):\n    encoded = []\n    for char in text:\n        if char.isalpha():\n            shift_amount = shift % 26\n            shifted = ord(char) + shift_amount\n            if char.islower():\n                if shifted > ord('z'):\n                    shifted -= 26\n            elif char.isupper():\n                if shifted > ord('Z'):\n                    shifted -= 26\n            encoded.append(chr(shifted))\n        else:\n            encoded.append(char)\n    return ''.join(encoded)\n\ndef caesar_cipher_brute_force(encoded_text):\n    possibilities = []\n    for possible_shift in range(1, 26):\n        decoded = caesar_cipher_encode(encoded_text, -possible_shift)\n        if re.search(r'\\bthe\\b', decoded):\n            possibilities.append(decoded)\n    return possibilities\n\nciphertext = caesar_cipher_encode(\"The quick brown fox jumps over the lazy dog\", 3)\npossible_decodings = caesar_cipher_brute_force(ciphertext)\n\nfor i, decoding in enumerate(possible_decodings, 1):\n    print(f\"{i}: {decoding}\")"}, {"role": "assistant", "content": "1: The quick brown fox jumps over the lazy dog\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef generate_spiral_pattern(n):\n    pattern = [[0] * n for _ in range(n)]\n    x, y = 0, 0\n    dx, dy = 0, 1\n    for i in range(1, n * n + 1):\n        pattern[x][y] = i\n        if pattern[(x + dx) % n][(y + dy) % n] != 0:\n            dx, dy = dy, -dx\n        x += dx\n        y += dy\n    return pattern\n\ndef search_for_prime(matrix):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    found_primes = []\n    for row in matrix:\n        for num in row:\n            if is_prime(num):\n                found_primes.append(num)\n    return found_primes\n\ndef main():\n    size = 10\n    print(\"Generating spiral pattern:\")\n    spiral_pattern = generate_spiral_pattern(size)\n    for row in spiral_pattern:\n        print(row)\n    print(\"\\nSearching for prime numbers:\")\n    primes = search_for_prime(spiral_pattern)\n    print(\"Primes found:\", primes)\n\nmain()"}, {"role": "assistant", "content": "Generating spiral pattern:\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n[36, 37, 38, 39, 40, 41, 42, 43, 44, 11]\n[35, 64, 65, 66, 67, 68, 69, 70, 45, 12]\n[34, 63, 84, 85, 86, 87, 88, 71, 46, 13]\n[33, 62, 83, 96, 97, 98, 89, 72, 47, 14]\n[32, 61, 82, 95, 100, 99, 90, 73, 48, 15]\n[31, 60, 81, 94, 93, 92, 91, 74, 49, 16]\n[30, 59, 80, 79, 78, 77, 76, 75, 50, 17]\n[29, 58, 57, 56, 55, 54, 53, 52, 51, 18]\n[28, 27, 26, 25, 24, 23, 22, 21, 20, 19]\n\nSearching for prime numbers:\nPrimes found: [2, 3, 5, 7, 37, 41, 43, 11, 67, 71, 13, 83, 97, 89, 47, 61, 73, 31, 59, 79, 17, 29, 53, 23, 19]\n"}]}
{"messages": [{"role": "user", "content": "from math import sqrt\nfrom statistics import median\n\ndef find_median_deviation(data):\n    n = len(data)\n    sorted_data = sorted(data)\n    med = median(sorted_data)\n    deviations = [abs(x - med) for x in sorted_data]\n    return median(deviations)\n\ndef search_deviation_threshold(data, threshold):\n    low, high = 0, len(data) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        deviation = find_median_deviation(data[:mid+1])\n        if deviation < threshold:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return data[:low]\n\ndata = [16, 22, 7, 13, 22, 10, 3, 15, 26, 18, 13, 17, 14, 11, 15, 19, 12, 24, 23, 20]\nthreshold = 4.0\nresult = search_deviation_threshold(data, threshold)\n\nfor item in result:\n    print(item)"}, {"role": "assistant", "content": "16\n22\n"}]}
{"messages": [{"role": "user", "content": "from math import sqrt\n\ndef is_perfect_square(x):\n    s = int(sqrt(x))\n    return s * s == x\n\ndef fibonacci_sequence(n):\n    fibs = [0, 1]\n    for i in range(2, n):\n        fibs.append(fibs[-1] + fibs[-2])\n    return fibs\n\ndef sort_by_digit_sum(numbers):\n    return sorted(numbers, key=lambda x: sum(int(digit) for digit in str(x)))\n\nfibonacci_numbers = fibonacci_sequence(20)\nperfect_square_fibonaccis = [num for num in fibonacci_numbers if is_perfect_square(num)]\n\nsorted_perfect_square_fibonaccis = sort_by_digit_sum(perfect_square_fibonaccis)\n\nfor number in sorted_perfect_square_fibonaccis:\n    print(number)"}, {"role": "assistant", "content": "0\n1\n1\n144\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndata = [\n    (1, 3.5), (2, 4.2), (3, 4.8), (4, 5.0), (5, 6.3),\n    (6, 5.9), (7, 7.1), (8, 8.4), (9, 7.5), (10, 9.0),\n    (11, 6.8), (12, 7.2), (13, 8.5), (14, 9.3), (15, 10.1),\n    (16, 8.2), (17, 11.0), (18, 10.8), (19, 12.5), (20, 11.7)\n]\n\nsorted_data = sorted(data, key=lambda x: x[1])\n\nquartiles = [\n    statistics.median([x[1] for x in sorted_data[:len(sorted_data)//2]]),\n    statistics.median([x[1] for x in sorted_data]),\n    statistics.median([x[1] for x in sorted_data[len(sorted_data)//2:]])\n]\n\nfor i, q in enumerate(quartiles, start=1):\n    print(f\"Quartile {i}: {q}\")\n\noutliers = []\niqr = quartiles[2] - quartiles[0]\nlow_threshold = quartiles[0] - 1.5 * iqr\nhigh_threshold = quartiles[2] + 1.5 * iqr\n\nfor item in sorted_data:\n    if item[1] < low_threshold or item[1] > high_threshold:\n        outliers.append(item)\n\nprint(\"\\nOutliers:\")\nfor o in outliers:\n    print(f\"Point {o[0]} with value {o[1]}\")"}, {"role": "assistant", "content": "Quartile 1: 6.1\nQuartile 2: 7.85\nQuartile 3: 9.7\n\nOutliers:\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\ndef binary_search_transform(sorted_dates, target_date):\n    left, right = 0, len(sorted_dates) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if sorted_dates[mid] == target_date:\n            return mid\n        elif sorted_dates[mid] < target_date:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndate_strings = [\n    \"2023-01-01\", \"2023-02-15\", \"2023-03-10\", \"2023-04-25\",\n    \"2023-05-30\", \"2023-06-20\", \"2023-07-15\", \"2023-08-05\",\n    \"2023-09-10\", \"2023-10-22\", \"2023-11-30\", \"2023-12-25\"\n]\n\ndates = [datetime.strptime(date, \"%Y-%m-%d\").date() for date in date_strings]\n\nsearch_dates = [\n    \"2023-04-25\", \"2023-11-30\", \"2023-01-01\", \"2023-06-20\",\n    \"2023-07-17\", \"2023-08-05\", \"2023-02-15\", \"2023-12-26\"\n]\n\nsearch_dates_transformed = [datetime.strptime(date, \"%Y-%m-%d\").date() for date in search_dates]\n\nresults = [binary_search_transform(dates, date) for date in search_dates_transformed]\n\nfor index, result in enumerate(results):\n    print(f\"Search for {search_dates[index]} -> Index: {result}\")"}, {"role": "assistant", "content": "Search for 2023-04-25 -> Index: 3\nSearch for 2023-11-30 -> Index: 10\nSearch for 2023-01-01 -> Index: 0\nSearch for 2023-06-20 -> Index: 5\nSearch for 2023-07-17 -> Index: -1\nSearch for 2023-08-05 -> Index: 7\nSearch for 2023-02-15 -> Index: 1\nSearch for 2023-12-26 -> Index: -1\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef sort_by_distance(points, center):\n    return sorted(points, key=lambda p: math.sqrt((p[0] - center[0])**2 + (p[1] - center[1])**2))\n\ndef transform_points(points, factor):\n    transformed = [(x * factor, y * factor) for x, y in points]\n    print(\"Transformed points:\", transformed)\n    return transformed\n\ndef main():\n    points = [(2, 3), (4, 6), (1, 5), (7, 8), (5, 2), (9, 1), (3, 4), (6, 7), (8, 3), (0, 0)]\n    center = (5, 5)\n    factor = 1.5\n\n    print(\"Original points:\", points)\n    sorted_points = sort_by_distance(points, center)\n    print(\"Points sorted by distance from\", center, \":\", sorted_points)\n\n    transformed_sorted_points = transform_points(sorted_points, factor)\n    final_sorted_points = sort_by_distance(transformed_sorted_points, tuple(factor * x for x in center))\n    print(\"Final sorted points by distance after transformation:\", final_sorted_points)\n\nmain()"}, {"role": "assistant", "content": "Original points: [(2, 3), (4, 6), (1, 5), (7, 8), (5, 2), (9, 1), (3, 4), (6, 7), (8, 3), (0, 0)]\nPoints sorted by distance from (5, 5) : [(4, 6), (3, 4), (6, 7), (5, 2), (2, 3), (7, 8), (8, 3), (1, 5), (9, 1), (0, 0)]\nTransformed points: [(6.0, 9.0), (4.5, 6.0), (9.0, 10.5), (7.5, 3.0), (3.0, 4.5), (10.5, 12.0), (12.0, 4.5), (1.5, 7.5), (13.5, 1.5), (0.0, 0.0)]\nFinal sorted points by distance after transformation: [(6.0, 9.0), (4.5, 6.0), (9.0, 10.5), (7.5, 3.0), (3.0, 4.5), (10.5, 12.0), (12.0, 4.5), (1.5, 7.5), (13.5, 1.5), (0.0, 0.0)]\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef harmonic_mean(nums):\n    return len(nums) / sum(1 / n for n in nums)\n\nsequences = [\n    [2, 3, 5, 7, 11, 13],\n    [8, 6, 17, 4, 19, 12],\n    [20, 15, 30, 5, 10, 25],\n    [29, 23, 31, 37, 41, 43],\n    [14, 18, 22, 26, 30, 34],\n    [49, 7, 35, 21, 42, 28],\n    [50, 40, 60, 70, 80, 90],\n    [16, 8, 24, 32, 48, 56],\n    [99, 81, 72, 54, 63, 45],\n    [66, 55, 44, 33, 22, 11]\n]\n\nsorted_sequences = sorted(sequences, key=harmonic_mean)\n\nfor seq in sorted_sequences:\n    print(seq)"}, {"role": "assistant", "content": "[2, 3, 5, 7, 11, 13]\n[8, 6, 17, 4, 19, 12]\n[20, 15, 30, 5, 10, 25]\n[16, 8, 24, 32, 48, 56]\n[49, 7, 35, 21, 42, 28]\n[14, 18, 22, 26, 30, 34]\n[66, 55, 44, 33, 22, 11]\n[29, 23, 31, 37, 41, 43]\n[50, 40, 60, 70, 80, 90]\n[99, 81, 72, 54, 63, 45]\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef custom_sort_words(text):\n    words = re.findall(r'\\b\\w+\\b', text.lower())\n    words.sort(key=lambda x: (len(x), x))\n    return words\n\ndef process_text(text):\n    sorted_words = custom_sort_words(text)\n    return \"\\n\".join(sorted_words)\n\ntext_block = \"\"\"\nThe quick brown fox jumps over the lazy dog. \nThis is a sample text for testing sorting algorithms.\nPython programming is both fun and educative.\n\"\"\"\n\nsorted_text = process_text(text_block)\nprint(sorted_text)"}, {"role": "assistant", "content": "a\nis\nis\nand\ndog\nfor\nfox\nfun\nthe\nthe\nboth\nlazy\nover\ntext\nthis\nbrown\njumps\nquick\npython\nsample\nsorting\ntesting\neducative\nalgorithms\nprogramming\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef sort_dates_by_month_day(dates):\n    return sorted(dates, key=lambda date: (date.month, date.day))\n\ndate_strings = [\n    \"2023-12-25\", \"2023-01-01\", \"2023-03-15\", \"2023-07-04\",\n    \"2023-11-11\", \"2023-10-31\", \"2023-02-14\", \"2023-09-09\",\n    \"2023-08-08\", \"2023-05-05\", \"2023-06-06\", \"2023-04-01\"\n]\n\ndates = [datetime.strptime(date_str, \"%Y-%m-%d\") for date_str in date_strings]\n\nsorted_dates = sort_dates_by_month_day(dates)\nsorted_dates_str = [date.strftime(\"%Y-%m-%d\") for date in sorted_dates]\n\nfor date in sorted_dates_str:\n    print(date)"}, {"role": "assistant", "content": "2023-01-01\n2023-02-14\n2023-03-15\n2023-04-01\n2023-05-05\n2023-06-06\n2023-07-04\n2023-08-08\n2023-09-09\n2023-10-31\n2023-11-11\n2023-12-25\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\nimport re\n\nclass LogAnalyzer:\n    def __init__(self, logs):\n        self.logs = logs\n        self.pattern = re.compile(r\"(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}) - (\\w+): (.+)\")\n\n    def parse_logs(self):\n        parsed_logs = []\n        for log in self.logs:\n            match = self.pattern.match(log)\n            if match:\n                timestamp = datetime.strptime(match.group(1), \"%Y-%m-%d %H:%M:%S\")\n                level = match.group(2)\n                message = match.group(3)\n                parsed_logs.append((timestamp, level, message))\n        return parsed_logs\n\n    def search_logs(self, search_term, start_time=None, end_time=None):\n        parsed_logs = self.parse_logs()\n        results = []\n        for timestamp, level, message in parsed_logs:\n            if search_term.lower() in message.lower():\n                if (start_time is None or timestamp >= start_time) and (end_time is None or timestamp <= end_time):\n                    results.append((timestamp, level, message))\n        return results\n\nlogs = [\n    \"2023-01-01 12:00:00 - INFO: System started\",\n    \"2023-01-01 12:05:00 - ERROR: Failed to connect to database\",\n    \"2023-01-01 12:10:00 - INFO: User logged in\",\n    \"2023-01-01 12:15:00 - WARNING: Low disk space\",\n    \"2023-01-01 12:20:00 - INFO: User logged out\",\n    \"2023-01-01 12:25:00 - ERROR: Failed to save file\",\n    \"2023-01-01 12:30:00 - INFO: System shutdown\"\n]\n\nanalyzer = LogAnalyzer(logs)\nstart_time = datetime(2023, 1, 1, 12, 5)\nend_time = datetime(2023, 1, 1, 12, 25)\nsearch_term = \"Failed\"\n\nprint(\"Searching logs...\")\nresults = analyzer.search_logs(search_term, start_time, end_time)\n\nfor result in results:\n    print(result)"}, {"role": "assistant", "content": "Searching logs...\n(datetime.datetime(2023, 1, 1, 12, 5), 'ERROR', 'Failed to connect to database')\n(datetime.datetime(2023, 1, 1, 12, 25), 'ERROR', 'Failed to save file')\n"}]}
{"messages": [{"role": "user", "content": "def determine_rank(players):\n    scores = [(name, sum([ord(c) for c in name])) for name in players]\n    scores.sort(key=lambda x: x[1], reverse=True)\n    return scores\n\ndef game_simulation():\n    players = [\n        \"Alice\", \"Bob\", \"Charlie\", \"Diana\", \"Evan\", \n        \"Fiona\", \"George\", \"Hannah\", \"Ivy\", \"Jack\", \n        \"Kara\", \"Liam\", \"Mona\", \"Nina\", \"Oscar\", \n        \"Paul\", \"Quinn\", \"Rita\", \"Sam\", \"Tina\"\n    ]\n    \n    rounds = 3\n    leaderboard = {name: 0 for name in players}\n\n    for _ in range(rounds):\n        round_ranking = determine_rank(players)\n        for idx, (name, score) in enumerate(round_ranking):\n            leaderboard[name] += (len(players) - idx)\n\n    final_ranking = sorted(leaderboard.items(), key=lambda x: x[1], reverse=True)\n    \n    for rank, (name, score) in enumerate(final_ranking, 1):\n        print(f\"Rank {rank}: {name} with a total score of {score}\")\n\ngame_simulation()"}, {"role": "assistant", "content": "Rank 1: Charlie with a total score of 60\nRank 2: George with a total score of 57\nRank 3: Hannah with a total score of 54\nRank 4: Quinn with a total score of 51\nRank 5: Oscar with a total score of 48\nRank 6: Fiona with a total score of 45\nRank 7: Alice with a total score of 42\nRank 8: Diana with a total score of 39\nRank 9: Paul with a total score of 36\nRank 10: Rita with a total score of 33\nRank 11: Tina with a total score of 30\nRank 12: Mona with a total score of 27\nRank 13: Evan with a total score of 24\nRank 14: Nina with a total score of 21\nRank 15: Liam with a total score of 18\nRank 16: Kara with a total score of 15\nRank 17: Jack with a total score of 12\nRank 18: Ivy with a total score of 9\nRank 19: Sam with a total score of 6\nRank 20: Bob with a total score of 3\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef distance(point1, point2):\n    return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2)\n\ndef angle_from_origin(point):\n    return math.atan2(point[1], point[0])\n\ndef sort_points(points):\n    return sorted(points, key=lambda p: (angle_from_origin(p), distance((0, 0), p)))\n\ndef calculate_perimeter(points):\n    perimeter = 0\n    for i in range(len(points)):\n        perimeter += distance(points[i], points[(i + 1) % len(points)])\n    return perimeter\n\ndef main():\n    points = [(2, 3), (3, 4), (5, 0), (0, 0), (2, 2), (4, 4), (1, 4), (3, 3), (5, 5), (1, 1)]\n    sorted_points = sort_points(points)\n    perimeter = calculate_perimeter(sorted_points)\n    for point in sorted_points:\n        print(f\"Point: {point}, Distance from origin: {distance((0, 0), point):.2f}, Angle: {math.degrees(angle_from_origin(point)):.2f}\")\n    print(f\"Total Perimeter of Convex Hull: {perimeter:.2f}\")\n\nmain()"}, {"role": "assistant", "content": "Point: (0, 0), Distance from origin: 0.00, Angle: 0.00\nPoint: (5, 0), Distance from origin: 5.00, Angle: 0.00\nPoint: (1, 1), Distance from origin: 1.41, Angle: 45.00\nPoint: (2, 2), Distance from origin: 2.83, Angle: 45.00\nPoint: (3, 3), Distance from origin: 4.24, Angle: 45.00\nPoint: (4, 4), Distance from origin: 5.66, Angle: 45.00\nPoint: (5, 5), Distance from origin: 7.07, Angle: 45.00\nPoint: (3, 4), Distance from origin: 5.00, Angle: 53.13\nPoint: (2, 3), Distance from origin: 3.61, Angle: 56.31\nPoint: (1, 4), Distance from origin: 4.12, Angle: 75.96\nTotal Perimeter of Convex Hull: 23.97\n"}]}
{"messages": [{"role": "user", "content": "from math import sqrt\n\ndef distance(p1, p2):\n    return sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\ndef perimeter(polygon):\n    return sum(distance(polygon[i], polygon[i + 1]) for i in range(-1, len(polygon) - 1))\n\ndef sort_polygons_by_perimeter(polygons):\n    return sorted(polygons, key=perimeter)\n\npolygons = [\n    [(0, 0), (1, 1), (1, 0)],\n    [(0, 0), (4, 0), (4, 3), (0, 3)],\n    [(0, 0), (3, 0), (3, 4)],\n    [(0, 0), (2, 2), (2, 0)]\n]\n\nsorted_polygons = sort_polygons_by_perimeter(polygons)\n\nfor i, polygon in enumerate(sorted_polygons, start=1):\n    print(f\"Polygon {i}:\")\n    for point in polygon:\n        print(point)\n    print(\"Perimeter:\", perimeter(polygon))\n    print()"}, {"role": "assistant", "content": "Polygon 1:\n(0, 0)\n(1, 1)\n(1, 0)\nPerimeter: 3.414213562373095\n\nPolygon 2:\n(0, 0)\n(2, 2)\n(2, 0)\nPerimeter: 6.82842712474619\n\nPolygon 3:\n(0, 0)\n(3, 0)\n(3, 4)\nPerimeter: 12.0\n\nPolygon 4:\n(0, 0)\n(4, 0)\n(4, 3)\n(0, 3)\nPerimeter: 14.0\n\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef custom_sort_key(value):\n    return (value[0], -value[1])\n\ndef generate_points(n):\n    points = []\n    for i in range(1, n + 1):\n        angle = 2 * math.pi * i / n\n        x = round(math.cos(angle), 3)\n        y = round(math.sin(angle), 3)\n        points.append((x, y))\n    return points\n\ndef pattern_generation(n):\n    points = generate_points(n)\n    sorted_points = sorted(points, key=custom_sort_key)\n\n    max_x = max(p[0] for p in sorted_points)\n    min_x = min(p[0] for p in sorted_points)\n\n    grid_size = 2 * int(max(abs(min_x), abs(max_x)) * 10) + 1\n    grid = [[' ' for _ in range(grid_size)] for _ in range(grid_size)]\n\n    for x, y in sorted_points:\n        grid_x = int((x + 1) * 10)\n        grid_y = int((y + 1) * 10)\n        grid[grid_y][grid_x] = '*'\n    \n    print(\"\\nDebug: Sorted Points:\", sorted_points)\n    for row in reversed(grid):\n        print(\"\".join(row))\n\npattern_generation(21)"}, {"role": "assistant", "content": "\nDebug: Sorted Points: [(-0.989, 0.149), (-0.989, -0.149), (-0.901, 0.434), (-0.901, -0.434), (-0.733, 0.68), (-0.733, -0.68), (-0.5, 0.866), (-0.5, -0.866), (-0.223, 0.975), (-0.223, -0.975), (0.075, 0.997), (0.075, -0.997), (0.365, 0.931), (0.365, -0.931), (0.623, 0.782), (0.623, -0.782), (0.826, 0.563), (0.826, -0.563), (0.956, 0.295), (0.956, -0.295), (1.0, -0.0)]\n                     \n       *  *  *       \n     *               \n                *    \n  *                  \n                  *  \n*                    \n                     \n                   * \n*                    \n                    *\n                     \n*                    \n                   * \n                     \n*                    \n                  *  \n  *                  \n                *    \n     *               \n       *  *  *       \n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef transform_data(data):\n    def binary_search(arr, target):\n        low, high = 0, len(arr) - 1\n        while low <= high:\n            mid = (low + high) // 2\n            if arr[mid] < target:\n                low = mid + 1\n            elif arr[mid] > target:\n                high = mid - 1\n            else:\n                return mid\n        return low  # Incorrect return value for not found, should return -1\n\n    transformed = [math.ceil(math.sqrt(x)) for x in data]\n    print(\"Transformed Data:\", transformed)\n\n    search_results = []\n    for x in transformed:\n        index = binary_search(transformed, x)\n        search_results.append(index)\n\n    print(\"Search Results:\", search_results)\n    return search_results\n\ndata = [4, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225, 256, 289]\nresults = transform_data(data)\n\nprint(\"Final Results:\", results)"}, {"role": "assistant", "content": "Transformed Data: [2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]\nSearch Results: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\nFinal Results: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\n"}]}
{"messages": [{"role": "user", "content": "import math\nfrom statistics import mean, median, stdev\n\ndef quicksort(arr):\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    return quicksort(left) + middle + quicksort(right)\n\ndef iqr(data):\n    sorted_data = quicksort(data)\n    mid = len(sorted_data) // 2\n    q1 = median(sorted_data[:mid])\n    q3 = median(sorted_data[-mid:])\n    return q3 - q1\n\ndata = [7, 5, 1, 9, 3, 8, 6, 2, 4, 10, 15, 13, 18, 12, 17, 11, 14, 16, 20, 19]\nsorted_data = quicksort(data)\n\noutput = []\noutput.append(f\"Sorted Data: {sorted_data}\")\noutput.append(f\"Mean: {mean(data)}\")\noutput.append(f\"Median: {median(data)}\")\noutput.append(f\"Standard Deviation: {stdev(data)}\")\noutput.append(f\"Interquartile Range: {iqr(data)}\")\n\nfor line in output:\n    print(line)"}, {"role": "assistant", "content": "Sorted Data: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\nMean: 10.5\nMedian: 10.5\nStandard Deviation: 5.916079783099616\nInterquartile Range: 10.0\n"}]}
{"messages": [{"role": "user", "content": "def generate_spiral(n):\n    spiral = [[0] * n for _ in range(n)]\n    dr = [0, 1, 0, -1]\n    dc = [1, 0, -1, 0]\n    r, c = 0, 0\n    di = 0\n    for i in range(n * n):\n        spiral[r][c] = i + 1\n        nr, nc = r + dr[di], c + dc[di]\n        if 0 <= nr < n and 0 <= nc < n and spiral[nr][nc] == 0:\n            r, c = nr, nc\n        else:\n            di = (di + 1) % 4\n            r, c = r + dr[di], c + dc[di]\n    return spiral\n\ndef search_number_in_spiral(spiral, target):\n    for r in range(len(spiral)):\n        for c in range(len(spiral[0])):\n            if spiral[r][c] == target:\n                return (r, c)\n    return None\n\nn = 10\nspiral = generate_spiral(n)\ntarget_pattern = [5, 17, 23, 37, 50, 73, 89, 100]\nresults = []\n\nfor target in target_pattern:\n    position = search_number_in_spiral(spiral, target)\n    formatted_position = f\"Number {target} found at position: {position}\" if position else f\"Number {target} not found\"\n    results.append(formatted_position)\n\nfor result in results:\n    print(result)"}, {"role": "assistant", "content": "Number 5 found at position: (0, 4)\nNumber 17 found at position: (7, 9)\nNumber 23 found at position: (9, 5)\nNumber 37 found at position: (1, 1)\nNumber 50 found at position: (7, 8)\nNumber 73 found at position: (5, 7)\nNumber 89 found at position: (4, 6)\nNumber 100 found at position: (5, 4)\n"}]}
{"messages": [{"role": "user", "content": "def encode_message(message):\n    encoded = \"\"\n    for char in message:\n        encoded += chr((ord(char) + 3) % 256)\n    return encoded\n\ndef decode_message(encoded):\n    decoded = \"\"\n    for char in encoded:\n        decoded += chr((ord(char) - 3) % 256)\n    return decoded\n\ndef sort_encoded(encoded):\n    return ''.join(sorted(encoded))\n\nmessage = \"Hello, World! This is a secret message.\"\nencoded = encode_message(message)\nsorted_encoded = sort_encoded(encoded)\ndecoded = decode_message(sorted_encoded)\n\nprint(\"Original Message:\")\nprint(message)\nprint(\"\\nEncoded Message:\")\nprint(encoded)\nprint(\"\\nSorted Encoded Message:\")\nprint(sorted_encoded)\nprint(\"\\nDecoded (from sorted) Message:\")\nprint(decoded)"}, {"role": "assistant", "content": "Original Message:\nHello, World! This is a secret message.\n\nEncoded Message:\nKhoor/#Zruog$#Wklv#lv#d#vhfuhw#phvvdjh1\n\nSorted Encoded Message:\n######$/1KWZddfghhhhhjklloooprruuvvvvvw\n\nDecoded (from sorted) Message:\n      !,.HTWaacdeeeeeghiilllmoorrssssst\n"}]}
{"messages": [{"role": "user", "content": "import datetime\nfrom statistics import mean\n\ndef sort_timestamps_by_year(timestamps):\n    return sorted(timestamps, key=lambda x: x.month)\n\ntimestamps = [\n    datetime.datetime(2021, 5, 17, 10, 15),\n    datetime.datetime(2020, 6, 21, 14, 30),\n    datetime.datetime(2022, 3, 11, 9, 45),\n    datetime.datetime(2020, 12, 25, 17, 0),\n    datetime.datetime(2021, 1, 1, 0, 0),\n    datetime.datetime(2022, 8, 5, 20, 20),\n    datetime.datetime(2021, 11, 11, 11, 11),\n    datetime.datetime(2020, 7, 4, 4, 44),\n    datetime.datetime(2022, 2, 14, 13, 0),\n    datetime.datetime(2020, 10, 31, 23, 59)\n]\n\nsorted_timestamps = sort_timestamps_by_year(timestamps)\n\naverage_year = int(mean(ts.year for ts in sorted_timestamps))\nfiltered_timestamps = [ts for ts in sorted_timestamps if ts.year >= average_year]\n\nfor ts in filtered_timestamps:\n    print(ts.strftime(\"%Y-%m-%d %H:%M\"))"}, {"role": "assistant", "content": "2021-01-01 00:00\n2022-02-14 13:00\n2022-03-11 09:45\n2021-05-17 10:15\n2020-06-21 14:30\n2020-07-04 04:44\n2022-08-05 20:20\n2020-10-31 23:59\n2021-11-11 11:11\n2020-12-25 17:00\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\ndef sort_players_by_score(players):\n    return sorted(players, key=lambda x: x[1], reverse=True)\n\ndef simulate_game():\n    players = [\n        (\"Alice\", 34, datetime(2023, 10, 1, 14, 0)),\n        (\"Bob\", 28, datetime(2023, 10, 1, 15, 0)),\n        (\"Charlie\", 45, datetime(2023, 10, 1, 13, 0)),\n        (\"David\", 22, datetime(2023, 10, 1, 16, 0)),\n        (\"Eve\", 30, datetime(2023, 10, 1, 12, 0)),\n        (\"Frank\", 28, datetime(2023, 10, 1, 11, 0)),\n        (\"Grace\", 50, datetime(2023, 10, 1, 17, 0)),\n        (\"Heidi\", 34, datetime(2023, 10, 1, 18, 0)),\n        (\"Ivan\", 55, datetime(2023, 10, 1, 10, 0)),\n        (\"Judy\", 40, datetime(2023, 10, 1, 19, 0)),\n    ]\n    \n    sorted_players = sort_players_by_score(players)\n    for rank, (name, score, time) in enumerate(sorted_players, 1):\n        print(f\"Rank {rank}: {name} with score {score} at {time.time()}\")\n\nsimulate_game()"}, {"role": "assistant", "content": "Rank 1: Ivan with score 55 at 10:00:00\nRank 2: Grace with score 50 at 17:00:00\nRank 3: Charlie with score 45 at 13:00:00\nRank 4: Judy with score 40 at 19:00:00\nRank 5: Alice with score 34 at 14:00:00\nRank 6: Heidi with score 34 at 18:00:00\nRank 7: Eve with score 30 at 12:00:00\nRank 8: Bob with score 28 at 15:00:00\nRank 9: Frank with score 28 at 11:00:00\nRank 10: David with score 22 at 16:00:00\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef calculate_median(arr):\n    n = len(arr)\n    arr.sort()\n    midpoint = n // 2\n    if n % 2 == 1:\n        return arr[midpoint]\n    else:\n        return (arr[midpoint - 1] + arr[midpoint]) / 2\n\ndef search_for_median_value(data, target_median):\n    low = 0\n    high = len(data) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        print(f\"Debug: low={low}, high={high}, mid={mid}\")\n\n        median = calculate_median(data[low:mid+1])\n        print(f\"Debug: Sub-array median={median}\")\n\n        if math.isclose(median, target_median, abs_tol=1e-9):\n            print(f\"Debug: Found target median in sub-array: {data[low:mid+1]}\")\n            return data[low:mid+1]\n        elif median < target_median:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return []\n\ndata = [34, 50, 23, 5, 12, 45, 67, 89, 21, 43, 56, 78, 98, 31, 65, 87]\ntarget_median = 45.0\n\nresult = search_for_median_value(data, target_median)\n\nprint(\"Final Result:\", result)"}, {"role": "assistant", "content": "Debug: low=0, high=15, mid=7\nDebug: Sub-array median=39.5\nDebug: low=8, high=15, mid=11\nDebug: Sub-array median=49.5\nDebug: low=8, high=10, mid=9\nDebug: Sub-array median=32.0\nDebug: low=10, high=10, mid=10\nDebug: Sub-array median=56\nFinal Result: []\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndates = [\n    \"2023-11-05 12:15:00\",\n    \"2023-11-01 09:30:00\",\n    \"2023-11-03 17:45:00\",\n    \"2023-11-02 11:00:00\",\n    \"2023-11-04 08:00:00\",\n    \"2023-11-06 19:30:00\",\n    \"2023-11-07 05:20:00\",\n    \"2023-11-08 22:55:00\",\n    \"2023-11-09 14:10:00\",\n    \"2023-11-10 06:35:00\"\n]\n\ndate_objects = [datetime.strptime(d, \"%Y-%m-%d %H:%M:%S\") for d in dates]\n\nweekday_sorted_dates = sorted(date_objects, key=lambda x: (x.weekday(), x.time()))\n\nweekdays = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n\nfor date_obj in weekday_sorted_dates:\n    date_str = date_obj.strftime(\"%Y-%m-%d %H:%M:%S\")\n    day_of_week = weekdays[date_obj.weekday()]\n    print(f\"{date_str} - {day_of_week}\")"}, {"role": "assistant", "content": "2023-11-06 19:30:00 - Monday\n2023-11-07 05:20:00 - Tuesday\n2023-11-01 09:30:00 - Wednesday\n2023-11-08 22:55:00 - Wednesday\n2023-11-02 11:00:00 - Thursday\n2023-11-09 14:10:00 - Thursday\n2023-11-10 06:35:00 - Friday\n2023-11-03 17:45:00 - Friday\n2023-11-04 08:00:00 - Saturday\n2023-11-05 12:15:00 - Sunday\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef find_words_with_most_vowels(text):\n    words = re.findall(r'\\b\\w+\\b', text)\n    def vowel_count(word):\n        return sum(1 for char in word.lower() if char in 'aeiou')\n    max_vowels = max(vowel_count(word) for word in words)\n    words_with_max_vowels = [word for word in words if vowel_count(word) == max_vowels]\n    return words_with_max_vowels\n\ntext = \"\"\"\nArtificial intelligence is the simulation of human intelligence processes by machines,\nespecially computer systems. These processes include learning, reasoning, and self-correction.\nA few specific applications of AI include expert systems, speech recognition, and machine vision.\n\"\"\"\n\nwords_with_most_vowels = find_words_with_most_vowels(text)\nfor word in words_with_most_vowels:\n    print(word)"}, {"role": "assistant", "content": "Artificial\nintelligence\nsimulation\nintelligence\napplications\nrecognition\n"}]}
{"messages": [{"role": "user", "content": "def check_winner(board, player):\n    # Check rows\n    for row in board:\n        if all(s == player for s in row):\n            return True\n    # Check columns\n    for col in range(len(board)):\n        if all(row[col] == player for row in board):\n            return True\n    # Check diagonals\n    if all(board[i][i] == player for i in range(len(board))):\n        return True\n    if all(board[i][len(board) - 1 - i] == player for i in range(len(board))):\n        return True\n    return False\n\ndef print_board(board):\n    for row in board:\n        print(\" \".join(row))\n    print()\n\ndef solve_tic_tac_toe(board):\n    players = ['X', 'O']\n    for player in players:\n        print(f\"Checking for player {player}\")\n        if check_winner(board, player):\n            print(f\"Player {player} wins!\")\n            return\n    print(\"No winner yet!\")\n\nboard = [\n    ['X', 'O', 'X'],\n    ['O', 'X', 'O'],\n    ['O', 'X', 'X']\n]\n\nprint(\"Initial board state:\")\nprint_board(board)\n\nsolve_tic_tac_toe(board)"}, {"role": "assistant", "content": "Initial board state:\nX O X\nO X O\nO X X\n\nChecking for player X\nPlayer X wins!\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef generate_pattern(n):\n    pattern = []\n    for i in range(1, n + 1):\n        pattern.append(' '.join(str(x) for x in range(1, i + 1)))\n    return pattern\n\ndef search_pattern(pattern, search_string):\n    compiled_pattern = re.compile(search_string)\n    for line in pattern:\n        if compiled_pattern.search(line):\n            return line\n    return \"No match found\"\n\nn = 15\npattern = generate_pattern(n)\nsearch_string = r\"\\b3 4\\b\"\nresult = search_pattern(pattern, search_string)\n\nfor line in pattern:\n    print(line)\nprint(\"Search Result:\", result)"}, {"role": "assistant", "content": "1\n1 2\n1 2 3\n1 2 3 4\n1 2 3 4 5\n1 2 3 4 5 6\n1 2 3 4 5 6 7\n1 2 3 4 5 6 7 8\n1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9 10\n1 2 3 4 5 6 7 8 9 10 11\n1 2 3 4 5 6 7 8 9 10 11 12\n1 2 3 4 5 6 7 8 9 10 11 12 13\n1 2 3 4 5 6 7 8 9 10 11 12 13 14\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\nSearch Result: 1 2 3 4\n"}]}
{"messages": [{"role": "user", "content": "import math\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\ndef distance(p1, p2):\n    return math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2)\n\ndef perimeter(triangle):\n    return (distance(triangle[0], triangle[1]) +\n            distance(triangle[1], triangle[2]) +\n            distance(triangle[2], triangle[0]))\n\ndef find_min_perimeter(triangles):\n    min_perim = float('inf')\n    min_triangle = None\n    for triangle in triangles:\n        perim = perimeter(triangle)\n        if perim < min_perim:\n            min_perim = perim\n            min_triangle = triangle\n    return min_triangle, min_perim\n\ntriangles = [\n    [Point(0, 0), Point(1, 0), Point(0, 1)],\n    [Point(0, 0), Point(2, 0), Point(0, 2)],\n    [Point(1, 1), Point(3, 4), Point(5, 1)],\n    [Point(0, 0), Point(3, 0), Point(0, 4)],\n    [Point(1, 1), Point(1, 4), Point(5, 4)],\n    [Point(2, 2), Point(3, 5), Point(6, 2)],\n    [Point(1, 0), Point(4, 0), Point(1, 3)],\n    [Point(0, 0), Point(1, 2), Point(3, 0)],\n    [Point(0, 0), Point(0, 2), Point(2, 0)],\n    [Point(2, 2), Point(5, 5), Point(8, 2)],\n    [Point(0, 0), Point(4, 0), Point(0, 3)],\n    [Point(1, 1), Point(4, 1), Point(1, 5)],\n    [Point(0, 0), Point(3, 0), Point(0, 5)],\n    [Point(1, 1), Point(3, 3), Point(5, 1)],\n    [Point(2, 1), Point(4, 5), Point(6, 1)]\n]\n\nmin_triangle, min_perimeter = find_min_perimeter(triangles)\n\nfor point in min_triangle:\n    print(f\"({point.x}, {point.y})\")\nprint(f\"Perimeter: {min_perimeter:.2f}\")"}, {"role": "assistant", "content": "(0, 0)\n(1, 0)\n(0, 1)\nPerimeter: 3.41\n"}]}
{"messages": [{"role": "user", "content": "def generate_pattern(n):\n    pattern = []\n    for i in range(1, n + 1):\n        row = [j for j in range(1, i + 1)]\n        pattern.append(row)\n    return pattern\n\ndef sort_pattern_lexicographically(pattern):\n    flattened = []\n    for row in pattern:\n        flattened.extend(row)\n    \n    print(\"Flattened pattern before sorting:\", flattened)\n    sorted_flattened = sorted(flattened, key=lambda x: str(x))\n    print(\"Flattened pattern after sorting:\", sorted_flattened)\n    \n    return sorted_flattened\n\nn = 10\npattern = generate_pattern(n)\nprint(\"Generated Pattern:\")\nfor row in pattern:\n    print(row)\n\nsorted_flattened = sort_pattern_lexicographically(pattern)\nindex = 0\nfor i in range(1, n + 1):\n    print(\" \".join(str(sorted_flattened[index + j]) for j in range(i)))\n    index += i"}, {"role": "assistant", "content": "Generated Pattern:\n[1]\n[1, 2]\n[1, 2, 3]\n[1, 2, 3, 4]\n[1, 2, 3, 4, 5]\n[1, 2, 3, 4, 5, 6]\n[1, 2, 3, 4, 5, 6, 7]\n[1, 2, 3, 4, 5, 6, 7, 8]\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nFlattened pattern before sorting: [1, 1, 2, 1, 2, 3, 1, 2, 3, 4, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nFlattened pattern after sorting: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 10, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 9, 9]\n1\n1 1\n1 1 1\n1 1 1 1\n10 2 2 2 2\n2 2 2 2 2 3\n3 3 3 3 3 3 3\n4 4 4 4 4 4 4 5\n5 5 5 5 5 6 6 6 6\n6 7 7 7 7 8 8 8 9 9\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef custom_sequence(n):\n    sequence = []\n    for i in range(1, n + 1):\n        value = int(i * math.sin(i) + i * math.cos(i))\n        sequence.append(value)\n    return sequence\n\ndef custom_sort(seq):\n    def complex_key(x):\n        return (x % 5, -x, str(x))\n    \n    sorted_seq = sorted(seq, key=complex_key)\n    return sorted_seq\n\nn = 50\nseq = custom_sequence(n)\nprint(\"Original sequence:\")\nfor num in seq:\n    print(num, end=' ')\nprint(\"\\n\")\n\nsorted_seq = custom_sort(seq)\nprint(\"Sorted sequence:\")\nfor num in sorted_seq:\n    print(num, end=' ')\nprint(\"\\n\")"}, {"role": "assistant", "content": "Original sequence:\n1 0 -2 -5 -3 4 9 6 -4 -13 -10 3 17 15 -1 -19 -21 -1 21 26 6 -22 -31 -11 21 36 17 -19 -40 -25 15 44 32 -10 -46 -40 4 47 47 3 -46 -55 -11 44 61 21 -40 -67 -32 35 \n\nSorted sequence:\n35 15 15 0 -5 -10 -10 -25 -40 -40 -40 -55 61 36 26 21 21 21 6 6 1 -4 -19 -19 47 47 32 17 17 -3 -13 3 3 -2 -22 -32 -67 44 44 9 4 4 -1 -1 -11 -11 -21 -31 -46 -46 \n\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef find_next_full_moon(start_date):\n    full_moon_reference = datetime(2021, 12, 18)  # known full moon date\n    days_between_full_moons = 29.53\n    current_date = datetime.strptime(start_date, \"%Y-%m-%d\")\n    \n    days_difference = (current_date - full_moon_reference).days\n    cycles_since_reference = days_difference / days_between_full_moons\n\n    next_full_moon = full_moon_reference + timedelta(days=round((cycles_since_reference + 1) * days_between_full_moons))\n    \n    return next_full_moon\n\ndef search_full_moons_in_year(year):\n    full_moons_in_year = []\n    current_date = datetime(year, 1, 1)\n    end_date = datetime(year, 12, 31)\n\n    while current_date <= end_date:\n        full_moon = find_next_full_moon(current_date.strftime(\"%Y-%m-%d\"))\n        if full_moon.year == year and full_moon not in full_moons_in_year:\n            full_moons_in_year.append(full_moon)\n        current_date += timedelta(days=30)\n    \n    return full_moons_in_year\n\nyear_to_search = 2023\nfull_moons = search_full_moons_in_year(year_to_search)\nfor moon in full_moons:\n    print(moon.strftime(\"%Y-%m-%d\"))"}, {"role": "assistant", "content": "2023-01-31\n2023-03-02\n2023-04-01\n2023-05-01\n2023-05-31\n2023-06-30\n2023-07-30\n2023-08-29\n2023-09-28\n2023-10-28\n2023-11-27\n2023-12-27\n"}]}
{"messages": [{"role": "user", "content": "def rank_players(players):\n    return sorted(players, key=lambda x: (-x[1], x[0]))\n\ndef determine_winner(players):\n    sorted_players = rank_players(players)\n    return sorted_players[0][0]\n\nplayers = [\n    (\"Alice\", 15),\n    (\"Bob\", 20),\n    (\"Charlie\", 20),\n    (\"Dave\", 18),\n    (\"Eve\", 22),\n    (\"Frank\", 18),\n    (\"Grace\", 22),\n    (\"Hannah\", 15),\n    (\"Ivy\", 20),\n    (\"Jack\", 17)\n]\n\nranked_players = rank_players(players)\nwinner = determine_winner(players)\n\nfor i, player in enumerate(ranked_players):\n    print(f\"Rank {i + 1}: {player[0]} with score {player[1]}\")\n\nprint(f\"\\nWinner: {winner}\")"}, {"role": "assistant", "content": "Rank 1: Eve with score 22\nRank 2: Grace with score 22\nRank 3: Bob with score 20\nRank 4: Charlie with score 20\nRank 5: Ivy with score 20\nRank 6: Dave with score 18\nRank 7: Frank with score 18\nRank 8: Jack with score 17\nRank 9: Alice with score 15\nRank 10: Hannah with score 15\n\nWinner: Eve\n"}]}
{"messages": [{"role": "user", "content": "import string\n\ndef caesar_cipher_encrypt(text, shift):\n    encrypted_text = []\n    for char in text:\n        if char in string.ascii_lowercase:\n            encrypted_text.append(chr((ord(char) - ord('a') + shift) % 26 + ord('a')))\n        elif char in string.ascii_uppercase:\n            encrypted_text.append(chr((ord(char) - ord('A') + shift) % 26 + ord('A')))\n        else:\n            encrypted_text.append(char)\n    return ''.join(encrypted_text)\n\ndef caesar_cipher_decrypt(text, shift):\n    return caesar_cipher_encrypt(text, -shift)\n\ndef search_and_decrypt(encrypted_text):\n    print(\"Encrypted text:\", encrypted_text)\n    for shift in range(26):\n        decrypted_text = caesar_cipher_decrypt(encrypted_text, shift)\n        print(f\"Trying shift {shift}: {decrypted_text}\")\n\noriginal_text = \"Secret Message with Caesar Cipher\"\nshift_value = 3\nencrypted = caesar_cipher_encrypt(original_text, shift_value)\nsearch_and_decrypt(encrypted)"}, {"role": "assistant", "content": "Encrypted text: Vhfuhw Phvvdjh zlwk Fdhvdu Flskhu\nTrying shift 0: Vhfuhw Phvvdjh zlwk Fdhvdu Flskhu\nTrying shift 1: Ugetgv Oguucig ykvj Ecguct Ekrjgt\nTrying shift 2: Tfdsfu Nfttbhf xjui Dbftbs Djqifs\nTrying shift 3: Secret Message with Caesar Cipher\nTrying shift 4: Rdbqds Ldrrzfd vhsg Bzdrzq Bhogdq\nTrying shift 5: Qcapcr Kcqqyec ugrf Aycqyp Agnfcp\nTrying shift 6: Pbzobq Jbppxdb tfqe Zxbpxo Zfmebo\nTrying shift 7: Oaynap Iaoowca sepd Ywaown Yeldan\nTrying shift 8: Nzxmzo Hznnvbz rdoc Xvznvm Xdkczm\nTrying shift 9: Mywlyn Gymmuay qcnb Wuymul Wcjbyl\nTrying shift 10: Lxvkxm Fxlltzx pbma Vtxltk Vbiaxk\nTrying shift 11: Kwujwl Ewkksyw oalz Uswksj Uahzwj\nTrying shift 12: Jvtivk Dvjjrxv nzky Trvjri Tzgyvi\nTrying shift 13: Iushuj Cuiiqwu myjx Squiqh Syfxuh\nTrying shift 14: Htrgti Bthhpvt lxiw Rpthpg Rxewtg\nTrying shift 15: Gsqfsh Asggous kwhv Qosgof Qwdvsf\nTrying shift 16: Frperg Zrffntr jvgu Pnrfne Pvcure\nTrying shift 17: Eqodqf Yqeemsq iuft Omqemd Oubtqd\nTrying shift 18: Dpncpe Xpddlrp htes Nlpdlc Ntaspc\nTrying shift 19: Combod Wocckqo gsdr Mkockb Mszrob\nTrying shift 20: Bnlanc Vnbbjpn frcq Ljnbja Lryqna\nTrying shift 21: Amkzmb Umaaiom eqbp Kimaiz Kqxpmz\nTrying shift 22: Zljyla Tlzzhnl dpao Jhlzhy Jpwoly\nTrying shift 23: Ykixkz Skyygmk cozn Igkygx Iovnkx\nTrying shift 24: Xjhwjy Rjxxflj bnym Hfjxfw Hnumjw\nTrying shift 25: Wigvix Qiwweki amxl Geiwev Gmtliv\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\nimport calendar\n\ndef get_weekdays_in_year(year):\n    weekdays = [0] * 7\n    date = datetime(year, 1, 1)\n    while date.year == year:\n        weekdays[date.weekday()] += 1\n        date += timedelta(days=1)\n    return weekdays\n\ndef sort_weekdays_by_occurrence(year):\n    weekdays_count = get_weekdays_in_year(year)\n    weekdays_count_sorted = sorted(enumerate(weekdays_count), key=lambda x: x[1])\n    return [(calendar.day_name[i], count) for i, count in weekdays_count_sorted]\n\ndef print_sorted_weekday_occurrences(year):\n    sorted_weekdays = sort_weekdays_by_occurrence(year)\n    for weekday, count in sorted_weekdays:\n        print(f\"{weekday}: {count} days\")\n\nyear = 2024\nprint_sorted_weekday_occurrences(year)"}, {"role": "assistant", "content": "Wednesday: 52 days\nThursday: 52 days\nFriday: 52 days\nSaturday: 52 days\nSunday: 52 days\nMonday: 53 days\nTuesday: 53 days\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef linear_search_mode(data):\n    max_count = 0\n    mode = None\n    for num in data:\n        count = data.count(num)\n        if count > max_count:\n            max_count = count\n            mode = num\n    return mode\n\ndef binary_search_mean(sorted_data, mean_value):\n    left, right = 0, len(sorted_data) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if sorted_data[mid] == mean_value:\n            return mid\n        elif sorted_data[mid] < mean_value:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndata = [\n    15, 22, 27, 22, 15, 27, 15, 27, 15, 22, 27, 22, 15, 27, 15, 27, 15, 22, 27, 22,\n    15, 27, 15, 27, 15, 22, 27, 22, 15, 27, 15, 27, 15, 22, 27, 22, 15, 27, 15, 27,\n    15, 22, 27, 22, 15, 27, 15, 27, 15, 22, 27, 22, 15, 27, 15, 27, 15, 22, 27, 22,\n    15, 27, 15, 27, 15, 22, 27, 22, 15, 27, 15, 27, 15, 22, 27, 22, 15, 27, 15, 27,\n    15, 22, 27, 22, 15, 27, 15, 27, 15, 22, 27, 22, 15, 27, 15, 27, 15, 22, 27, 22\n]\n\nmode_result = linear_search_mode(data)\nmean_value = statistics.mean(data)\nsorted_data = sorted(data)\nmean_index = binary_search_mean(sorted_data, mean_value)\n\nprint(f\"Mode of the data: {mode_result}\")\nprint(f\"Mean of the data: {mean_value:.2f}\")\nprint(f\"Index of mean in sorted data (if found): {mean_index}\")"}, {"role": "assistant", "content": "Mode of the data: 15\nMean of the data: 21.26\nIndex of mean in sorted data (if found): -1\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef quicksort(data):\n    if len(data) <= 1:\n        return data\n    pivot = data[len(data) // 2]\n    left = [x for x in data if x < pivot]\n    middle = [x for x in data if x == pivot]\n    right = [x for x in data if x > pivot]\n    return quicksort(left) + middle + quicksort(right)\n\ndef sort_dates_by_weekday(dates):\n    weekdays = [(date.weekday(), date) for date in dates]\n    sorted_dates = quicksort(weekdays)\n    return [date for _, date in sorted_dates]\n\ndates = [datetime(2023, 10, i) for i in range(1, 31)]\nsorted_dates = sort_dates_by_weekday(dates)\n\nfor date in sorted_dates:\n    print(date.strftime('%A, %Y-%m-%d'))"}, {"role": "assistant", "content": "Monday, 2023-10-02\nMonday, 2023-10-09\nMonday, 2023-10-16\nMonday, 2023-10-23\nMonday, 2023-10-30\nTuesday, 2023-10-03\nTuesday, 2023-10-10\nTuesday, 2023-10-17\nTuesday, 2023-10-24\nWednesday, 2023-10-04\nWednesday, 2023-10-11\nWednesday, 2023-10-18\nWednesday, 2023-10-25\nThursday, 2023-10-05\nThursday, 2023-10-12\nThursday, 2023-10-19\nThursday, 2023-10-26\nFriday, 2023-10-06\nFriday, 2023-10-13\nFriday, 2023-10-20\nFriday, 2023-10-27\nSaturday, 2023-10-07\nSaturday, 2023-10-14\nSaturday, 2023-10-21\nSaturday, 2023-10-28\nSunday, 2023-10-01\nSunday, 2023-10-08\nSunday, 2023-10-15\nSunday, 2023-10-22\nSunday, 2023-10-29\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef generate_spiral_pattern(n):\n    grid = [[' ' for _ in range(n)] for _ in range(n)]\n    x, y = n // 2, n // 2\n    grid[x][y] = '*'\n    num = 1\n    step = 1\n\n    while True:\n        for _ in range(step):\n            y += 1\n            if 0 <= x < n and 0 <= y < n:\n                grid[x][y] = '*'\n            num += 1\n            if num > n ** 2:\n                return grid\n\n        for _ in range(step):\n            x -= 1\n            if 0 <= x < n and 0 <= y < n:\n                grid[x][y] = '*'\n            num += 1\n            if num > n ** 2:\n                return grid\n\n        step += 1\n\n        for _ in range(step):\n            y -= 1\n            if 0 <= x < n and 0 <= y < n:\n                grid[x][y] = '*'\n            num += 1\n            if num > n ** 2:\n                return grid\n\n        for _ in range(step):\n            x += 1\n            if 0 <= x < n and 0 <= y < n:\n                grid[x][y] = '*'\n            num += 1\n            if num > n ** 2:\n                return grid\n\n        step += 1\n\ndef sort_diagonals(grid):\n    n = len(grid)\n    diagonals = []\n\n    for d in range(-n + 1, n):\n        diag = []\n        for i in range(n):\n            j = i + d\n            if 0 <= i < n and 0 <= j < n:\n                diag.append(grid[i][j])\n        if diag:\n            sorted_diag = sorted(diag, reverse=True)\n            diagonals.append(sorted_diag)\n\n    new_grid = [[' ' for _ in range(n)] for _ in range(n)]\n    for d, diag in zip(range(-n + 1, n), diagonals):\n        index = 0\n        for i in range(n):\n            j = i + d\n            if 0 <= i < n and 0 <= j < n:\n                new_grid[i][j] = diag[index]\n                index += 1\n\n    return new_grid\n\nn = 10\npattern = generate_spiral_pattern(n)\nprint(\"Original Spiral Pattern:\")\nfor row in pattern:\n    print(''.join(row))\n\nsorted_pattern = sort_diagonals(pattern)\nprint(\"\\nDiagonally Sorted Pattern:\")\nfor row in sorted_pattern:\n    print(''.join(row))"}, {"role": "assistant", "content": "Original Spiral Pattern:\n**********\n *********\n *********\n *********\n *********\n *********\n *********\n *********\n *********\n *********\n\nDiagonally Sorted Pattern:\n**********\n**********\n**********\n**********\n**********\n**********\n**********\n**********\n**********\n         *\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef generate_pattern(n):\n    if n == 1:\n        return [\"*\"]\n    sub_pattern = generate_pattern(n - 1)\n    pattern = []\n    space = \" \" * (n - 1)\n    for line in sub_pattern:\n        pattern.append(space + line + space)\n    middle = \"*\" * (2 * n - 1)\n    pattern.append(middle)\n    for line in sub_pattern:\n        pattern.append(space + line + space)\n    return pattern\n\ndef find_star_sequence(pattern, sequence):\n    for i, line in enumerate(pattern):\n        if re.search(sequence, line):\n            return i, line\n    return -1, None\n\nn = 5\npattern = generate_pattern(n)\nsequence = r\"\\* \\*\"\nindex, line = find_star_sequence(pattern, sequence)\n\nfor line in pattern:\n    print(line)\n\nif index != -1:\n    print(f\"Sequence '{sequence}' found in line {index + 1}: {line}\")\nelse:\n    print(f\"Sequence '{sequence}' not found\")"}, {"role": "assistant", "content": "          *          \n         ***         \n          *          \n       *****       \n          *          \n         ***         \n          *          \n    *******    \n          *          \n         ***         \n          *          \n       *****       \n          *          \n         ***         \n          *          \n*********\n          *          \n         ***         \n          *          \n       *****       \n          *          \n         ***         \n          *          \n    *******    \n          *          \n         ***         \n          *          \n       *****       \n          *          \n         ***         \n          *          \nSequence '\\* \\*' not found\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndata = [\n    \"2023-10-05 14:30:00\",\n    \"2021-05-10 09:00:00\",\n    \"2022-12-25 15:45:00\",\n    \"2023-01-01 00:00:00\",\n    \"2021-11-11 11:11:11\",\n    \"2022-07-04 12:00:00\",\n    \"2023-03-17 17:30:00\",\n    \"2021-08-15 08:00:00\",\n    \"2022-02-14 14:00:00\",\n    \"2023-07-07 07:07:07\"\n]\n\ndates = [datetime.datetime.strptime(d, \"%Y-%m-%d %H:%M:%S\") for d in data]\n\ndef custom_sort_key(date):\n    return (date.year, date.month, len(str(date.day)), date.day)\n\nsorted_dates = sorted(dates, key=custom_sort_key)\n\ntransformed = [d.strftime(\"%Y-%m-%d %H:%M:%S\") for d in sorted_dates]\n\nfor t in transformed:\n    print(t)"}, {"role": "assistant", "content": "2021-05-10 09:00:00\n2021-08-15 08:00:00\n2021-11-11 11:11:11\n2022-02-14 14:00:00\n2022-07-04 12:00:00\n2022-12-25 15:45:00\n2023-01-01 00:00:00\n2023-03-17 17:30:00\n2023-07-07 07:07:07\n2023-10-05 14:30:00\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"\nSorting can be done in various ways. Text processing is an interesting domain.\nHowever, sorting text based on word length is a unique approach. \nLet's explore this method with a sample text. \nThis text contains several sentences of varying lengths.\n\"\"\"\n\ndef sort_words_by_length(text):\n    words = re.findall(r'\\b\\w+\\b', text)\n    sorted_words = sorted(words, key=lambda w: len(w))\n    return sorted_words\n\ndef process_text_paragraphs(text):\n    paragraphs = text.strip().split('\\n')\n    sorted_paragraphs = sorted(paragraphs, key=lambda p: len(p.split()), reverse=True)\n    return \"\\n\".join(sorted_paragraphs)\n\nsorted_words = sort_words_by_length(text)\nsorted_paragraphs = process_text_paragraphs(text)\n\nprint(\"Sorted Words by Length:\")\nfor word in sorted_words:\n    print(word)\n\nprint(\"\\nSorted Paragraphs by Word Count:\")\nprint(sorted_paragraphs)"}, {"role": "assistant", "content": "Sorted Words by Length:\na\ns\na\nbe\nin\nis\nan\non\nis\nof\ncan\nLet\ndone\nways\nText\ntext\nword\nthis\nwith\ntext\nThis\ntext\nbased\ndomain\nlength\nunique\nmethod\nsample\nSorting\nvarious\nHowever\nsorting\nexplore\nseveral\nvarying\nlengths\napproach\ncontains\nsentences\nprocessing\ninteresting\n\nSorted Paragraphs by Word Count:\nSorting can be done in various ways. Text processing is an interesting domain.\nHowever, sorting text based on word length is a unique approach. \nLet's explore this method with a sample text. \nThis text contains several sentences of varying lengths.\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef generate_points(n):\n    return [(math.cos(2 * math.pi * i / n), math.sin(2 * math.pi * i / n)) for i in range(n)]\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\ndef closest_point(start, points):\n    min_dist = float('inf')\n    closest = None\n    for point in points:\n        if point != start:\n            dist = distance(start, point)\n            if dist < min_dist:\n                min_dist = dist\n                closest = point\n    return closest\n\ndef calculate_path(points):\n    path = [points[0]]\n    while len(path) < len(points):\n        current = path[-1]\n        next_point = closest_point(current, points)\n        path.append(next_point)\n        points.remove(next_point)\n    return path\n\ndef path_length(path):\n    return sum(distance(path[i], path[i + 1]) for i in range(len(path) - 1))\n\nn = 25\npoints = generate_points(n)\npath = calculate_path(points)\ntotal_length = path_length(path)\n\nfor i, point in enumerate(path):\n    print(f\"Step {i}: {point}\")\n\nprint(f\"Total Path Length: {total_length:.4f}\")"}, {"role": "assistant", "content": "Step 0: (1.0, 0.0)\nStep 1: (0.9685831611286311, 0.2486898871648548)\nStep 2: (1.0, 0.0)\nStep 3: (0.968583161128631, -0.24868988716485535)\nStep 4: (0.8763066800438631, -0.4817536741017161)\nStep 5: (0.7289686274214113, -0.684547105928689)\nStep 6: (0.5358267949789968, -0.844327925502015)\nStep 7: (0.30901699437494723, -0.9510565162951536)\nStep 8: (0.06279051952931283, -0.9980267284282716)\nStep 9: (-0.18738131458572463, -0.9822872507286887)\nStep 10: (-0.42577929156507216, -0.9048270524660198)\nStep 11: (-0.6374239897486895, -0.7705132427757894)\nStep 12: (-0.8090169943749478, -0.5877852522924727)\nTotal Path Length: 3.0080\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef sort_data_descending(data):\n    return sorted(data)\n\ndef calculate_median(data):\n    return statistics.median(data)\n\ndata = [23, 5, 67, 34, 89, 12, 55, 38, 92, 45, 13, 76, 54, 30, 11, 78, 66, 29, 82, 9]\n\nsorted_data = sort_data_descending(data)\nmedian_value = calculate_median(sorted_data)\n\nprint(\"Sorted Data (Descending):\")\nfor value in sorted_data:\n    print(value)\n\nprint(\"\\nMedian Value:\")\nprint(median_value)"}, {"role": "assistant", "content": "Sorted Data (Descending):\n5\n9\n11\n12\n13\n23\n29\n30\n34\n38\n45\n54\n55\n66\n67\n76\n78\n82\n89\n92\n\nMedian Value:\n41.5\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef angle_from_origin(point):\n    x, y = point\n    return math.atan2(y, x)\n\ndef distance_from_origin(point):\n    x, y = point\n    return math.sqrt(x**2 + y**2)\n\ndef sort_points(points):\n    sorted_by_angle = sorted(points, key=angle_from_origin)\n    sorted_by_distance = sorted(sorted_by_angle, key=distance_from_origin)\n    return sorted_by_distance\n\npoints = [\n    (10, 0), (0, 10), (-10, 0), (0, -10),\n    (5, 5), (-5, 5), (-5, -5), (5, -5),\n    (8, 2), (2, 8), (-8, 2), (-2, 8),\n    (-8, -2), (-2, -8), (8, -2), (2, -8)\n]\n\nsorted_points = sort_points(points)\n\nfor point in sorted_points:\n    print(f\"Point: {point}, Distance: {distance_from_origin(point):.2f}, Angle: {math.degrees(angle_from_origin(point)):.2f}\")"}, {"role": "assistant", "content": "Point: (-5, -5), Distance: 7.07, Angle: -135.00\nPoint: (5, -5), Distance: 7.07, Angle: -45.00\nPoint: (5, 5), Distance: 7.07, Angle: 45.00\nPoint: (-5, 5), Distance: 7.07, Angle: 135.00\nPoint: (-8, -2), Distance: 8.25, Angle: -165.96\nPoint: (-2, -8), Distance: 8.25, Angle: -104.04\nPoint: (2, -8), Distance: 8.25, Angle: -75.96\nPoint: (8, -2), Distance: 8.25, Angle: -14.04\nPoint: (8, 2), Distance: 8.25, Angle: 14.04\nPoint: (2, 8), Distance: 8.25, Angle: 75.96\nPoint: (-2, 8), Distance: 8.25, Angle: 104.04\nPoint: (-8, 2), Distance: 8.25, Angle: 165.96\nPoint: (0, -10), Distance: 10.00, Angle: -90.00\nPoint: (10, 0), Distance: 10.00, Angle: 0.00\nPoint: (0, 10), Distance: 10.00, Angle: 90.00\nPoint: (-10, 0), Distance: 10.00, Angle: 180.00\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef generate_dates(start_date, num_days):\n    return [(start_date + timedelta(days=i)).strftime(\"%Y-%m-%d\") for i in range(num_days)]\n\ndef sort_dates_by_weekday(dates):\n    return sorted(dates, key=lambda date: datetime.strptime(date, \"%Y-%m-%d\").weekday())\n\nstart_date = datetime(2023, 1, 1)\nnum_days = 20\n\ndates = generate_dates(start_date, num_days)\nsorted_dates = sort_dates_by_weekday(dates)\n\nfor date in sorted_dates:\n    print(date)"}, {"role": "assistant", "content": "2023-01-02\n2023-01-09\n2023-01-16\n2023-01-03\n2023-01-10\n2023-01-17\n2023-01-04\n2023-01-11\n2023-01-18\n2023-01-05\n2023-01-12\n2023-01-19\n2023-01-06\n2023-01-13\n2023-01-20\n2023-01-07\n2023-01-14\n2023-01-01\n2023-01-08\n2023-01-15\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef distance(point):\n    return math.sqrt(point[0] ** 2 + point[1] ** 2)\n\ndef angle(point):\n    return math.atan2(point[1], point[0])\n\ndef sort_points(points):\n    points.sort(key=lambda point: (distance(point), angle(point)))\n    return points\n\ndef generate_points():\n    return [\n        (5, 2), (1, 7), (-3, -8), (7, -3), (-6, 5), (0, 0),\n        (4, 4), (-2, -1), (1, 1), (0, 3), (3, 0), (-4, -3),\n        (8, 8), (-7, 7), (9, 0), (0, -9), (6, 6), (-5, -5),\n        (2, 9), (-9, 2), (3, -9), (-1, 1), (-3, 3), (7, 7)\n    ]\n\ndef calculate_areas(points):\n    areas = []\n    for point in points:\n        x, y = point\n        area = abs(x * y) / 2\n        areas.append((point, area))\n    return areas\n\ndef main():\n    points = generate_points()\n    print(\"Original Points:\")\n    for point in points:\n        print(point)\n    sorted_points = sort_points(points)\n    print(\"\\nSorted Points by Distance and Angle:\")\n    for point in sorted_points:\n        print(point)\n    areas = calculate_areas(sorted_points)\n    print(\"\\nPoints with Triangle Areas:\")\n    for point, area in areas:\n        print(f\"Point: {point}, Area: {area:.2f}\")\n\nmain()"}, {"role": "assistant", "content": "Original Points:\n(5, 2)\n(1, 7)\n(-3, -8)\n(7, -3)\n(-6, 5)\n(0, 0)\n(4, 4)\n(-2, -1)\n(1, 1)\n(0, 3)\n(3, 0)\n(-4, -3)\n(8, 8)\n(-7, 7)\n(9, 0)\n(0, -9)\n(6, 6)\n(-5, -5)\n(2, 9)\n(-9, 2)\n(3, -9)\n(-1, 1)\n(-3, 3)\n(7, 7)\n\nSorted Points by Distance and Angle:\n(0, 0)\n(1, 1)\n(-1, 1)\n(-2, -1)\n(3, 0)\n(0, 3)\n(-3, 3)\n(-4, -3)\n(5, 2)\n(4, 4)\n(-5, -5)\n(1, 7)\n(7, -3)\n(-6, 5)\n(6, 6)\n(-3, -8)\n(0, -9)\n(9, 0)\n(2, 9)\n(-9, 2)\n(3, -9)\n(7, 7)\n(-7, 7)\n(8, 8)\n\nPoints with Triangle Areas:\nPoint: (0, 0), Area: 0.00\nPoint: (1, 1), Area: 0.50\nPoint: (-1, 1), Area: 0.50\nPoint: (-2, -1), Area: 1.00\nPoint: (3, 0), Area: 0.00\nPoint: (0, 3), Area: 0.00\nPoint: (-3, 3), Area: 4.50\nPoint: (-4, -3), Area: 6.00\nPoint: (5, 2), Area: 5.00\nPoint: (4, 4), Area: 8.00\nPoint: (-5, -5), Area: 12.50\nPoint: (1, 7), Area: 3.50\nPoint: (7, -3), Area: 10.50\nPoint: (-6, 5), Area: 15.00\nPoint: (6, 6), Area: 18.00\nPoint: (-3, -8), Area: 12.00\nPoint: (0, -9), Area: 0.00\nPoint: (9, 0), Area: 0.00\nPoint: (2, 9), Area: 9.00\nPoint: (-9, 2), Area: 9.00\nPoint: (3, -9), Area: 13.50\nPoint: (7, 7), Area: 24.50\nPoint: (-7, 7), Area: 24.50\nPoint: (8, 8), Area: 32.00\n"}]}
{"messages": [{"role": "user", "content": "def find_nearest_lower(nums, target):\n    low, high = 0, len(nums) - 1\n    result = -1\n    while low <= high:\n        mid = (low + high) // 2\n        print(f\"Low: {low}, High: {high}, Mid: {mid}, Current: {nums[mid]}\")\n        if nums[mid] < target:\n            result = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    return result\n\ndata = [3, 8, 10, 15, 18, 22, 27, 31, 36, 40, 45, 50, 55, 60, 65]\ntarget_values = [5, 25, 35, 44, 48, 55, 70]\n\nfor target in target_values:\n    index = find_nearest_lower(data, target)\n    if index != -1:\n        print(f\"Target: {target}, Nearest Lower: {data[index]}\")\n    else:\n        print(f\"Target: {target}, Nearest Lower: None\")"}, {"role": "assistant", "content": "Low: 0, High: 14, Mid: 7, Current: 31\nLow: 0, High: 6, Mid: 3, Current: 15\nLow: 0, High: 2, Mid: 1, Current: 8\nLow: 0, High: 0, Mid: 0, Current: 3\nTarget: 5, Nearest Lower: 3\nLow: 0, High: 14, Mid: 7, Current: 31\nLow: 0, High: 6, Mid: 3, Current: 15\nLow: 4, High: 6, Mid: 5, Current: 22\nLow: 6, High: 6, Mid: 6, Current: 27\nTarget: 25, Nearest Lower: 22\nLow: 0, High: 14, Mid: 7, Current: 31\nLow: 8, High: 14, Mid: 11, Current: 50\nLow: 8, High: 10, Mid: 9, Current: 40\nLow: 8, High: 8, Mid: 8, Current: 36\nTarget: 35, Nearest Lower: 31\nLow: 0, High: 14, Mid: 7, Current: 31\nLow: 8, High: 14, Mid: 11, Current: 50\nLow: 8, High: 10, Mid: 9, Current: 40\nLow: 10, High: 10, Mid: 10, Current: 45\nTarget: 44, Nearest Lower: 40\nLow: 0, High: 14, Mid: 7, Current: 31\nLow: 8, High: 14, Mid: 11, Current: 50\nLow: 8, High: 10, Mid: 9, Current: 40\nLow: 10, High: 10, Mid: 10, Current: 45\nTarget: 48, Nearest Lower: 45\nLow: 0, High: 14, Mid: 7, Current: 31\nLow: 8, High: 14, Mid: 11, Current: 50\nLow: 12, High: 14, Mid: 13, Current: 60\nLow: 12, High: 12, Mid: 12, Current: 55\nTarget: 55, Nearest Lower: 50\nLow: 0, High: 14, Mid: 7, Current: 31\nLow: 8, High: 14, Mid: 11, Current: 50\nLow: 12, High: 14, Mid: 13, Current: 60\nLow: 14, High: 14, Mid: 14, Current: 65\nTarget: 70, Nearest Lower: 65\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef is_leap_year(year):\n    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n\ndef find_dates_with_31_days(year):\n    months_with_31_days = []\n    for month in range(1, 13):\n        try:\n            date = datetime(year, month, 31)\n            if date.month == month:\n                months_with_31_days.append(date.strftime(\"%B\"))\n        except ValueError:\n            pass\n    return months_with_31_days\n\ndef search_closest_friday_13th(start_year, end_year):\n    closest_friday_13ths = []\n    for year in range(start_year, end_year + 1):\n        for month in range(1, 13):\n            date = datetime(year, month, 13)\n            if date.weekday() == 4:\n                closest_friday_13ths.append(date.strftime(\"%Y-%m-%d\"))\n    return closest_friday_13ths\n\ncurrent_year = datetime.now().year\nprint(f\"Months with 31 days in {current_year}:\")\nprint(find_dates_with_31_days(current_year))\n\nstart_year = current_year - 5\nend_year = current_year\nprint(f\"\\nSearching for Friday the 13ths between {start_year} and {end_year}:\")\n\nfriday_13ths = search_closest_friday_13th(start_year, end_year)\nfor friday in friday_13ths:\n    print(friday)"}, {"role": "assistant", "content": "Months with 31 days in 2025:\n['January', 'March', 'May', 'July', 'August', 'October', 'December']\n\nSearching for Friday the 13ths between 2020 and 2025:\n2020-03-13\n2020-11-13\n2021-08-13\n2022-05-13\n2023-01-13\n2023-10-13\n2024-09-13\n2024-12-13\n2025-06-13\n"}]}
{"messages": [{"role": "user", "content": "from collections import defaultdict\n\ndef sort_words_by_vowel_count(text):\n    vowel_count_dict = defaultdict(list)\n    vowels = set(\"aeiouAEIOU\")\n    \n    for word in text.split():\n        count = sum(1 for char in word if char in vowels)\n        vowel_count_dict[count].append(word)\n        \n    sorted_counts = sorted(vowel_count_dict.keys(), reverse=True)\n    \n    for count in sorted_counts:\n        vowel_count_dict[count].sort()\n        print(f\"Words with {count} vowels:\")\n        for word in vowel_count_dict[count]:\n            print(word)\n        print(\"----\")\n\ntext = \"\"\"\n    The quick brown fox jumps over the lazy dog in an extraordinary fashion\n    while considering the implications of its decisions and the ramifications\n    of its actions in a world full of possibilities and endless opportunities.\n\"\"\"\n\nsort_words_by_vowel_count(text)"}, {"role": "assistant", "content": "Words with 6 vowels:\nopportunities.\npossibilities\nramifications\n----\nWords with 5 vowels:\nextraordinary\nimplications\n----\nWords with 4 vowels:\nconsidering\ndecisions\n----\nWords with 3 vowels:\nactions\nfashion\n----\nWords with 2 vowels:\nendless\nover\nquick\nwhile\n----\nWords with 1 vowels:\nThe\na\nan\nand\nand\nbrown\ndog\nfox\nfull\nin\nin\nits\nits\njumps\nlazy\nof\nof\nof\nthe\nthe\nthe\nworld\n----\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef custom_sort_key(word):\n    transformed = ''.join([str(ord(c)) for c in word])\n    return int(transformed)\n\ndef encrypt_message(message):\n    words = re.findall(r'\\b\\w+\\b', message)\n    sorted_words = sorted(words, key=custom_sort_key)\n    return ' '.join(sorted_words)\n\ndef main():\n    message = (\n        \"Encrypting messages is essential in the modern era where data privacy \"\n        \"is a top priority for individuals and organizations alike\"\n    )\n    encrypted_message = encrypt_message(message)\n    print(encrypted_message)\n\nif __name__ == \"__main__\":\n    main()"}, {"role": "assistant", "content": "a in is is era and for the top data alike where modern privacy messages priority essential Encrypting individuals organizations\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\ndef encode_message(message):\n    return \"\".join(chr((ord(char) + 5) % 256) for char in message)\n\ndef decode_message(encoded):\n    return \"\".join(chr((ord(char) - 5) % 256) for char in encoded)\n\ndef sort_dates(encoded_dates):\n    decoded_dates = [(date_str, decode_message(date_str)) for date_str in encoded_dates]\n    date_objects = [(date_str, datetime.strptime(decoded, \"%Y-%m-%d\")) for date_str, decoded in decoded_dates]\n    sorted_date_objects = sorted(date_objects, key=lambda x: x[1])\n    return [encoded for encoded, _ in sorted_date_objects]\n\ndates = [\n    encode_message(\"2023-10-07\"),\n    encode_message(\"2021-05-21\"),\n    encode_message(\"2022-12-25\"),\n    encode_message(\"2020-01-01\"),\n    encode_message(\"2023-04-15\"),\n    encode_message(\"2023-07-19\"),\n    encode_message(\"2019-08-09\"),\n    encode_message(\"2024-02-29\"),\n    encode_message(\"2025-11-11\"),\n    encode_message(\"2022-06-30\"),\n    encode_message(\"2023-03-08\"),\n    encode_message(\"2021-09-17\"),\n    encode_message(\"2020-11-30\"),\n    encode_message(\"2021-12-31\"),\n    encode_message(\"2023-01-01\"),\n    encode_message(\"2022-08-15\"),\n    encode_message(\"2023-05-05\"),\n    encode_message(\"2020-07-07\"),\n    encode_message(\"2021-03-14\"),\n    encode_message(\"2022-02-14\")\n]\n\nsorted_encoded_dates = sort_dates(dates)\nfor encoded_date in sorted_encoded_dates:\n    print(encoded_date)"}, {"role": "assistant", "content": "756>25=25>\n7575256256\n757525<25<\n7575266285\n7576258269\n757625:276\n757625>26<\n7576267286\n7577257269\n757725;285\n757725=26:\n757726727:\n7578256256\n757825825=\n757825926:\n757825:25:\n757825<26>\n757826525<\n757925727>\n757:266266\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef find_leap_years(start_year, end_year):\n    leap_years = []\n    for year in range(start_year, end_year + 1):\n        date = datetime(year, 2, 29)\n        if date.year == year:\n            leap_years.append(year)\n    return leap_years\n\ndef search_next_friday_13th(start_date):\n    current_date = start_date\n    while True:\n        if current_date.day == 13 and current_date.weekday() == 4:\n            return current_date\n        current_date += timedelta(days=1)\n\nstart_year = 1900\nend_year = 2100\nleap_years = find_leap_years(start_year, end_year)\n\nstart_date = datetime(2023, 1, 1)\nnext_friday_13ths = []\n\nfor _ in range(20):\n    next_friday_13th = search_next_friday_13th(start_date)\n    next_friday_13ths.append(next_friday_13th.strftime('%Y-%m-%d'))\n    start_date = next_friday_13th + timedelta(days=1)\n\noutput_lines = [f\"Leap Years: {leap_years}\\n\", \"Next 20 Friday the 13ths:\\n\"] + next_friday_13ths\nprint(\"\\n\".join(output_lines))"}, {"role": "assistant", "content": "Traceback (most recent call last):\n  File \"<string>\", line 20, in <module>\n  File \"<string>\", line 6, in find_leap_years\nValueError: day is out of range for month\n"}]}
{"messages": [{"role": "user", "content": "def find_optimal_move(board, player):\n    opponent = 'X' if player == 'O' else 'O'\n    best_score = -float('inf')\n    best_move = None\n\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == ' ':\n                board[i][j] = player\n                score = minimax(board, 0, False, player, opponent)\n                board[i][j] = ' '\n                if score > best_score:\n                    best_score = score\n                    best_move = (i, j)\n    \n    return best_move\n\ndef minimax(board, depth, is_maximizing, player, opponent):\n    winner = check_winner(board)\n    if winner == player:\n        return 1\n    elif winner == opponent:\n        return -1\n    elif is_board_full(board):\n        return 0\n\n    if is_maximizing:\n        best_score = -float('inf')\n        for i in range(3):\n            for j in range(3):\n                if board[i][j] == ' ':\n                    board[i][j] = player\n                    score = minimax(board, depth + 1, False, player, opponent)\n                    board[i][j] = ' '\n                    best_score = max(score, best_score)\n        return best_score\n    else:\n        best_score = float('inf')\n        for i in range(3):\n            for j in range(3):\n                if board[i][j] == ' ':\n                    board[i][j] = opponent\n                    score = minimax(board, depth + 1, True, player, opponent)\n                    board[i][j] = ' '\n                    best_score = min(score, best_score)\n        return best_score\n\ndef check_winner(board):\n    lines = [\n        [board[0][0], board[0][1], board[0][2]],\n        [board[1][0], board[1][1], board[1][2]],\n        [board[2][0], board[2][1], board[2][2]],\n        [board[0][0], board[1][0], board[2][0]],\n        [board[0][1], board[1][1], board[2][1]],\n        [board[0][2], board[1][2], board[2][2]],\n        [board[0][0], board[1][1], board[2][2]],\n        [board[2][0], board[1][1], board[0][2]],\n    ]\n    for line in lines:\n        if line[0] == line[1] == line[2] != ' ':\n            return line[0]\n    return None\n\ndef is_board_full(board):\n    for row in board:\n        if ' ' in row:\n            return False\n    return True\n\ndef print_board(board):\n    for row in board:\n        print('|'.join(row))\n        print(\"-+-+-\")\n\nboard = [\n    ['X', 'O', 'X'],\n    ['O', ' ', ' '],\n    ['X', ' ', 'O']\n]\n\nplayer = 'X'\nmove = find_optimal_move(board, player)\nprint(\"Optimal move for player '{}' is: {}\".format(player, move))\n\nboard[move[0]][move[1]] = player\nprint(\"Updated Board:\")\nprint_board(board)"}, {"role": "assistant", "content": "Optimal move for player 'X' is: (1, 1)\nUpdated Board:\nX|O|X\n-+-+-\nO|X| \n-+-+-\nX| |O\n-+-+-\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndata = [\n    (\"2023-01-01\", 10),\n    (\"2023-01-02\", 15),\n    (\"2023-01-03\", 20),\n    (\"2023-01-04\", 25),\n    (\"2023-01-05\", 30),\n    (\"2023-01-06\", 35),\n    (\"2023-01-07\", 40),\n    (\"2023-01-08\", 45),\n    (\"2023-01-09\", 50),\n    (\"2023-01-10\", 55),\n    (\"2023-01-11\", 60),\n    (\"2023-01-12\", 65),\n    (\"2023-01-13\", 70),\n    (\"2023-01-14\", 75),\n    (\"2023-01-15\", 80)\n]\n\nstart_date = datetime.datetime.strptime(\"2023-01-05\", \"%Y-%m-%d\")\nend_date = datetime.datetime.strptime(\"2023-01-12\", \"%Y-%m-%d\")\n\ndef binary_search(data, target_date):\n    low = 0\n    high = len(data) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        mid_date = datetime.datetime.strptime(data[mid][0], \"%Y-%m-%d\")\n        if mid_date < target_date:\n            low = mid + 1\n        elif mid_date > target_date:\n            high = mid - 1\n        else:\n            return mid\n    return None\n\nstart_index = binary_search(data, start_date)\nend_index = binary_search(data, end_date)\n\nif start_index is not None and end_index is not None:\n    for record in data[start_index:end_index + 1]:\n        print(record)"}, {"role": "assistant", "content": "('2023-01-05', 30)\n('2023-01-06', 35)\n('2023-01-07', 40)\n('2023-01-08', 45)\n('2023-01-09', 50)\n('2023-01-10', 55)\n('2023-01-11', 60)\n('2023-01-12', 65)\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef buggy_sort(data):\n    sorted_data = sorted(data, reverse=True)\n    print(\"Data sorted in descending order:\", sorted_data)\n    return sorted_data\n\ndef analyze_data(data):\n    median_value = statistics.median(data)\n    print(\"Median of data is:\", median_value)\n    \n    sorted_data = buggy_sort(data)\n    print(\"Sorted data:\", sorted_data)\n    \n    above_median = [x for x in sorted_data if x > median_value]\n    print(\"Values above median:\", above_median)\n    return above_median\n\ndata = [5, 1, 9, 3, 7, 8, 2, 6, 4, 10]\nabove_median_values = analyze_data(data)\n\nprint(\"Final values above median:\", above_median_values)"}, {"role": "assistant", "content": "Median of data is: 5.5\nData sorted in descending order: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\nSorted data: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\nValues above median: [10, 9, 8, 7, 6]\nFinal values above median: [10, 9, 8, 7, 6]\n"}]}
{"messages": [{"role": "user", "content": "def generate_pattern(n):\n    pattern = []\n    for i in range(1, n + 1):\n        pattern.append(''.join(str((j % 10)) for j in range(1, i + 1)))\n    return pattern\n\ndef sort_pattern(pattern):\n    return sorted(pattern, key=lambda x: (len(x), x[-1], x))\n\ndef display_pattern(sorted_pattern):\n    for line in sorted_pattern:\n        print(line)\n\nn = 10\npattern = generate_pattern(n)\nsorted_pattern = sort_pattern(pattern)\ndisplay_pattern(sorted_pattern)"}, {"role": "assistant", "content": "1\n12\n123\n1234\n12345\n123456\n1234567\n12345678\n123456789\n1234567890\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef perimeter_of_polygon(vertices):\n    perimeter = 0\n    for i in range(len(vertices)):\n        x1, y1 = vertices[i]\n        x2, y2 = vertices[(i + 1) % len(vertices)]\n        perimeter += math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n    return perimeter\n\ndef closest_polygon(target_perimeter, polygons):\n    min_diff = float('inf')\n    closest_poly = None\n    for polygon in polygons:\n        p = perimeter_of_polygon(polygon)\n        diff = abs(p - target_perimeter)\n        if diff < min_diff:\n            min_diff = diff\n            closest_poly = polygon\n    return closest_poly, min_diff\n\npolygons = [\n    [(0, 0), (2, 0), (1, 1)],\n    [(0, 0), (4, 0), (4, 3), (0, 3)],\n    [(0, 0), (3, 0), (3, 3), (0, 3)],\n    [(0, 0), (1, 0), (1, 1), (0, 1)],\n    [(0, 0), (5, 0), (5, 2), (0, 2)]\n]\n\ntarget_perimeter = 12.0\nclosest_poly, diff = closest_polygon(target_perimeter, polygons)\n\nfor i, vertex in enumerate(closest_poly):\n    print(f\"Vertex {i + 1}: {vertex}\")\nprint(f\"Perimeter difference: {diff:.2f}\")"}, {"role": "assistant", "content": "Vertex 1: (0, 0)\nVertex 2: (3, 0)\nVertex 3: (3, 3)\nVertex 4: (0, 3)\nPerimeter difference: 0.00\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef is_perfect_square(x):\n    return int(math.sqrt(x)) ** 2 == x\n\ndef fibonacci_search(sequence, key):\n    fib_m2 = 0\n    fib_m1 = 1\n    fib_m = fib_m2 + fib_m1\n    \n    while fib_m < len(sequence):\n        fib_m2 = fib_m1\n        fib_m1 = fib_m\n        fib_m = fib_m2 + fib_m1\n\n    offset = -1\n\n    while fib_m > 1:\n        i = min(offset + fib_m2, len(sequence) - 1)\n        print(f\"Checking index {i} with value {sequence[i]}\")\n\n        if sequence[i] < key:\n            fib_m = fib_m1\n            fib_m1 = fib_m2\n            fib_m2 = fib_m - fib_m1\n            offset = i\n        elif sequence[i] > key:\n            fib_m = fib_m2\n            fib_m1 -= fib_m2\n            fib_m2 = fib_m - fib_m1\n        else:\n            return i\n\n    if fib_m1 and offset + 1 < len(sequence) and sequence[offset + 1] == key:\n        return offset + 1\n\n    print(\"Key not found in the sequence\")\n    return -1\n\ndef generate_sequence(limit):\n    sequence = []\n    for n in range(1, limit):\n        if is_perfect_square(n * (n + 1) // 2):\n            sequence.append(n * (n + 1) // 2)\n    return sequence\n\nsequence = generate_sequence(100)\nprint(\"Generated Sequence:\")\nprint(sequence)\n\nsearch_key = 15\nprint(f\"Searching for {search_key} in the sequence.\")\nindex = fibonacci_search(sequence, search_key)\n\nif index != -1:\n    print(f\"Found {search_key} at index {index}.\")\nelse:\n    print(f\"{search_key} is not in the sequence.\")"}, {"role": "assistant", "content": "Generated Sequence:\n[1, 36, 1225]\nSearching for 15 in the sequence.\nChecking index 0 with value 1\nChecking index 1 with value 36\nKey not found in the sequence\n15 is not in the sequence.\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef find_substrings(s, pattern):\n    return [m.start() for m in re.finditer(pattern, s)]\n\ndef transform_data(data):\n    transformed = []\n    for string in data:\n        substrings = find_substrings(string, r'[aeiou]{2}')\n        if substrings:\n            transformed.append((string, substrings))\n    return transformed\n\ndef search_transformed(data, keyword):\n    results = []\n    for item, positions in data:\n        if keyword in item:\n            results.append((item, positions))\n    return results\n\ndata = [\n    \"abacus\",\n    \"queue\",\n    \"education\",\n    \"coordinate\",\n    \"devious\",\n    \"sequoia\",\n    \"pneumonia\",\n    \"baobab\",\n    \"aeronautical\",\n    \"eulogy\",\n    \"euphoria\"\n]\n\ntransformed_data = transform_data(data)\nsearch_results = search_transformed(transformed_data, 'ou')\n\nfor result in search_results:\n    print(f\"String: {result[0]}, Positions of double vowels: {result[1]}\")"}, {"role": "assistant", "content": "String: devious, Positions of double vowels: [3]\n"}]}
{"messages": [{"role": "user", "content": "def tetris_piece_sort(pieces):\n    def piece_score(piece):\n        return sum(piece) + max(piece) * len(piece)\n\n    sorted_pieces = sorted(pieces, key=piece_score)\n    return sorted_pieces\n\ntetris_pieces = [\n    [4, 1, 1, 1],\n    [2, 2, 3],\n    [5, 5],\n    [3, 1, 4],\n    [2, 2, 2, 2],\n    [1, 1, 1, 1, 1, 1, 1],\n    [6, 2],\n    [3, 3, 3]\n]\n\nsorted_tetris_pieces = tetris_piece_sort(tetris_pieces)\n\nprint(\"Initial Tetris Pieces:\")\nfor piece in tetris_pieces:\n    print(piece)\nprint(\"\\nSorted Tetris Pieces by Complexity:\")\nfor piece in sorted_tetris_pieces:\n    print(piece)"}, {"role": "assistant", "content": "Initial Tetris Pieces:\n[4, 1, 1, 1]\n[2, 2, 3]\n[5, 5]\n[3, 1, 4]\n[2, 2, 2, 2]\n[1, 1, 1, 1, 1, 1, 1]\n[6, 2]\n[3, 3, 3]\n\nSorted Tetris Pieces by Complexity:\n[1, 1, 1, 1, 1, 1, 1]\n[2, 2, 3]\n[2, 2, 2, 2]\n[3, 3, 3]\n[5, 5]\n[3, 1, 4]\n[6, 2]\n[4, 1, 1, 1]\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndata = [\n    [5, 1, 9, 3, 14],\n    [2, 7, 1, 4, 2],\n    [10, 5, 8, 9, 12],\n    [3, 6, 2, 10, 7],\n    [9, 4, 5, 8, 0]\n]\n\ndef quicksort(arr):\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    return quicksort(left) + middle + quicksort(right)\n\nsorted_data = [quicksort(row) for row in data]\nmedians = [statistics.median(row) for row in sorted_data]\n\nfinal_data = quicksort(medians)\n\nfor value in final_data:\n    print(value)"}, {"role": "assistant", "content": "2\n5\n5\n6\n9\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"Once upon a time in a land far, far away, there lived a wise old king. \nHe had three sons, each with their own unique talents and ambitions. \nThe first son was brave and strong, the second was clever and quick-witted, \nand the third was kind and compassionate.\"\"\"\n\nsearch_words = [\"wise\", \"strong\", \"clever\", \"kind\", \"queen\", \"dragon\", \"ambitions\", \"quick-witted\"]\n\ndef search_text(word, text):\n    print(f\"Searching for: {word}\")\n    matches = re.finditer(r'\\b' + re.escape(word) + r'\\b', text, re.IGNORECASE)\n    positions = [match.start() for match in matches]\n    if positions:\n        print(f\"Word '{word}' found at positions: {positions}\")\n    else:\n        print(f\"Word '{word}' not found\")\n    return positions\n\nresults = {}\nfor word in search_words:\n    positions = search_text(word, text)\n    results[word] = positions\n\nprint(\"\\nSummary of search results:\")\nfor word, positions in results.items():\n    if positions:\n        print(f\"'{word}': {len(positions)} occurrence(s) at positions {positions}\")\n    else:\n        print(f\"'{word}': Not found\")"}, {"role": "assistant", "content": "Searching for: wise\nWord 'wise' found at positions: [56]\nSearching for: strong\nWord 'strong' found at positions: [170]\nSearching for: clever\nWord 'clever' found at positions: [193]\nSearching for: kind\nWord 'kind' found at positions: [237]\nSearching for: queen\nWord 'queen' not found\nSearching for: dragon\nWord 'dragon' not found\nSearching for: ambitions\nWord 'ambitions' found at positions: [130]\nSearching for: quick-witted\nWord 'quick-witted' found at positions: [204]\n\nSummary of search results:\n'wise': 1 occurrence(s) at positions [56]\n'strong': 1 occurrence(s) at positions [170]\n'clever': 1 occurrence(s) at positions [193]\n'kind': 1 occurrence(s) at positions [237]\n'queen': Not found\n'dragon': Not found\n'ambitions': 1 occurrence(s) at positions [130]\n'quick-witted': 1 occurrence(s) at positions [204]\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndates = [\n    datetime(2023, 1, 15),\n    datetime(2022, 12, 25),\n    datetime(2023, 3, 1),\n    datetime(2023, 2, 14),\n    datetime(2022, 11, 5),\n    datetime(2023, 4, 10),\n    datetime(2023, 5, 25),\n    datetime(2022, 6, 7),\n    datetime(2023, 8, 30),\n    datetime(2023, 7, 4),\n    datetime(2022, 9, 11),\n    datetime(2023, 10, 31),\n    datetime(2023, 12, 25),\n    datetime(2022, 2, 22),\n    datetime(2022, 3, 15)\n]\n\nprint(\"Original dates:\")\nfor date in dates:\n    print(date.strftime('%Y-%m-%d'))\n\nsorted_dates = sorted(dates, key=lambda x: (x.month, x.day))\n\nprint(\"\\nDates sorted by month and day:\")\nfor date in sorted_dates:\n    print(date.strftime('%Y-%m-%d'))\n\ntoday = datetime.now()\nnext_dates = [date for date in sorted_dates if date >= today]\nnext_dates += [date.replace(year=today.year + 1) for date in sorted_dates if date < today]\n\nprint(\"\\nNext upcoming dates:\")\nfor date in next_dates:\n    print(date.strftime('%Y-%m-%d'))"}, {"role": "assistant", "content": "Original dates:\n2023-01-15\n2022-12-25\n2023-03-01\n2023-02-14\n2022-11-05\n2023-04-10\n2023-05-25\n2022-06-07\n2023-08-30\n2023-07-04\n2022-09-11\n2023-10-31\n2023-12-25\n2022-02-22\n2022-03-15\n\nDates sorted by month and day:\n2023-01-15\n2023-02-14\n2022-02-22\n2023-03-01\n2022-03-15\n2023-04-10\n2023-05-25\n2022-06-07\n2023-07-04\n2023-08-30\n2022-09-11\n2023-10-31\n2022-11-05\n2022-12-25\n2023-12-25\n\nNext upcoming dates:\n2026-01-15\n2026-02-14\n2026-02-22\n2026-03-01\n2026-03-15\n2026-04-10\n2026-05-25\n2026-06-07\n2026-07-04\n2026-08-30\n2026-09-11\n2026-10-31\n2026-11-05\n2026-12-25\n2026-12-25\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\ndef closest_pair(points):\n    def merge_sort(arr):\n        if len(arr) > 1:\n            mid = len(arr) // 2\n            L = arr[:mid]\n            R = arr[mid:]\n\n            merge_sort(L)\n            merge_sort(R)\n\n            i = j = k = 0\n            while i < len(L) and j < len(R):\n                if L[i][1] < R[j][1]:\n                    arr[k] = L[i]\n                    i += 1\n                else:\n                    arr[k] = R[j]\n                    j += 1\n                k += 1\n\n            while i < len(L):\n                arr[k] = L[i]\n                i += 1\n                k += 1\n\n            while j < len(R):\n                arr[k] = R[j]\n                j += 1\n                k += 1\n\n    def closest_pair_recursive(pts_sorted_by_x):\n        if len(pts_sorted_by_x) <= 3:\n            min_dist = float('inf')\n            for i in range(len(pts_sorted_by_x)):\n                for j in range(i + 1, len(pts_sorted_by_x)):\n                    d = distance(pts_sorted_by_x[i], pts_sorted_by_x[j])\n                    if d < min_dist:\n                        min_dist = d\n            return min_dist\n\n        mid = len(pts_sorted_by_x) // 2\n        left_x = pts_sorted_by_x[:mid]\n        right_x = pts_sorted_by_x[mid:]\n\n        min_left = closest_pair_recursive(left_x)\n        min_right = closest_pair_recursive(right_x)\n        min_dist = min(min_left, min_right)\n\n        mid_x = left_x[-1][0]\n        strip = [p for p in pts_sorted_by_x if abs(p[0] - mid_x) < min_dist]\n        merge_sort(strip)\n\n        for i in range(len(strip)):\n            for j in range(i + 1, min(i + 7, len(strip))):\n                d = distance(strip[i], strip[j])\n                if d < min_dist:\n                    min_dist = d\n\n        return min_dist\n\n    x_sorted = sorted(points, key=lambda p: p[0])\n    return closest_pair_recursive(x_sorted)\n\npoints = [(0, 0), (1, 1), (3, 4), (7, 5), (13, 3), (5, 5), (2, 8), (6, 9), (8, 10), (10, 12)]\nresult = closest_pair(points)\n\nprint(\"\\nThe closest pair distance is:\", result)"}, {"role": "assistant", "content": "\nThe closest pair distance is: 1.4142135623730951\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef find_most_frequent_date(dates):\n    date_counts = {}\n    for date in dates:\n        if date in date_counts:\n            date_counts[date] += 1\n        else:\n            date_counts[date] = 1\n    \n    sorted_dates = sorted(date_counts.items(), key=lambda x: (-x[1], x[0]))\n    most_frequent_date, frequency = sorted_dates[0]\n    \n    return most_frequent_date, frequency\n\nbase_date = datetime(2023, 1, 1)\ndates = [base_date + timedelta(days=i % 31) for i in range(100)]\n\nmost_frequent_date, frequency = find_most_frequent_date(dates)\n\nfor date, count in sorted(find_most_frequent_date(dates) for _ in range(10)):\n    print(f\"Date: {date.strftime('%Y-%m-%d')}, Frequency: {count}\")"}, {"role": "assistant", "content": "Date: 2023-01-01, Frequency: 4\nDate: 2023-01-01, Frequency: 4\nDate: 2023-01-01, Frequency: 4\nDate: 2023-01-01, Frequency: 4\nDate: 2023-01-01, Frequency: 4\nDate: 2023-01-01, Frequency: 4\nDate: 2023-01-01, Frequency: 4\nDate: 2023-01-01, Frequency: 4\nDate: 2023-01-01, Frequency: 4\nDate: 2023-01-01, Frequency: 4\n"}]}
{"messages": [{"role": "user", "content": "def sort_names_by_length(names):\n    print(\"Original names:\", names)\n    sorted_names = sorted(names, key=len, reverse=True)\n    print(\"Names sorted by length (ascending):\", sorted_names)\n    return sorted_names\n\nnames_list = [\n    \"Alice\", \"Bob\", \"Charlotte\", \"Daniel\",\n    \"Eve\", \"Frank\", \"Georgina\", \"Harold\",\n    \"Isabella\", \"Jonathan\", \"Katherine\", \"Leon\"\n]\n\nsorted_names = sort_names_by_length(names_list)\n\nprint(\"\\nFinal sorted names:\")\nfor name in sorted_names:\n    print(name)"}, {"role": "assistant", "content": "Original names: ['Alice', 'Bob', 'Charlotte', 'Daniel', 'Eve', 'Frank', 'Georgina', 'Harold', 'Isabella', 'Jonathan', 'Katherine', 'Leon']\nNames sorted by length (ascending): ['Charlotte', 'Katherine', 'Georgina', 'Isabella', 'Jonathan', 'Daniel', 'Harold', 'Alice', 'Frank', 'Leon', 'Bob', 'Eve']\n\nFinal sorted names:\nCharlotte\nKatherine\nGeorgina\nIsabella\nJonathan\nDaniel\nHarold\nAlice\nFrank\nLeon\nBob\nEve\n"}]}
{"messages": [{"role": "user", "content": "def zigzag_search(n):\n    matrix = [[0] * n for _ in range(n)]\n    num = 1\n    for diag in range(2 * n - 1):\n        if diag % 2 == 0:\n            x = min(diag, n - 1)\n            y = diag - x\n            while x >= 0 and y < n:\n                matrix[x][y] = num\n                num += 1\n                x -= 1\n                y += 1\n        else:\n            y = min(diag, n - 1)\n            x = diag - y\n            while y >= 0 and x < n:\n                matrix[x][y] = num\n                num += 1\n                x += 1\n                y -= 1\n    return matrix\n\nsize = 10\nresult = zigzag_search(size)\nfor row in result:\n    print(\" \".join(f\"{num:3}\" for num in row))"}, {"role": "assistant", "content": "  1   2   6   7  15  16  28  29  45  46\n  3   5   8  14  17  27  30  44  47  64\n  4   9  13  18  26  31  43  48  63  65\n 10  12  19  25  32  42  49  62  66  79\n 11  20  24  33  41  50  61  67  78  80\n 21  23  34  40  51  60  68  77  81  90\n 22  35  39  52  59  69  76  82  89  91\n 36  38  53  58  70  75  83  88  92  97\n 37  54  57  71  74  84  87  93  96  98\n 55  56  72  73  85  86  94  95  99 100\n"}]}
{"messages": [{"role": "user", "content": "def knight_moves(start, end):\n    directions = [\n        (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (1, 2), (1, -2), (-1, 2), (-1, -2)\n    ]\n    \n    board_size = 8\n    visited = set()\n    queue = [(start, 0)]\n    \n    while queue:\n        (current_x, current_y), moves = queue.pop(0)\n        if (current_x, current_y) == end:\n            return moves\n        if (current_x, current_y) in visited:\n            continue\n        visited.add((current_x, current_y))\n        \n        for dx, dy in directions:\n            new_x, new_y = current_x + dx, current_y + dy\n            if 0 <= new_x < board_size and 0 <= new_y < board_size:\n                queue.append(((new_x, new_y), moves + 1))\n    return -1\n\ndef solve_knights_puzzle():\n    positions = [\n        ((0, 0), (7, 7)), ((6, 6), (7, 7)), ((3, 3), (0, 0)),\n        ((1, 1), (2, 2)), ((4, 2), (6, 0)), ((2, 5), (5, 2)),\n        ((0, 1), (7, 6)), ((7, 1), (0, 6)), ((4, 4), (4, 4)),\n        ((5, 5), (7, 3)), ((3, 7), (0, 0)), ((6, 7), (0, 1)),\n        ((1, 6), (6, 1)), ((0, 7), (7, 0)), ((2, 0), (0, 2)),\n        ((7, 7), (5, 5)), ((0, 0), (4, 6)), ((5, 1), (2, 6)),\n        ((6, 4), (5, 5)), ((3, 4), (2, 5))\n    ]\n    results = [knight_moves(start, end) for start, end in positions]\n    return results\n\nfor result in solve_knights_puzzle():\n    print(result)"}, {"role": "assistant", "content": "6\n4\n2\n2\n4\n2\n4\n4\n0\n4\n4\n4\n4\n6\n4\n4\n4\n4\n2\n2\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef vigenere_decrypt(ciphertext, keyword):\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    keyword_repeated = ''.join(keyword[i % len(keyword)] for i in range(len(ciphertext)))\n    plaintext = []\n\n    for c, k in zip(ciphertext, keyword_repeated):\n        if c in alphabet:\n            c_index = alphabet.index(c)\n            k_index = alphabet.index(k)\n            p_index = (c_index - k_index) % len(alphabet)\n            plaintext.append(alphabet[p_index])\n        else:\n            plaintext.append(c)\n\n    return ''.join(plaintext)\n\ndef find_keyword(ciphertext, plaintext):\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    possible_keywords = set()\n\n    for key_length in range(1, len(plaintext) + 1):\n        keyword = []\n        for i in range(key_length):\n            segment = []\n            for j in range(i, len(plaintext), key_length):\n                if plaintext[j] in alphabet and ciphertext[j] in alphabet:\n                    p_index = alphabet.index(plaintext[j])\n                    c_index = alphabet.index(ciphertext[j])\n                    k_index = (c_index - p_index) % len(alphabet)\n                    segment.append(alphabet[k_index])\n            if segment:\n                keyword.append(segment[0])\n        possible_keywords.add(''.join(keyword))\n    \n    return possible_keywords\n\nciphertext = 'RIJVSUYVJN'\nplaintext = 'HELLOWORLD'\n\nkeywords = find_keyword(ciphertext, plaintext)\n\nfor keyword in keywords:\n    decrypted_text = vigenere_decrypt(ciphertext, keyword)\n    print(f\"Keyword: {keyword} -> Decrypted: {decrypted_text}\")"}, {"role": "assistant", "content": "Keyword: KEY -> Decrypted: HELLOWORLD\nKeyword: KEYKEY -> Decrypted: HELLOWORLD\nKeyword: KEYKEYKEYK -> Decrypted: HELLOWORLD\nKeyword: KEYK -> Decrypted: HELLIQALZJ\nKeyword: KE -> Decrypted: HEZRIQORZJ\nKeyword: K -> Decrypted: HYZLIKOLZD\nKeyword: KEYKEYKEY -> Decrypted: HELLOWORLD\nKeyword: KEYKE -> Decrypted: HELLOKUXZJ\nKeyword: KEYKEYK -> Decrypted: HELLOWOLFP\nKeyword: KEYKEYKE -> Decrypted: HELLOWORZJ\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\ndef is_sorted_odd_even(sequence):\n    odd_numbers = sorted([x for x in sequence if x % 2 != 0])\n    even_numbers = sorted([x for x in sequence if x % 2 == 0], reverse=True)\n    return odd_numbers + even_numbers\n\nsequence = [5, 3, 8, 6, 1, 7, 10, 2, 4, 9]\nsorted_sequence = is_sorted_odd_even(sequence)\n\nfor i, num in enumerate(sorted_sequence):\n    print(f\"{i+1:02d}: {num} - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\")"}, {"role": "assistant", "content": "01: 1 - 2025-04-01 16:07:47\n02: 3 - 2025-04-01 16:07:47\n03: 5 - 2025-04-01 16:07:47\n04: 7 - 2025-04-01 16:07:47\n05: 9 - 2025-04-01 16:07:47\n06: 10 - 2025-04-01 16:07:47\n07: 8 - 2025-04-01 16:07:47\n08: 6 - 2025-04-01 16:07:47\n09: 4 - 2025-04-01 16:07:47\n10: 2 - 2025-04-01 16:07:47\n"}]}
{"messages": [{"role": "user", "content": "import re\nfrom collections import Counter\n\ntext = \"\"\"\nArtificial intelligence, machine learning, and deep learning are rapidly evolving fields. Understanding the nuances of these terms is key to navigating the complexities of modern technology.\nEffective communication in tech depends on clear and precise language. As technology progresses, so does the vocabulary that describes it.\n\"\"\"\n\nwords = re.findall(r'\\b\\w+\\b', text.lower())\nprint(\"Words extracted from text:\", words)\n\nfrequency = Counter(words)\nprint(\"Word Frequency:\", frequency)\n\nsorted_words = sorted(frequency.items(), key=lambda x: (-x[1], x[0]))\nprint(\"Sorted words by frequency and alphabetically:\", sorted_words)\n\noutput_lines = []\nfor word, freq in sorted_words:\n    if freq > 1:\n        output_lines.append(f\"{word}: {freq}\")\n\nprint(\"Words with frequency > 1:\")\nfor line in output_lines:\n    print(line)"}, {"role": "assistant", "content": "Words extracted from text: ['artificial', 'intelligence', 'machine', 'learning', 'and', 'deep', 'learning', 'are', 'rapidly', 'evolving', 'fields', 'understanding', 'the', 'nuances', 'of', 'these', 'terms', 'is', 'key', 'to', 'navigating', 'the', 'complexities', 'of', 'modern', 'technology', 'effective', 'communication', 'in', 'tech', 'depends', 'on', 'clear', 'and', 'precise', 'language', 'as', 'technology', 'progresses', 'so', 'does', 'the', 'vocabulary', 'that', 'describes', 'it']\nWord Frequency: Counter({'the': 3, 'learning': 2, 'and': 2, 'of': 2, 'technology': 2, 'artificial': 1, 'intelligence': 1, 'machine': 1, 'deep': 1, 'are': 1, 'rapidly': 1, 'evolving': 1, 'fields': 1, 'understanding': 1, 'nuances': 1, 'these': 1, 'terms': 1, 'is': 1, 'key': 1, 'to': 1, 'navigating': 1, 'complexities': 1, 'modern': 1, 'effective': 1, 'communication': 1, 'in': 1, 'tech': 1, 'depends': 1, 'on': 1, 'clear': 1, 'precise': 1, 'language': 1, 'as': 1, 'progresses': 1, 'so': 1, 'does': 1, 'vocabulary': 1, 'that': 1, 'describes': 1, 'it': 1})\nSorted words by frequency and alphabetically: [('the', 3), ('and', 2), ('learning', 2), ('of', 2), ('technology', 2), ('are', 1), ('artificial', 1), ('as', 1), ('clear', 1), ('communication', 1), ('complexities', 1), ('deep', 1), ('depends', 1), ('describes', 1), ('does', 1), ('effective', 1), ('evolving', 1), ('fields', 1), ('in', 1), ('intelligence', 1), ('is', 1), ('it', 1), ('key', 1), ('language', 1), ('machine', 1), ('modern', 1), ('navigating', 1), ('nuances', 1), ('on', 1), ('precise', 1), ('progresses', 1), ('rapidly', 1), ('so', 1), ('tech', 1), ('terms', 1), ('that', 1), ('these', 1), ('to', 1), ('understanding', 1), ('vocabulary', 1)]\nWords with frequency > 1:\nthe: 3\nand: 2\nlearning: 2\nof: 2\ntechnology: 2\n"}]}
{"messages": [{"role": "user", "content": "def generate_pattern(n):\n    pattern = []\n    for i in range(1, n + 1):\n        pattern.append((i, i ** 2))\n    return pattern\n\ndef binary_search(pattern, target):\n    low, high = 0, len(pattern) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if pattern[mid][1] == target:\n            return pattern[mid][0]\n        elif pattern[mid][1] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return None\n\nn = 100\npattern = generate_pattern(n)\ntargets = [i ** 2 for i in range(10, 20)]\nsearch_results = [(target, binary_search(pattern, target)) for target in targets]\n\nfor target, result in search_results:\n    print(f\"Target square {target}, found index: {result}\")"}, {"role": "assistant", "content": "Target square 100, found index: 10\nTarget square 121, found index: 11\nTarget square 144, found index: 12\nTarget square 169, found index: 13\nTarget square 196, found index: 14\nTarget square 225, found index: 15\nTarget square 256, found index: 16\nTarget square 289, found index: 17\nTarget square 324, found index: 18\nTarget square 361, found index: 19\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\ndef custom_sort(game_scores):\n    return sorted(game_scores, key=lambda x: x[1])\n\nplayers = [\n    ('Alice', datetime(2023, 10, 20, 14, 30), 85),\n    ('Bob', datetime(2023, 10, 20, 16, 45), 95),\n    ('Charlie', datetime(2023, 10, 20, 12, 10), 75),\n    ('Diana', datetime(2023, 10, 20, 11, 0), 65),\n    ('Eve', datetime(2023, 10, 20, 15, 55), 105)\n]\n\nsorted_players = custom_sort(players)\n\nfor player in sorted_players:\n    print(f\"Player: {player[0]}, Time: {player[1].strftime('%H:%M')}, Score: {player[2]}\")\n\nprint(\"\\nDebug: Sorted by score, expected by time\")"}, {"role": "assistant", "content": "Player: Diana, Time: 11:00, Score: 65\nPlayer: Charlie, Time: 12:10, Score: 75\nPlayer: Alice, Time: 14:30, Score: 85\nPlayer: Eve, Time: 15:55, Score: 105\nPlayer: Bob, Time: 16:45, Score: 95\n\nDebug: Sorted by score, expected by time\n"}]}
{"messages": [{"role": "user", "content": "def find_best_strategy():\n    strategies = [\"Attack\", \"Defend\", \"Retreat\", \"Negotiate\", \"Ambush\", \"Surprise\"]\n    scores = [8, 6, 7, 4, 9, 5]\n    \n    def search_strategy(strategy_list, score_list):\n        max_score = min(score_list)\n        max_index = score_list.index(max_score)\n        return strategy_list[max_index], max_score\n\n    best_strategy, best_score = search_strategy(strategies, scores)\n    return best_strategy, best_score\n\nstrategy, score = find_best_strategy()\n\nfor i in range(10):\n    print(f\"Strategy: {strategy}, Score: {score}\")"}, {"role": "assistant", "content": "Strategy: Negotiate, Score: 4\nStrategy: Negotiate, Score: 4\nStrategy: Negotiate, Score: 4\nStrategy: Negotiate, Score: 4\nStrategy: Negotiate, Score: 4\nStrategy: Negotiate, Score: 4\nStrategy: Negotiate, Score: 4\nStrategy: Negotiate, Score: 4\nStrategy: Negotiate, Score: 4\nStrategy: Negotiate, Score: 4\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef generate_dates(start_date, num_days, step_days):\n    dates = [start_date + timedelta(days=step_days * i) for i in range(num_days)]\n    return dates\n\ndef sort_dates_by_month_day(dates):\n    return sorted(dates, key=lambda date: (date.month, date.day))\n\nstart = datetime(2023, 1, 1)\ndates = generate_dates(start, 50, 3)\nsorted_dates = sort_dates_by_month_day(dates)\n\nfor date in sorted_dates:\n    print(date.strftime(\"%Y-%m-%d\"))"}, {"role": "assistant", "content": "2023-01-01\n2023-01-04\n2023-01-07\n2023-01-10\n2023-01-13\n2023-01-16\n2023-01-19\n2023-01-22\n2023-01-25\n2023-01-28\n2023-01-31\n2023-02-03\n2023-02-06\n2023-02-09\n2023-02-12\n2023-02-15\n2023-02-18\n2023-02-21\n2023-02-24\n2023-02-27\n2023-03-02\n2023-03-05\n2023-03-08\n2023-03-11\n2023-03-14\n2023-03-17\n2023-03-20\n2023-03-23\n2023-03-26\n2023-03-29\n2023-04-01\n2023-04-04\n2023-04-07\n2023-04-10\n2023-04-13\n2023-04-16\n2023-04-19\n2023-04-22\n2023-04-25\n2023-04-28\n2023-05-01\n2023-05-04\n2023-05-07\n2023-05-10\n2023-05-13\n2023-05-16\n2023-05-19\n2023-05-22\n2023-05-25\n2023-05-28\n"}]}
{"messages": [{"role": "user", "content": "import math\nimport statistics\n\ndef advanced_search_median_search(data):\n    data.sort()\n    median = data[len(data) // 2]\n    return median\n\ndef calculate_distance(point1, point2):\n    return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2)\n\ndef find_nearest_to_median(points):\n    x_coords = [p[0] for p in points]\n    median_x = advanced_search_median_search(x_coords)\n    min_distance = float('inf')\n    nearest_point = None\n    for point in points:\n        dist = calculate_distance((median_x, 0), point)\n        if dist < min_distance:\n            min_distance = dist\n            nearest_point = point\n    return nearest_point\n\npoints = [(2, 3), (5, 4), (9, 6), (4, 7), (8, 1), (7, 2), (1, 5), (3, 8), (6, 9), (0, 0)]\nnearest_point = find_nearest_to_median(points)\nfor point in points:\n    print(f\"Point: {point}, Distance to Nearest: {calculate_distance(point, nearest_point)}\")"}, {"role": "assistant", "content": "Point: (2, 3), Distance to Nearest: 5.0990195135927845\nPoint: (5, 4), Distance to Nearest: 2.8284271247461903\nPoint: (9, 6), Distance to Nearest: 4.47213595499958\nPoint: (4, 7), Distance to Nearest: 5.830951894845301\nPoint: (8, 1), Distance to Nearest: 1.4142135623730951\nPoint: (7, 2), Distance to Nearest: 0.0\nPoint: (1, 5), Distance to Nearest: 6.708203932499369\nPoint: (3, 8), Distance to Nearest: 7.211102550927978\nPoint: (6, 9), Distance to Nearest: 7.0710678118654755\nPoint: (0, 0), Distance to Nearest: 7.280109889280518\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef generate_sequence(n):\n    return [round(math.sin(i) * 100) for i in range(n)]\n\ndef find_local_extrema(seq):\n    extrema = []\n    for i in range(1, len(seq) - 1):\n        if (seq[i] > seq[i-1] and seq[i] > seq[i+1]) or (seq[i] < seq[i-1] and seq[i] < seq[i+1]):\n            extrema.append((i, seq[i]))\n    return extrema\n\ndef binary_search_closest(seq, target):\n    low, high = 0, len(seq) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        print(f\"Searching between indices {low} and {high}, middle at {mid}\")\n        if seq[mid] < target:\n            low = mid + 1\n        elif seq[mid] > target:\n            high = mid - 1\n        else:\n            return mid\n    return low if low < len(seq) and abs(seq[low] - target) < abs(seq[high] - target) else high\n\nsequence = generate_sequence(100)\nprint(\"Generated Sequence:\", sequence)\n\nextrema = find_local_extrema(sequence)\nprint(\"Local Extrema:\", extrema)\n\ntarget_value = 50\nprint(f\"Searching for closest to {target_value} in sequence.\")\nclosest_index = binary_search_closest(sequence, target_value)\nprint(f\"Closest value to {target_value} found at index {closest_index} with value {sequence[closest_index]}\")"}, {"role": "assistant", "content": "Generated Sequence: [0, 84, 91, 14, -76, -96, -28, 66, 99, 41, -54, -100, -54, 42, 99, 65, -29, -96, -75, 15, 91, 84, -1, -85, -91, -13, 76, 96, 27, -66, -99, -40, 55, 100, 53, -43, -99, -64, 30, 96, 75, -16, -92, -83, 2, 85, 90, 12, -77, -95, -26, 67, 99, 40, -56, -100, -52, 44, 99, 64, -30, -97, -74, 17, 92, 83, -3, -86, -90, -11, 77, 95, 25, -68, -99, -39, 57, 100, 51, -44, -99, -63, 31, 97, 73, -18, -92, -82, 4, 86, 89, 11, -78, -95, -25, 68, 98, 38, -57, -100]\nLocal Extrema: [(2, 91), (5, -96), (8, 99), (11, -100), (14, 99), (17, -96), (20, 91), (24, -91), (27, 96), (30, -99), (33, 100), (36, -99), (39, 96), (42, -92), (46, 90), (49, -95), (52, 99), (55, -100), (58, 99), (61, -97), (64, 92), (68, -90), (71, 95), (74, -99), (77, 100), (80, -99), (83, 97), (86, -92), (90, 89), (93, -95), (96, 98)]\nSearching for closest to 50 in sequence.\nSearching between indices 0 and 99, middle at 49\nSearching between indices 50 and 99, middle at 74\nSearching between indices 75 and 99, middle at 87\nSearching between indices 88 and 99, middle at 93\nSearching between indices 94 and 99, middle at 96\nSearching between indices 94 and 95, middle at 94\nSearching between indices 95 and 95, middle at 95\nClosest value to 50 found at index 95 with value 68\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef median_absolute_deviation(data):\n    data.sort()\n    median = data[len(data) // 2]\n    deviations = [abs(x - median) for x in data]\n    deviations.sort()\n    return deviations[len(deviations) // 2]\n\ndef quicksort(data):\n    if len(data) <= 1:\n        return data\n    pivot = data[len(data) // 2]\n    less = [x for x in data if x < pivot]\n    equal = [x for x in data if x == pivot]\n    greater = [x for x in data if x > pivot]\n    return quicksort(less) + equal + quicksort(greater)\n\ndef mean_absolute_deviation(data):\n    mean = sum(data) / len(data)\n    deviations = [abs(x - mean) for x in data]\n    return sum(deviations) / len(deviations)\n\ndata = [4, 2, 5, 8, 6, 7, 3, 9, 1, 0]\n\nsorted_data = quicksort(data)\nprint(\"Sorted Data: \", sorted_data)\n\nmad = median_absolute_deviation(data)\nprint(\"Median Absolute Deviation: \", mad)\n\nmad_mean = mean_absolute_deviation(sorted_data)\nprint(\"Mean Absolute Deviation (on sorted data): \", mad_mean)"}, {"role": "assistant", "content": "Sorted Data:  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nMedian Absolute Deviation:  3\nMean Absolute Deviation (on sorted data):  2.5\n"}]}
{"messages": [{"role": "user", "content": "import itertools\n\ndef collatz_length(n):\n    length = 1\n    while n != 1:\n        n = n // 2 if n % 2 == 0 else 3 * n + 1\n        length += 1\n    return length\n\ncollatz_sequence_lengths = [(i, collatz_length(i)) for i in range(1, 101)]\ncollatz_sequence_lengths.sort(key=lambda x: (x[1], x[0]))\n\ngrouped_by_length = itertools.groupby(collatz_sequence_lengths, key=lambda x: x[1])\n\nfor length, numbers in grouped_by_length:\n    sorted_numbers = sorted([num for num, _ in numbers])\n    print(f\"Length {length}: {sorted_numbers}\")"}, {"role": "assistant", "content": "Length 1: [1]\nLength 2: [2]\nLength 3: [4]\nLength 4: [8]\nLength 5: [16]\nLength 6: [5, 32]\nLength 7: [10, 64]\nLength 8: [3, 20, 21]\nLength 9: [6, 40, 42]\nLength 10: [12, 13, 80, 84, 85]\nLength 11: [24, 26]\nLength 12: [48, 52, 53]\nLength 13: [17, 96]\nLength 14: [34, 35]\nLength 15: [11, 68, 69, 70, 75]\nLength 16: [22, 23]\nLength 17: [7, 44, 45, 46]\nLength 18: [14, 15, 88, 90, 92, 93]\nLength 19: [28, 29, 30]\nLength 20: [9, 56, 58, 60, 61]\nLength 21: [18, 19]\nLength 22: [36, 37, 38]\nLength 23: [72, 74, 76, 77, 81]\nLength 24: [25]\nLength 25: [49, 50, 51]\nLength 26: [98, 99, 100]\nLength 27: [33]\nLength 28: [65, 66, 67]\nLength 30: [43]\nLength 31: [86, 87, 89]\nLength 33: [57, 59]\nLength 35: [39]\nLength 36: [78, 79]\nLength 93: [91]\nLength 103: [71]\nLength 105: [47]\nLength 106: [94, 95]\nLength 107: [31]\nLength 108: [62, 63]\nLength 110: [41]\nLength 111: [82, 83]\nLength 112: [27]\nLength 113: [54, 55]\nLength 116: [73]\nLength 119: [97]\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\ndef perimeter(points):\n    peri = 0\n    for i in range(len(points)):\n        peri += distance(points[i], points[(i + 1) % len(points)])\n    return peri\n\nshapes = [\n    [(0, 0), (4, 0), (4, 3), (0, 3)],\n    [(0, 0), (3, 0), (3, 3)],\n    [(1, 1), (5, 1), (3, 4)],\n    [(0, 0), (6, 0), (3, 6)],\n    [(2, 1), (7, 1), (7, 6), (2, 6)]\n]\n\nperimeters = [(perimeter(shape), shape) for shape in shapes]\nprint(\"Perimeters with Shapes:\")\nfor peri, shape in perimeters:\n    print(f\"Perimeter: {peri:.2f} | Shape: {shape}\")\n\nsorted_perimeters = sorted(perimeters)\nprint(\"\\nSorted Shapes by Perimeter:\")\nfor peri, shape in sorted_perimeters:\n    print(f\"Perimeter: {peri:.2f} | Shape: {shape}\")\n\nlargest_perimeter_shape = sorted_perimeters[-1][1]\nprint(\"\\nShape with the Largest Perimeter:\")\nprint(largest_perimeter_shape)"}, {"role": "assistant", "content": "Perimeters with Shapes:\nPerimeter: 14.00 | Shape: [(0, 0), (4, 0), (4, 3), (0, 3)]\nPerimeter: 10.24 | Shape: [(0, 0), (3, 0), (3, 3)]\nPerimeter: 11.21 | Shape: [(1, 1), (5, 1), (3, 4)]\nPerimeter: 19.42 | Shape: [(0, 0), (6, 0), (3, 6)]\nPerimeter: 20.00 | Shape: [(2, 1), (7, 1), (7, 6), (2, 6)]\n\nSorted Shapes by Perimeter:\nPerimeter: 10.24 | Shape: [(0, 0), (3, 0), (3, 3)]\nPerimeter: 11.21 | Shape: [(1, 1), (5, 1), (3, 4)]\nPerimeter: 14.00 | Shape: [(0, 0), (4, 0), (4, 3), (0, 3)]\nPerimeter: 19.42 | Shape: [(0, 0), (6, 0), (3, 6)]\nPerimeter: 20.00 | Shape: [(2, 1), (7, 1), (7, 6), (2, 6)]\n\nShape with the Largest Perimeter:\n[(2, 1), (7, 1), (7, 6), (2, 6)]\n"}]}
{"messages": [{"role": "user", "content": "def find_fib_index_with_property(n):\n    a, b = 0, 1\n    index = 1\n    while True:\n        a, b = b, a + b\n        index += 1\n        num_str = str(b)\n        if len(num_str) >= n:\n            if all(num_str[i] == num_str[-(i + 1)] for i in range(n)):\n                return index, b\n\nlength = 3\nindex, fibonacci_number = find_fib_index_with_property(length)\nprint(f\"The first Fibonacci number with at least {length} digits, where the first {length} digits form a palindrome, is:\")\nprint(f\"Index: {index}\")\nprint(f\"Fibonacci Number: {fibonacci_number}\")"}, {"role": "assistant", "content": "The first Fibonacci number with at least 3 digits, where the first 3 digits form a palindrome, is:\nIndex: 317\nFibonacci Number: 793591407804151926593793042126891128819610710140145037958273777397\n"}]}
{"messages": [{"role": "user", "content": "def encode_text(text):\n    return ''.join(format(ord(char), '08b') for char in text)\n\ndef decode_text(binary_sequence):\n    chars = [binary_sequence[i:i+8] for i in range(0, len(binary_sequence), 8)]\n    return ''.join(chr(int(b, 2)) for b in chars)\n\ndef sort_encoded(encoded_text):\n    return ''.join(sorted([encoded_text[i:i+8] for i in range(0, len(encoded_text), 8)]))\n\noriginal_text = \"encryption\"\nencoded = encode_text(original_text)\nsorted_encoded = sort_encoded(encoded)\ndecoded_sorted = decode_text(sorted_encoded)\n\nprint(\"Original Text:\", original_text)\nprint(\"Encoded Binary:\", encoded)\nprint(\"Sorted Encoded Binary:\", sorted_encoded)\nprint(\"Decoded Sorted Text:\", decoded_sorted)"}, {"role": "assistant", "content": "Original Text: encryption\nEncoded Binary: 01100101011011100110001101110010011110010111000001110100011010010110111101101110\nSorted Encoded Binary: 01100011011001010110100101101110011011100110111101110000011100100111010001111001\nDecoded Sorted Text: ceinnoprty\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"In the vast realm of data processing, text analysis stands out as a particularly interesting domain. \nThe goal is often to extract meaningful patterns from unstructured data. For instance, one might want to \nidentify the most frequently occurring words, locate particular phrases, or even detect the sentiment \nexpressed in a body of text. \n\nHowever, before any of this can be done, the text must be pre-processed. This involves several steps \nsuch as tokenization, stopword removal, and stemming or lemmatization. Once pre-processed, the text can \nbe searched or analyzed using various algorithms.\n\nSearching algorithms, for example, can be used to find specific patterns or keywords within the text. \nThese algorithms vary in complexity and efficiency, from simple linear searches to more sophisticated \napproaches like the Knuth-Morris-Pratt algorithm. The choice of algorithm often depends on the size of \nthe data and the specific requirements of the task at hand.\"\"\"\n\npattern = re.compile(r'\\b\\w{5,}\\b')\nmatches = pattern.findall(text)\n\nword_count = {}\nfor word in matches:\n    word_count[word] = word_count.get(word, 0) + 1\n\nsorted_words = sorted(word_count.items(), key=lambda item: item[1], reverse=True)\n\nfor word, count in sorted_words:\n    print(f'{word}: {count}')"}, {"role": "assistant", "content": "algorithms: 3\noften: 2\npatterns: 2\nprocessed: 2\nspecific: 2\nalgorithm: 2\nrealm: 1\nprocessing: 1\nanalysis: 1\nstands: 1\nparticularly: 1\ninteresting: 1\ndomain: 1\nextract: 1\nmeaningful: 1\nunstructured: 1\ninstance: 1\nmight: 1\nidentify: 1\nfrequently: 1\noccurring: 1\nwords: 1\nlocate: 1\nparticular: 1\nphrases: 1\ndetect: 1\nsentiment: 1\nexpressed: 1\nHowever: 1\nbefore: 1\ninvolves: 1\nseveral: 1\nsteps: 1\ntokenization: 1\nstopword: 1\nremoval: 1\nstemming: 1\nlemmatization: 1\nsearched: 1\nanalyzed: 1\nusing: 1\nvarious: 1\nSearching: 1\nexample: 1\nkeywords: 1\nwithin: 1\nThese: 1\ncomplexity: 1\nefficiency: 1\nsimple: 1\nlinear: 1\nsearches: 1\nsophisticated: 1\napproaches: 1\nKnuth: 1\nMorris: 1\nPratt: 1\nchoice: 1\ndepends: 1\nrequirements: 1\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef generate_dates(start_date, num_days):\n    return [(start_date + timedelta(days=i)).strftime('%Y-%m-%d') for i in range(num_days)]\n\ndata = {\n    \"2023-10-01\": 50,\n    \"2023-10-02\": 40,\n    \"2023-10-03\": 70,\n    \"2023-10-04\": 60,\n    \"2023-10-05\": 80,\n    \"2023-10-06\": 55,\n    \"2023-10-07\": 65,\n    \"2023-10-08\": 75,\n    \"2023-10-09\": 85,\n    \"2023-10-10\": 45,\n}\n\nstart_date = datetime.strptime(\"2023-10-01\", '%Y-%m-%d')\ndate_list = generate_dates(start_date, 10)\n\nsorted_data = sorted(data.items(), key=lambda x: x[1], reverse=True)\nanomalies = [(date, value) for date, value in sorted_data if value > 70]\n\nfor date, value in anomalies:\n    print(f\"Anomaly on {date}: Value = {value}\")"}, {"role": "assistant", "content": "Anomaly on 2023-10-09: Value = 85\nAnomaly on 2023-10-05: Value = 80\nAnomaly on 2023-10-08: Value = 75\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef find_birthday_weekdays(start_year, end_year):\n    weekdays_count = [0] * 7\n    for year in range(start_year, end_year + 1):\n        for month in range(1, 13):\n            first_day = datetime(year, month, 1)\n            last_day = (first_day + timedelta(days=32)).replace(day=1) - timedelta(days=1)\n            for day in range(1, last_day.day + 1):\n                current_day = datetime(year, month, day)\n                weekday_index = current_day.weekday()\n                weekdays_count[weekday_index] += 1\n    return weekdays_count\n\ndef weekday_name(index):\n    return [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"][index]\n\nstart_year = 1900\nend_year = 1903\n\nweekdays_count = find_birthday_weekdays(start_year, end_year)\nresults = sorted(enumerate(weekdays_count), key=lambda x: -x[1])\n\nfor index, count in results:\n    print(f\"{weekday_name(index)}: {count} birthdays\")"}, {"role": "assistant", "content": "Monday: 209 birthdays\nTuesday: 209 birthdays\nWednesday: 209 birthdays\nThursday: 209 birthdays\nFriday: 208 birthdays\nSaturday: 208 birthdays\nSunday: 208 birthdays\n"}]}
{"messages": [{"role": "user", "content": "def bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\n\ndef generate_pattern(n):\n    pattern = [i * (n - i) for i in range(n)]\n    print(f\"Initial pattern: {pattern}\")\n    sorted_pattern = bubble_sort(pattern)\n    print(f\"Sorted pattern: {sorted_pattern}\")\n    return sorted_pattern\n\ndef print_pattern(pattern):\n    for num in pattern:\n        print(' '.join(str(num) for _ in range(num)))\n\nn = 10\npattern = generate_pattern(n)\nprint(\"Final pattern:\")\nprint_pattern(pattern)"}, {"role": "assistant", "content": "Initial pattern: [0, 9, 16, 21, 24, 25, 24, 21, 16, 9]\nSorted pattern: [0, 9, 9, 16, 16, 21, 21, 24, 24, 25]\nFinal pattern:\n\n9 9 9 9 9 9 9 9 9\n9 9 9 9 9 9 9 9 9\n16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16\n16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16\n21 21 21 21 21 21 21 21 21 21 21 21 21 21 21 21 21 21 21 21 21\n21 21 21 21 21 21 21 21 21 21 21 21 21 21 21 21 21 21 21 21 21\n24 24 24 24 24 24 24 24 24 24 24 24 24 24 24 24 24 24 24 24 24 24 24 24\n24 24 24 24 24 24 24 24 24 24 24 24 24 24 24 24 24 24 24 24 24 24 24 24\n25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25\n"}]}
{"messages": [{"role": "user", "content": "players = [\n    {\"name\": \"Alice\", \"scores\": [5, 7, 8, 6]},\n    {\"name\": \"Bob\", \"scores\": [9, 5, 3, 7]},\n    {\"name\": \"Charlie\", \"scores\": [8, 9, 6, 5]},\n    {\"name\": \"David\", \"scores\": [6, 8, 9, 7]},\n    {\"name\": \"Eve\", \"scores\": [7, 6, 5, 8]},\n    {\"name\": \"Frank\", \"scores\": [5, 9, 8, 6]}\n]\n\ndef calculate_average(scores):\n    return sum(scores) / len(scores)\n\ndef sort_players_by_average(players):\n    return sorted(players, key=lambda player: calculate_average(player[\"scores\"]), reverse=True)\n\nsorted_players = sort_players_by_average(players)\n\nranked_players = []\nfor rank, player in enumerate(sorted_players, start=1):\n    average_score = calculate_average(player[\"scores\"])\n    ranked_players.append(f\"Rank {rank}: {player['name']}, Average Score: {average_score:.2f}\")\n\nfor player in ranked_players:\n    print(player)"}, {"role": "assistant", "content": "Rank 1: David, Average Score: 7.50\nRank 2: Charlie, Average Score: 7.00\nRank 3: Frank, Average Score: 7.00\nRank 4: Alice, Average Score: 6.50\nRank 5: Eve, Average Score: 6.50\nRank 6: Bob, Average Score: 6.00\n"}]}
{"messages": [{"role": "user", "content": "from itertools import product\n\ndef is_valid_move(board, x, y, n):\n    for i in range(9):\n        if board[x][i] == n or board[i][y] == n:\n            return False\n    subgrid_x, subgrid_y = 3 * (x // 3), 3 * (y // 3)\n    for i, j in product(range(3), repeat=2):\n        if board[subgrid_x + i][subgrid_y + j] == n:\n            return False\n    return True\n\ndef solve_sudoku(board):\n    for x, y in product(range(9), repeat=2):\n        if board[x][y] == 0:\n            for n in range(1, 10):\n                if is_valid_move(board, x, y, n):\n                    board[x][y] = n\n                    if solve_sudoku(board):\n                        return True\n                    board[x][y] = 0\n            return False\n    return True\n\nsudoku_board = [\n    [5, 3, 0, 0, 7, 0, 0, 0, 0],\n    [6, 0, 0, 1, 9, 5, 0, 0, 0],\n    [0, 9, 8, 0, 0, 0, 0, 6, 0],\n    [8, 0, 0, 0, 6, 0, 0, 0, 3],\n    [4, 0, 0, 8, 0, 3, 0, 0, 1],\n    [7, 0, 0, 0, 2, 0, 0, 0, 6],\n    [0, 6, 0, 0, 0, 0, 2, 8, 0],\n    [0, 0, 0, 4, 1, 9, 0, 0, 5],\n    [0, 0, 0, 0, 8, 0, 0, 7, 9],\n]\n\nsolve_sudoku(sudoku_board)\n\nfor row in sudoku_board:\n    print(row)"}, {"role": "assistant", "content": "[5, 3, 4, 6, 7, 8, 9, 1, 2]\n[6, 7, 2, 1, 9, 5, 3, 4, 8]\n[1, 9, 8, 3, 4, 2, 5, 6, 7]\n[8, 5, 9, 7, 6, 1, 4, 2, 3]\n[4, 2, 6, 8, 5, 3, 7, 9, 1]\n[7, 1, 3, 9, 2, 4, 8, 5, 6]\n[9, 6, 1, 5, 3, 7, 2, 8, 4]\n[2, 8, 7, 4, 1, 9, 6, 3, 5]\n[3, 4, 5, 2, 8, 6, 1, 7, 9]\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndata = [\n    2, 3, 5, 8, 12, 18, 21, 25, 28, 31,\n    35, 36, 38, 40, 42, 46, 47, 50, 53, 57,\n    60, 62, 65, 68, 71, 73, 75, 78, 80, 83,\n    86, 88, 90, 93, 95, 97, 100, 103, 106, 108\n]\n\ndef find_outlier(data):\n    median = statistics.median(data)\n    q1 = statistics.median(data[:len(data)//2])\n    q3 = statistics.median(data[len(data)//2:])\n    iqr = q3 - q1\n    lower_bound = q1 - 1.5 * iqr\n    upper_bound = q3 + 1.5 * iqr\n    \n    outliers = []\n    for value in data:\n        if value < lower_bound or value > upper_bound:\n            outliers.append(value)\n    return outliers\n\noutliers = find_outlier(data)\n\nif outliers:\n    print(\"Outliers found:\", outliers)\nelse:\n    print(\"No outliers found\")"}, {"role": "assistant", "content": "No outliers found\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef find_next_leap_years(start_year, count):\n    leap_years = []\n    year = start_year\n    while len(leap_years) < count:\n        if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):\n            leap_years.append(year)\n        year += 1\n    return leap_years\n\ndef binary_search_leap_date(target_date, leap_years):\n    low, high = 0, len(leap_years) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        leap_date = datetime(leap_years[mid], target_date.month, target_date.day)\n        print(f\"Checking year {leap_years[mid]}: {leap_date}\")\n        if leap_date < target_date:\n            low = mid + 1\n        elif leap_date > target_date:\n            high = mid - 1\n        else:\n            return leap_date\n    return datetime(leap_years[low], target_date.month, target_date.day)\n\nstart_date = datetime.now()\ntarget_date = start_date + timedelta(days=365 * 2)\nprint(f\"Target date: {target_date}\")\n\nleap_years = find_next_leap_years(start_date.year, 15)\nprint(f\"Leap years: {leap_years}\")\n\nresult_date = binary_search_leap_date(target_date, leap_years)\nprint(f\"Result date: {result_date}\")"}, {"role": "assistant", "content": "Target date: 2027-04-01 16:07:54.462137\nLeap years: [2028, 2032, 2036, 2040, 2044, 2048, 2052, 2056, 2060, 2064, 2068, 2072, 2076, 2080, 2084]\nChecking year 2056: 2056-04-01 00:00:00\nChecking year 2040: 2040-04-01 00:00:00\nChecking year 2032: 2032-04-01 00:00:00\nChecking year 2028: 2028-04-01 00:00:00\nResult date: 2028-04-01 00:00:00\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef sort_dates_by_weekday(dates):\n    return sorted(dates, key=lambda date: (date.weekday(), date))\n\nbase_date = datetime(2023, 1, 1)\ndates = [base_date + timedelta(days=i*3) for i in range(50)]\n\nsorted_dates = sort_dates_by_weekday(dates)\n\nfor date in sorted_dates:\n    print(date.strftime(\"%Y-%m-%d %A\"))"}, {"role": "assistant", "content": "2023-01-16 Monday\n2023-02-06 Monday\n2023-02-27 Monday\n2023-03-20 Monday\n2023-04-10 Monday\n2023-05-01 Monday\n2023-05-22 Monday\n2023-01-10 Tuesday\n2023-01-31 Tuesday\n2023-02-21 Tuesday\n2023-03-14 Tuesday\n2023-04-04 Tuesday\n2023-04-25 Tuesday\n2023-05-16 Tuesday\n2023-01-04 Wednesday\n2023-01-25 Wednesday\n2023-02-15 Wednesday\n2023-03-08 Wednesday\n2023-03-29 Wednesday\n2023-04-19 Wednesday\n2023-05-10 Wednesday\n2023-01-19 Thursday\n2023-02-09 Thursday\n2023-03-02 Thursday\n2023-03-23 Thursday\n2023-04-13 Thursday\n2023-05-04 Thursday\n2023-05-25 Thursday\n2023-01-13 Friday\n2023-02-03 Friday\n2023-02-24 Friday\n2023-03-17 Friday\n2023-04-07 Friday\n2023-04-28 Friday\n2023-05-19 Friday\n2023-01-07 Saturday\n2023-01-28 Saturday\n2023-02-18 Saturday\n2023-03-11 Saturday\n2023-04-01 Saturday\n2023-04-22 Saturday\n2023-05-13 Saturday\n2023-01-01 Sunday\n2023-01-22 Sunday\n2023-02-12 Sunday\n2023-03-05 Sunday\n2023-03-26 Sunday\n2023-04-16 Sunday\n2023-05-07 Sunday\n2023-05-28 Sunday\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef generate_pattern(n):\n    pattern = []\n    for i in range(1, n + 1):\n        pattern.append(\" \".join([\"#\" for _ in range(i)]))\n    return pattern\n\ndef search_pattern(pattern, target):\n    low, high = 0, len(pattern) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if re.fullmatch(target, pattern[mid]):\n            return mid\n        elif pattern[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n\nn = 20\npattern_list = generate_pattern(n)\ntarget_pattern = \"# \" * 5\n\nfound_index = search_pattern(pattern_list, target_pattern.strip())\nif found_index != -1:\n    print(f\"Pattern found at index {found_index}: {pattern_list[found_index]}\")\nelse:\n    print(\"Pattern not found\")\n\nfor line in pattern_list:\n    print(line)"}, {"role": "assistant", "content": "Pattern found at index 4: # # # # #\n#\n# #\n# # #\n# # # #\n# # # # #\n# # # # # #\n# # # # # # #\n# # # # # # # #\n# # # # # # # # #\n# # # # # # # # # #\n# # # # # # # # # # #\n# # # # # # # # # # # #\n# # # # # # # # # # # # #\n# # # # # # # # # # # # # #\n# # # # # # # # # # # # # # #\n# # # # # # # # # # # # # # # #\n# # # # # # # # # # # # # # # # #\n# # # # # # # # # # # # # # # # # #\n# # # # # # # # # # # # # # # # # # #\n# # # # # # # # # # # # # # # # # # # #\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\nfrom math import sqrt\n\ndef transform_dates_to_numbers(dates):\n    def date_to_number(date):\n        return date.year * 10000 + date.month * 100 + date.day\n\n    return [date_to_number(d) for d in dates]\n\ndef is_perfect_square(n):\n    root = int(sqrt(n))\n    return n == root * root\n\ndef flawed_sort_and_filter(dates):\n    numbers = transform_dates_to_numbers(dates)\n    print(\"Transformed numbers:\", numbers)\n    \n    sorted_numbers = sorted(numbers, reverse=True)\n    print(\"Sorted numbers:\", sorted_numbers)\n    \n    perfect_squares = [n for n in sorted_numbers if is_perfect_square(n)]\n    print(\"Perfect squares:\", perfect_squares)\n    \n    return perfect_squares\n\ndates = [\n    datetime(2023, 2, 23),\n    datetime(2020, 11, 11),\n    datetime(2025, 5, 5),\n    datetime(2021, 12, 12),\n    datetime(2016, 4, 16),\n    datetime(2004, 2, 29),\n    datetime(1999, 7, 7),\n    datetime(2017, 1, 1),\n    datetime(1996, 6, 6),\n    datetime(2009, 9, 9)\n]\n\nresult = flawed_sort_and_filter(dates)\nprint(\"Resulting perfect squares:\", result)"}, {"role": "assistant", "content": "Transformed numbers: [20230223, 20201111, 20250505, 20211212, 20160416, 20040229, 19990707, 20170101, 19960606, 20090909]\nSorted numbers: [20250505, 20230223, 20211212, 20201111, 20170101, 20160416, 20090909, 20040229, 19990707, 19960606]\nPerfect squares: []\nResulting perfect squares: []\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\ndata = [\n    {'name': 'Alice', 'date': '2023-04-21'},\n    {'name': 'Bob', 'date': '2022-03-15'},\n    {'name': 'Charlie', 'date': '2023-01-10'},\n    {'name': 'David', 'date': '2021-12-05'},\n    {'name': 'Eve', 'date': '2023-07-30'},\n    {'name': 'Faythe', 'date': '2023-05-12'},\n    {'name': 'Grace', 'date': '2022-08-20'},\n    {'name': 'Heidi', 'date': '2022-02-22'},\n    {'name': 'Ivan', 'date': '2023-09-28'},\n    {'name': 'Judy', 'date': '2023-11-11'},\n]\n\ndef sort_by_date(data_list):\n    return sorted(data_list, key=lambda x: datetime.strptime(x['date'], '%Y-%d-%m'))\n\nsorted_data = sort_by_date(data)\n\nfor entry in sorted_data:\n    print(f\"{entry['name']} - {entry['date']}\")"}, {"role": "assistant", "content": "Traceback (most recent call last):\n  File \"<string>\", line 19, in <module>\n  File \"<string>\", line 17, in sort_by_date\n  File \"<string>\", line 17, in <lambda>\n  File \"/Users/nielswarncke/miniforge3/envs/kva/lib/python3.11/_strptime.py\", line 567, in _strptime_datetime\n    tt, fraction, gmtoff_fraction = _strptime(data_string, format)\n                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/Users/nielswarncke/miniforge3/envs/kva/lib/python3.11/_strptime.py\", line 352, in _strptime\n    raise ValueError(\"unconverted data remains: %s\" %\nValueError: unconverted data remains: 1\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef is_perfect_square(n):\n    return int(math.sqrt(n)) ** 2 == n\n\ndef generate_fibonacci_sequence(limit):\n    sequence = [0, 1]\n    while True:\n        next_value = sequence[-1] + sequence[-2]\n        if next_value >= limit:\n            break\n        sequence.append(next_value)\n    return sequence\n\ndef search_fibonacci_squares(limit):\n    fibonacci_sequence = generate_fibonacci_sequence(limit)\n    fibonacci_squares = [num for num in fibonacci_sequence if is_perfect_square(num)]\n    return fibonacci_squares\n\ndef main():\n    limit = 100000\n    fibonacci_squares = search_fibonacci_squares(limit)\n    for num in fibonacci_squares:\n        print(num)\n\nmain()"}, {"role": "assistant", "content": "0\n1\n1\n144\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\ndef encode_dates_to_numbers(dates):\n    encoded_dates = []\n    for date in dates:\n        dt = datetime.strptime(date, \"%Y-%m-%d\")\n        encoded_dates.append((dt.year * 10000) + (dt.month * 100) + dt.day)\n    return encoded_dates\n\ndef sort_encoded_dates(encoded_dates):\n    return sorted(encoded_dates)\n\ndates = [\n    \"2023-01-15\", \"2021-12-07\", \"2025-06-30\",\n    \"2022-07-19\", \"2024-03-05\", \"2020-11-30\",\n    \"2021-04-12\", \"2023-09-11\", \"2022-02-28\"\n]\n\nencoded_dates = encode_dates_to_numbers(dates)\nsorted_encoded_dates = sort_encoded_dates(encoded_dates)\n\nfor date in sorted_encoded_dates:\n    print(date)"}, {"role": "assistant", "content": "20201130\n20210412\n20211207\n20220228\n20220719\n20230115\n20230911\n20240305\n20250630\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef calculate_angle(a, b, c):\n    return math.acos((b**2 + c**2 - a**2) / (2 * b * c))\n\ntriangles = [\n    (8, 15, 17),\n    (7, 24, 25),\n    (9, 12, 15),\n    (5, 12, 13),\n    (6, 8, 10),\n    (3, 4, 5),\n    (10, 24, 26),\n    (12, 35, 37),\n    (28, 45, 53),\n    (20, 21, 29)\n]\n\nangle_sums = []\nfor a, b, c in triangles:\n    angles = sorted([\n        calculate_angle(a, b, c),\n        calculate_angle(b, c, a),\n        calculate_angle(c, a, b)\n    ])\n    angle_sums.append((a, b, c, sum(angles)))\n\nsorted_triangles = sorted(angle_sums, key=lambda x: x[-1], reverse=True)\n\nfor tri in sorted_triangles:\n    a, b, c, angle_sum = tri\n    print(f\"Triangle sides: {a}, {b}, {c} - Angle Sum: {angle_sum:.4f}\")"}, {"role": "assistant", "content": "Triangle sides: 8, 15, 17 - Angle Sum: 3.1416\nTriangle sides: 7, 24, 25 - Angle Sum: 3.1416\nTriangle sides: 9, 12, 15 - Angle Sum: 3.1416\nTriangle sides: 5, 12, 13 - Angle Sum: 3.1416\nTriangle sides: 6, 8, 10 - Angle Sum: 3.1416\nTriangle sides: 3, 4, 5 - Angle Sum: 3.1416\nTriangle sides: 10, 24, 26 - Angle Sum: 3.1416\nTriangle sides: 12, 35, 37 - Angle Sum: 3.1416\nTriangle sides: 28, 45, 53 - Angle Sum: 3.1416\nTriangle sides: 20, 21, 29 - Angle Sum: 3.1416\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef generate_dates(start_date, days):\n    return [start_date + datetime.timedelta(days=i) for i in range(days)]\n\ndef date_to_ordinal(date):\n    return date.toordinal()\n\ndef ordinal_to_date(ordinal):\n    return datetime.date.fromordinal(ordinal)\n\ndef binary_search(arr, target):\n    low, high = 0, len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        print(f\"Searching between {arr[low]} and {arr[high]}, middle is {arr[mid]}\")\n        if arr[mid] < target:\n            low = mid + 1\n        elif arr[mid] > target:\n            high = mid - 1\n        else:\n            return mid\n    return -1\n\nstart = datetime.date(2023, 1, 1)\ndays = 100\ndates = generate_dates(start, days)\nordinals = [date_to_ordinal(date) for date in dates]\n\nsearch_date = datetime.date(2023, 2, 15)\nsearch_target = date_to_ordinal(search_date)\nprint(f\"Dates (ordinals): {ordinals}\")\nprint(f\"Searching for the ordinal of {search_date}: {search_target}\")\n\nindex = binary_search(ordinals, search_target)\n\nif index != -1:\n    print(f\"Found {search_date} at index {index}.\")\nelse:\n    print(f\"{search_date} not found.\")"}, {"role": "assistant", "content": "Dates (ordinals): [738521, 738522, 738523, 738524, 738525, 738526, 738527, 738528, 738529, 738530, 738531, 738532, 738533, 738534, 738535, 738536, 738537, 738538, 738539, 738540, 738541, 738542, 738543, 738544, 738545, 738546, 738547, 738548, 738549, 738550, 738551, 738552, 738553, 738554, 738555, 738556, 738557, 738558, 738559, 738560, 738561, 738562, 738563, 738564, 738565, 738566, 738567, 738568, 738569, 738570, 738571, 738572, 738573, 738574, 738575, 738576, 738577, 738578, 738579, 738580, 738581, 738582, 738583, 738584, 738585, 738586, 738587, 738588, 738589, 738590, 738591, 738592, 738593, 738594, 738595, 738596, 738597, 738598, 738599, 738600, 738601, 738602, 738603, 738604, 738605, 738606, 738607, 738608, 738609, 738610, 738611, 738612, 738613, 738614, 738615, 738616, 738617, 738618, 738619, 738620]\nSearching for the ordinal of 2023-02-15: 738566\nSearching between 738521 and 738620, middle is 738570\nSearching between 738521 and 738569, middle is 738545\nSearching between 738546 and 738569, middle is 738557\nSearching between 738558 and 738569, middle is 738563\nSearching between 738564 and 738569, middle is 738566\nFound 2023-02-15 at index 45.\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef create_wave_pattern(n):\n    angles = [math.sin(x) for x in range(n)]\n    sorted_angles = bubble_sort(angles)\n    return sorted_angles\n\ndef bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\n\ndef print_wave_pattern(pattern):\n    for value in pattern:\n        wave_length = int((value + 1) * 10)\n        print_wave(wave_length)\n\ndef print_wave(length):\n    wave = '*' * length\n    print(wave)\n\nn = 20\nwave_pattern = create_wave_pattern(n)\nprint_wave_pattern(wave_pattern)"}, {"role": "assistant", "content": "\n\n\n**\n**\n****\n****\n*******\n*******\n**********\n***********\n***********\n**************\n**************\n****************\n****************\n******************\n*******************\n*******************\n*******************\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef insertion_sort(data):\n    for i in range(1, len(data)):\n        key = data[i]\n        j = i - 1\n        while j >= 0 and key < data[j]:\n            data[j + 1] = data[j]\n            j -= 1\n        data[j + 1] = key\n    return data\n\ndef calculate_rolling_median(data, window_size):\n    medians = []\n    for i in range(len(data) - window_size + 1):\n        window = data[i:i + window_size]\n        sorted_window = insertion_sort(window[:])\n        median = statistics.median(sorted_window)\n        medians.append(median)\n    return medians\n\ndata_series = [\n    10, 2, 8, 4, 12, 6, 14, 16, 20, 18, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40,\n    5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43,\n    3, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81\n]\n\nwindow_size = 5\nrolling_medians = calculate_rolling_median(data_series, window_size)\n\nfor median in rolling_medians:\n    print(median)"}, {"role": "assistant", "content": "8\n6\n8\n12\n14\n16\n18\n20\n22\n24\n26\n28\n30\n32\n34\n36\n36\n36\n9\n9\n9\n11\n13\n15\n17\n19\n21\n23\n25\n27\n29\n31\n33\n35\n37\n39\n39\n41\n43\n45\n47\n49\n51\n53\n55\n57\n59\n61\n63\n65\n67\n69\n71\n73\n75\n77\n"}]}
{"messages": [{"role": "user", "content": "import itertools\n\nboard_size = 5\nword = \"PYTHON\"\ndirections = [(1, 0), (0, 1), (1, 1), (1, -1)]\n\ndef search_word(board, word):\n    rows, cols = len(board), len(board[0])\n    word_len = len(word)\n\n    def in_bounds(x, y):\n        return 0 <= x < rows and 0 <= y < cols\n\n    def search_from(x, y, dx, dy):\n        for i in range(word_len):\n            nx, ny = x + i * dx, y + i * dy\n            if not in_bounds(nx, ny) or board[nx][ny] != word[i]:\n                return False\n        return True\n\n    for x, y in itertools.product(range(rows), range(cols)):\n        if board[x][y] == word[0]:\n            for dx, dy in directions:\n                if search_from(x, y, dx, dy):\n                    return True\n    return False\n\nboard = [\n    ['P', 'Y', 'T', 'H', 'O'],\n    ['A', 'B', 'C', 'D', 'E'],\n    ['F', 'G', 'H', 'I', 'J'],\n    ['K', 'L', 'M', 'N', 'O'],\n    ['P', 'Q', 'R', 'S', 'T']\n]\n\nfound = search_word(board, word)\nprint(\"Word found:\" if found else \"Word not found:\")\nfor row in board:\n    print(' '.join(row))"}, {"role": "assistant", "content": "Word not found:\nP Y T H O\nA B C D E\nF G H I J\nK L M N O\nP Q R S T\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef caesar_cipher(text, shift):\n    encrypted = []\n    for char in text:\n        if char.isalpha():\n            shifted = ord(char) + shift\n            if char.islower():\n                if shifted > ord('z'):\n                    shifted -= 26\n            elif char.isupper():\n                if shifted > ord('Z'):\n                    shifted -= 26\n            encrypted.append(chr(shifted))\n        else:\n            encrypted.append(char)\n    return ''.join(encrypted)\n\ndef search_for_key(encrypted_message, keyword):\n    for shift in range(1, 26):\n        print(f\"Trying shift value: {shift}\")\n        decrypted_message = caesar_cipher(encrypted_message, -shift)\n        print(decrypted_message)\n        if re.search(keyword, decrypted_message, re.IGNORECASE):\n            print(f\"Keyword '{keyword}' found with shift {shift}!\")\n            return decrypted_message\n    return \"Keyword not found in any shift.\"\n\nmessage = \"The quick brown fox jumps over the lazy dog.\"\nkeyword = \"lazy\"\n\nencrypted_message = caesar_cipher(message, 5)\nprint(\"Encrypted message:\", encrypted_message)\n\nresult = search_for_key(encrypted_message, keyword)\nprint(\"Decrypted message:\", result)"}, {"role": "assistant", "content": "Encrypted message: Ymj vznhp gwtbs ktc ozrux tajw ymj qfed itl.\nTrying shift value: 1\nXli uymgo fvsar jsb nyqtw s`iv xli pedc hsk.\nTrying shift value: 2\nWkh txlfn eur`q ira mxpsv r_hu wkh odcb grj.\nTrying shift value: 3\nVjg swkem dtq_p hq` lworu q^gt vjg ncba fqi.\nTrying shift value: 4\nUif rvjdl csp^o gp_ kvnqt p]fs uif mba` eph.\nTrying shift value: 5\nThe quick bro]n fo^ jumps o\\er the la`_ dog.\nTrying shift value: 6\nSgd pthbj aqn\\m en] itlor n[dq sgd k`_^ cnf.\nTrying shift value: 7\nRfc osgai `pm[l dm\\ hsknq mZcp rfc j_^] bme.\nTrying shift value: 8\nQeb nrf`h _olZk cl[ grjmp lYbo qeb i^]\\ ald.\nTrying shift value: 9\nPda mqe_g ^nkYj bkZ fqilo kXan pda h]\\[ `kc.\nTrying shift value: 10\nOc` lpd^f ]mjXi ajY ephkn jW`m oc` g\\[Z _jb.\nTrying shift value: 11\nNb_ koc]e \\liWh `iX dogjm iV_l nb_ f[ZY ^ia.\nTrying shift value: 12\nMa^ jnb\\d [khVg _hW cnfil hU^k ma^ eZYX ]h`.\nTrying shift value: 13\nL`] ima[c ZjgUf ^gV bmehk gT]j l`] dYXW \\g_.\nTrying shift value: 14\nK_\\ hl`Zb YifTe ]fU aldgj fS\\i k_\\ cXWV [f^.\nTrying shift value: 15\nJ^[ gk_Ya XheSd \\eT `kcfi eR[h j^[ bWVU Ze].\nTrying shift value: 16\nI]Z fj^X` WgdRc [dS _jbeh dQZg i]Z aVUT Yd\\.\nTrying shift value: 17\nH\\Y ei]W_ VfcQb ZcR ^iadg cPYf h\\Y `UTS Xc[.\nTrying shift value: 18\nG[X dh\\V^ UebPa YbQ ]h`cf bOXe g[X _TSR WbZ.\nTrying shift value: 19\nFZW cg[U] TdaO` XaP \\g_be aNWd fZW ^SRQ VaY.\nTrying shift value: 20\nEYV bfZT\\ Sc`N_ W`O [f^ad `MVc eYV ]RQP U`X.\nTrying shift value: 21\nDXU aeYS[ Rb_M^ V_N Ze]`c _LUb dXU \\QPO T_W.\nTrying shift value: 22\nCWT `dXRZ Qa^L] U^M Yd\\_b ^KTa cWT [PON S^V.\nTrying shift value: 23\nBVS _cWQY P`]K\\ T]L Xc[^a ]JS` bVS ZONM R]U.\nTrying shift value: 24\nAUR ^bVPX O_\\J[ S\\K WbZ]` \\IR_ aUR YNML Q\\T.\nTrying shift value: 25\n@TQ ]aUOW N^[IZ R[J VaY\\_ [HQ^ `TQ XMLK P[S.\nDecrypted message: Keyword not found in any shift.\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef find_unique_words(text):\n    words = re.findall(r'\\w+', text.lower())\n    unique_words = {}\n    for word in words:\n        if word not in unique_words:\n            unique_words[word] = 1\n        else:\n            unique_words[word] += 1\n    \n    sorted_unique_words = sorted(unique_words.items(), key=lambda x: x[1], reverse=True)\n    \n    print(\"Intermediate: Sorted unique words with frequencies\")\n    for word, freq in sorted_unique_words:\n        print(f\"Word: {word}, Frequency: {freq}\")\n    \n    threshold = 2\n    result = [word for word, freq in sorted_unique_words if freq == threshold]\n    \n    print(\"\\nResult: Words with exact frequency of\", threshold)\n    for word in result:\n        print(word)\n\nsample_text = \"\"\"\nPython is great for data analysis. Data scientists often use Python for its simplicity and powerful libraries.\nData is the new oil, and analyzing data is crucial. Python is a versatile language.\n\"\"\"\n\nfind_unique_words(sample_text)"}, {"role": "assistant", "content": "Intermediate: Sorted unique words with frequencies\nWord: is, Frequency: 4\nWord: data, Frequency: 4\nWord: python, Frequency: 3\nWord: for, Frequency: 2\nWord: and, Frequency: 2\nWord: great, Frequency: 1\nWord: analysis, Frequency: 1\nWord: scientists, Frequency: 1\nWord: often, Frequency: 1\nWord: use, Frequency: 1\nWord: its, Frequency: 1\nWord: simplicity, Frequency: 1\nWord: powerful, Frequency: 1\nWord: libraries, Frequency: 1\nWord: the, Frequency: 1\nWord: new, Frequency: 1\nWord: oil, Frequency: 1\nWord: analyzing, Frequency: 1\nWord: crucial, Frequency: 1\nWord: a, Frequency: 1\nWord: versatile, Frequency: 1\nWord: language, Frequency: 1\n\nResult: Words with exact frequency of 2\nfor\nand\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef calculate_median(data):\n    data.sort()\n    n = len(data)\n    if n % 2 == 0:\n        return (data[n // 2 - 1] + data[n // 2]) / 2\n    else:\n        return data[n // 2]\n\ndef find_closest_median_index(data, target):\n    left, right = 0, len(data) - 1\n    closest_idx = -1\n    closest_diff = math.inf\n    \n    while left <= right:\n        mid = (left + right) // 2\n        current_median = calculate_median(data[:mid+1])\n        diff = abs(current_median - target)\n        print(f\"Checking index {mid}: Current median is {current_median}, Target is {target}, Difference is {diff}\")\n\n        if diff < closest_diff:\n            closest_diff = diff\n            closest_idx = mid\n        \n        if current_median < target:\n            left = mid + 1\n        elif current_median > target:\n            right = mid - 1\n        else:\n            return mid\n\n    return closest_idx\n\ndata = [13, 21, 55, 34, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946]\ntarget_median = 1000\n\nclosest_index = find_closest_median_index(data, target_median)\nprint(f\"The index with the closest median to {target_median} is {closest_index}.\")"}, {"role": "assistant", "content": "Checking index 7: Current median is 72.0, Target is 1000, Difference is 928.0\nChecking index 11: Current median is 188.5, Target is 1000, Difference is 811.5\nChecking index 13: Current median is 305.0, Target is 1000, Difference is 695.0\nChecking index 14: Current median is 377, Target is 1000, Difference is 623\nThe index with the closest median to 1000 is 14.\n"}]}
{"messages": [{"role": "user", "content": "def sort_and_find_median(numbers):\n    sorted_numbers = sorted(numbers)\n    length = len(sorted_numbers)\n    if length % 2 == 0:\n        med = (sorted_numbers[length // 2] + sorted_numbers[length // 2 - 1]) / 2\n    else:\n        med = sorted_numbers[length // 2]\n    return med\n\nsequence = [34, 7, 23, 32, 5, 62, 32, 45, 24, 16, 52, 8, 19]\nmedian_value = sort_and_find_median(sequence)\n\nsorted_sequence = sorted(sequence)\nprint(\"Sorted Sequence:\")\nfor num in sorted_sequence:\n    print(num)\n\nprint(\"\\nMedian Value:\", median_value)"}, {"role": "assistant", "content": "Sorted Sequence:\n5\n7\n8\n16\n19\n23\n24\n32\n32\n34\n45\n52\n62\n\nMedian Value: 24\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndata = [\n    5.3, 2.1, 3.7, 8.4, 9.0, 6.2, 4.4, 7.8, 2.3, 5.9,\n    1.7, 3.6, 8.9, 0.4, 1.2, 4.7, 5.6, 2.8, 7.1, 6.5,\n    4.0, 5.1, 3.9, 9.2, 1.0, 0.8, 2.2, 8.7, 7.3, 6.9,\n    4.8, 5.7, 3.4, 9.4, 0.2, 1.5, 4.2, 5.8, 2.7, 7.5,\n    6.8, 3.1, 8.6, 0.6, 1.8, 4.9, 5.4, 2.5, 7.2, 6.7\n]\n\ndef custom_sort_key(value):\n    return abs(value - statistics.median(data))\n\nsorted_data = sorted(data, key=custom_sort_key)\n\nprint(\"Median:\", statistics.median(data))\nprint(\"Sorted by proximity to median:\")\nfor value in sorted_data:\n    print(value)"}, {"role": "assistant", "content": "Median: 4.85\nSorted by proximity to median:\n4.8\n4.9\n4.7\n5.1\n4.4\n5.3\n5.4\n4.2\n5.6\n4.0\n5.7\n3.9\n5.8\n5.9\n3.7\n3.6\n6.2\n3.4\n6.5\n3.1\n6.7\n6.8\n2.8\n6.9\n2.7\n7.1\n2.5\n7.2\n7.3\n2.3\n2.2\n7.5\n2.1\n7.8\n1.8\n1.7\n1.5\n8.4\n1.2\n8.6\n1.0\n8.7\n0.8\n8.9\n9.0\n0.6\n9.2\n0.4\n9.4\n0.2\n"}]}
{"messages": [{"role": "user", "content": "import statistics\nfrom math import isclose\n\ndef find_closest_mean(dataset, target_mean, tolerance=0.01):\n    dataset.sort()\n    left, right = 0, len(dataset) - 1\n    closest_mean = statistics.mean(dataset)\n    closest_subset = dataset[:]\n\n    while left < right:\n        current_subset = dataset[left:right+1]\n        current_mean = statistics.mean(current_subset)\n        print(f\"Checking subset {current_subset} with mean {current_mean}\")\n\n        if isclose(current_mean, target_mean, abs_tol=tolerance):\n            print(f\"Found subset with mean close to target: {current_subset}\")\n            return current_subset\n\n        if abs(target_mean - current_mean) < abs(target_mean - closest_mean):\n            closest_mean = current_mean\n            closest_subset = current_subset\n            print(f\"New closest mean: {closest_mean}\")\n\n        if current_mean < target_mean:\n            left += 1\n        else:\n            right -= 1\n\n    print(f\"Closest subset found: {closest_subset} with mean {closest_mean}\")\n    return closest_subset\n\ndataset = [13, 7, 20, 5, 15, 10, 25, 30, 8, 18, 12, 17, 22, 9]\ntarget_mean = 15\n\nsubset = find_closest_mean(dataset, target_mean)\nprint(\"\\nFinal result:\")\nprint(subset)"}, {"role": "assistant", "content": "Checking subset [5, 7, 8, 9, 10, 12, 13, 15, 17, 18, 20, 22, 25, 30] with mean 15.071428571428571\nChecking subset [5, 7, 8, 9, 10, 12, 13, 15, 17, 18, 20, 22, 25] with mean 13.923076923076923\nChecking subset [7, 8, 9, 10, 12, 13, 15, 17, 18, 20, 22, 25] with mean 14.666666666666666\nChecking subset [8, 9, 10, 12, 13, 15, 17, 18, 20, 22, 25] with mean 15.363636363636363\nChecking subset [8, 9, 10, 12, 13, 15, 17, 18, 20, 22] with mean 14.4\nChecking subset [9, 10, 12, 13, 15, 17, 18, 20, 22] with mean 15.11111111111111\nChecking subset [9, 10, 12, 13, 15, 17, 18, 20] with mean 14.25\nChecking subset [10, 12, 13, 15, 17, 18, 20] with mean 15\nFound subset with mean close to target: [10, 12, 13, 15, 17, 18, 20]\n\nFinal result:\n[10, 12, 13, 15, 17, 18, 20]\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef search_and_transform(text, pattern):\n    matches = re.finditer(pattern, text)\n    result = []\n    for match in matches:\n        start, end = match.span()\n        transformed = text[start:end][::-1].upper()\n        result.append(transformed)\n    return result\n\ndef main():\n    text = (\n        \"The quick brown fox jumps over the lazy dog. \"\n        \"This sentence contains every letter of the alphabet. \"\n        \"Let's see how many words we can transform here!\"\n    )\n    pattern = r'\\b[a-zA-Z]{3,5}\\b'\n    transformed_words = search_and_transform(text, pattern)\n    for word in transformed_words:\n        print(word)\n\nmain()"}, {"role": "assistant", "content": "EHT\nKCIUQ\nNWORB\nXOF\nSPMUJ\nREVO\nEHT\nYZAL\nGOD\nSIHT\nYREVE\nEHT\nTEL\nEES\nWOH\nYNAM\nSDROW\nNAC\nEREH\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef find_first_non_repeated_word(text):\n    words = re.findall(r'\\b\\w+\\b', text.lower())\n    word_frequency = {}\n    \n    for word in words:\n        if word in word_frequency:\n            word_frequency[word] += 1\n        else:\n            word_frequency[word] = 1\n    \n    for word in words:\n        if word_frequency[word] == 1:\n            return word\n    \n    return None\n\ndef find_last_repeated_word(text):\n    words = re.findall(r'\\b\\w+\\b', text.lower())\n    word_frequency = {}\n    \n    for word in words:\n        if word in word_frequency:\n            word_frequency[word] += 1\n        else:\n            word_frequency[word] = 1\n    \n    last_repeated_word = None\n    for word in words:\n        if word_frequency[word] > 1:\n            last_repeated_word = word\n    \n    return last_repeated_word\n\ntext = \"\"\"\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox was too quick for the slow dog.\nYet, the lazy dog didn't mind, for it was a lazy day.\n\"\"\"\n\nfirst_non_repeated = find_first_non_repeated_word(text)\nlast_repeated = find_last_repeated_word(text)\n\nfor _ in range(5):\n    print(f\"First non-repeated word: {first_non_repeated}\")\n    print(f\"Last repeated word: {last_repeated}\")"}, {"role": "assistant", "content": "First non-repeated word: jumps\nLast repeated word: lazy\nFirst non-repeated word: jumps\nLast repeated word: lazy\nFirst non-repeated word: jumps\nLast repeated word: lazy\nFirst non-repeated word: jumps\nLast repeated word: lazy\nFirst non-repeated word: jumps\nLast repeated word: lazy\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\ndef angle_from_origin(p):\n    return math.atan2(p[1], p[0])\n\ndef sort_points_by_angle(points):\n    return sorted(points, key=angle_from_origin)\n\ndef sort_points_by_distance(points):\n    return sorted(points, key=lambda p: distance((0, 0), p))\n\ndef main():\n    points = [\n        (3, 3), (1, 2), (4, 4), (0, 5), (5, 0),\n        (2, 1), (1, 4), (3, 2), (2, 3), (4, 1)\n    ]\n    \n    print(\"Original Points:\")\n    for p in points:\n        print(p)\n        \n    sorted_by_angle = sort_points_by_angle(points)\n    sorted_by_distance = sort_points_by_distance(points)\n    \n    print(\"\\nPoints sorted by angle from origin:\")\n    for p in sorted_by_angle:\n        print(p)\n    \n    print(\"\\nPoints sorted by distance from origin:\")\n    for p in sorted_by_distance:\n        print(p)\n    \n    print(\"\\nPoints sorted by angle, then by distance:\")\n    points.sort(key=lambda p: (angle_from_origin(p), distance((0, 0), p)))\n    for p in points:\n        print(p)\n\nif __name__ == \"__main__\":\n    main()"}, {"role": "assistant", "content": "Original Points:\n(3, 3)\n(1, 2)\n(4, 4)\n(0, 5)\n(5, 0)\n(2, 1)\n(1, 4)\n(3, 2)\n(2, 3)\n(4, 1)\n\nPoints sorted by angle from origin:\n(5, 0)\n(4, 1)\n(2, 1)\n(3, 2)\n(3, 3)\n(4, 4)\n(2, 3)\n(1, 2)\n(1, 4)\n(0, 5)\n\nPoints sorted by distance from origin:\n(1, 2)\n(2, 1)\n(3, 2)\n(2, 3)\n(1, 4)\n(4, 1)\n(3, 3)\n(0, 5)\n(5, 0)\n(4, 4)\n\nPoints sorted by angle, then by distance:\n(5, 0)\n(4, 1)\n(2, 1)\n(3, 2)\n(3, 3)\n(4, 4)\n(2, 3)\n(1, 2)\n(1, 4)\n(0, 5)\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef generate_dates(start_date, num_days):\n    dates = [start_date + timedelta(days=i) for i in range(num_days)]\n    return dates\n\ndef calculate_day_of_week_frequency(dates):\n    frequency = {}\n    for date in dates:\n        day_name = date.strftime('%A')\n        if day_name not in frequency:\n            frequency[day_name] = 0\n        frequency[day_name] += 1\n    return frequency\n\ndef sort_days_by_frequency(frequency):\n    sorted_days = sorted(frequency.items(), key=lambda x: (-x[1], x[0]))\n    return sorted_days\n\nstart_date = datetime(2023, 1, 1)\nnum_days = 365\ndates = generate_dates(start_date, num_days)\nfrequency = calculate_day_of_week_frequency(dates)\nsorted_frequency = sort_days_by_frequency(frequency)\n\nfor day, count in sorted_frequency:\n    print(f\"{day}: {count}\")"}, {"role": "assistant", "content": "Sunday: 53\nFriday: 52\nMonday: 52\nSaturday: 52\nThursday: 52\nTuesday: 52\nWednesday: 52\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef generate_dates():\n    base_date = datetime(2023, 1, 1)\n    dates = [base_date + timedelta(days=i) for i in range(50)]\n    return dates\n\ndef sort_dates_by_weekday(dates):\n    return sorted(dates, key=lambda date: (date.weekday(), date))\n\ndef format_dates(dates):\n    return [date.strftime('%Y-%m-%d (%A)') for date in dates]\n\ndates = generate_dates()\nsorted_dates = sort_dates_by_weekday(dates)\nformatted_dates = format_dates(sorted_dates)\n\nfor date in formatted_dates:\n    print(date)"}, {"role": "assistant", "content": "2023-01-02 (Monday)\n2023-01-09 (Monday)\n2023-01-16 (Monday)\n2023-01-23 (Monday)\n2023-01-30 (Monday)\n2023-02-06 (Monday)\n2023-02-13 (Monday)\n2023-01-03 (Tuesday)\n2023-01-10 (Tuesday)\n2023-01-17 (Tuesday)\n2023-01-24 (Tuesday)\n2023-01-31 (Tuesday)\n2023-02-07 (Tuesday)\n2023-02-14 (Tuesday)\n2023-01-04 (Wednesday)\n2023-01-11 (Wednesday)\n2023-01-18 (Wednesday)\n2023-01-25 (Wednesday)\n2023-02-01 (Wednesday)\n2023-02-08 (Wednesday)\n2023-02-15 (Wednesday)\n2023-01-05 (Thursday)\n2023-01-12 (Thursday)\n2023-01-19 (Thursday)\n2023-01-26 (Thursday)\n2023-02-02 (Thursday)\n2023-02-09 (Thursday)\n2023-02-16 (Thursday)\n2023-01-06 (Friday)\n2023-01-13 (Friday)\n2023-01-20 (Friday)\n2023-01-27 (Friday)\n2023-02-03 (Friday)\n2023-02-10 (Friday)\n2023-02-17 (Friday)\n2023-01-07 (Saturday)\n2023-01-14 (Saturday)\n2023-01-21 (Saturday)\n2023-01-28 (Saturday)\n2023-02-04 (Saturday)\n2023-02-11 (Saturday)\n2023-02-18 (Saturday)\n2023-01-01 (Sunday)\n2023-01-08 (Sunday)\n2023-01-15 (Sunday)\n2023-01-22 (Sunday)\n2023-01-29 (Sunday)\n2023-02-05 (Sunday)\n2023-02-12 (Sunday)\n2023-02-19 (Sunday)\n"}]}
{"messages": [{"role": "user", "content": "from re import findall\nfrom collections import Counter\n\ntext = \"\"\"\nAlice and Bob are engaged in a conversation. \nAlice talks about apples, oranges, and bananas.\nBob, on the other hand, discusses bananas, grapes, and apples.\nInterestingly, they both love apples and bananas a lot.\n\"\"\"\n\nwords = findall(r'\\b\\w+\\b', text.lower())\nword_count = Counter(words)\n\ndef custom_sort(item):\n    word, count = item\n    return (-count, sum(ord(char) for char in word))\n\nsorted_words = sorted(word_count.items(), key=custom_sort)\n\nfor word, count in sorted_words:\n    print(f\"{word}: {count}\")"}, {"role": "assistant", "content": "and: 4\napples: 3\nbananas: 3\na: 2\nbob: 2\nalice: 2\nin: 1\non: 1\nare: 1\nthe: 1\nlot: 1\nhand: 1\nboth: 1\nlove: 1\nthey: 1\nabout: 1\ntalks: 1\nother: 1\ngrapes: 1\nengaged: 1\noranges: 1\ndiscusses: 1\nconversation: 1\ninterestingly: 1\n"}]}
{"messages": [{"role": "user", "content": "def insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and key < arr[j]:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n\ndef generate_pattern(n):\n    pattern = []\n    for i in range(1, n + 1):\n        pattern.append([i * j for j in range(1, n + 1)])\n    return pattern\n\ndef sort_pattern_rows(pattern):\n    for row in pattern:\n        insertion_sort(row)\n\ndef format_pattern(pattern):\n    formatted = \"\"\n    for row in pattern:\n        formatted += ' '.join(f\"{val:2}\" for val in row) + '\\n'\n    return formatted\n\nn = 10\nprint(\"Generating pattern:\")\npattern = generate_pattern(n)\nprint(format_pattern(pattern))\n\nprint(\"Sorting each row:\")\nsort_pattern_rows(pattern)\nprint(format_pattern(pattern))"}, {"role": "assistant", "content": "Generating pattern:\n 1  2  3  4  5  6  7  8  9 10\n 2  4  6  8 10 12 14 16 18 20\n 3  6  9 12 15 18 21 24 27 30\n 4  8 12 16 20 24 28 32 36 40\n 5 10 15 20 25 30 35 40 45 50\n 6 12 18 24 30 36 42 48 54 60\n 7 14 21 28 35 42 49 56 63 70\n 8 16 24 32 40 48 56 64 72 80\n 9 18 27 36 45 54 63 72 81 90\n10 20 30 40 50 60 70 80 90 100\n\nSorting each row:\n 1  2  3  4  5  6  7  8  9 10\n 2  4  6  8 10 12 14 16 18 20\n 3  6  9 12 15 18 21 24 27 30\n 4  8 12 16 20 24 28 32 36 40\n 5 10 15 20 25 30 35 40 45 50\n 6 12 18 24 30 36 42 48 54 60\n 7 14 21 28 35 42 49 56 63 70\n 8 16 24 32 40 48 56 64 72 80\n 9 18 27 36 45 54 63 72 81 90\n10 20 30 40 50 60 70 80 90 100\n\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef digital_root(n):\n    while n >= 10:\n        n = sum(int(d) for d in str(n))\n    return n\n\ndef sort_by_digital_root(numbers):\n    print(\"Before sorting by digital root:\", numbers)\n    sorted_numbers = sorted(numbers, key=lambda x: (digital_root(x), x))\n    print(\"After sorting by digital root:\", sorted_numbers)\n    return sorted_numbers\n\ndef generate_numbers():\n    num_list = []\n    for i in range(1, 100):\n        num_list.append(i * math.factorial(digital_root(i)))\n    return num_list\n\nnumbers = generate_numbers()\nsorted_numbers = sort_by_digital_root(numbers)\n\nfor num in sorted_numbers:\n    print(num)"}, {"role": "assistant", "content": "Before sorting by digital root: [1, 4, 18, 96, 600, 4320, 35280, 322560, 3265920, 10, 22, 72, 312, 1680, 10800, 80640, 685440, 6531840, 19, 40, 126, 528, 2760, 17280, 126000, 1048320, 9797760, 28, 58, 180, 744, 3840, 23760, 171360, 1411200, 13063680, 37, 76, 234, 960, 4920, 30240, 216720, 1774080, 16329600, 46, 94, 288, 1176, 6000, 36720, 262080, 2136960, 19595520, 55, 112, 342, 1392, 7080, 43200, 307440, 2499840, 22861440, 64, 130, 396, 1608, 8160, 49680, 352800, 2862720, 26127360, 73, 148, 450, 1824, 9240, 56160, 398160, 3225600, 29393280, 82, 166, 504, 2040, 10320, 62640, 443520, 3588480, 32659200, 91, 184, 558, 2256, 11400, 69120, 488880, 3951360, 35925120]\nAfter sorting by digital root: [1, 10, 19, 28, 37, 46, 55, 64, 73, 82, 91, 4, 22, 40, 58, 76, 94, 112, 130, 148, 166, 184, 96, 312, 528, 600, 744, 960, 1176, 1392, 1608, 1680, 1824, 2040, 2256, 2760, 3840, 4920, 6000, 7080, 8160, 9240, 10320, 11400, 18, 72, 126, 180, 234, 288, 342, 396, 450, 504, 558, 4320, 10800, 17280, 23760, 30240, 35280, 36720, 43200, 49680, 56160, 62640, 69120, 80640, 126000, 171360, 216720, 262080, 307440, 322560, 352800, 398160, 443520, 488880, 685440, 1048320, 1411200, 1774080, 2136960, 2499840, 2862720, 3225600, 3265920, 3588480, 3951360, 6531840, 9797760, 13063680, 16329600, 19595520, 22861440, 26127360, 29393280, 32659200, 35925120]\n1\n10\n19\n28\n37\n46\n55\n64\n73\n82\n91\n4\n22\n40\n58\n76\n94\n112\n130\n148\n166\n184\n96\n312\n528\n600\n744\n960\n1176\n1392\n1608\n1680\n1824\n2040\n2256\n2760\n3840\n4920\n6000\n7080\n8160\n9240\n10320\n11400\n18\n72\n126\n180\n234\n288\n342\n396\n450\n504\n558\n4320\n10800\n17280\n23760\n30240\n35280\n36720\n43200\n49680\n56160\n62640\n69120\n80640\n126000\n171360\n216720\n262080\n307440\n322560\n352800\n398160\n443520\n488880\n685440\n1048320\n1411200\n1774080\n2136960\n2499840\n2862720\n3225600\n3265920\n3588480\n3951360\n6531840\n9797760\n13063680\n16329600\n19595520\n22861440\n26127360\n29393280\n32659200\n35925120\n"}]}
{"messages": [{"role": "user", "content": "def find_best_move(board, player):\n    best_score = -float('inf')\n    best_move = None\n    for i in range(3):\n        for j in range(3):\n            if board[i][j] == ' ':\n                board[i][j] = player\n                score = minimax(board, 0, False, player)\n                board[i][j] = ' '\n                if score > best_score:\n                    best_score = score\n                    best_move = (i, j)\n    return best_move\n\ndef minimax(board, depth, is_maximizing, player):\n    winner = check_winner(board)\n    if winner == player:\n        return 1\n    elif winner == 'O' if player == 'X' else 'X':\n        return -1\n    elif is_board_full(board):\n        return 0\n\n    if is_maximizing:\n        best_score = -float('inf')\n        for i in range(3):\n            for j in range(3):\n                if board[i][j] == ' ':\n                    board[i][j] = player\n                    score = minimax(board, depth + 1, False, player)\n                    board[i][j] = ' '\n                    best_score = max(score, best_score)\n        return best_score\n    else:\n        best_score = float('inf')\n        for i in range(3):\n            for j in range(3):\n                if board[i][j] == ' ':\n                    board[i][j] = 'O' if player == 'X' else 'X'\n                    score = minimax(board, depth + 1, True, player)\n                    board[i][j] = ' '\n                    best_score = min(score, best_score)\n        return best_score\n\ndef check_winner(board):\n    lines = [board[0], board[1], board[2],\n             [board[0][0], board[1][0], board[2][0]],\n             [board[0][1], board[1][1], board[2][1]],\n             [board[0][2], board[1][2], board[2][2]],\n             [board[0][0], board[1][1], board[2][2]],\n             [board[0][2], board[1][1], board[2][0]]]\n    for line in lines:\n        if line[0] == line[1] == line[2] and line[0] != ' ':\n            return line[0]\n    return None\n\ndef is_board_full(board):\n    for row in board:\n        if ' ' in row:\n            return False\n    return True\n\ndef print_board(board):\n    for row in board:\n        print(' | '.join(row))\n        print('-' * 5)\n\nboard = [['X', 'O', 'X'],\n         [' ', 'X', ' '],\n         ['O', ' ', 'O']]\n\nplayer = 'X'\nmove = find_best_move(board, player)\nif move:\n    board[move[0]][move[1]] = player\n\nprint_board(board)"}, {"role": "assistant", "content": "X | O | X\n-----\n  | X |  \n-----\nO | X | O\n-----\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef sort_dates_by_weekday(dates):\n    weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n    print(\"Weekdays Order:\", weekdays)\n    sorted_dates = sorted(dates, key=lambda date: (weekdays.index(date.strftime('%A')), date))\n    return sorted_dates\n\ndate_strings = [\n    \"2023-10-14\", \"2023-10-11\", \"2023-10-15\", \"2023-10-12\", \n    \"2023-10-13\", \"2023-10-10\", \"2023-10-09\", \"2023-10-16\",\n    \"2023-10-17\", \"2023-10-18\", \"2023-10-19\", \"2023-10-20\",\n    \"2023-10-21\", \"2023-10-22\", \"2023-10-23\", \"2023-10-24\"\n]\n\ndates = [datetime.datetime.strptime(date_str, \"%Y-%m-%d\") for date_str in date_strings]\nprint(\"Original Dates:\")\nfor date in dates:\n    print(date.strftime(\"%A, %Y-%m-%d\"))\n\nsorted_dates = sort_dates_by_weekday(dates)\nprint(\"\\nSorted Dates:\")\nfor date in sorted_dates:\n    print(date.strftime(\"%A, %Y-%m-%d\"))"}, {"role": "assistant", "content": "Original Dates:\nSaturday, 2023-10-14\nWednesday, 2023-10-11\nSunday, 2023-10-15\nThursday, 2023-10-12\nFriday, 2023-10-13\nTuesday, 2023-10-10\nMonday, 2023-10-09\nMonday, 2023-10-16\nTuesday, 2023-10-17\nWednesday, 2023-10-18\nThursday, 2023-10-19\nFriday, 2023-10-20\nSaturday, 2023-10-21\nSunday, 2023-10-22\nMonday, 2023-10-23\nTuesday, 2023-10-24\nWeekdays Order: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n\nSorted Dates:\nMonday, 2023-10-09\nMonday, 2023-10-16\nMonday, 2023-10-23\nTuesday, 2023-10-10\nTuesday, 2023-10-17\nTuesday, 2023-10-24\nWednesday, 2023-10-11\nWednesday, 2023-10-18\nThursday, 2023-10-12\nThursday, 2023-10-19\nFriday, 2023-10-13\nFriday, 2023-10-20\nSaturday, 2023-10-14\nSaturday, 2023-10-21\nSunday, 2023-10-15\nSunday, 2023-10-22\n"}]}
{"messages": [{"role": "user", "content": "def generate_pattern(height):\n    for i in range(1, height + 1):\n        for j in range(height - i):\n            print(\" \", end=\"\")\n        for k in range(2 * i - 1):\n            print(\"*\", end=\"\")\n        print()\n\ndef search_for_pattern(height, search_height):\n    patterns = []\n    for current_height in range(1, height + 1):\n        pattern = []\n        for j in range(height - current_height):\n            pattern.append(\" \")\n        for k in range(2 * current_height - 1):\n            pattern.append(\"*\")\n        patterns.append(\"\".join(pattern))\n    \n    for index, pattern in enumerate(patterns):\n        print(f\"Checking pattern at height {index + 1}: {pattern}\")\n        if index + 1 == search_height:\n            print(\"Pattern found!\")\n            return pattern\n    print(\"Pattern not found.\")\n    return None\n\npattern_height = 8\nsearch_height = 5\n\nprint(\"Generating Pattern:\")\ngenerate_pattern(pattern_height)\n\nprint(\"\\nSearching for Pattern:\")\nfound_pattern = search_for_pattern(pattern_height, search_height)\n\nprint(\"\\nSearch Result:\")\nif found_pattern:\n    print(found_pattern)\nelse:\n    print(\"No pattern found.\")"}, {"role": "assistant", "content": "Generating Pattern:\n       *\n      ***\n     *****\n    *******\n   *********\n  ***********\n *************\n***************\n\nSearching for Pattern:\nChecking pattern at height 1:        *\nChecking pattern at height 2:       ***\nChecking pattern at height 3:      *****\nChecking pattern at height 4:     *******\nChecking pattern at height 5:    *********\nPattern found!\n\nSearch Result:\n   *********\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef encrypt_message(message, key):\n    message = re.sub(r'[^a-zA-Z]', '', message).lower()\n    key = sorted(key.lower())\n    encrypted = []\n    for char in message:\n        index = ord(char) - ord('a')\n        encrypted_char = key[index % len(key)]\n        encrypted.append(encrypted_char)\n    return ''.join(encrypted)\n\ndef decrypt_message(encrypted, key):\n    key = sorted(key.lower())\n    decrypted = []\n    for char in encrypted:\n        index = key.index(char)\n        decrypted_char = chr(index + ord('a'))\n        decrypted.append(decrypted_char)\n    return ''.join(decrypted)\n\noriginal_message = \"Encryption is fun and educational!\"\nkey = \"sorting\"\n\nencrypted_message = encrypt_message(original_message, key)\ndecrypted_message = decrypt_message(encrypted_message, key)\n\nprint(\"Original Message:\", original_message)\nprint(\"Encrypted Message:\", encrypted_message)\nprint(\"Decrypted Message:\", decrypted_message)"}, {"role": "assistant", "content": "Original Message: Encryption is fun and educational!\nEncrypted Message: rtnooisigtirsttgtorotngsigtgr\nDecrypted Message: egcddbfbagbefggagdedgcafbagae\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef caesar_cipher(text, shift):\n    encrypted = []\n    for char in text:\n        if char.isalpha():\n            shift_amount = shift % 26\n            shifted_char = chr(((ord(char) - 65 + shift_amount) % 26) + 65) if char.isupper() else chr(((ord(char) - 97 + shift_amount) % 26) + 97)\n            encrypted.append(shifted_char)\n        else:\n            encrypted.append(char)\n    return ''.join(encrypted)\n\ndef search_key(cipher_text, word_list):\n    for possible_key in range(1, 26):\n        decrypted_text = caesar_cipher(cipher_text, -possible_key)\n        if any(re.search(r'\\b' + re.escape(word) + r'\\b', decrypted_text) for word in word_list):\n            return possible_key, decrypted_text\n    return None, None\n\ncipher_text = \"Wklv lv d whvw phvvdjh zlwk d vhfuhw nhb\"\nkeywords = [\"test\", \"message\", \"secret\", \"key\"]\n\nkey, decrypted_message = search_key(cipher_text, keywords)\nif key:\n    print(f\"Key found: {key}\")\n    print(\"Decrypted Message:\")\n    print(decrypted_message)\nelse:\n    print(\"No key found with the given keywords.\")"}, {"role": "assistant", "content": "Key found: 3\nDecrypted Message:\nThis is a test message with a secret key\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef encrypt_data(data, key):\n    encrypted = []\n    for char in data:\n        encrypted.append(chr((ord(char) + key) % 256))\n    return encrypted\n\ndef decrypt_data(data, key):\n    decrypted = []\n    for char in data:\n        decrypted.append(chr((ord(char) - key) % 256))\n    return decrypted\n\ndef sort_by_frequency(data):\n    frequency = {}\n    for char in data:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    return sorted(data, key=lambda x: frequency[x])\n\ndef pseudo_encode(data):\n    sorted_data = sort_by_frequency(data)\n    blocks = [sorted_data[i:i+4] for i in range(0, len(sorted_data), 4)]\n    encoded = []\n    for block in blocks:\n        block_sum = sum(ord(char) for char in block)\n        encoded.append(chr(block_sum % 256))\n    return ''.join(encoded)\n\ndef pseudo_decode(encoded_data):\n    decoded = []\n    for char in encoded_data:\n        decoded.append(chr((ord(char) * 4) % 256))\n    return ''.join(decoded)\n\nmessage = \"Advanced Encryption Test with Unique Sort\"\nkey = 5\n\nencrypted_message = encrypt_data(message, key)\nencoded_message = pseudo_encode(encrypted_message)\ndecoded_message = pseudo_decode(encoded_message)\ndecrypted_message = decrypt_data(decoded_message, key)\n\nprint(f\"Original Message: {message}\")\nprint(f\"Encrypted Message: {''.join(encrypted_message)}\")\nprint(f\"Encoded Message: {encoded_message}\")\nprint(f\"Decoded Message: {decoded_message}\")\nprint(f\"Decrypted Message: {''.join(decrypted_message)}\")"}, {"role": "assistant", "content": "Original Message: Advanced Encryption Test with Unique Sort\nEncrypted Message: Fi{fshji%Jshw~uynts%Yjxy%|nym%Zsnvzj%Xtwy\nEncoded Message: q\u00c4\u00b9\u00a3\u00bc\u00c3\u00b0\u00d2\u00de\u0094%\nDecoded Message: \u00c4\u0010\u00e4\u008c\u00f0\f\u00c0HxP\u0094\nDecrypted Message: \u00bf\u000b\u00df\u0087\u00eb\u0007\u00bbCsK\u008f\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef calculate_distance(point1, point2):\n    return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)\n\ndef search_smallest_distance(points):\n    min_dist = float('inf')\n    pair = (None, None)\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            dist = calculate_distance(points[i], points[j])\n            if dist < min_dist:\n                min_dist = dist\n                pair = (points[i], points[j])\n    return pair\n\ndef find_largest_distance(points):\n    max_dist = float('-inf')\n    pair = (None, None)\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            dist = calculate_distance(points[i], points[j])\n            if dist > max_dist:\n                max_dist = dist\n                pair = (points[i], points[j])\n    return min_dist\n\npoints = [(1, 2), (4, 6), (7, 8), (2, 1), (10, 10), (5, 5)]\nresult = find_largest_distance(points)\nprint(result)"}, {"role": "assistant", "content": "Traceback (most recent call last):\n  File \"<string>\", line 29, in <module>\n  File \"<string>\", line 26, in find_largest_distance\nNameError: name 'min_dist' is not defined. Did you mean: 'max_dist'?\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"Python is a high-level, interpreted, general-purpose programming language. Its design philosophy emphasizes code readability with the use of significant indentation.\nPython is dynamically-typed and garbage-collected. It supports multiple programming paradigms, including structured (particularly, procedural), object-oriented and functional programming.\"\"\"\n\nword_to_search = \"programming\"\nindexes = []\n\nprint(\"Searching for the word:\", word_to_search)\nprint(\"Text length:\", len(text))\nprint(\"Text:\", text)\n\nfor match in re.finditer(r'\\b' + re.escape(word_to_search) + r'\\b', text):\n    start_index = match.start()\n    print(f\"Found '{word_to_search}' at index: {start_index}\")\n    indexes.append(start_index)\n\nprint(\"All indexes where the word was found:\", indexes)\nprint(\"Total occurrences found:\", len(indexes))"}, {"role": "assistant", "content": "Searching for the word: programming\nText length: 353\nText: Python is a high-level, interpreted, general-purpose programming language. Its design philosophy emphasizes code readability with the use of significant indentation.\nPython is dynamically-typed and garbage-collected. It supports multiple programming paradigms, including structured (particularly, procedural), object-oriented and functional programming.\nFound 'programming' at index: 53\nFound 'programming' at index: 238\nFound 'programming' at index: 341\nAll indexes where the word was found: [53, 238, 341]\nTotal occurrences found: 3\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef search_next_mondays(year):\n    start_date = datetime(year, 1, 1)\n    end_date = datetime(year, 12, 31)\n    mondays = []\n    \n    current_date = start_date\n    while current_date <= end_date:\n        if current_date.weekday() == 0:\n            mondays.append(current_date)\n        current_date += timedelta(days=1)\n    \n    return mondays\n\ndef binary_search_date(dates, target_date):\n    low, high = 0, len(dates) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        mid_date = dates[mid]\n        \n        if mid_date == target_date:\n            return mid\n        elif mid_date < target_date:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return -1\n\nyear = 2024\nmondays = search_next_mondays(year)\ntarget_date = datetime(year, 6, 3)\n\nindex = binary_search_date(mondays, target_date)\n\nif index != -1:\n    print(f\"Found {target_date.strftime('%Y-%m-%d')} at index {index} in the list of Mondays.\")\nelse:\n    print(f\"{target_date.strftime('%Y-%m-%d')} is not a Monday in the list.\")\n\nfor monday in mondays:\n    print(monday.strftime('%Y-%m-%d'))"}, {"role": "assistant", "content": "Found 2024-06-03 at index 22 in the list of Mondays.\n2024-01-01\n2024-01-08\n2024-01-15\n2024-01-22\n2024-01-29\n2024-02-05\n2024-02-12\n2024-02-19\n2024-02-26\n2024-03-04\n2024-03-11\n2024-03-18\n2024-03-25\n2024-04-01\n2024-04-08\n2024-04-15\n2024-04-22\n2024-04-29\n2024-05-06\n2024-05-13\n2024-05-20\n2024-05-27\n2024-06-03\n2024-06-10\n2024-06-17\n2024-06-24\n2024-07-01\n2024-07-08\n2024-07-15\n2024-07-22\n2024-07-29\n2024-08-05\n2024-08-12\n2024-08-19\n2024-08-26\n2024-09-02\n2024-09-09\n2024-09-16\n2024-09-23\n2024-09-30\n2024-10-07\n2024-10-14\n2024-10-21\n2024-10-28\n2024-11-04\n2024-11-11\n2024-11-18\n2024-11-25\n2024-12-02\n2024-12-09\n2024-12-16\n2024-12-23\n2024-12-30\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef distance_from_origin(point):\n    return math.sqrt(point[0]**2 + point[1]**2)\n\npoints = [\n    (3, 4), (1, 1), (0, 0), (5, 12), (-3, -4),\n    (2, 2), (3, 3), (6, 8), (9, 12), (-5, -12),\n    (7, 24), (8, 15), (10, 24), (24, 7), (12, 5)\n]\n\nprint(\"Original points:\")\nfor p in points:\n    print(p)\n\nsorted_points = sorted(points, key=distance_from_origin)\n\nprint(\"\\nPoints sorted by distance from origin:\")\nfor p in sorted_points:\n    print(p)"}, {"role": "assistant", "content": "Original points:\n(3, 4)\n(1, 1)\n(0, 0)\n(5, 12)\n(-3, -4)\n(2, 2)\n(3, 3)\n(6, 8)\n(9, 12)\n(-5, -12)\n(7, 24)\n(8, 15)\n(10, 24)\n(24, 7)\n(12, 5)\n\nPoints sorted by distance from origin:\n(0, 0)\n(1, 1)\n(2, 2)\n(3, 3)\n(3, 4)\n(-3, -4)\n(6, 8)\n(5, 12)\n(-5, -12)\n(12, 5)\n(9, 12)\n(8, 15)\n(7, 24)\n(24, 7)\n(10, 24)\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\ndef convert_to_unix_timestamps(dates):\n    return [int(datetime.strptime(date, \"%Y-%m-%d\").timestamp()) for date in dates]\n\ndef search_max_timestamp(dates):\n    unix_timestamps = convert_to_unix_timestamps(dates)\n    max_timestamp = min(unix_timestamps)\n    max_index = unix_timestamps.index(max_timestamp)\n    return dates[max_index]\n\ndate_list = [\n    \"2021-12-25\", \"2020-01-01\", \"2022-07-04\", \"2019-08-15\",\n    \"2020-12-31\", \"2021-05-05\", \"2018-11-11\", \"2023-01-01\",\n    \"2022-01-01\", \"2020-07-20\", \"2019-12-31\", \"2021-10-10\",\n    \"2022-03-15\", \"2021-11-01\", \"2023-03-01\", \"2020-05-15\",\n    \"2019-04-01\", \"2021-09-09\", \"2022-12-12\", \"2020-10-10\",\n    \"2021-06-06\", \"2018-01-01\", \"2022-08-08\", \"2019-07-07\",\n    \"2023-04-04\"\n]\n\nresult = search_max_timestamp(date_list)\nprint(result)"}, {"role": "assistant", "content": "2018-01-01\n"}]}
{"messages": [{"role": "user", "content": "import math\nimport statistics\n\ndef weighted_median(data, weights):\n    sorted_data, sorted_weights = zip(*sorted(zip(data, weights)))\n    cumulative_weight = 0\n    total_weight = sum(sorted_weights)\n    for i, weight in enumerate(sorted_weights):\n        cumulative_weight += weight\n        if cumulative_weight >= total_weight / 2:\n            return sorted_data[i]\n\ndata = [81, 59, 75, 60, 97, 85, 72, 99, 68, 77, 94, 62]\nweights = [1, 2, 3, 4, 5, 1, 1, 1, 2, 3, 4, 5]\nmedian = statistics.median(data)\nweighted_median_value = weighted_median(data, weights)\n\nprint(f\"Data: {data}\")\nprint(f\"Weights: {weights}\")\nprint(f\"Simple Median: {median}\")\nprint(f\"Weighted Median: {weighted_median_value}\")\n\ndata.sort()\nlower_half = data[:len(data)//2]\nupper_half = data[len(data)//2:]\n\nq1 = statistics.median(lower_half)\nq3 = statistics.median(upper_half)\n\niqr = q3 - q1\n\nprint(f\"Sorted Data: {data}\")\nprint(f\"Q1: {q1}\")\nprint(f\"Q3: {q3}\")\nprint(f\"IQR: {iqr}\")\n\ndef quicksort(data):\n    if len(data) <= 1:\n        return data\n    pivot = data[len(data) // 2]\n    left = [x for x in data if x < pivot]\n    middle = [x for x in data if x == pivot]\n    right = [x for x in data if x > pivot]\n    return quicksort(left) + middle + quicksort(right)\n\nsorted_data = quicksort(data)\nprint(f\"Quicksorted Data: {sorted_data}\")\nprint(f\"Length of Data: {len(data)}\")\nprint(f\"Mean of Data: {statistics.mean(data)}\")\nprint(f\"Variance of Data: {statistics.variance(data)}\")\nprint(f\"Standard Deviation of Data: {math.sqrt(statistics.variance(data))}\")"}, {"role": "assistant", "content": "Data: [81, 59, 75, 60, 97, 85, 72, 99, 68, 77, 94, 62]\nWeights: [1, 2, 3, 4, 5, 1, 1, 1, 2, 3, 4, 5]\nSimple Median: 76.0\nWeighted Median: 75\nSorted Data: [59, 60, 62, 68, 72, 75, 77, 81, 85, 94, 97, 99]\nQ1: 65.0\nQ3: 89.5\nIQR: 24.5\nQuicksorted Data: [59, 60, 62, 68, 72, 75, 77, 81, 85, 94, 97, 99]\nLength of Data: 12\nMean of Data: 77.41666666666667\nVariance of Data: 199.90151515151516\nStandard Deviation of Data: 14.138653229763971\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef binary_search_mean(data, target):\n    low, high = 0, len(data) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        mean = statistics.mean(data[:mid+1])\n        if mean == target:\n            return mid\n        elif mean < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n\ndata = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 9, 7, 9, 3, 2, 3, 8, 4, 6, 2, 6, 4, 3, 8, 3, 2, 7, 9, 5]\ndata.sort()\n\ntarget_means = [3.5, 4.0, 5.0, 6.5, 7.5, 8.5]\nresults = []\n\nfor target in target_means:\n    index = binary_search_mean(data, target)\n    if index != -1:\n        results.append((target, index, data[:index+1]))\n    else:\n        results.append((target, \"not found\"))\n\nfor result in results:\n    print(result)"}, {"role": "assistant", "content": "(3.5, 'not found')\n(4.0, 24, [1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 7, 8])\n(5.0, 'not found')\n(6.5, 'not found')\n(7.5, 'not found')\n(8.5, 'not found')\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\nplayers = [\n    {\"name\": \"Alice\", \"score\": 1500, \"last_played\": datetime(2023, 5, 17)},\n    {\"name\": \"Bob\", \"score\": 1200, \"last_played\": datetime(2023, 5, 18)},\n    {\"name\": \"Charlie\", \"score\": 1800, \"last_played\": datetime(2023, 5, 16)},\n    {\"name\": \"David\", \"score\": 1600, \"last_played\": datetime(2023, 5, 15)},\n    {\"name\": \"Eve\", \"score\": 1700, \"last_played\": datetime(2023, 5, 19)},\n    {\"name\": \"Frank\", \"score\": 1300, \"last_played\": datetime(2023, 5, 14)},\n    {\"name\": \"Grace\", \"score\": 1100, \"last_played\": datetime(2023, 5, 20)},\n    {\"name\": \"Heidi\", \"score\": 1400, \"last_played\": datetime(2023, 5, 13)},\n    {\"name\": \"Ivan\", \"score\": 1250, \"last_played\": datetime(2023, 5, 12)},\n    {\"name\": \"Judy\", \"score\": 1350, \"last_played\": datetime(2023, 5, 11)}\n]\n\nprint(\"Initial Players List:\")\nfor player in players:\n    print(f\"{player['name']} - Score: {player['score']}, Last Played: {player['last_played'].strftime('%Y-%m-%d')}\")\n\ndef sort_players_by_score_then_date(players):\n    sorted_players = sorted(players, key=lambda x: (x['score'], x['last_played']))\n    return sorted_players\n\nsorted_players = sort_players_by_score_then_date(players)\n\nprint(\"\\nSorted Players List:\")\nfor player in sorted_players:\n    print(f\"{player['name']} - Score: {player['score']}, Last Played: {player['last_played'].strftime('%Y-%m-%d')}\")"}, {"role": "assistant", "content": "Initial Players List:\nAlice - Score: 1500, Last Played: 2023-05-17\nBob - Score: 1200, Last Played: 2023-05-18\nCharlie - Score: 1800, Last Played: 2023-05-16\nDavid - Score: 1600, Last Played: 2023-05-15\nEve - Score: 1700, Last Played: 2023-05-19\nFrank - Score: 1300, Last Played: 2023-05-14\nGrace - Score: 1100, Last Played: 2023-05-20\nHeidi - Score: 1400, Last Played: 2023-05-13\nIvan - Score: 1250, Last Played: 2023-05-12\nJudy - Score: 1350, Last Played: 2023-05-11\n\nSorted Players List:\nGrace - Score: 1100, Last Played: 2023-05-20\nBob - Score: 1200, Last Played: 2023-05-18\nIvan - Score: 1250, Last Played: 2023-05-12\nFrank - Score: 1300, Last Played: 2023-05-14\nJudy - Score: 1350, Last Played: 2023-05-11\nHeidi - Score: 1400, Last Played: 2023-05-13\nAlice - Score: 1500, Last Played: 2023-05-17\nDavid - Score: 1600, Last Played: 2023-05-15\nEve - Score: 1700, Last Played: 2023-05-19\nCharlie - Score: 1800, Last Played: 2023-05-16\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef is_date_palindrome(date_str):\n    return date_str == date_str[::-1]\n\ndef search_for_palindrome_dates(start_date, end_date):\n    current_date = start_date\n    palindromes = []\n    while current_date <= end_date:\n        date_str = current_date.strftime('%m%d%Y')\n        if is_date_palindrome(date_str):\n            print(f\"Found palindrome: {date_str}\")\n            palindromes.append(date_str)\n        current_date += timedelta(days=1)\n    return palindromes\n\ndef find_all_palindrome_dates(year):\n    start_date = datetime(year, 1, 1)\n    end_date = datetime(year, 12, 31)\n    return search_for_palindrome_dates(start_date, end_date)\n\nyear_to_search = 2025\nprint(f\"Searching for palindrome dates in the year: {year_to_search}\")\npalindrome_dates = find_all_palindrome_dates(year_to_search)\nprint(f\"Total palindrome dates found: {len(palindrome_dates)}\")\nfor palindrome in palindrome_dates:\n    print(palindrome)"}, {"role": "assistant", "content": "Searching for palindrome dates in the year: 2025\nTotal palindrome dates found: 0\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef find_friday_13th(year):\n    fridays = []\n    for month in range(1, 13):\n        date = datetime(year, month, 13)\n        if date.weekday() == 4:\n            fridays.append(date.strftime(\"%B %d, %Y\"))\n    return fridays\n\ndef binary_search_friday(years):\n    low = 0\n    high = len(years) - 1\n    result = []\n    while low <= high:\n        mid = (low + high) // 2\n        print(f\"Searching year: {years[mid]}\")\n        fridays = find_friday_13th(years[mid])\n        if fridays:\n            print(f\"Found Friday the 13th in {years[mid]}: {fridays}\")\n            result.extend(fridays)\n            high = mid - 1\n        else:\n            low = mid + 1\n    return result\n\nstart_year = 1900\nend_year = 2023\nyears = list(range(start_year, end_year + 1))\n\nfriday_13ths = binary_search_friday(years)\nfor friday in friday_13ths:\n    print(friday)"}, {"role": "assistant", "content": "Searching year: 1961\nFound Friday the 13th in 1961: ['January 13, 1961', 'October 13, 1961']\nSearching year: 1930\nFound Friday the 13th in 1930: ['June 13, 1930']\nSearching year: 1914\nFound Friday the 13th in 1914: ['February 13, 1914', 'March 13, 1914', 'November 13, 1914']\nSearching year: 1906\nFound Friday the 13th in 1906: ['April 13, 1906', 'July 13, 1906']\nSearching year: 1902\nFound Friday the 13th in 1902: ['June 13, 1902']\nSearching year: 1900\nFound Friday the 13th in 1900: ['April 13, 1900', 'July 13, 1900']\nJanuary 13, 1961\nOctober 13, 1961\nJune 13, 1930\nFebruary 13, 1914\nMarch 13, 1914\nNovember 13, 1914\nApril 13, 1906\nJuly 13, 1906\nJune 13, 1902\nApril 13, 1900\nJuly 13, 1900\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef sort_dates_by_weekday(dates):\n    weekdays = {'Monday': 0, 'Tuesday': 1, 'Wednesday': 2, 'Thursday': 3, \n                'Friday': 4, 'Saturday': 5, 'Sunday': 6}\n    return sorted(dates, key=lambda date: (weekdays[date.strftime('%A')], date))\n\ndate_strings = [\n    '2023-10-02', '2023-10-03', '2023-10-04', '2023-10-05', '2023-10-06',\n    '2023-10-07', '2023-10-08', '2023-10-09', '2023-10-10', '2023-10-11',\n    '2023-10-12', '2023-10-13', '2023-10-14', '2023-10-15', '2023-10-16',\n    '2023-10-17', '2023-10-18', '2023-10-19', '2023-10-20', '2023-10-21',\n    '2023-10-22', '2023-10-23', '2023-10-24', '2023-10-25', '2023-10-26',\n    '2023-10-27', '2023-10-28', '2023-10-29', '2023-10-30', '2023-10-31'\n]\n\ndates = [datetime.datetime.strptime(date_str, '%Y-%m-%d') for date_str in date_strings]\nsorted_dates = sort_dates_by_weekday(dates)\n\nfor date in sorted_dates:\n    print(date.strftime('%Y-%m-%d %A'))"}, {"role": "assistant", "content": "2023-10-02 Monday\n2023-10-09 Monday\n2023-10-16 Monday\n2023-10-23 Monday\n2023-10-30 Monday\n2023-10-03 Tuesday\n2023-10-10 Tuesday\n2023-10-17 Tuesday\n2023-10-24 Tuesday\n2023-10-31 Tuesday\n2023-10-04 Wednesday\n2023-10-11 Wednesday\n2023-10-18 Wednesday\n2023-10-25 Wednesday\n2023-10-05 Thursday\n2023-10-12 Thursday\n2023-10-19 Thursday\n2023-10-26 Thursday\n2023-10-06 Friday\n2023-10-13 Friday\n2023-10-20 Friday\n2023-10-27 Friday\n2023-10-07 Saturday\n2023-10-14 Saturday\n2023-10-21 Saturday\n2023-10-28 Saturday\n2023-10-08 Sunday\n2023-10-15 Sunday\n2023-10-22 Sunday\n2023-10-29 Sunday\n"}]}
{"messages": [{"role": "user", "content": "import re\nimport datetime\n\ndata = [\n    \"Alice:2023-03-01\",\n    \"Bob:2023-02-28\",\n    \"Charlie:2023-03-03\",\n    \"David:2023-02-27\",\n    \"Eve:2023-03-02\",\n    \"Frank:2023-03-01\",\n    \"Grace:2023-03-02\"\n]\n\ndef parse_data(data):\n    parsed = []\n    for entry in data:\n        name, date_str = entry.split(':')\n        date = datetime.datetime.strptime(date_str, \"%Y-%m-%d\").date()\n        parsed.append((name, date))\n    return parsed\n\ndef pattern_search(transformed_data, pattern):\n    regex = re.compile(pattern)\n    matches = [name for name, date in transformed_data if regex.search(name)]\n    return matches\n\ndef transform_and_search(data, pattern):\n    transformed_data = parse_data(data)\n    matches = pattern_search(transformed_data, pattern)\n    return matches\n\npattern = r'^[A-M]'\nmatches = transform_and_search(data, pattern)\nfor match in matches:\n    print(match)"}, {"role": "assistant", "content": "Alice\nBob\nCharlie\nDavid\nEve\nFrank\nGrace\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef sort_dates_by_weekday(dates):\n    def weekday_key(date):\n        return date.weekday()\n\n    return sorted(dates, key=weekday_key)\n\ndates = [\n    datetime(2023, 10, 15),\n    datetime(2023, 10, 14),\n    datetime(2023, 10, 13),\n    datetime(2023, 10, 16),\n    datetime(2023, 10, 17),\n    datetime(2023, 10, 12),\n    datetime(2023, 10, 18)\n]\n\nsorted_dates = sort_dates_by_weekday(dates)\nfor date in sorted_dates:\n    print(date.strftime(\"%Y-%m-%d %A\"))"}, {"role": "assistant", "content": "2023-10-16 Monday\n2023-10-17 Tuesday\n2023-10-18 Wednesday\n2023-10-12 Thursday\n2023-10-13 Friday\n2023-10-14 Saturday\n2023-10-15 Sunday\n"}]}
{"messages": [{"role": "user", "content": "def generate_pattern(n):\n    pattern = []\n    for i in range(n):\n        line = [\"*\"] * (i + 1)\n        pattern.append(\"\".join(line))\n    return pattern\n\ndef sort_pattern_desc(pattern):\n    for i in range(len(pattern)):\n        for j in range(0, len(pattern)-i-1):\n            if len(pattern[j]) < len(pattern[j+1]):\n                pattern[j], pattern[j+1] = pattern[j+1], pattern[j]\n    return pattern\n\nn = 10\npattern = generate_pattern(n)\nsorted_pattern = sort_pattern_desc(pattern)\n\nfor line in sorted_pattern:\n    print(line)"}, {"role": "assistant", "content": "**********\n*********\n********\n*******\n******\n*****\n****\n***\n**\n*\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\nevents = [\n    (\"Event A\", datetime.datetime(2023, 5, 20, 14, 30)),\n    (\"Event B\", datetime.datetime(2023, 4, 18, 16, 0)),\n    (\"Event C\", datetime.datetime(2023, 5, 21, 9, 0)),\n    (\"Event D\", datetime.datetime(2023, 5, 20, 10, 15)),\n    (\"Event E\", datetime.datetime(2023, 4, 18, 18, 30)),\n    (\"Event F\", datetime.datetime(2023, 4, 18, 16, 0)),\n    (\"Event G\", datetime.datetime(2023, 5, 21, 9, 0)),\n    (\"Event H\", datetime.datetime(2023, 5, 20, 14, 30)),\n    (\"Event I\", datetime.datetime(2023, 4, 18, 18, 30)),\n    (\"Event J\", datetime.datetime(2023, 4, 18, 16, 0))\n]\n\nsorted_events = sorted(events, key=lambda x: (x[1], x[0]))\n\nfor event in sorted_events:\n    print(event[0], event[1].strftime('%Y-%m-%d %H:%M'))"}, {"role": "assistant", "content": "Event B 2023-04-18 16:00\nEvent F 2023-04-18 16:00\nEvent J 2023-04-18 16:00\nEvent E 2023-04-18 18:30\nEvent I 2023-04-18 18:30\nEvent D 2023-05-20 10:15\nEvent A 2023-05-20 14:30\nEvent H 2023-05-20 14:30\nEvent C 2023-05-21 09:00\nEvent G 2023-05-21 09:00\n"}]}
{"messages": [{"role": "user", "content": "import itertools\n\ndef evaluate_hand(hand):\n    values = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6,\n              '7': 7, '8': 8, '9': 9, 'T': 10, 'J': 11,\n              'Q': 12, 'K': 13, 'A': 14}\n    hand_values = sorted([values[card[0]] for card in hand], reverse=True)\n    print(f\"Evaluating hand: {hand} -> Values: {hand_values}\")\n    return hand_values\n\ndef determine_winner(hands):\n    sorted_hands = sorted(hands, key=evaluate_hand, reverse=True)\n    print(f\"Sorted hands based on value: {sorted_hands}\")\n    return sorted_hands[0]\n\nranks = '23456789TJQKA'\nsuits = 'CDHS'\ndeck = [rank + suit for rank in ranks for suit in suits]\n\nplayers = list(itertools.combinations(deck, 5))\n\nplayer_hands = players[:10]  # Only pick the first 10 for a quick game\nprint(\"Initial hands:\")\nfor hand in player_hands:\n    print(hand)\n\nwinner = determine_winner(player_hands)\nprint(f\"The winning hand is: {winner}\")"}, {"role": "assistant", "content": "Initial hands:\n('2C', '2D', '2H', '2S', '3C')\n('2C', '2D', '2H', '2S', '3D')\n('2C', '2D', '2H', '2S', '3H')\n('2C', '2D', '2H', '2S', '3S')\n('2C', '2D', '2H', '2S', '4C')\n('2C', '2D', '2H', '2S', '4D')\n('2C', '2D', '2H', '2S', '4H')\n('2C', '2D', '2H', '2S', '4S')\n('2C', '2D', '2H', '2S', '5C')\n('2C', '2D', '2H', '2S', '5D')\nEvaluating hand: ('2C', '2D', '2H', '2S', '3C') -> Values: [3, 2, 2, 2, 2]\nEvaluating hand: ('2C', '2D', '2H', '2S', '3D') -> Values: [3, 2, 2, 2, 2]\nEvaluating hand: ('2C', '2D', '2H', '2S', '3H') -> Values: [3, 2, 2, 2, 2]\nEvaluating hand: ('2C', '2D', '2H', '2S', '3S') -> Values: [3, 2, 2, 2, 2]\nEvaluating hand: ('2C', '2D', '2H', '2S', '4C') -> Values: [4, 2, 2, 2, 2]\nEvaluating hand: ('2C', '2D', '2H', '2S', '4D') -> Values: [4, 2, 2, 2, 2]\nEvaluating hand: ('2C', '2D', '2H', '2S', '4H') -> Values: [4, 2, 2, 2, 2]\nEvaluating hand: ('2C', '2D', '2H', '2S', '4S') -> Values: [4, 2, 2, 2, 2]\nEvaluating hand: ('2C', '2D', '2H', '2S', '5C') -> Values: [5, 2, 2, 2, 2]\nEvaluating hand: ('2C', '2D', '2H', '2S', '5D') -> Values: [5, 2, 2, 2, 2]\nSorted hands based on value: [('2C', '2D', '2H', '2S', '5C'), ('2C', '2D', '2H', '2S', '5D'), ('2C', '2D', '2H', '2S', '4C'), ('2C', '2D', '2H', '2S', '4D'), ('2C', '2D', '2H', '2S', '4H'), ('2C', '2D', '2H', '2S', '4S'), ('2C', '2D', '2H', '2S', '3C'), ('2C', '2D', '2H', '2S', '3D'), ('2C', '2D', '2H', '2S', '3H'), ('2C', '2D', '2H', '2S', '3S')]\nThe winning hand is: ('2C', '2D', '2H', '2S', '5C')\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef distance(point1, point2):\n    return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2)\n\ndef angle_from_origin(point):\n    return math.atan2(point[1], point[0])\n\ndef sort_points_by_angle(points):\n    return sorted(points, key=angle_from_origin)\n\ndef perimeter_of_polygon(points):\n    perimeter = 0\n    for i in range(len(points)):\n        perimeter += distance(points[i], points[(i + 1) % len(points)])\n    return perimeter\n\npoints = [\n    (1, 2), (4, 4), (3, -1), (0, 0), (-2, 1),\n    (1, -3), (-3, -3), (2, 3), (-1, 4), (0, -2)\n]\n\nsorted_points = sort_points_by_angle(points)\nperimeter = perimeter_of_polygon(sorted_points)\n\nprint(\"Sorted Points by Angle from Origin:\")\nfor p in sorted_points:\n    print(f\"{p} -> Angle: {angle_from_origin(p):.2f}\")\n\nprint(f\"\\nPerimeter of Polygon: {perimeter:.2f}\")"}, {"role": "assistant", "content": "Sorted Points by Angle from Origin:\n(-3, -3) -> Angle: -2.36\n(0, -2) -> Angle: -1.57\n(1, -3) -> Angle: -1.25\n(3, -1) -> Angle: -0.32\n(0, 0) -> Angle: 0.00\n(4, 4) -> Angle: 0.79\n(2, 3) -> Angle: 0.98\n(1, 2) -> Angle: 1.11\n(-1, 4) -> Angle: 1.82\n(-2, 1) -> Angle: 2.68\n\nPerimeter of Polygon: 29.99\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\nimport statistics\n\ndata = [\n    {'timestamp': '2023-10-01 08:00:00', 'value': 35},\n    {'timestamp': '2023-10-01 09:00:00', 'value': 37},\n    {'timestamp': '2023-10-01 10:00:00', 'value': 34},\n    {'timestamp': '2023-10-01 11:00:00', 'value': 40},\n    {'timestamp': '2023-10-01 12:00:00', 'value': 42},\n    {'timestamp': '2023-10-01 13:00:00', 'value': 38},\n    {'timestamp': '2023-10-01 14:00:00', 'value': 36},\n    {'timestamp': '2023-10-01 15:00:00', 'value': 39},\n    {'timestamp': '2023-10-01 16:00:00', 'value': 41},\n    {'timestamp': '2023-10-01 17:00:00', 'value': 43},\n    {'timestamp': '2023-10-01 18:00:00', 'value': 37}\n]\n\nfor entry in data:\n    entry['datetime'] = datetime.strptime(entry['timestamp'], '%Y-%m-%d %H:%M:%S')\n\nsorted_data = sorted(data, key=lambda x: x['value'])\n\nmedian_value = statistics.median(entry['value'] for entry in sorted_data)\n\nfiltered_data = [entry for entry in sorted_data if entry['value'] >= median_value]\n\nfor entry in filtered_data:\n    print(f\"{entry['datetime'].strftime('%Y-%m-%d %H:%M:%S')} - {entry['value']}\")"}, {"role": "assistant", "content": "2023-10-01 13:00:00 - 38\n2023-10-01 15:00:00 - 39\n2023-10-01 11:00:00 - 40\n2023-10-01 16:00:00 - 41\n2023-10-01 12:00:00 - 42\n2023-10-01 17:00:00 - 43\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef cosine_similarity(v1, v2):\n    dot_product = sum(a * b for a, b in zip(v1, v2))\n    magnitude_v1 = math.sqrt(sum(a ** 2 for a in v1))\n    magnitude_v2 = math.sqrt(sum(b ** 2 for b in v2))\n    if magnitude_v1 == 0 or magnitude_v2 == 0:\n        return 0\n    return dot_product / (magnitude_v1 * magnitude_v2)\n\ndef search_similar_vectors(vectors, query_vector, threshold):\n    similar_vectors = []\n    for vector in vectors:\n        similarity = cosine_similarity(vector, query_vector)\n        if similarity > threshold:\n            similar_vectors.append((vector, similarity))\n    return sorted(similar_vectors, key=lambda x: x[1], reverse=True)\n\ndata_vectors = [\n    [1, 0, 0],\n    [0, 1, 1],\n    [1, 1, 0],\n    [0, 0, 1],\n    [1, 1, 1],\n    [0, 0, 0],\n    [0.5, 0.5, 0],\n    [0.5, 0.5, 0.5]\n]\n\nquery = [0.3, 0.3, 0.3]\nthreshold = 0.5\n\nresults = search_similar_vectors(data_vectors, query, threshold)\n\nfor vector, similarity in results:\n    print(f\"Vector: {vector}, Similarity: {similarity:.2f}\")"}, {"role": "assistant", "content": "Vector: [1, 1, 1], Similarity: 1.00\nVector: [0.5, 0.5, 0.5], Similarity: 1.00\nVector: [0, 1, 1], Similarity: 0.82\nVector: [1, 1, 0], Similarity: 0.82\nVector: [0.5, 0.5, 0], Similarity: 0.82\nVector: [1, 0, 0], Similarity: 0.58\nVector: [0, 0, 1], Similarity: 0.58\n"}]}
{"messages": [{"role": "user", "content": "def selection_sort(arr):\n    for i in range(len(arr)):\n        min_idx = i\n        for j in range(i + 1, len(arr)):\n            if arr[min_idx] > arr[j]:\n                min_idx = j\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr\n\ndef evaluate_game_score(scores, player_names):\n    sorted_scores = selection_sort(scores.copy())\n    rank_list = []\n    for score in sorted_scores:\n        for i, original_score in enumerate(scores):\n            if original_score == score and player_names[i] not in rank_list:\n                rank_list.append(player_names[i])\n                break\n    return rank_list\n\nplayers = [\n    \"Alice\", \"Bob\", \"Charlie\", \"David\", \"Eva\", \n    \"Frank\", \"Grace\", \"Hannah\", \"Ivy\", \"Jack\"\n]\n\nscores = [34, 21, 55, 13, 89, 5, 42, 8, 55, 21]\n\nranked_players = evaluate_game_score(scores, players)\n\nfor rank, player in enumerate(ranked_players, start=1):\n    print(f\"Rank {rank}: {player}\")"}, {"role": "assistant", "content": "Rank 1: Frank\nRank 2: Hannah\nRank 3: David\nRank 4: Bob\nRank 5: Jack\nRank 6: Alice\nRank 7: Grace\nRank 8: Charlie\nRank 9: Ivy\nRank 10: Eva\n"}]}
{"messages": [{"role": "user", "content": "def is_safe(board, row, col, num):\n    for x in range(9):\n        if board[row][x] == num or board[x][col] == num:\n            return False\n    start_row, start_col = 3 * (row // 3), 3 * (col // 3)\n    for i in range(3):\n        for j in range(3):\n            if board[i + start_row][j + start_col] == num:\n                return False\n    return True\n\ndef solve_sudoku(board):\n    empty_pos = find_empty_location(board)\n    if not empty_pos:\n        return True\n    row, col = empty_pos\n    for num in range(1, 10):\n        if is_safe(board, row, col, num):\n            board[row][col] = num\n            if solve_sudoku(board):\n                return True\n            board[row][col] = 0\n    return False\n\ndef find_empty_location(board):\n    for i in range(9):\n        for j in range(9):\n            if board[i][j] == 0:\n                return (i, j)\n    return None\n\ndef print_board(board):\n    for row in board:\n        print(\" \".join(str(num) for num in row))\n\nsudoku_board = [\n    [5, 3, 0, 0, 7, 0, 0, 0, 0],\n    [6, 0, 0, 1, 9, 5, 0, 0, 0],\n    [0, 9, 8, 0, 0, 0, 0, 6, 0],\n    [8, 0, 0, 0, 6, 0, 0, 0, 3],\n    [4, 0, 0, 8, 0, 3, 0, 0, 1],\n    [7, 0, 0, 0, 2, 0, 0, 0, 6],\n    [0, 6, 0, 0, 0, 0, 2, 8, 0],\n    [0, 0, 0, 4, 1, 9, 0, 0, 5],\n    [0, 0, 0, 0, 8, 0, 0, 7, 9]\n]\n\nif solve_sudoku(sudoku_board):\n    print_board(sudoku_board)\nelse:\n    print(\"No solution exists\")"}, {"role": "assistant", "content": "5 3 4 6 7 8 9 1 2\n6 7 2 1 9 5 3 4 8\n1 9 8 3 4 2 5 6 7\n8 5 9 7 6 1 4 2 3\n4 2 6 8 5 3 7 9 1\n7 1 3 9 2 4 8 5 6\n9 6 1 5 3 7 2 8 4\n2 8 7 4 1 9 6 3 5\n3 4 5 2 8 6 1 7 9\n"}]}
{"messages": [{"role": "user", "content": "from itertools import cycle\n\ndef xor_encrypt_decrypt(text, key):\n    return ''.join(chr(ord(c) ^ ord(k)) for c, k in zip(text, cycle(key)))\n\ndef encrypt_message(message, key):\n    encrypted = xor_encrypt_decrypt(message, key)\n    sorted_encrypted = ''.join(sorted(encrypted))\n    return sorted_encrypted\n\ndef decrypt_message(sorted_encrypted, key):\n    encrypted = ''.join(sorted_encrypted)\n    decrypted = xor_encrypt_decrypt(encrypted, key)\n    return decrypted\n\nmessage = \"This is a secret message that needs encryption!\"\nkey = \"key123\"\n\nencrypted = encrypt_message(message, key)\ndecrypted = decrypt_message(encrypted, key)\n\nprint(\"Encrypted and Sorted Message:\")\nprint(encrypted)\nprint(\"\\nAttempted Decryption:\")\nprint(decrypted)"}, {"role": "assistant", "content": "Encrypted and Sorted Message:\n\u0000\u0005\b\n\u000b\f\n\u000e\u000e\u0010\u0011\u0011\u0011\u0012\u0012\u0013\u0013\u0013\u0016\u0016\u0017\u0018\u0018\u001a\u001c\u001c\u001f?AABCCEEFKKPPUUVVZ^_\n\nAttempted Decryption:\nk`q;9?fkw!#\"zwk\"! }sn)*)wyf\u000esr)&:twu .)agf=3#om\n"}]}
{"messages": [{"role": "user", "content": "from itertools import permutations\nimport hashlib\n\ndef encode_string(s):\n    return hashlib.sha256(s.encode()).hexdigest()[:8]\n\ndef search_encoded_permutation(target_hash, charset):\n    for perm in permutations(charset):\n        permuted_string = ''.join(perm)\n        encoded = encode_string(permuted_string)\n        if encoded == target_hash:\n            return permuted_string\n    return None\n\ncharset = 'abcde'\ntarget_encoded = encode_string('decab')\n\nresult = search_encoded_permutation(target_encoded, charset)\n\nif result:\n    print(f\"Found matching permutation: {result}\")\nelse:\n    print(\"No permutation matched the target hash.\")"}, {"role": "assistant", "content": "Found matching permutation: decab\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef custom_sort_key(num):\n    return (sum(int(digit)**2 for digit in str(num)), -num)\n\ndef generate_sequence(n):\n    sequence = []\n    for i in range(1, n + 1):\n        sequence.append(i * (i + 1) / 2)\n    return sequence\n\ndef main():\n    sequence = generate_sequence(100)\n    print(\"Generated sequence:\")\n    print(sequence)\n    \n    sorted_sequence = sorted(sequence, key=custom_sort_key)\n    \n    print(\"\\nSorted sequence based on custom key:\")\n    for num in sorted_sequence:\n        print(num)\n\nmain()"}, {"role": "assistant", "content": "Traceback (most recent call last):\n  File \"<string>\", line 23, in <module>\n  File \"<string>\", line 17, in main\n  File \"<string>\", line 4, in custom_sort_key\n  File \"<string>\", line 4, in <genexpr>\nValueError: invalid literal for int() with base 10: '.'\n"}]}
{"messages": [{"role": "user", "content": "import re\nfrom datetime import datetime\n\ndef search_longest_palindrome(text):\n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    words = re.findall(r'\\b\\w+\\b', text)\n    longest_palindrome = \"\"\n    \n    for word in words:\n        if is_palindrome(word) and len(word) > len(longest_palindrome):\n            longest_palindrome = word\n    \n    return longest_palindrome\n\ntext = (\n    \"Madam Arora teaches malayalam and level civic. \"\n    \"Refer to the racecar and deed stats\"\n)\n\nstart_time = datetime.now()\nlongest_word = search_longest_palindrome(text)\nend_time = datetime.now()\n\nprint(f\"Longest palindrome: {longest_word}\")\nprint(f\"Time taken: {end_time - start_time}\")"}, {"role": "assistant", "content": "Longest palindrome: malayalam\nTime taken: 0:00:00.000070\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef sort_words_by_vowel_count(text):\n    words = re.findall(r'\\b\\w+\\b', text)\n    sorted_words = sorted(words, key=lambda word: sum(1 for letter in word if letter in 'aeiouAEIOU'), reverse=True)\n    return ' '.join(sorted_words)\n\ntext = \"Sorting algorithms can be fascinating and educational\"\nsorted_text = sort_words_by_vowel_count(text)\nprint(sorted_text)"}, {"role": "assistant", "content": "educational fascinating algorithms Sorting can be and\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef generate_pattern(word):\n    return re.sub(r'(?<=.)(?=.)', '.*', word)\n\ndef search_patterns(dictionary, target):\n    pattern = generate_pattern(target)\n    regex = re.compile(pattern)\n    return [word for word in dictionary if regex.fullmatch(word)]\n\ndictionary = [\n    \"apples\", \"applis\", \"bppmes\", \"cppmes\", \"applesauce\",\n    \"applos\", \"applss\", \"appmes\", \"appies\", \"bppkes\", \"cppkes\"\n]\n\ntarget_word = \"apples\"\nmatched = search_patterns(dictionary, target_word)\n\nfor word in matched:\n    print(word)"}, {"role": "assistant", "content": "apples\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndata = [\n    (\"2023-10-02\", 1),\n    (\"2023-09-15\", 4),\n    (\"2023-08-22\", 3),\n    (\"2023-10-02\", 2),\n    (\"2023-09-20\", 5),\n    (\"2023-10-01\", 1),\n    (\"2023-09-15\", 2),\n    (\"2023-08-22\", 4),\n    (\"2023-10-03\", 2),\n    (\"2023-09-18\", 3),\n]\n\ndef custom_sort(item):\n    date_obj = datetime.datetime.strptime(item[0], \"%Y-%m-%d\")\n    return (date_obj, item[1])\n\nsorted_data = sorted(data, key=custom_sort)\n\ntransformed_data = []\nfor date_str, value in sorted_data:\n    date_obj = datetime.datetime.strptime(date_str, \"%Y-%m-%d\")\n    weekday = date_obj.strftime(\"%A\")\n    transformed_data.append((date_str, weekday, value))\n\nfor record in transformed_data:\n    print(f\"Date: {record[0]}, Weekday: {record[1]}, Value: {record[2]}\")"}, {"role": "assistant", "content": "Date: 2023-08-22, Weekday: Tuesday, Value: 3\nDate: 2023-08-22, Weekday: Tuesday, Value: 4\nDate: 2023-09-15, Weekday: Friday, Value: 2\nDate: 2023-09-15, Weekday: Friday, Value: 4\nDate: 2023-09-18, Weekday: Monday, Value: 3\nDate: 2023-09-20, Weekday: Wednesday, Value: 5\nDate: 2023-10-01, Weekday: Sunday, Value: 1\nDate: 2023-10-02, Weekday: Monday, Value: 1\nDate: 2023-10-02, Weekday: Monday, Value: 2\nDate: 2023-10-03, Weekday: Tuesday, Value: 2\n"}]}
{"messages": [{"role": "user", "content": "def find_fibonacci_index_by_value(value):\n    fib_sequence = [0, 1]\n    while fib_sequence[-1] < value:\n        fib_sequence.append(fib_sequence[-1] + fib_sequence[-2])\n    if fib_sequence[-1] == value:\n        return len(fib_sequence) - 1\n    return -1\n\ndef find_fibonacci_value_by_index(index):\n    if index == 0:\n        return 0\n    elif index == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, index + 1):\n            a, b = b, a + b\n        return b\n\nnumbers_to_search = [\n    1, 5, 8, 13, 21, 34, 55, 89, 144, 233, \n    377, 610, 987, 1597, 2584, 4181, 6765, \n    10946, 17711, 28657, 46368, 75025, 121393\n]\n\nindices_of_numbers = [find_fibonacci_index_by_value(x) for x in numbers_to_search]\nvalues_by_indices = [find_fibonacci_value_by_index(x) for x in indices_of_numbers]\n\nfor number, index, value in zip(numbers_to_search, indices_of_numbers, values_by_indices):\n    print(f\"Fibonacci number {number} is at index {index} and value by index is {value}.\")"}, {"role": "assistant", "content": "Fibonacci number 1 is at index 1 and value by index is 1.\nFibonacci number 5 is at index 5 and value by index is 5.\nFibonacci number 8 is at index 6 and value by index is 8.\nFibonacci number 13 is at index 7 and value by index is 13.\nFibonacci number 21 is at index 8 and value by index is 21.\nFibonacci number 34 is at index 9 and value by index is 34.\nFibonacci number 55 is at index 10 and value by index is 55.\nFibonacci number 89 is at index 11 and value by index is 89.\nFibonacci number 144 is at index 12 and value by index is 144.\nFibonacci number 233 is at index 13 and value by index is 233.\nFibonacci number 377 is at index 14 and value by index is 377.\nFibonacci number 610 is at index 15 and value by index is 610.\nFibonacci number 987 is at index 16 and value by index is 987.\nFibonacci number 1597 is at index 17 and value by index is 1597.\nFibonacci number 2584 is at index 18 and value by index is 2584.\nFibonacci number 4181 is at index 19 and value by index is 4181.\nFibonacci number 6765 is at index 20 and value by index is 6765.\nFibonacci number 10946 is at index 21 and value by index is 10946.\nFibonacci number 17711 is at index 22 and value by index is 17711.\nFibonacci number 28657 is at index 23 and value by index is 28657.\nFibonacci number 46368 is at index 24 and value by index is 46368.\nFibonacci number 75025 is at index 25 and value by index is 75025.\nFibonacci number 121393 is at index 26 and value by index is 121393.\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef generate_pattern(n):\n    pattern = ''\n    for i in range(n):\n        line = ''.join(['*' if (i+j) % 2 == 0 else ' ' for j in range(n)])\n        pattern += line + '\\n'\n    return pattern\n\ndef search_pattern_in_grid(grid, pattern):\n    grid_lines = grid.splitlines()\n    pattern_lines = pattern.splitlines()\n    pattern_height = len(pattern_lines)\n    pattern_width = len(pattern_lines[0])\n\n    def check_pattern(x, y):\n        for i in range(pattern_height):\n            for j in range(pattern_width):\n                if grid_lines[x+i][y+j] != pattern_lines[i][j]:\n                    return False\n        return True\n\n    matches = []\n    for i in range(len(grid_lines) - pattern_height + 1):\n        for j in range(len(grid_lines[0]) - pattern_width + 1):\n            if check_pattern(i, j):\n                matches.append((i, j))\n\n    return matches\n\ngrid_size = 10\npattern_size = 3\n\ngrid = generate_pattern(grid_size)\npattern = generate_pattern(pattern_size)\n\nprint(\"Grid:\")\nprint(grid)\nprint(\"Pattern:\")\nprint(pattern)\nprint(\"Searching for pattern in grid...\")\n\nmatches = search_pattern_in_grid(grid, pattern)\n\nprint(\"Matches found at:\")\nfor match in matches:\n    print(f\"Row: {match[0]}, Column: {match[1]}\")"}, {"role": "assistant", "content": "Grid:\n* * * * * \n * * * * *\n* * * * * \n * * * * *\n* * * * * \n * * * * *\n* * * * * \n * * * * *\n* * * * * \n * * * * *\n\nPattern:\n* *\n * \n* *\n\nSearching for pattern in grid...\nMatches found at:\nRow: 0, Column: 0\nRow: 0, Column: 2\nRow: 0, Column: 4\nRow: 0, Column: 6\nRow: 1, Column: 1\nRow: 1, Column: 3\nRow: 1, Column: 5\nRow: 1, Column: 7\nRow: 2, Column: 0\nRow: 2, Column: 2\nRow: 2, Column: 4\nRow: 2, Column: 6\nRow: 3, Column: 1\nRow: 3, Column: 3\nRow: 3, Column: 5\nRow: 3, Column: 7\nRow: 4, Column: 0\nRow: 4, Column: 2\nRow: 4, Column: 4\nRow: 4, Column: 6\nRow: 5, Column: 1\nRow: 5, Column: 3\nRow: 5, Column: 5\nRow: 5, Column: 7\nRow: 6, Column: 0\nRow: 6, Column: 2\nRow: 6, Column: 4\nRow: 6, Column: 6\nRow: 7, Column: 1\nRow: 7, Column: 3\nRow: 7, Column: 5\nRow: 7, Column: 7\n"}]}
{"messages": [{"role": "user", "content": "import re\nfrom collections import deque\n\ntext = \"\"\"\nIn a distant land, there was a kingdom ruled by a kind and just king. The kingdom was known for its lush green\nforests and serene lakes. The people of the kingdom lived in harmony with nature. However, deep within the heart\nof the forest, there was a legend of a mysterious creature that guarded an ancient secret.\n\"\"\"\n\nsearch_terms = ['king', 'forest', 'creature', 'harmony', 'legend', 'ancient', 'secret']\nwords = re.findall(r'\\b\\w+\\b', text.lower())\n\ndef search_terms_in_text(words, search_terms):\n    found_terms = {term: [] for term in search_terms}\n    term_deque = {term: deque(maxlen=2) for term in search_terms}\n    \n    for i, word in enumerate(words):\n        for term in search_terms:\n            if word.startswith(term):\n                term_deque[term].append(i)\n                if len(term_deque[term]) == 2:\n                    if term_deque[term][1] - term_deque[term][0] == 1:\n                        found_terms[term].append((term_deque[term][0], term_deque[term][1]))\n    \n    return found_terms\n\nresult = search_terms_in_text(words, search_terms)\nfor term, positions in result.items():\n    if positions:\n        print(f\"'{term}' found consecutively at positions: {positions}\")\n    else:\n        print(f\"'{term}' not found consecutively.\")"}, {"role": "assistant", "content": "'king' not found consecutively.\n'forest' not found consecutively.\n'creature' not found consecutively.\n'harmony' not found consecutively.\n'legend' not found consecutively.\n'ancient' not found consecutively.\n'secret' not found consecutively.\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef is_leap_year(year):\n    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n\ndef find_friday_13th(start_year, end_year):\n    friday_13ths = []\n    for year in range(start_year, end_year + 1):\n        for month in range(1, 13):\n            date = datetime.date(year, month, 13)\n            if date.weekday() == 4:\n                friday_13ths.append(date)\n                print(f\"Found: {date}\")\n    return friday_13ths\n\nstart_year = 2000\nend_year = 2022\n\nfriday_13ths = find_friday_13th(start_year, end_year)\n\nprint(f\"\\nTotal number of Friday the 13ths from {start_year} to {end_year}: {len(friday_13ths)}\\n\")\nfor date in friday_13ths:\n    print(date)"}, {"role": "assistant", "content": "Found: 2000-10-13\nFound: 2001-04-13\nFound: 2001-07-13\nFound: 2002-09-13\nFound: 2002-12-13\nFound: 2003-06-13\nFound: 2004-02-13\nFound: 2004-08-13\nFound: 2005-05-13\nFound: 2006-01-13\nFound: 2006-10-13\nFound: 2007-04-13\nFound: 2007-07-13\nFound: 2008-06-13\nFound: 2009-02-13\nFound: 2009-03-13\nFound: 2009-11-13\nFound: 2010-08-13\nFound: 2011-05-13\nFound: 2012-01-13\nFound: 2012-04-13\nFound: 2012-07-13\nFound: 2013-09-13\nFound: 2013-12-13\nFound: 2014-06-13\nFound: 2015-02-13\nFound: 2015-03-13\nFound: 2015-11-13\nFound: 2016-05-13\nFound: 2017-01-13\nFound: 2017-10-13\nFound: 2018-04-13\nFound: 2018-07-13\nFound: 2019-09-13\nFound: 2019-12-13\nFound: 2020-03-13\nFound: 2020-11-13\nFound: 2021-08-13\nFound: 2022-05-13\n\nTotal number of Friday the 13ths from 2000 to 2022: 39\n\n2000-10-13\n2001-04-13\n2001-07-13\n2002-09-13\n2002-12-13\n2003-06-13\n2004-02-13\n2004-08-13\n2005-05-13\n2006-01-13\n2006-10-13\n2007-04-13\n2007-07-13\n2008-06-13\n2009-02-13\n2009-03-13\n2009-11-13\n2010-08-13\n2011-05-13\n2012-01-13\n2012-04-13\n2012-07-13\n2013-09-13\n2013-12-13\n2014-06-13\n2015-02-13\n2015-03-13\n2015-11-13\n2016-05-13\n2017-01-13\n2017-10-13\n2018-04-13\n2018-07-13\n2019-09-13\n2019-12-13\n2020-03-13\n2020-11-13\n2021-08-13\n2022-05-13\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef pattern_generator(n):\n    pattern = []\n    for i in range(1, n + 1):\n        row = [(j * i) for j in range(1, n + 1)]\n        pattern.append(row)\n    return pattern\n\ndef custom_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        swapped = False\n        for j in range(0, n-i-1):\n            if sum(arr[j]) > sum(arr[j+1]):\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n                swapped = True\n        if not swapped:\n            break\n    return arr\n\nn = 10\nprint(\"Generating pattern:\")\npattern = pattern_generator(n)\nfor row in pattern:\n    print(row)\n\nprint(\"\\nSorting pattern by the sum of elements in each row:\")\nsorted_pattern = custom_sort(pattern)\nfor row in sorted_pattern:\n    print(row)"}, {"role": "assistant", "content": "Generating pattern:\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n[3, 6, 9, 12, 15, 18, 21, 24, 27, 30]\n[4, 8, 12, 16, 20, 24, 28, 32, 36, 40]\n[5, 10, 15, 20, 25, 30, 35, 40, 45, 50]\n[6, 12, 18, 24, 30, 36, 42, 48, 54, 60]\n[7, 14, 21, 28, 35, 42, 49, 56, 63, 70]\n[8, 16, 24, 32, 40, 48, 56, 64, 72, 80]\n[9, 18, 27, 36, 45, 54, 63, 72, 81, 90]\n[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]\n\nSorting pattern by the sum of elements in each row:\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n[3, 6, 9, 12, 15, 18, 21, 24, 27, 30]\n[4, 8, 12, 16, 20, 24, 28, 32, 36, 40]\n[5, 10, 15, 20, 25, 30, 35, 40, 45, 50]\n[6, 12, 18, 24, 30, 36, 42, 48, 54, 60]\n[7, 14, 21, 28, 35, 42, 49, 56, 63, 70]\n[8, 16, 24, 32, 40, 48, 56, 64, 72, 80]\n[9, 18, 27, 36, 45, 54, 63, 72, 81, 90]\n[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\ndef days_in_month(year, month):\n    next_month = month % 12 + 1\n    next_year = year + (month // 12)\n    return (datetime(next_year, next_month, 1) - datetime(year, month, 1)).days\n\ndata = [\n    {\"year\": 2022, \"month\": 12, \"sales\": 1500},\n    {\"year\": 2023, \"month\": 1, \"sales\": 1200},\n    {\"year\": 2023, \"month\": 2, \"sales\": 1800},\n    {\"year\": 2023, \"month\": 3, \"sales\": 2000},\n    {\"year\": 2023, \"month\": 4, \"sales\": 1600},\n    {\"year\": 2023, \"month\": 5, \"sales\": 1700},\n    {\"year\": 2023, \"month\": 6, \"sales\": 2100},\n    {\"year\": 2023, \"month\": 7, \"sales\": 1900},\n    {\"year\": 2023, \"month\": 8, \"sales\": 2200},\n    {\"year\": 2023, \"month\": 9, \"sales\": 2300},\n    {\"year\": 2023, \"month\": 10, \"sales\": 1800},\n    {\"year\": 2023, \"month\": 11, \"sales\": 2500},\n    {\"year\": 2023, \"month\": 12, \"sales\": 2700},\n]\n\nfor record in data:\n    record[\"days_in_month\"] = days_in_month(record[\"year\"], record[\"month\"])\n\nsorted_data = sorted(data, key=lambda x: x[\"sales\"] / x[\"days_in_month\"], reverse=True)\n\nfor record in sorted_data:\n    year = record[\"year\"]\n    month = record[\"month\"]\n    sales_per_day = record[\"sales\"] / record[\"days_in_month\"]\n    print(f\"{year}-{month:02d}: {sales_per_day:.2f} sales/day\")"}, {"role": "assistant", "content": "2023-12: 87.10 sales/day\n2023-11: 83.33 sales/day\n2023-09: 76.67 sales/day\n2023-08: 70.97 sales/day\n2023-06: 70.00 sales/day\n2023-03: 64.52 sales/day\n2023-02: 64.29 sales/day\n2023-07: 61.29 sales/day\n2023-10: 58.06 sales/day\n2023-05: 54.84 sales/day\n2023-04: 53.33 sales/day\n2022-12: 48.39 sales/day\n2023-01: 38.71 sales/day\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef date_sorter(dates):\n    def calculate_date_value(date_str):\n        date_obj = datetime.strptime(date_str, '%Y-%m-%d')\n        return (date_obj.month * 100) + date_obj.year\n\n    date_list = [f\"2023-0{m}-0{d}\" for m in range(1, 10) for d in range(1, 4)]\n    date_list += [f\"2023-1{m}-0{d}\" for m in range(0, 3) for d in range(1, 4)]\n\n    print(\"Before sorting:\")\n    for date in date_list:\n        print(date)\n\n    sorted_dates = sorted(date_list, key=calculate_date_value)\n\n    print(\"\\nAfter sorting:\")\n    for date in sorted_dates:\n        print(date)\n\n    next_days = [(datetime.strptime(date, '%Y-%m-%d') + timedelta(days=1)).strftime('%Y-%m-%d') for date in sorted_dates]\n    \n    print(\"\\nNext day for each sorted date:\")\n    for next_day in next_days:\n        print(next_day)\n\ndate_sorter([])"}, {"role": "assistant", "content": "Before sorting:\n2023-01-01\n2023-01-02\n2023-01-03\n2023-02-01\n2023-02-02\n2023-02-03\n2023-03-01\n2023-03-02\n2023-03-03\n2023-04-01\n2023-04-02\n2023-04-03\n2023-05-01\n2023-05-02\n2023-05-03\n2023-06-01\n2023-06-02\n2023-06-03\n2023-07-01\n2023-07-02\n2023-07-03\n2023-08-01\n2023-08-02\n2023-08-03\n2023-09-01\n2023-09-02\n2023-09-03\n2023-10-01\n2023-10-02\n2023-10-03\n2023-11-01\n2023-11-02\n2023-11-03\n2023-12-01\n2023-12-02\n2023-12-03\n\nAfter sorting:\n2023-01-01\n2023-01-02\n2023-01-03\n2023-02-01\n2023-02-02\n2023-02-03\n2023-03-01\n2023-03-02\n2023-03-03\n2023-04-01\n2023-04-02\n2023-04-03\n2023-05-01\n2023-05-02\n2023-05-03\n2023-06-01\n2023-06-02\n2023-06-03\n2023-07-01\n2023-07-02\n2023-07-03\n2023-08-01\n2023-08-02\n2023-08-03\n2023-09-01\n2023-09-02\n2023-09-03\n2023-10-01\n2023-10-02\n2023-10-03\n2023-11-01\n2023-11-02\n2023-11-03\n2023-12-01\n2023-12-02\n2023-12-03\n\nNext day for each sorted date:\n2023-01-02\n2023-01-03\n2023-01-04\n2023-02-02\n2023-02-03\n2023-02-04\n2023-03-02\n2023-03-03\n2023-03-04\n2023-04-02\n2023-04-03\n2023-04-04\n2023-05-02\n2023-05-03\n2023-05-04\n2023-06-02\n2023-06-03\n2023-06-04\n2023-07-02\n2023-07-03\n2023-07-04\n2023-08-02\n2023-08-03\n2023-08-04\n2023-09-02\n2023-09-03\n2023-09-04\n2023-10-02\n2023-10-03\n2023-10-04\n2023-11-02\n2023-11-03\n2023-11-04\n2023-12-02\n2023-12-03\n2023-12-04\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef find_nearest_point_on_circle(circle_center, radius, points):\n    def distance_squared(p1, p2):\n        return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\n\n    def project_to_circle(p):\n        vector_x = p[0] - circle_center[0]\n        vector_y = p[1] - circle_center[1]\n        mag = math.sqrt(vector_x ** 2 + vector_y ** 2)\n        if mag == 0:\n            return circle_center\n        scale = radius / mag\n        return (circle_center[0] + vector_x * scale, circle_center[1] + vector_y * scale)\n\n    projected_points = [project_to_circle(point) for point in points]\n    results = []\n    \n    for point, proj in zip(points, projected_points):\n        dist_sq = distance_squared(point, proj)\n        results.append((point, proj, dist_sq))\n        print(f\"Original Point: {point}, Projected: {proj}, Distance^2: {dist_sq}\")\n\n    return sorted(results, key=lambda x: x[2])\n\ncircle_center = (5, 5)\nradius = 10\npoints = [(3, 4), (9, 9), (15, 15), (5, 5), (0, 0), (20, 5), (5, 20)]\n\nnearest_points = find_nearest_point_on_circle(circle_center, radius, points)\nprint(\"\\nSorted Result (Closest to Farthest):\")\nfor point, projection, dist_sq in nearest_points:\n    print(f\"Point: {point}, Projected: {projection}, Distance^2: {dist_sq}\")"}, {"role": "assistant", "content": "Original Point: (3, 4), Projected: (-3.944271909999159, 0.5278640450004204), Distance^2: 60.27864045000421\nOriginal Point: (9, 9), Projected: (12.071067811865476, 12.071067811865476), Distance^2: 18.8629150101524\nOriginal Point: (15, 15), Projected: (12.071067811865476, 12.071067811865476), Distance^2: 17.157287525380987\nOriginal Point: (5, 5), Projected: (5, 5), Distance^2: 0\nOriginal Point: (0, 0), Projected: (-2.0710678118654746, -2.0710678118654746), Distance^2: 8.57864376269049\nOriginal Point: (20, 5), Projected: (15.0, 5.0), Distance^2: 25.0\nOriginal Point: (5, 20), Projected: (5.0, 15.0), Distance^2: 25.0\n\nSorted Result (Closest to Farthest):\nPoint: (5, 5), Projected: (5, 5), Distance^2: 0\nPoint: (0, 0), Projected: (-2.0710678118654746, -2.0710678118654746), Distance^2: 8.57864376269049\nPoint: (15, 15), Projected: (12.071067811865476, 12.071067811865476), Distance^2: 17.157287525380987\nPoint: (9, 9), Projected: (12.071067811865476, 12.071067811865476), Distance^2: 18.8629150101524\nPoint: (20, 5), Projected: (15.0, 5.0), Distance^2: 25.0\nPoint: (5, 20), Projected: (5.0, 15.0), Distance^2: 25.0\nPoint: (3, 4), Projected: (-3.944271909999159, 0.5278640450004204), Distance^2: 60.27864045000421\n"}]}
{"messages": [{"role": "user", "content": "from math import sqrt\n\ndef generate_interesting_sequence(n):\n    sequence = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            sequence.append(i ** 2)\n        else:\n            sequence.append(i ** 3)\n    return sequence\n\ndef is_perfect_square(num):\n    return int(sqrt(num)) ** 2 == num\n\ndef find_first_perfect_square(sequence):\n    for idx, num in enumerate(sequence):\n        if is_perfect_square(num):\n            return idx, num\n    return -1, None\n\nn = 100\nsequence = generate_interesting_sequence(n)\nprint(\"Generated sequence (first 20 elements):\", sequence[:20])\n\nindex, perfect_square = find_first_perfect_square(sequence)\nif index != -1:\n    print(f\"First perfect square in sequence is {perfect_square} at index {index}.\")\nelse:\n    print(\"No perfect square found in the sequence.\")"}, {"role": "assistant", "content": "Generated sequence (first 20 elements): [1, 4, 27, 16, 125, 36, 343, 64, 729, 100, 1331, 144, 2197, 196, 3375, 256, 4913, 324, 6859, 400]\nFirst perfect square in sequence is 1 at index 0.\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef point_distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\ndef closest_pair_of_points(points):\n    def brute_force(points):\n        min_dist = float('inf')\n        pair = (None, None)\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = point_distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (points[i], points[j])\n        return pair, min_dist\n\n    def strip_closest(strip, d):\n        min_dist = d\n        pair = (None, None)\n        for i in range(len(strip)):\n            j = i + 1\n            while j < len(strip) and (strip[j][1] - strip[i][1]) < min_dist:\n                dist = point_distance(strip[i], strip[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    pair = (strip[i], strip[j])\n                j += 1\n        return pair, min_dist\n\n    def recursive_search(points_sorted_x, points_sorted_y):\n        if len(points_sorted_x) <= 3:\n            return brute_force(points_sorted_x)\n\n        mid = len(points_sorted_x) // 2\n        mid_point = points_sorted_x[mid]\n\n        left_of_center = points_sorted_x[:mid]\n        right_of_center = points_sorted_x[mid:]\n\n        left_sorted_y = list(filter(lambda x: x in left_of_center, points_sorted_y))\n        right_sorted_y = list(filter(lambda x: x in right_of_center, points_sorted_y))\n\n        (p1, q1), dist1 = recursive_search(left_of_center, left_sorted_y)\n        (p2, q2), dist2 = recursive_search(right_of_center, right_sorted_y)\n\n        if dist1 < dist2:\n            d = dist1\n            pair = (p1, q1)\n        else:\n            d = dist2\n            pair = (p2, q2)\n\n        strip = [p for p in points_sorted_y if abs(p[0] - mid_point[0]) < d]\n        (p3, q3), dist3 = strip_closest(strip, d)\n\n        if dist3 < d:\n            return (p3, q3), dist3\n        else:\n            return pair, d\n\n    points_sorted_x = sorted(points, key=lambda x: x[0])\n    points_sorted_y = sorted(points, key=lambda x: x[1])\n\n    pair, _ = recursive_search(points_sorted_x, points_sorted_y)\n    return pair\n\npoints = [(2, 3), (12, 30), (40, 50), (5, 1), (12, 10), (3, 4), (8, 16), (2, 2), (10, 2), (15, 3)]\nresult = closest_pair_of_points(points)\nprint(f\"The farthest pair of points is: {result}\")"}, {"role": "assistant", "content": "The farthest pair of points is: ((2, 3), (2, 2))\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef generate_date_sequence(start_date, num_days):\n    return [start_date + timedelta(days=i) for i in range(num_days)]\n\ndef find_date_with_most_fridays(dates):\n    day_counts = {}\n    for date in dates:\n        first_day_of_month = date.replace(day=1)\n        if first_day_of_month not in day_counts:\n            last_day_of_month = (first_day_of_month + timedelta(days=31)).replace(day=1) - timedelta(days=1)\n            current_date = first_day_of_month\n            friday_count = 0\n            while current_date <= last_day_of_month:\n                if current_date.weekday() == 4:\n                    friday_count += 1\n                current_date += timedelta(days=1)\n            day_counts[first_day_of_month] = friday_count\n    max_fridays = max(day_counts.values())\n    return [date for date, count in day_counts.items() if count == max_fridays]\n\nstart_date = datetime(2000, 1, 1)\nnum_days = 365 * 5\ndates = generate_date_sequence(start_date, num_days)\nmonths_with_most_fridays = find_date_with_most_fridays(dates)\n\nfor date in sorted(months_with_most_fridays):\n    print(date.strftime(\"%B %Y\"), \"had the most Fridays\")"}, {"role": "assistant", "content": "March 2000 had the most Fridays\nJune 2000 had the most Fridays\nSeptember 2000 had the most Fridays\nDecember 2000 had the most Fridays\nMarch 2001 had the most Fridays\nJune 2001 had the most Fridays\nAugust 2001 had the most Fridays\nNovember 2001 had the most Fridays\nMarch 2002 had the most Fridays\nMay 2002 had the most Fridays\nAugust 2002 had the most Fridays\nNovember 2002 had the most Fridays\nJanuary 2003 had the most Fridays\nMay 2003 had the most Fridays\nAugust 2003 had the most Fridays\nOctober 2003 had the most Fridays\nJanuary 2004 had the most Fridays\nApril 2004 had the most Fridays\nJuly 2004 had the most Fridays\nOctober 2004 had the most Fridays\nDecember 2004 had the most Fridays\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef mean(numbers):\n    return sum(numbers) / len(numbers)\n\ndef standard_deviation(numbers):\n    avg = mean(numbers)\n    variance = sum((x - avg) ** 2 for x in numbers) / len(numbers)\n    return math.sqrt(variance)\n\ndef sort_by_distance_from_mean(numbers):\n    avg = mean(numbers)\n    sorted_numbers = sorted(numbers, key=lambda x: abs(x - avg))\n    return sorted_numbers\n\ndata = [43, 21, 78, 34, 56, 99, 12, 67, 89, 29, 15, 46, 68, 82, 31, 55, 49, 94, 40, 27]\n\nprint(\"Original Data:\")\nprint(data)\n\nsorted_data = sort_by_distance_from_mean(data)\nprint(\"\\nData sorted by distance from mean:\")\nprint(sorted_data)\n\navg = mean(data)\nstd_dev = standard_deviation(data)\n\nprint(\"\\nMean:\", avg)\nprint(\"Standard Deviation:\", std_dev)\n\nprint(\"\\nSorted Data with Distance from Mean:\")\nfor num in sorted_data:\n    dist = abs(num - avg)\n    print(f\"Value: {num}, Distance from Mean: {dist:.2f}\")"}, {"role": "assistant", "content": "Original Data:\n[43, 21, 78, 34, 56, 99, 12, 67, 89, 29, 15, 46, 68, 82, 31, 55, 49, 94, 40, 27]\n\nData sorted by distance from mean:\n[49, 55, 56, 46, 43, 40, 67, 68, 34, 31, 29, 27, 78, 82, 21, 15, 89, 12, 94, 99]\n\nMean: 51.75\nStandard Deviation: 26.020905057280387\n\nSorted Data with Distance from Mean:\nValue: 49, Distance from Mean: 2.75\nValue: 55, Distance from Mean: 3.25\nValue: 56, Distance from Mean: 4.25\nValue: 46, Distance from Mean: 5.75\nValue: 43, Distance from Mean: 8.75\nValue: 40, Distance from Mean: 11.75\nValue: 67, Distance from Mean: 15.25\nValue: 68, Distance from Mean: 16.25\nValue: 34, Distance from Mean: 17.75\nValue: 31, Distance from Mean: 20.75\nValue: 29, Distance from Mean: 22.75\nValue: 27, Distance from Mean: 24.75\nValue: 78, Distance from Mean: 26.25\nValue: 82, Distance from Mean: 30.25\nValue: 21, Distance from Mean: 30.75\nValue: 15, Distance from Mean: 36.75\nValue: 89, Distance from Mean: 37.25\nValue: 12, Distance from Mean: 39.75\nValue: 94, Distance from Mean: 42.25\nValue: 99, Distance from Mean: 47.25\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef custom_sort(s):\n    return sorted(s, key=lambda x: re.sub(r'[aeiou]', '', x))\n\ndef process_text(text):\n    words = re.findall(r'\\w+', text.lower())\n    print(\"Extracted words:\", words)\n    sorted_words = custom_sort(words)\n    print(\"Words sorted by consonant order:\", sorted_words)\n    return sorted_words\n\ntext = \"\"\"\nSorting algorithms can be fascinating,\nespecially when you need to sort text\nbased on specific criteria. Let's see\nhow they behave with different inputs!\n\"\"\"\n\nsorted_text = process_text(text)\nprint(\"\\nFinal sorted text:\")\nfor word in sorted_text:\n    print(word)"}, {"role": "assistant", "content": "Extracted words: ['sorting', 'algorithms', 'can', 'be', 'fascinating', 'especially', 'when', 'you', 'need', 'to', 'sort', 'text', 'based', 'on', 'specific', 'criteria', 'let', 's', 'see', 'how', 'they', 'behave', 'with', 'different', 'inputs']\nWords sorted by consonant order: ['be', 'behave', 'based', 'can', 'criteria', 'different', 'fascinating', 'how', 'algorithms', 'let', 'on', 'need', 'inputs', 's', 'see', 'specific', 'especially', 'sort', 'sorting', 'to', 'they', 'text', 'when', 'with', 'you']\n\nFinal sorted text:\nbe\nbehave\nbased\ncan\ncriteria\ndifferent\nfascinating\nhow\nalgorithms\nlet\non\nneed\ninputs\ns\nsee\nspecific\nespecially\nsort\nsorting\nto\nthey\ntext\nwhen\nwith\nyou\n"}]}
{"messages": [{"role": "user", "content": "import math\nimport statistics\n\nclass DataSet:\n    def __init__(self, data):\n        self.data = sorted(data)\n        self.size = len(data)\n        self.mean = statistics.mean(data)\n        self.std_dev = statistics.stdev(data)\n        \n    def z_score(self, value):\n        return (value - self.mean) / self.std_dev\n\n    def find_closest_z_score(self, target_z):\n        low, high = 0, self.size - 1\n        closest_index = None\n        closest_diff = float('inf')\n        \n        while low <= high:\n            mid = (low + high) // 2\n            mid_value = self.data[mid]\n            mid_z_score = self.z_score(mid_value)\n            \n            diff = abs(mid_z_score - target_z)\n            if diff < closest_diff:\n                closest_diff = diff\n                closest_index = mid\n\n            if mid_z_score < target_z:\n                low = mid + 1\n            elif mid_z_score > target_z:\n                high = mid - 1\n            else:\n                break\n        \n            print(f\"Checking value: {mid_value}, z-score: {mid_z_score}, target: {target_z}, diff: {diff}\")\n\n        return self.data[closest_index], closest_diff\n\ndata = [15, 20, 35, 40, 50, 60, 65, 70, 80, 90, 100]\ntarget_z_score = 1.5\n\ndataset = DataSet(data)\nvalue, diff = dataset.find_closest_z_score(target_z_score)\n\nprint(f\"\\nData set: {data}\")\nprint(f\"Mean: {dataset.mean}, Std Dev: {dataset.std_dev}\")\nprint(f\"Target z-score: {target_z_score}\")\nprint(f\"Value with closest z-score: {value}, Difference: {diff}\")"}, {"role": "assistant", "content": "Checking value: 60, z-score: 0.11493648582009691, target: 1.5, diff: 1.385063514179903\nChecking value: 80, z-score: 0.837394396689278, target: 1.5, diff: 0.662605603310722\nChecking value: 90, z-score: 1.1986233521238685, target: 1.5, diff: 0.3013766478761315\nChecking value: 100, z-score: 1.559852307558459, target: 1.5, diff: 0.05985230755845894\n\nData set: [15, 20, 35, 40, 50, 60, 65, 70, 80, 90, 100]\nMean: 56.81818181818182, Std Dev: 27.68327358466907\nTarget z-score: 1.5\nValue with closest z-score: 100, Difference: 0.05985230755845894\n"}]}
{"messages": [{"role": "user", "content": "def is_fibonacci(n, fib_set):\n    return n in fib_set\n\ndef generate_fibonacci_sequence(limit):\n    fib_sequence = [0, 1]\n    while True:\n        next_fib = fib_sequence[-1] + fib_sequence[-2]\n        if next_fib > limit:\n            break\n        fib_sequence.append(next_fib)\n    return fib_sequence\n\ndef sort_numbers_by_fibonacci_property(numbers):\n    fib_sequence = generate_fibonacci_sequence(max(numbers))\n    fib_set = set(fib_sequence)\n    print(\"Fibonacci Sequence:\", fib_sequence)\n    \n    fibonacci_numbers = sorted([n for n in numbers if is_fibonacci(n, fib_set)])\n    non_fibonacci_numbers = sorted([n for n in numbers if not is_fibonacci(n, fib_set)])\n    \n    print(\"Fibonacci Numbers:\", fibonacci_numbers)\n    print(\"Non-Fibonacci Numbers:\", non_fibonacci_numbers)\n    \n    return fibonacci_numbers + non_fibonacci_numbers\n\nnumbers = [34, 21, 5, 8, 3, 13, 1, 0, 2, 89, 55, 4, 7, 6, 144, 233, 12, 377, 144]\nsorted_numbers = sort_numbers_by_fibonacci_property(numbers)\nprint(\"Sorted Numbers:\", sorted_numbers)"}, {"role": "assistant", "content": "Fibonacci Sequence: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377]\nFibonacci Numbers: [0, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 144, 233, 377]\nNon-Fibonacci Numbers: [4, 6, 7, 12]\nSorted Numbers: [0, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 144, 233, 377, 4, 6, 7, 12]\n"}]}
{"messages": [{"role": "user", "content": "def custom_sort(data):\n    return sorted(data, key=lambda x: (x[1], x[0]))\n\ndef binary_search(sorted_data, target):\n    low = 0\n    high = len(sorted_data) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        print(f\"Searching at index: {mid}, value: {sorted_data[mid]}\")\n        if sorted_data[mid] == target:\n            return mid\n        elif sorted_data[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n\ndata = [(3, 'apple'), (1, 'banana'), (4, 'cherry'), (2, 'date'), (5, 'elderberry')]\nprint(\"Original data:\")\nfor item in data:\n    print(item)\n\nsorted_data = custom_sort(data)\nprint(\"\\nSorted data:\")\nfor item in sorted_data:\n    print(item)\n\ntarget = (1, 'banana')\nprint(f\"\\nSearching for target: {target}\")\nindex = binary_search(sorted_data, target)\n\nif index != -1:\n    print(f\"\\nTarget {target} found at index: {index}\")\nelse:\n    print(f\"\\nTarget {target} not found in the data\")"}, {"role": "assistant", "content": "Original data:\n(3, 'apple')\n(1, 'banana')\n(4, 'cherry')\n(2, 'date')\n(5, 'elderberry')\n\nSorted data:\n(3, 'apple')\n(1, 'banana')\n(4, 'cherry')\n(2, 'date')\n(5, 'elderberry')\n\nSearching for target: (1, 'banana')\nSearching at index: 2, value: (4, 'cherry')\nSearching at index: 0, value: (3, 'apple')\n\nTarget (1, 'banana') not found in the data\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef find_median_index(arr):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == statistics.median(arr):\n            return mid\n        elif arr[mid] < statistics.median(arr):\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndata = [\n    [34, 67, 23, 89, 12, 78, 56],\n    [101, 203, 405, 309, 502, 606, 708],\n    [1002, 2031, 3054, 4098, 5023, 6039, 7045],\n    [12, 23, 34, 45, 56, 67, 78],\n    [9, 15, 36, 47, 58, 69, 70],\n    [109, 209, 309, 409, 509, 609, 709],\n    [5, 15, 25, 35, 45, 55, 65],\n    [3, 7, 9, 14, 18, 21, 24],\n    [8, 16, 24, 32, 40, 48, 56],\n    [11, 21, 31, 41, 51, 61, 71]\n]\n\nresults = [find_median_index(sorted(group)) for group in data]\n\nfor result in results:\n    print(result)"}, {"role": "assistant", "content": "3\n3\n3\n3\n3\n3\n3\n3\n3\n3\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef transform_and_search(data, pattern):\n    print(\"Original Data:\")\n    for line in data:\n        print(line)\n    \n    transformed_data = []\n    for line in data:\n        words = line.split()\n        transformed_words = [word[::-1] for word in words]\n        transformed_line = ' '.join(transformed_words)\n        transformed_data.append(transformed_line)\n    \n    print(\"\\nTransformed Data:\")\n    for line in transformed_data:\n        print(line)\n\n    search_results = []\n    for index, line in enumerate(transformed_data):\n        if re.search(pattern, line):\n            search_results.append((index, line))\n    \n    print(\"\\nSearch Results:\")\n    for result in search_results:\n        print(f\"Line {result[0]}: {result[1]}\")\n\ndata = [\n    \"searching algorithms are fascinating\",\n    \"data transformation is a key concept\",\n    \"python code can be elegant\",\n    \"pattern matching is powerful\",\n    \"search and transform with style\"\n]\n\npattern = r'\\be[lm][a-z]*\\b'\ntransform_and_search(data, pattern)"}, {"role": "assistant", "content": "Original Data:\nsearching algorithms are fascinating\ndata transformation is a key concept\npython code can be elegant\npattern matching is powerful\nsearch and transform with style\n\nTransformed Data:\ngnihcraes smhtirogla era gnitanicsaf\natad noitamrofsnart si a yek tpecnoc\nnohtyp edoc nac eb tnagele\nnrettap gnihctam si lufrewop\nhcraes dna mrofsnart htiw elyts\n\nSearch Results:\nLine 4: hcraes dna mrofsnart htiw elyts\n"}]}
{"messages": [{"role": "user", "content": "import string\n\ndef flawed_encryption(text):\n    def custom_sort_key(char):\n        return string.ascii_lowercase.index(char.lower()) if char.isalpha() else ord(char)\n\n    def flawed_sort(lst):\n        for i in range(len(lst)):\n            min_idx = i\n            for j in range(i+1, len(lst)):\n                if custom_sort_key(lst[j]) < custom_sort_key(lst[min_idx]):\n                    min_idx = j\n            if i != min_idx:\n                lst[i], lst[min_idx] = lst[min_idx], lst[i]\n        return lst\n\n    encrypted_chars = list(text)\n    flawed_sort(encrypted_chars)\n    return ''.join(encrypted_chars)\n\ntext = \"The quick brown fox jumps over the lazy dog\"\nencrypted_text = flawed_encryption(text)\n\nfor idx, char in enumerate(encrypted_text, start=1):\n    print(f\"{idx:2}: {char}\")"}, {"role": "assistant", "content": " 1: a\n 2: b\n 3: c\n 4: d\n 5: e\n 6: e\n 7: e\n 8: f\n 9: g\n10: h\n11: h\n12: i\n13: j\n14: k\n15: l\n16: m\n17: n\n18: o\n19: o\n20: o\n21: o\n22: p\n23: q\n24: r\n25: r\n26: s\n27: t\n28: T\n29: u\n30: u\n31: v\n32: w\n33: x\n34: y\n35: z\n36:  \n37:  \n38:  \n39:  \n40:  \n41:  \n42:  \n43:  \n"}]}
{"messages": [{"role": "user", "content": "import re\nimport math\n\ndef get_vowel_percentage(text):\n    vowels = set(\"aeiouAEIOU\")\n    total_chars = len(text)\n    vowel_count = sum(1 for char in text if char in vowels)\n    return (vowel_count / total_chars) * 100 if total_chars > 0 else 0\n\ndef find_best_fit(pattern, texts):\n    max_fit = -1\n    best_text = \"\"\n    for text in texts:\n        print(f\"Analyzing text: {text[:30]}...\")  # Debug print\n        matches = re.findall(pattern, text)\n        print(f\"Pattern matches found: {len(matches)}\")  # Debug print\n        percentage = get_vowel_percentage(text)\n        print(f\"Vowel percentage: {percentage:.2f}%\")  # Debug print\n        fit_score = len(matches) * percentage\n        print(f\"Fit score: {fit_score}\")  # Debug print\n        if fit_score > max_fit:\n            max_fit = fit_score\n            best_text = text\n    return best_text, max_fit\n\ntexts = [\n    \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\",\n    \"Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\",\n    \"Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris.\",\n    \"Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore.\",\n    \"Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n]\n\npattern = r\"\\b[a-zA-Z]{4,}\\b\"\n\nbest_text, best_fit_score = find_best_fit(pattern, texts)\nprint(\"\\nBest fitting text:\")\nprint(best_text)\nprint(f\"Best fit score: {best_fit_score}\")"}, {"role": "assistant", "content": "Analyzing text: Lorem ipsum dolor sit amet, co...\nPattern matches found: 7\nVowel percentage: 33.93%\nFit score: 237.5\nAnalyzing text: Sed do eiusmod tempor incididu...\nPattern matches found: 7\nVowel percentage: 39.39%\nFit score: 275.75757575757575\nAnalyzing text: Ut enim ad minim veniam, quis ...\nPattern matches found: 8\nVowel percentage: 37.31%\nFit score: 298.5074626865672\nAnalyzing text: Duis aute irure dolor in repre...\nPattern matches found: 10\nVowel percentage: 38.96%\nFit score: 389.6103896103897\nAnalyzing text: Excepteur sint occaecat cupida...\nPattern matches found: 12\nVowel percentage: 35.45%\nFit score: 425.45454545454544\n\nBest fitting text:\nExcepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\nBest fit score: 425.45454545454544\n"}]}
{"messages": [{"role": "user", "content": "from collections import Counter\nimport re\n\ntext = \"\"\"\nIn the beginning the Universe was created. This has made a lot of people very angry and been widely regarded as a bad move.\nThe story so far: In the beginning the Universe was created. This has made a lot of people very angry and been widely regarded as a bad move.\nFord Prefect knew that it was going to be a long time before he would ever be able to afford to take a taxi.\n\"\"\"\n\nwords = re.findall(r'\\b\\w+\\b', text.lower())\nword_frequency = Counter(words)\nprint(\"Word Frequencies:\")\nprint(word_frequency)\n\nsorted_by_frequency = sorted(word_frequency.items(), key=lambda x: (-x[1], x[0]))\nprint(\"\\nWords sorted by frequency and alphabetically:\")\nfor word, freq in sorted_by_frequency:\n    print(f\"{word}: {freq}\")\n\nunique_words = [word for word, freq in sorted_by_frequency if freq == 1]\nprint(\"\\nUnique Words:\")\nprint(unique_words)\n\nsorted_unique_words = sorted(unique_words, key=lambda x: (-len(x), x))\nprint(\"\\nUnique Words sorted by length and alphabetically:\")\nfor word in sorted_unique_words:\n    print(word)"}, {"role": "assistant", "content": "Word Frequencies:\nCounter({'a': 6, 'the': 5, 'was': 3, 'to': 3, 'in': 2, 'beginning': 2, 'universe': 2, 'created': 2, 'this': 2, 'has': 2, 'made': 2, 'lot': 2, 'of': 2, 'people': 2, 'very': 2, 'angry': 2, 'and': 2, 'been': 2, 'widely': 2, 'regarded': 2, 'as': 2, 'bad': 2, 'move': 2, 'be': 2, 'story': 1, 'so': 1, 'far': 1, 'ford': 1, 'prefect': 1, 'knew': 1, 'that': 1, 'it': 1, 'going': 1, 'long': 1, 'time': 1, 'before': 1, 'he': 1, 'would': 1, 'ever': 1, 'able': 1, 'afford': 1, 'take': 1, 'taxi': 1})\n\nWords sorted by frequency and alphabetically:\na: 6\nthe: 5\nto: 3\nwas: 3\nand: 2\nangry: 2\nas: 2\nbad: 2\nbe: 2\nbeen: 2\nbeginning: 2\ncreated: 2\nhas: 2\nin: 2\nlot: 2\nmade: 2\nmove: 2\nof: 2\npeople: 2\nregarded: 2\nthis: 2\nuniverse: 2\nvery: 2\nwidely: 2\nable: 1\nafford: 1\nbefore: 1\never: 1\nfar: 1\nford: 1\ngoing: 1\nhe: 1\nit: 1\nknew: 1\nlong: 1\nprefect: 1\nso: 1\nstory: 1\ntake: 1\ntaxi: 1\nthat: 1\ntime: 1\nwould: 1\n\nUnique Words:\n['able', 'afford', 'before', 'ever', 'far', 'ford', 'going', 'he', 'it', 'knew', 'long', 'prefect', 'so', 'story', 'take', 'taxi', 'that', 'time', 'would']\n\nUnique Words sorted by length and alphabetically:\nprefect\nafford\nbefore\ngoing\nstory\nwould\nable\never\nford\nknew\nlong\ntake\ntaxi\nthat\ntime\nfar\nhe\nit\nso\n"}]}
{"messages": [{"role": "user", "content": "def sort_and_generate_pattern(n):\n    sequences = []\n    for i in range(1, n + 1):\n        sequence = [(j * i) % n for j in range(1, n)]\n        sequences.append(sequence)\n\n    def merge_sort(arr):\n        if len(arr) > 1:\n            mid = len(arr) // 2\n            L = arr[:mid]\n            R = arr[mid:]\n            merge_sort(L)\n            merge_sort(R)\n            i = j = k = 0\n            while i < len(L) and j < len(R):\n                if L[i] > R[j]:\n                    arr[k] = L[i]\n                    i += 1\n                else:\n                    arr[k] = R[j]\n                    j += 1\n                k += 1\n            while i < len(L):\n                arr[k] = L[i]\n                i += 1\n                k += 1\n            while j < len(R):\n                arr[k] = R[j]\n                j += 1\n                k += 1\n\n    for seq in sequences:\n        merge_sort(seq)\n\n    pattern = \"\"\n    for seq in sequences:\n        pattern += \"\".join(str(num) for num in seq) + \"\\n\"\n    return pattern\n\nprint(sort_and_generate_pattern(10))"}, {"role": "assistant", "content": "987654321\n886644220\n987654321\n886644220\n555550000\n886644220\n987654321\n886644220\n987654321\n000000000\n\n"}]}
{"messages": [{"role": "user", "content": "def find_best_path(grid, start, end):\n    def heuristic(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    open_set = [start]\n    came_from = {}\n    g_score = {start: 0}\n    f_score = {start: heuristic(start, end)}\n\n    while open_set:\n        current = min(open_set, key=lambda x: f_score.get(x, float('inf')))\n        \n        if current == end:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            return path[::-1]\n\n        open_set.remove(current)\n\n        for i, j in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            neighbor = (current[0] + i, current[1] + j)\n\n            if 0 <= neighbor[0] < len(grid) and 0 <= neighbor[1] < len(grid[0]):\n                if grid[neighbor[0]][neighbor[1]] == 1:\n                    continue\n\n                tentative_g_score = g_score[current] + 1\n\n                if tentative_g_score < g_score.get(neighbor, float('inf')):\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = tentative_g_score + heuristic(neighbor, end)\n                    if neighbor not in open_set:\n                        open_set.append(neighbor)\n\n    return []\n\ngrid = [\n    [0, 1, 0, 0, 0],\n    [0, 1, 0, 1, 0],\n    [0, 0, 0, 1, 0],\n    [0, 1, 1, 1, 0],\n    [0, 0, 0, 0, 0]\n]\n\nstart = (0, 0)\nend = (4, 4)\npath = find_best_path(grid, start, end)\nfor step in path:\n    print(step)"}, {"role": "assistant", "content": "(1, 0)\n(2, 0)\n(3, 0)\n(4, 0)\n(4, 1)\n(4, 2)\n(4, 3)\n(4, 4)\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef distance_from_origin(point):\n    return math.sqrt(point[0]**2 + point[1]**2)\n\ndef angle_from_origin(point):\n    return math.atan2(point[1], point[0])\n\ndef polar_angle_sort(points):\n    print(\"Sorting based on polar angle and distance from origin...\")\n    sorted_points = sorted(points, key=lambda p: (angle_from_origin(p), distance_from_origin(p)))\n    for p in sorted_points:\n        print(f\"Point: {p}, Angle: {angle_from_origin(p):.2f}, Distance: {distance_from_origin(p):.2f}\")\n    return sorted_points\n\ndef calculate_polygon_area(points):\n    print(\"Calculating polygon area...\")\n    n = len(points)\n    area = 0.0\n    for i in range(n):\n        j = (i + 1) % n\n        area += points[i][0] * points[j][1]\n        area -= points[j][0] * points[i][1]\n    area = abs(area) / 2.0\n    print(f\"Calculated area: {area:.2f}\")\n    return area\n\npoints = [\n    (4, 5), (2, 1), (1, 1), (3, 3), (5, 2), \n    (3, 5), (2, 4), (1, 2), (4, 2), (0, 0)\n]\n\nprint(\"Original points:\")\nfor p in points:\n    print(p)\n\nsorted_points = polar_angle_sort(points)\narea = calculate_polygon_area(sorted_points)\n\nprint(\"\\nSorted points:\")\nfor p in sorted_points:\n    print(p)\n\nprint(f\"\\nArea of polygon formed by sorted points: {area:.2f}\")"}, {"role": "assistant", "content": "Original points:\n(4, 5)\n(2, 1)\n(1, 1)\n(3, 3)\n(5, 2)\n(3, 5)\n(2, 4)\n(1, 2)\n(4, 2)\n(0, 0)\nSorting based on polar angle and distance from origin...\nPoint: (0, 0), Angle: 0.00, Distance: 0.00\nPoint: (5, 2), Angle: 0.38, Distance: 5.39\nPoint: (2, 1), Angle: 0.46, Distance: 2.24\nPoint: (4, 2), Angle: 0.46, Distance: 4.47\nPoint: (1, 1), Angle: 0.79, Distance: 1.41\nPoint: (3, 3), Angle: 0.79, Distance: 4.24\nPoint: (4, 5), Angle: 0.90, Distance: 6.40\nPoint: (3, 5), Angle: 1.03, Distance: 5.83\nPoint: (1, 2), Angle: 1.11, Distance: 2.24\nPoint: (2, 4), Angle: 1.11, Distance: 4.47\nCalculating polygon area...\nCalculated area: 6.00\n\nSorted points:\n(0, 0)\n(5, 2)\n(2, 1)\n(4, 2)\n(1, 1)\n(3, 3)\n(4, 5)\n(3, 5)\n(1, 2)\n(2, 4)\n\nArea of polygon formed by sorted points: 6.00\n"}]}
{"messages": [{"role": "user", "content": "from math import factorial\n\ndef digit_sum(n):\n    return sum(int(d) for d in str(n))\n\ndef factorial_digit_sort(seq):\n    return sorted(seq, key=lambda x: (digit_sum(factorial(x)), x))\n\nnumbers = list(range(20))\nsorted_numbers = factorial_digit_sort(numbers)\n\nfor num in sorted_numbers:\n    print(f\"{num}: {digit_sum(factorial(num))}\")"}, {"role": "assistant", "content": "0: 1\n1: 1\n2: 2\n5: 3\n3: 6\n4: 6\n6: 9\n7: 9\n8: 9\n9: 27\n10: 27\n12: 27\n13: 27\n11: 36\n14: 45\n15: 45\n19: 45\n18: 54\n16: 63\n17: 63\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef encode_message(message):\n    return ''.join(chr((ord(char) + 3) % 256) for char in message)\n\ndef decode_message(encoded_message):\n    return ''.join(chr((ord(char) - 3) % 256) for char in encoded_message)\n\ndef search_for_keyword(encoded_messages, keyword):\n    decoded_messages = [decode_message(msg) for msg in encoded_messages]\n    matching_indices = []\n    for i, decoded_msg in enumerate(decoded_messages):\n        if keyword in decoded_msg:\n            matching_indices.append(i)\n    return matching_indices\n\nmessages = [\n    \"Hello, World!\",\n    \"Python is fun\",\n    \"Search algorithms\",\n    \"Encryption and encoding\",\n    \"Find the secret message\",\n    \"This is a test message\",\n    \"Another message here\",\n    \"Learning Python\",\n    \"Algorithms are cool\",\n    \"Secret: the keyword is 'fun'\"\n]\n\nencoded_messages = [encode_message(msg) for msg in messages]\nkeyword = \"fun\"\nmatching_indices = search_for_keyword(encoded_messages, keyword)\n\nfor index in matching_indices:\n    print(f\"Message {index + 1}: {decode_message(encoded_messages[index])}\")"}, {"role": "assistant", "content": "Message 2: Python is fun\nMessage 10: Secret: the keyword is 'fun'\n"}]}
{"messages": [{"role": "user", "content": "def generate_pattern(m, n):\n    return [[1 if (i + j) % 2 == 0 else 0 for j in range(n)] for i in range(m)]\n\ndef search_pattern(pattern, target):\n    occurrences = []\n    for row_index, row in enumerate(pattern):\n        for col_index in range(len(row) - len(target) + 1):\n            if row[col_index:col_index + len(target)] == target:\n                occurrences.append((row_index, col_index))\n    return occurrences\n\ndef display_pattern_with_search_results(pattern, search_results, target):\n    for row_index, row in enumerate(pattern):\n        line = \"\"\n        for col_index, value in enumerate(row):\n            if (row_index, col_index) in search_results:\n                line += f\"[{target[0]}]\"\n            else:\n                line += f\" {value} \"\n        print(line)\n\nm, n = 10, 10\ntarget_pattern = [1, 0, 1]\n\npattern = generate_pattern(m, n)\nsearch_results = search_pattern(pattern, target_pattern)\ndisplay_pattern_with_search_results(pattern, search_results, target_pattern)"}, {"role": "assistant", "content": "[1] 0 [1] 0 [1] 0 [1] 0  1  0 \n 0 [1] 0 [1] 0 [1] 0 [1] 0  1 \n[1] 0 [1] 0 [1] 0 [1] 0  1  0 \n 0 [1] 0 [1] 0 [1] 0 [1] 0  1 \n[1] 0 [1] 0 [1] 0 [1] 0  1  0 \n 0 [1] 0 [1] 0 [1] 0 [1] 0  1 \n[1] 0 [1] 0 [1] 0 [1] 0  1  0 \n 0 [1] 0 [1] 0 [1] 0 [1] 0  1 \n[1] 0 [1] 0 [1] 0 [1] 0  1  0 \n 0 [1] 0 [1] 0 [1] 0 [1] 0  1 \n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef transform_dates(dates):\n    transformed = []\n    for date in dates:\n        transformed.append((date, datetime.datetime.strptime(date, '%Y-%m-%d')))\n    return transformed\n\ndef sort_dates(dates):\n    return sorted(dates, key=lambda x: x[1])\n\ndates_list = [\n    \"2023-09-14\", \"2022-03-22\", \"2023-01-05\", \"2021-08-08\",\n    \"2022-11-11\", \"2023-07-19\", \"2022-05-05\", \"2023-10-10\"\n]\n\nprint(\"Original dates:\")\nfor date in dates_list:\n    print(date)\n\ntransformed_dates = transform_dates(dates_list)\n\nprint(\"\\nTransformed dates for sorting:\")\nfor date, dt in transformed_dates:\n    print(f\"{date}: {dt}\")\n\nsorted_dates = sort_dates(transformed_dates)\n\nprint(\"\\nSorted dates:\")\nfor date, dt in sorted_dates:\n    print(date)"}, {"role": "assistant", "content": "Original dates:\n2023-09-14\n2022-03-22\n2023-01-05\n2021-08-08\n2022-11-11\n2023-07-19\n2022-05-05\n2023-10-10\n\nTransformed dates for sorting:\n2023-09-14: 2023-09-14 00:00:00\n2022-03-22: 2022-03-22 00:00:00\n2023-01-05: 2023-01-05 00:00:00\n2021-08-08: 2021-08-08 00:00:00\n2022-11-11: 2022-11-11 00:00:00\n2023-07-19: 2023-07-19 00:00:00\n2022-05-05: 2022-05-05 00:00:00\n2023-10-10: 2023-10-10 00:00:00\n\nSorted dates:\n2021-08-08\n2022-03-22\n2022-05-05\n2022-11-11\n2023-01-05\n2023-07-19\n2023-09-14\n2023-10-10\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef find_first_vowel_word(text):\n    words = re.findall(r'\\b\\w+\\b', text)\n    for word in words:\n        if re.search(r'[aeiouAEIOU]', word):\n            return word\n    return None\n\ndef main():\n    text = \"\"\"\n    Python is an interpreted high-level general-purpose programming language. \n    Its design philosophy emphasizes code readability with its use of significant indentation. \n    Its language constructs as well as its object-oriented approach aim to help programmers write clear, \n    logical code for small and large-scale projects.\n    \"\"\"\n    \n    result = find_first_vowel_word(text)\n    if result:\n        print(\"The first word with a vowel is:\", result)\n    else:\n        print(\"No word with a vowel found.\")\n\nmain()"}, {"role": "assistant", "content": "The first word with a vowel is: Python\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef is_leap_year(year):\n    return (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)\n\ndef days_in_month(year, month):\n    if month == 2:\n        return 29 if is_leap_year(year) else 28\n    return 30 if month in {4, 6, 9, 11} else 31\n\ndef find_first_sunday(year, month):\n    dt = datetime(year, month, 1)\n    while dt.weekday() != 6:\n        dt += timedelta(days=1)\n    return dt\n\ndef date_search_algorithm(start_year, end_year):\n    date_list = []\n    for year in range(start_year, end_year + 1):\n        for month in range(1, 13):\n            first_sunday = find_first_sunday(year, month)\n            last_day = days_in_month(year, month)\n            if first_sunday.day <= 7 and last_day - first_sunday.day < 7:\n                date_list.append(first_sunday)\n    return date_list\n\nstart_year = 2000\nend_year = 2023\nresult_dates = date_search_algorithm(start_year, end_year)\n\nprint(\"Special Sundays between\", start_year, \"and\", end_year, \"are:\")\nfor date in result_dates:\n    print(date.strftime(\"%Y-%m-%d\"))\n\nprint(\"Total special Sundays found:\", len(result_dates))"}, {"role": "assistant", "content": "Special Sundays between 2000 and 2023 are:\nTotal special Sundays found: 0\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndata = [\n    {'name': 'Alice', 'scores': {'math': 88, 'english': 72, 'science': 95}},\n    {'name': 'Bob', 'scores': {'math': 70, 'english': 85, 'science': 80}},\n    {'name': 'Charlie', 'scores': {'math': 92, 'english': 88, 'science': 91}},\n    {'name': 'David', 'scores': {'math': 85, 'english': 78, 'science': 85}},\n    {'name': 'Eva', 'scores': {'math': 79, 'english': 82, 'science': 89}},\n    {'name': 'Frank', 'scores': {'math': 90, 'english': 74, 'science': 92}},\n    {'name': 'Grace', 'scores': {'math': 84, 'english': 79, 'science': 88}},\n    {'name': 'Hannah', 'scores': {'math': 89, 'english': 90, 'science': 94}}\n]\n\nsubjects = ['math', 'english', 'science']\n\nfor subject in subjects:\n    sorted_data = sorted(data, key=lambda x: x['scores'][subject])\n    names = [student['name'] for student in sorted_data]\n    scores = [student['scores'][subject] for student in sorted_data]\n    median_score = statistics.median(scores)\n    print(f\"Subject: {subject.capitalize()}\")\n    print(f\"Sorted scores: {list(zip(names, scores))}\")\n    print(f\"Median score: {median_score}\\n\")"}, {"role": "assistant", "content": "Subject: Math\nSorted scores: [('Bob', 70), ('Eva', 79), ('Grace', 84), ('David', 85), ('Alice', 88), ('Hannah', 89), ('Frank', 90), ('Charlie', 92)]\nMedian score: 86.5\n\nSubject: English\nSorted scores: [('Alice', 72), ('Frank', 74), ('David', 78), ('Grace', 79), ('Eva', 82), ('Bob', 85), ('Charlie', 88), ('Hannah', 90)]\nMedian score: 80.5\n\nSubject: Science\nSorted scores: [('Bob', 80), ('David', 85), ('Grace', 88), ('Eva', 89), ('Charlie', 91), ('Frank', 92), ('Hannah', 94), ('Alice', 95)]\nMedian score: 90.0\n\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef parse_date(date_str):\n    return datetime.datetime.strptime(date_str, \"%Y-%m-%d\")\n\ndef analyze_dates(dates):\n    date_objs = [parse_date(date) for date in dates]\n    sorted_dates = sorted(date_objs, key=lambda d: d.day)\n    return [d.strftime(\"%Y-%m-%d\") for d in sorted_dates]\n\ndates_list = [\n    \"2023-03-15\", \"2023-05-01\", \"2023-04-20\",\n    \"2023-01-25\", \"2023-07-12\", \"2023-08-23\",\n    \"2023-02-11\", \"2023-09-09\", \"2023-06-30\",\n    \"2023-11-19\", \"2023-10-05\", \"2023-12-28\"\n]\n\nordered_dates = analyze_dates(dates_list)\nfor date in ordered_dates:\n    print(date)"}, {"role": "assistant", "content": "2023-05-01\n2023-10-05\n2023-09-09\n2023-02-11\n2023-07-12\n2023-03-15\n2023-11-19\n2023-04-20\n2023-08-23\n2023-01-25\n2023-12-28\n2023-06-30\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef divisors(n):\n    divs = []\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divs.append(i)\n            if i != n // i:\n                divs.append(n // i)\n    return sorted(divs)\n\ndef unique_digit_count(num):\n    return len(set(str(num)))\n\ndef sort_sequences_by_divisors_and_uniqueness(sequences):\n    return sorted(sequences, key=lambda seq: (len(divisors(seq)), unique_digit_count(seq)))\n\nsequences = [112, 121, 211, 123, 231, 312, 321, 213, 234, 432, 342]\nsorted_sequences = sort_sequences_by_divisors_and_uniqueness(sequences)\n\nfor seq in sorted_sequences:\n    print(seq)"}, {"role": "assistant", "content": "211\n121\n123\n321\n213\n231\n112\n234\n342\n312\n432\n"}]}
{"messages": [{"role": "user", "content": "def fibonacci(n):\n    sequence = [0, 1]\n    while len(sequence) < n:\n        sequence.append(sequence[-1] + sequence[-2])\n    return sequence\n\ndef search_sequence(sequence, target):\n    for i, number in enumerate(sequence):\n        if number == target:\n            return i\n    return -1\n\ndef find_special_numbers(n, k):\n    fib_sequence = fibonacci(n)\n    special_numbers = [x for x in range(1, n) if x % k == 0]\n    results = []\n\n    for number in special_numbers:\n        index = search_sequence(fib_sequence, number)\n        if index != -1:\n            results.append((number, index))\n\n    return results\n\nn = 100\nk = 7\nspecial_numbers_with_indices = find_special_numbers(n, k)\nfor number, index in special_numbers_with_indices:\n    print(f\"Number {number} found at index {index} in Fibonacci sequence.\")"}, {"role": "assistant", "content": "Number 21 found at index 8 in Fibonacci sequence.\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\ndef is_inside_circle(circle_center, radius, point):\n    return distance(circle_center, point) <= radius\n\ndef search_closest_point_in_circle(points, circle_center, radius):\n    closest_point = None\n    closest_distance = float('inf')\n    for point in points:\n        if is_inside_circle(circle_center, radius, point):\n            dist = distance(circle_center, point)\n            if dist < closest_distance:\n                closest_distance = dist\n                closest_point = point\n    return closest_point\n\ndef generate_points():\n    points = []\n    for x in range(10):\n        for y in range(10):\n            points.append((x, y))\n    return points\n\npoints = generate_points()\ncircle_center = (5, 5)\nradius = 3.0\nclosest_point = search_closest_point_in_circle(points, circle_center, radius)\n\nfor point in points:\n    if is_inside_circle(circle_center, radius, point):\n        print(f\"Point {point} is inside the circle.\")\n\nif closest_point:\n    print(\"\\nClosest point to the center within the circle is:\", closest_point)\nelse:\n    print(\"\\nNo points found inside the circle.\")"}, {"role": "assistant", "content": "Point (2, 5) is inside the circle.\nPoint (3, 3) is inside the circle.\nPoint (3, 4) is inside the circle.\nPoint (3, 5) is inside the circle.\nPoint (3, 6) is inside the circle.\nPoint (3, 7) is inside the circle.\nPoint (4, 3) is inside the circle.\nPoint (4, 4) is inside the circle.\nPoint (4, 5) is inside the circle.\nPoint (4, 6) is inside the circle.\nPoint (4, 7) is inside the circle.\nPoint (5, 2) is inside the circle.\nPoint (5, 3) is inside the circle.\nPoint (5, 4) is inside the circle.\nPoint (5, 5) is inside the circle.\nPoint (5, 6) is inside the circle.\nPoint (5, 7) is inside the circle.\nPoint (5, 8) is inside the circle.\nPoint (6, 3) is inside the circle.\nPoint (6, 4) is inside the circle.\nPoint (6, 5) is inside the circle.\nPoint (6, 6) is inside the circle.\nPoint (6, 7) is inside the circle.\nPoint (7, 3) is inside the circle.\nPoint (7, 4) is inside the circle.\nPoint (7, 5) is inside the circle.\nPoint (7, 6) is inside the circle.\nPoint (7, 7) is inside the circle.\nPoint (8, 5) is inside the circle.\n\nClosest point to the center within the circle is: (5, 5)\n"}]}
{"messages": [{"role": "user", "content": "patterns = [\n    \"*****\",\n    \"**** \",\n    \"***  \",\n    \"**   \",\n    \"*    \",\n    \" *   \",\n    \"  *  \",\n    \"   * \",\n    \"    *\",\n    \"*****\"\n]\n\ndef custom_sort(pattern):\n    return len(pattern.strip()), pattern\n\nsorted_patterns = sorted(patterns, key=custom_sort)\n\nfor pattern in sorted_patterns:\n    print(pattern)"}, {"role": "assistant", "content": "    *\n   * \n  *  \n *   \n*    \n**   \n***  \n**** \n*****\n*****\n"}]}
{"messages": [{"role": "user", "content": "def custom_encoder(s):\n    encoded = []\n    for c in s:\n        encoded.append(ord(c) * 3)\n    return encoded\n\ndef custom_decoder(encoded):\n    decoded = \"\"\n    for num in encoded:\n        decoded += chr(num // 3)\n    return decoded\n\ndef insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and key < arr[j]:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n\ndef sort_encoded(encoded):\n    insertion_sort(encoded)\n\nmessage = \"EncryptionTest\"\nprint(\"Original Message:\", message)\nencoded_message = custom_encoder(message)\nprint(\"Encoded Message:\", encoded_message)\n\nsort_encoded(encoded_message)\nprint(\"Sorted Encoded Message:\", encoded_message)\n\ndecoded_message = custom_decoder(encoded_message)\nprint(\"Decoded Message:\", decoded_message)"}, {"role": "assistant", "content": "Original Message: EncryptionTest\nEncoded Message: [207, 330, 297, 342, 363, 336, 348, 315, 333, 330, 252, 303, 345, 348]\nSorted Encoded Message: [207, 252, 297, 303, 315, 330, 330, 333, 336, 342, 345, 348, 348, 363]\nDecoded Message: ETceinnoprstty\n"}]}
{"messages": [{"role": "user", "content": "import math\nimport datetime\n\ndef time_to_minutes(time_str):\n    hours, minutes = map(int, time_str.split(':'))\n    return hours * 60 + minutes\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_next_prime(start):\n    num = start + 1\n    while not is_prime(num):\n        num += 1\n    return num\n\nmeeting_times = [\n    \"09:00\", \"10:15\", \"12:30\", \"14:45\", \"16:00\",\n    \"18:15\", \"20:30\", \"22:45\", \"23:59\"\n]\n\nmeeting_minutes = [time_to_minutes(t) for t in meeting_times]\n\nprime_times = []\nfor time in meeting_minutes:\n    next_prime = find_next_prime(time)\n    prime_times.append(next_prime)\n    print(f\"Meeting time in minutes: {time}, Next prime: {next_prime}\")\n\nprint(\"\\nPrime meeting minutes converted back to 'HH:MM':\")\nfor prime in prime_times:\n    hours = prime // 60\n    minutes = prime % 60\n    print(f\"{hours:02}:{minutes:02}\")"}, {"role": "assistant", "content": "Meeting time in minutes: 540, Next prime: 541\nMeeting time in minutes: 615, Next prime: 617\nMeeting time in minutes: 750, Next prime: 751\nMeeting time in minutes: 885, Next prime: 887\nMeeting time in minutes: 960, Next prime: 967\nMeeting time in minutes: 1095, Next prime: 1097\nMeeting time in minutes: 1230, Next prime: 1231\nMeeting time in minutes: 1365, Next prime: 1367\nMeeting time in minutes: 1439, Next prime: 1447\n\nPrime meeting minutes converted back to 'HH:MM':\n09:01\n10:17\n12:31\n14:47\n16:07\n18:17\n20:31\n22:47\n24:07\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef distance_from_origin(point):\n    return math.sqrt(point[0] ** 2 + point[1] ** 2)\n\ndef sort_by_polar_angle(points):\n    def polar_angle(p):\n        return math.atan2(p[1], p[0])\n    return sorted(points, key=lambda p: (polar_angle(p), distance_from_origin(p)))\n\ndef generate_polygon_points(n):\n    points = []\n    for i in range(n):\n        angle = 2 * math.pi * i / n\n        x = math.cos(angle)\n        y = math.sin(angle)\n        points.append((x, y))\n    return points\n\ndef sort_polygon_vertices(points):\n    return sorted(points, key=lambda p: (p[1], p[0]))\n\nn = 11\npoints = generate_polygon_points(n)\nsorted_points = sort_by_polar_angle(points)\nsorted_vertices = sort_polygon_vertices(sorted_points)\n\nfor p in sorted_vertices:\n    print(f\"({p[0]:.2f}, {p[1]:.2f})\")"}, {"role": "assistant", "content": "(-0.14, -0.99)\n(0.42, -0.91)\n(-0.65, -0.76)\n(0.84, -0.54)\n(-0.96, -0.28)\n(1.00, 0.00)\n(-0.96, 0.28)\n(0.84, 0.54)\n(-0.65, 0.76)\n(0.42, 0.91)\n(-0.14, 0.99)\n"}]}
{"messages": [{"role": "user", "content": "import datetime\nfrom statistics import mean\n\ndata = [\n    {\"date\": \"2023-03-01\", \"value\": 10},\n    {\"date\": \"2023-02-01\", \"value\": 20},\n    {\"date\": \"2023-01-01\", \"value\": 5},\n    {\"date\": \"2023-04-01\", \"value\": 15},\n    {\"date\": \"2023-05-01\", \"value\": 25},\n    {\"date\": \"2023-06-01\", \"value\": 30},\n    {\"date\": \"2023-07-01\", \"value\": 35},\n    {\"date\": \"2023-08-01\", \"value\": 40},\n    {\"date\": \"2023-09-01\", \"value\": 45},\n    {\"date\": \"2023-10-01\", \"value\": 50},\n]\n\nfor item in data:\n    item[\"date\"] = datetime.datetime.strptime(item[\"date\"], \"%Y-%m-%d\")\n\nsorted_data = sorted(data, key=lambda x: x[\"date\"])\nmonthly_averages = []\n\nfor i in range(len(sorted_data) - 2):\n    window = sorted_data[i:i+3]\n    avg_value = mean(item[\"value\"] for item in window)\n    monthly_averages.append((window[-1][\"date\"].strftime(\"%B %Y\"), avg_value))\n\nmonthly_averages.sort(key=lambda x: x[1], reverse=True)\n\nfor month, avg in monthly_averages:\n    print(f\"{month}: {avg:.2f}\")"}, {"role": "assistant", "content": "October 2023: 45.00\nSeptember 2023: 40.00\nAugust 2023: 35.00\nJuly 2023: 30.00\nJune 2023: 23.33\nMay 2023: 16.67\nApril 2023: 15.00\nMarch 2023: 11.67\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef date_search(dates, target):\n    low, high = 0, len(dates) - 1\n    target_date = datetime.strptime(target, '%Y-%m-%d')\n    \n    while low <= high:\n        mid = (low + high) // 2\n        mid_date = datetime.strptime(dates[mid], '%Y-%m-%d')\n        \n        if mid_date == target_date:\n            return mid\n        elif mid_date < target_date:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return -1\n\ndates = [(datetime(2023, 1, 1) + timedelta(days=i)).strftime('%Y-%m-%d') for i in range(100)]\ntarget_dates = [\n    \"2023-01-15\", \"2023-02-28\", \"2023-03-10\", \"2023-04-25\", \"2023-05-05\",\n    \"2023-06-15\", \"2023-07-20\", \"2023-08-30\", \"2023-09-10\", \"2023-10-31\"\n]\n\nfor target in target_dates:\n    result = date_search(dates, target)\n    output = f\"Target Date: {target}, Index: {result}\"\n    print(output)"}, {"role": "assistant", "content": "Target Date: 2023-01-15, Index: 14\nTarget Date: 2023-02-28, Index: 58\nTarget Date: 2023-03-10, Index: 68\nTarget Date: 2023-04-25, Index: -1\nTarget Date: 2023-05-05, Index: -1\nTarget Date: 2023-06-15, Index: -1\nTarget Date: 2023-07-20, Index: -1\nTarget Date: 2023-08-30, Index: -1\nTarget Date: 2023-09-10, Index: -1\nTarget Date: 2023-10-31, Index: -1\n"}]}
{"messages": [{"role": "user", "content": "def find_hidden_treasure(grid, start, end):\n    def search_path(x, y, path):\n        if (x, y) == end:\n            return path + [(x, y)]\n        if not (0 <= x < len(grid)) or not (0 <= y < len(grid[0])) or grid[x][y] == 'X':\n            return None\n        grid[x][y] = 'X'\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            new_path = search_path(x + dx, y + dy, path + [(x, y)])\n            if new_path:\n                return new_path\n        return None\n    \n    path = search_path(*start, [])\n    if path is None:\n        return []\n    return path[:-1]\n\nterrain = [\n    ['.', '.', '.', '.', '.', '.', '.'],\n    ['.', 'X', 'X', 'X', '.', 'X', '.'],\n    ['.', '.', '.', 'X', '.', 'X', '.'],\n    ['X', 'X', '.', 'X', '.', '.', '.'],\n    ['.', '.', '.', '.', 'X', 'X', '.'],\n    ['.', 'X', '.', '.', '.', '.', '.'],\n    ['.', '.', '.', 'X', '.', '.', 'T']\n]\n\nfound_path = find_hidden_treasure(terrain, (0, 0), (6, 6))\nfor position in found_path:\n    print(f\"Step to: {position}\")"}, {"role": "assistant", "content": "Step to: (0, 0)\nStep to: (1, 0)\nStep to: (2, 0)\nStep to: (2, 1)\nStep to: (2, 2)\nStep to: (3, 2)\nStep to: (4, 2)\nStep to: (5, 2)\nStep to: (5, 3)\nStep to: (5, 4)\nStep to: (6, 4)\nStep to: (6, 5)\nStep to: (5, 5)\nStep to: (5, 6)\n"}]}
{"messages": [{"role": "user", "content": "def sort_sentences_by_word_count(text):\n    sentences = text.split('. ')\n    sorted_sentences = sorted(sentences, key=len)\n    return sorted_sentences\n\nparagraph = (\n    \"Sorting sentences can be interesting. \"\n    \"This is a short one. \"\n    \"Here we have a slightly longer sentence than the previous one. \"\n    \"Do you like sorting algorithms. \"\n    \"Python makes it easy to sort things.\"\n)\n\nsorted_sentences = sort_sentences_by_word_count(paragraph)\n\nfor sentence in sorted_sentences:\n    print(sentence.strip() + '.')"}, {"role": "assistant", "content": "This is a short one.\nDo you like sorting algorithms.\nSorting sentences can be interesting.\nPython makes it easy to sort things..\nHere we have a slightly longer sentence than the previous one.\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndata = [\n    34, 47, 23, 45, 56, 78, 89, 90, 12, 34, 56, 23, 45, 67, 89, 90, 12, 34, 56, \n    23, 45, 67, 89, 90, 12, 34, 56, 23, 45, 67, 89, 90, 12, 34, 56, 23, 45, 67, \n    89, 90, 12, 34, 56, 23, 45, 67, 89, 90, 12, 34, 56, 23, 45, 67, 89, 90, 12, \n    34, 56, 23, 45, 67, 89, 90, 12, 34, 56, 23, 45, 67, 89, 90, 12, 34, 56, 23\n]\n\nprint(\"Original Data:\")\nprint(data)\n\nsorted_data = sorted(data)\nprint(\"\\nSorted Data:\")\nprint(sorted_data)\n\nmean_value = statistics.mean(data)\nprint(\"\\nMean Value:\")\nprint(mean_value)\n\nmedian_value = statistics.median(data)\nprint(\"\\nMedian Value:\")\nprint(median_value)\n\nmode_value = statistics.mode(data)\nprint(\"\\nMode Value:\")\nprint(mode_value)\n\nvariance_value = statistics.variance(data)\nprint(\"\\nVariance Value:\")\nprint(variance_value)\n\nprint(\"\\nData elements greater than the mean:\")\ngreater_than_mean = list(filter(lambda x: x > mean_value, data))\nsorted_greater_than_mean = sorted(greater_than_mean)\nprint(sorted_greater_than_mean)\n\nprint(\"\\nData elements less than the mean:\")\nless_than_mean = list(filter(lambda x: x < mean_value, data))\nsorted_less_than_mean = sorted(less_than_mean)\nprint(sorted_less_than_mean)"}, {"role": "assistant", "content": "Original Data:\n[34, 47, 23, 45, 56, 78, 89, 90, 12, 34, 56, 23, 45, 67, 89, 90, 12, 34, 56, 23, 45, 67, 89, 90, 12, 34, 56, 23, 45, 67, 89, 90, 12, 34, 56, 23, 45, 67, 89, 90, 12, 34, 56, 23, 45, 67, 89, 90, 12, 34, 56, 23, 45, 67, 89, 90, 12, 34, 56, 23, 45, 67, 89, 90, 12, 34, 56, 23, 45, 67, 89, 90, 12, 34, 56, 23]\n\nSorted Data:\n[12, 12, 12, 12, 12, 12, 12, 12, 12, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 45, 45, 45, 45, 45, 45, 45, 45, 45, 47, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 67, 67, 67, 67, 67, 67, 67, 67, 78, 89, 89, 89, 89, 89, 89, 89, 89, 89, 90, 90, 90, 90, 90, 90, 90, 90, 90]\n\nMean Value:\n51.51315789473684\n\nMedian Value:\n46.0\n\nMode Value:\n34\n\nVariance Value:\n726.0131578947369\n\nData elements greater than the mean:\n[56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 67, 67, 67, 67, 67, 67, 67, 67, 78, 89, 89, 89, 89, 89, 89, 89, 89, 89, 90, 90, 90, 90, 90, 90, 90, 90, 90]\n\nData elements less than the mean:\n[12, 12, 12, 12, 12, 12, 12, 12, 12, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 45, 45, 45, 45, 45, 45, 45, 45, 45, 47]\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef is_consonant(char):\n    return char.lower() in \"bcdfghjklmnpqrstvwxyz\"\n\ndef pattern_search(string, pattern):\n    matches = []\n    for i in range(len(string) - len(pattern) + 1):\n        match_found = True\n        for j in range(len(pattern)):\n            if string[i + j] != pattern[j]:\n                match_found = False\n                break\n        if match_found:\n            matches.append(i)\n    return matches\n\ndef generate_spiral(n):\n    spiral = [[' ' for _ in range(n)] for _ in range(n)]\n    x, y = n // 2, n // 2\n    dx, dy = -1, 0\n    step = 1\n    current_value = 1\n    while current_value <= n * n:\n        for _ in range(2):\n            for _ in range(step):\n                if 0 <= x < n and 0 <= y < n:\n                    if is_consonant(chr(96 + current_value)):\n                        spiral[y][x] = chr(96 + current_value)\n                    current_value += 1\n                x += dx\n                y += dy\n            dx, dy = dy, -dx\n        step += 1\n    return spiral\n\ndef print_spiral(spiral):\n    for row in spiral:\n        print(''.join(row))\n        print()\n\nstring = \"thequickbrownfoxjumpsoverthelazydog\"\npattern = \"fox\"\nmatches = pattern_search(string, pattern)\nprint(f\"Pattern '{pattern}' found at indices: {matches}\")\nprint(\"Generated Spiral:\")\n\nspiral = generate_spiral(math.ceil(math.sqrt(len(string))))\nprint_spiral(spiral)"}, {"role": "assistant", "content": "Pattern 'fox' found at indices: [13]\nGenerated Spiral:\n      \n\nzyxwv \n\n j hgt\n\n kb fs\n\n lcd r\n\n mn pq\n\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef calculate_polygon_perimeter(points):\n    perimeter = 0\n    for i in range(len(points)):\n        p1 = points[i]\n        p2 = points[(i + 1) % len(points)]\n        distance = math.sqrt((p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2)\n        perimeter += distance\n    return perimeter\n\ndef sort_polygons_by_area(polygons):\n    def polygon_area(points):\n        area = 0\n        for i in range(len(points)):\n            x1, y1 = points[i]\n            x2, y2 = points[(i + 1) % len(points)]\n            area += x1 * y2 - x2 * y1\n        return abs(area) / 2\n\n    sorted_polygons = sorted(polygons, key=calculate_polygon_perimeter)\n    return sorted_polygons\n\npolygons = [\n    [(1, 1), (4, 1), (4, 5), (1, 5)],\n    [(2, 2), (6, 2), (6, 8), (2, 8)],\n    [(0, 0), (3, 0), (3, 3), (0, 3)],\n    [(0, 0), (1, 0), (1, 1), (0, 1)]\n]\n\nsorted_polys = sort_polygons_by_area(polygons)\n\nfor poly in sorted_polys:\n    perimeter = calculate_polygon_perimeter(poly)\n    print(f\"Polygon with vertices {poly} has perimeter {perimeter:.2f}\")"}, {"role": "assistant", "content": "Polygon with vertices [(0, 0), (1, 0), (1, 1), (0, 1)] has perimeter 4.00\nPolygon with vertices [(0, 0), (3, 0), (3, 3), (0, 3)] has perimeter 12.00\nPolygon with vertices [(1, 1), (4, 1), (4, 5), (1, 5)] has perimeter 14.00\nPolygon with vertices [(2, 2), (6, 2), (6, 8), (2, 8)] has perimeter 20.00\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndata = [15, 22, 29, 37, 42, 51, 55, 62, 71, 73, 81, 88, 92, 95, 97, 100]\n\ndef mean(data):\n    return sum(data) / len(data)\n\ndef variance(data):\n    m = mean(data)\n    return sum((x - m) ** 2 for x in data) / len(data)\n\ndef std_deviation(data):\n    return math.sqrt(variance(data))\n\ndef nearest_index(data, value):\n    low, high = 0, len(data) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if data[mid] < value:\n            low = mid + 1\n        elif data[mid] > value:\n            high = mid - 1\n        else:\n            return mid\n    if low >= len(data):\n        return len(data) - 1\n    if high < 0:\n        return 0\n    if abs(data[low] - value) < abs(data[high] - value):\n        return low\n    return high\n\nmean_value = mean(data)\nstd_dev = std_deviation(data)\nthreshold = mean_value + std_dev\n\nindex = nearest_index(data, threshold)\nprint(f\"Mean: {mean_value:.2f}\")\nprint(f\"Standard Deviation: {std_dev:.2f}\")\nprint(f\"Threshold (Mean + Std Dev): {threshold:.2f}\")\nprint(f\"Nearest Value to Threshold: {data[index]}\")\nprint(f\"Index of Nearest Value: {index}\")\n\nfor i, val in enumerate(data):\n    print(f\"Value: {val}, Difference from Mean: {abs(val - mean_value):.2f}\")"}, {"role": "assistant", "content": "Mean: 63.12\nStandard Deviation: 27.35\nThreshold (Mean + Std Dev): 90.48\nNearest Value to Threshold: 92\nIndex of Nearest Value: 12\nValue: 15, Difference from Mean: 48.12\nValue: 22, Difference from Mean: 41.12\nValue: 29, Difference from Mean: 34.12\nValue: 37, Difference from Mean: 26.12\nValue: 42, Difference from Mean: 21.12\nValue: 51, Difference from Mean: 12.12\nValue: 55, Difference from Mean: 8.12\nValue: 62, Difference from Mean: 1.12\nValue: 71, Difference from Mean: 7.88\nValue: 73, Difference from Mean: 9.88\nValue: 81, Difference from Mean: 17.88\nValue: 88, Difference from Mean: 24.88\nValue: 92, Difference from Mean: 28.88\nValue: 95, Difference from Mean: 31.88\nValue: 97, Difference from Mean: 33.88\nValue: 100, Difference from Mean: 36.88\n"}]}
{"messages": [{"role": "user", "content": "players = [\n    {'name': 'Alice', 'score': 1200},\n    {'name': 'Bob', 'score': 800},\n    {'name': 'Charlie', 'score': 950},\n    {'name': 'David', 'score': 1100},\n    {'name': 'Eve', 'score': 1050},\n    {'name': 'Frank', 'score': 980},\n    {'name': 'Grace', 'score': 870},\n    {'name': 'Hannah', 'score': 920},\n    {'name': 'Ivy', 'score': 1000},\n    {'name': 'Jack', 'score': 1150},\n]\n\ndef merge_sort(arr, key):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort(left_half, key)\n        merge_sort(right_half, key)\n\n        i = j = k = 0\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i][key] < right_half[j][key]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n\nmerge_sort(players, 'score')\n\nfor i, player in enumerate(players, start=1):\n    print(f\"Rank {i}: {player['name']} with score {player['score']}\")"}, {"role": "assistant", "content": "Rank 1: Bob with score 800\nRank 2: Grace with score 870\nRank 3: Hannah with score 920\nRank 4: Charlie with score 950\nRank 5: Frank with score 980\nRank 6: Ivy with score 1000\nRank 7: Eve with score 1050\nRank 8: David with score 1100\nRank 9: Jack with score 1150\nRank 10: Alice with score 1200\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\ndef date_to_ordinal(date_str):\n    return datetime.strptime(date_str, \"%Y-%m-%d\").toordinal()\n\ndef ordinal_to_date(ordinal):\n    return datetime.fromordinal(ordinal).strftime(\"%Y-%m-%d\")\n\ndef sort_dates_by_distance(target_date, date_list):\n    target_ordinal = date_to_ordinal(target_date)\n    sorted_dates = sorted(date_list, key=lambda date: abs(date_to_ordinal(date) - target_ordinal))\n    return sorted_dates\n\ndates = [\n    \"2023-10-01\", \"2023-09-15\", \"2023-12-25\", \"2023-11-11\", \"2023-08-23\",\n    \"2023-12-31\", \"2023-09-01\", \"2023-11-05\", \"2023-10-15\", \"2023-07-30\",\n    \"2023-10-20\", \"2023-10-05\", \"2023-09-10\", \"2023-11-30\", \"2023-08-05\",\n    \"2023-12-01\", \"2023-11-01\", \"2023-10-10\", \"2023-09-25\", \"2023-08-15\"\n]\n\ntarget_date = \"2023-10-10\"\nsorted_dates = sort_dates_by_distance(target_date, dates)\n\nfor date in sorted_dates:\n    print(date)"}, {"role": "assistant", "content": "2023-10-10\n2023-10-15\n2023-10-05\n2023-10-01\n2023-10-20\n2023-09-25\n2023-11-01\n2023-09-15\n2023-11-05\n2023-09-10\n2023-11-11\n2023-09-01\n2023-08-23\n2023-11-30\n2023-12-01\n2023-08-15\n2023-08-05\n2023-07-30\n2023-12-25\n2023-12-31\n"}]}
{"messages": [{"role": "user", "content": "import math\nimport statistics\n\ndata = [23, 42, 35, 66, 74, 12, 45, 87, 39, 78, 54, 56, 67, 89, 90, 21, 22, 38, 29, 47]\n\ndef median_absolute_deviation(data):\n    med = statistics.median(data)\n    deviations = [abs(x - med) for x in data]\n    mad = statistics.median(deviations)\n    return mad\n\ndef sort_by_deviation(data):\n    med = statistics.median(data)\n    return sorted(data, key=lambda x: abs(x - med))\n\ndef custom_sort(data):\n    mad = median_absolute_deviation(data)\n    print(f\"Median Absolute Deviation: {mad}\")\n    threshold = mad * 1.5\n    print(f\"Threshold for Deviation: {threshold}\")\n    near_median = [x for x in data if abs(x - statistics.median(data)) <= threshold]\n    far_from_median = [x for x in data if abs(x - statistics.median(data)) > threshold]\n    near_median_sorted = sort_by_deviation(near_median)\n    far_from_median_sorted = sort_by_deviation(far_from_median)\n    return near_median_sorted + far_from_median_sorted\n\nsorted_data = custom_sort(data)\nprint(\"Original Data:\", data)\nprint(\"Sorted Data by Custom Deviation Logic:\")\nfor idx, value in enumerate(sorted_data):\n    print(f\"{idx + 1}: {value}\")"}, {"role": "assistant", "content": "Median Absolute Deviation: 20.5\nThreshold for Deviation: 30.75\nOriginal Data: [23, 42, 35, 66, 74, 12, 45, 87, 39, 78, 54, 56, 67, 89, 90, 21, 22, 38, 29, 47]\nSorted Data by Custom Deviation Logic:\n1: 42\n2: 45\n3: 39\n4: 38\n5: 47\n6: 35\n7: 54\n8: 29\n9: 56\n10: 23\n11: 22\n12: 21\n13: 66\n14: 67\n15: 74\n16: 87\n17: 89\n18: 90\n19: 78\n20: 12\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef find_odd_words(text):\n    words = re.findall(r'\\b\\w+\\b', text)\n    sorted_words = sorted(words)\n    return binary_search_odd(sorted_words, 0, len(sorted_words) - 1)\n\ndef binary_search_odd(words, left, right):\n    if left > right:\n        return []\n    mid = (left + right) // 2\n    if len(words[mid]) % 2 == 0:\n        return binary_search_odd(words, left, mid - 1) + binary_search_odd(words, mid + 1, right)\n    else:\n        return [words[mid]] + binary_search_odd(words, left, mid - 1) + binary_search_odd(words, mid + 1, right)\n\ntext_data = \"\"\"\nIn a small village, nestled between rolling hills and vast fields, there was a mysterious library. \nThis library was unlike any other, because it contained books that were filled with secrets and magic. \nThe villagers often spoke of the library in hushed tones, for they believed that only the curious \nand brave could uncover its mysteries. One day, a young girl named Sophie decided to explore the library.\n\"\"\"\n\nodd_words = find_odd_words(text_data)\nfor word in odd_words:\n    print(word)"}, {"role": "assistant", "content": "library\nbrave\na\nThe\nOne\na\na\nany\nand\nand\nand\nbecause\nbetween\nbooks\nday\ncould\ncontained\ncurious\nexplore\ndecided\nfor\nhills\nits\nlibrary\nmysteries\nlibrary\nlibrary\nmagic\nnamed\nnestled\nrolling\noften\nother\nsmall\nsecrets\nspoke\nthere\nthe\nthe\nthe\ntones\nuncover\nwas\nvillage\nvillagers\nwas\nyoung\n"}]}
{"messages": [{"role": "user", "content": "import re\nfrom datetime import datetime\n\ndef caesar_cipher(text, shift):\n    encrypted = []\n    for char in text:\n        if char.isalpha():\n            shift_base = ord('a') if char.islower() else ord('A')\n            encrypted.append(chr((ord(char) - shift_base + shift) % 26 + shift_base))\n        else:\n            encrypted.append(char)\n    return ''.join(encrypted)\n\ndef find_encrypted_date(text, shift):\n    encrypted_text = caesar_cipher(text, shift)\n    pattern = r'\\b[A-Z]{3}\\b \\d{2}, \\d{4}'\n    matches = re.findall(pattern, encrypted_text)\n    return matches\n\ntext = \"Important meeting on OCT 15, 2023. Backup OCT 20, 2023.\"\nshift = 5\n\nprint(\"Original text:\")\nprint(text)\nprint(\"\\nEncrypted text with shift\", shift, \":\")\nencrypted_text = caesar_cipher(text, shift)\nprint(encrypted_text)\n\nprint(\"\\nSearching for encrypted dates...\")\nencrypted_dates = find_encrypted_date(text, shift)\nprint(\"Encrypted dates found:\", encrypted_dates)\n\nprint(\"\\nDecrypting found dates...\")\nfor enc_date in encrypted_dates:\n    decrypted_date = caesar_cipher(enc_date, -shift)\n    print(\"Encrypted:\", enc_date, \"Decrypted:\", decrypted_date)\n\nprint(\"\\nVerifying decrypted dates:\")\nfor enc_date in encrypted_dates:\n    decrypted_date = caesar_cipher(enc_date, -shift)\n    try:\n        parsed_date = datetime.strptime(decrypted_date, \"%b %d, %Y\")\n        print(\"Valid date:\", decrypted_date)\n    except ValueError:\n        print(\"Invalid date format:\", decrypted_date)"}, {"role": "assistant", "content": "Original text:\nImportant meeting on OCT 15, 2023. Backup OCT 20, 2023.\n\nEncrypted text with shift 5 :\nNrutwyfsy rjjynsl ts THY 15, 2023. Gfhpzu THY 20, 2023.\n\nSearching for encrypted dates...\nEncrypted dates found: ['THY 15, 2023', 'THY 20, 2023']\n\nDecrypting found dates...\nEncrypted: THY 15, 2023 Decrypted: OCT 15, 2023\nEncrypted: THY 20, 2023 Decrypted: OCT 20, 2023\n\nVerifying decrypted dates:\nValid date: OCT 15, 2023\nValid date: OCT 20, 2023\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"\nIn the beginning, there was the Word, and the Word was with God, and the Word was God.\nHe was with God in the beginning. Through him all things were made; without him nothing was made that has been made.\nIn him was life, and that life was the light of all mankind. The light shines in the darkness, and the darkness has not overcome it.\n\"\"\"\n\nwords = re.findall(r'\\b\\w+\\b', text.lower())\nword_count = {}\n\nfor word in words:\n    if word in word_count:\n        word_count[word] += 1\n    else:\n        word_count[word] = 1\n\nprint(\"Word frequencies before sorting:\")\nfor word, count in word_count.items():\n    print(f\"{word}: {count}\")\n\nsorted_words = sorted(word_count.items(), key=lambda item: (-item[1], len(item[0]), item[0]))\n\nprint(\"\\nSorted words by frequency, length, and lexicographical order:\")\nfor word, count in sorted_words:\n    print(f\"{word}: {count}\")"}, {"role": "assistant", "content": "Word frequencies before sorting:\nin: 4\nthe: 9\nbeginning: 2\nthere: 1\nwas: 7\nword: 3\nand: 4\nwith: 2\ngod: 3\nhe: 1\nthrough: 1\nhim: 3\nall: 2\nthings: 1\nwere: 1\nmade: 3\nwithout: 1\nnothing: 1\nthat: 2\nhas: 2\nbeen: 1\nlife: 2\nlight: 2\nof: 1\nmankind: 1\nshines: 1\ndarkness: 2\nnot: 1\novercome: 1\nit: 1\n\nSorted words by frequency, length, and lexicographical order:\nthe: 9\nwas: 7\nin: 4\nand: 4\ngod: 3\nhim: 3\nmade: 3\nword: 3\nall: 2\nhas: 2\nlife: 2\nthat: 2\nwith: 2\nlight: 2\ndarkness: 2\nbeginning: 2\nhe: 1\nit: 1\nof: 1\nnot: 1\nbeen: 1\nwere: 1\nthere: 1\nshines: 1\nthings: 1\nmankind: 1\nnothing: 1\nthrough: 1\nwithout: 1\novercome: 1\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\ndef triangle_area(p1, p2, p3):\n    a = distance(p1, p2)\n    b = distance(p2, p3)\n    c = distance(p3, p1)\n    s = (a + b + c) / 2\n    return math.sqrt(s * (s - a) * (s - b) * (s - c))\n\ndef sort_triangles(vertices):\n    triangles = [(vertices[i], vertices[j], vertices[k])\n                 for i in range(len(vertices))\n                 for j in range(i + 1, len(vertices))\n                 for k in range(j + 1, len(vertices))]\n    triangles.sort(key=lambda tri: triangle_area(*tri))\n    return triangles\n\ndef main():\n    points = [(0, 0), (1, 0), (0, 1), (1, 1), (2, 0), (0, 2)]\n    sorted_triangles = sort_triangles(points)\n    for tri in sorted_triangles:\n        area = triangle_area(*tri)\n        print(f\"Vertices: {tri} - Area: {area:.2f}\")\n\nmain()"}, {"role": "assistant", "content": "Vertices: ((0, 0), (1, 0), (2, 0)) - Area: 0.00\nVertices: ((0, 0), (0, 1), (0, 2)) - Area: 0.00\nVertices: ((1, 1), (2, 0), (0, 2)) - Area: 0.00\nVertices: ((1, 0), (0, 1), (2, 0)) - Area: 0.50\nVertices: ((1, 0), (0, 1), (0, 2)) - Area: 0.50\nVertices: ((1, 0), (1, 1), (0, 2)) - Area: 0.50\nVertices: ((0, 1), (1, 1), (2, 0)) - Area: 0.50\nVertices: ((1, 0), (0, 1), (1, 1)) - Area: 0.50\nVertices: ((0, 0), (1, 0), (0, 1)) - Area: 0.50\nVertices: ((0, 0), (1, 0), (1, 1)) - Area: 0.50\nVertices: ((0, 0), (0, 1), (1, 1)) - Area: 0.50\nVertices: ((1, 0), (1, 1), (2, 0)) - Area: 0.50\nVertices: ((0, 1), (1, 1), (0, 2)) - Area: 0.50\nVertices: ((1, 0), (2, 0), (0, 2)) - Area: 1.00\nVertices: ((0, 1), (2, 0), (0, 2)) - Area: 1.00\nVertices: ((0, 0), (1, 1), (2, 0)) - Area: 1.00\nVertices: ((0, 0), (1, 1), (0, 2)) - Area: 1.00\nVertices: ((0, 0), (1, 0), (0, 2)) - Area: 1.00\nVertices: ((0, 0), (0, 1), (2, 0)) - Area: 1.00\nVertices: ((0, 0), (2, 0), (0, 2)) - Area: 2.00\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef is_leap_year(year):\n    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n\ndef generate_dates(start_year, end_year):\n    dates = []\n    for year in range(start_year, end_year + 1):\n        for month in range(1, 13):\n            if month == 2:\n                day_limit = 29 if is_leap_year(year) else 28\n            elif month in (4, 6, 9, 11):\n                day_limit = 30\n            else:\n                day_limit = 31\n            for day in range(1, day_limit + 1):\n                dates.append(datetime(year, month, day))\n    return dates\n\ndef linear_search(dates, target_date):\n    for date in dates:\n        if date == target_date:\n            return date\n    return None\n\nstart_year = 2020\nend_year = 2023\ndates = generate_dates(start_year, end_year)\ntarget_date = datetime(2022, 12, 25)\nresult = linear_search(dates, target_date)\n\nif result:\n    print(f\"Target date {result.strftime('%Y-%m-%d')} found!\")\nelse:\n    print(\"Target date not found.\")"}, {"role": "assistant", "content": "Target date 2022-12-25 found!\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef find_median_deviation(data):\n    sorted_data = sorted(data)\n    median = statistics.median(sorted_data)\n    deviations = [abs(x - median) for x in sorted_data]\n    print(f\"Sorted data: {sorted_data}\")\n    print(f\"Median: {median}\")\n    print(f\"Deviations from median: {deviations}\")\n\n    return binary_search(sorted_data, deviations)\n\ndef binary_search(arr, deviations):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        print(f\"Checking middle point at index {mid}: {arr[mid]}\")\n        if deviations[mid] == 0:  # This condition is intentionally incorrect\n            return arr[mid]\n        elif deviations[mid] > 0:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return None\n\ndata = [15, 21, 13, 45, 34, 8, 20, 29, 11, 17]\nresult = find_median_deviation(data)\nprint(f\"Result from binary search: {result}\")"}, {"role": "assistant", "content": "Sorted data: [8, 11, 13, 15, 17, 20, 21, 29, 34, 45]\nMedian: 18.5\nDeviations from median: [10.5, 7.5, 5.5, 3.5, 1.5, 1.5, 2.5, 10.5, 15.5, 26.5]\nChecking middle point at index 4: 17\nChecking middle point at index 1: 11\nChecking middle point at index 0: 8\nResult from binary search: None\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\ndef generate_pattern(size):\n    pattern = []\n    for i in range(size):\n        line = [datetime.now().microsecond % 10 for _ in range(size)]\n        pattern.append(line)\n    return pattern\n\ndef sort_pattern_vertically(pattern):\n    size = len(pattern)\n    for i in range(size):\n        column = [pattern[j][i] for j in range(size)]\n        column.sort(reverse=True)\n        for j in range(size):\n            pattern[j][i] = column[j]\n    return pattern\n\ndef display_pattern(pattern):\n    for line in pattern:\n        print(\" \".join(str(x) for x in line))\n\npattern_size = 10\npattern = generate_pattern(pattern_size)\nsorted_pattern = sort_pattern_vertically(pattern)\ndisplay_pattern(sorted_pattern)"}, {"role": "assistant", "content": "7 7 7 8 8 9 9 9 9 9\n6 7 7 7 8 8 9 8 9 9\n5 6 6 7 7 8 8 8 8 8\n5 6 6 7 7 7 8 7 5 5\n5 5 5 6 6 7 7 5 4 5\n4 2 2 3 3 4 4 4 4 5\n2 1 2 2 3 3 3 3 3 4\n1 0 1 1 2 2 3 3 3 4\n0 0 1 1 2 2 2 3 0 1\n0 0 1 1 1 2 2 0 0 0\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef generate_number_sequence(n):\n    return [round(math.sin(x) * 100) for x in range(n)]\n\ndef custom_sort(sequence):\n    return sorted(sequence, key=lambda x: (x % 10, x))\n\ndef main():\n    sequence = generate_number_sequence(50)\n    print(\"Original sequence:\")\n    print(sequence)\n    \n    sorted_sequence = custom_sort(sequence)\n    print(\"\\nSorted sequence:\")\n    print(sorted_sequence)\n    \n    print(\"\\nSequential differences:\")\n    differences = [abs(sorted_sequence[i] - sorted_sequence[i-1]) for i in range(1, len(sorted_sequence))]\n    for diff in differences:\n        print(diff)\n\nmain()"}, {"role": "assistant", "content": "Original sequence:\n[0, 84, 91, 14, -76, -96, -28, 66, 99, 41, -54, -100, -54, 42, 99, 65, -29, -96, -75, 15, 91, 84, -1, -85, -91, -13, 76, 96, 27, -66, -99, -40, 55, 100, 53, -43, -99, -64, 30, 96, 75, -16, -92, -83, 2, 85, 90, 12, -77, -95]\n\nSorted sequence:\n[-100, -40, 0, 30, 90, 100, -99, -99, -29, 41, 91, 91, -28, 2, 12, 42, -77, 53, -96, -96, -76, -66, -16, 14, 84, 84, -95, -85, -75, 15, 55, 65, 75, 85, -64, -54, -54, 66, 76, 96, 96, -83, -43, -13, 27, -92, -91, -1, 99, 99]\n\nSequential differences:\n60\n40\n30\n60\n10\n199\n0\n70\n70\n50\n0\n119\n30\n10\n30\n119\n130\n149\n0\n20\n10\n50\n30\n70\n0\n179\n10\n10\n90\n40\n10\n10\n10\n149\n10\n0\n120\n10\n20\n0\n179\n40\n30\n40\n119\n1\n90\n100\n0\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef calculate_score(word):\n    return sum(ord(char) - ord('a') + 1 for char in word.lower())\n\ndef sort_words_by_score(words):\n    return sorted(words, key=lambda word: calculate_score(word), reverse=True)\n\ndef generate_words(seed_word, num_words):\n    words = [seed_word]\n    for _ in range(num_words - 1):\n        new_word = ''.join(chr((ord(char) - ord('a') + 1) % 26 + ord('a')) for char in words[-1])\n        words.append(new_word)\n    return words\n\ndef simulate_game(seed_word, num_rounds):\n    words = generate_words(seed_word, num_rounds)\n    sorted_words = sort_words_by_score(words)\n    return sorted_words\n\nseed_word = \"game\"\nnum_rounds = 20\nsorted_words = simulate_game(seed_word, num_rounds)\n\nfor word in sorted_words:\n    print(word, calculate_score(word))"}, {"role": "assistant", "content": "tnzr 78\nztfx 76\nsmyq 74\nysew 72\nrlxp 70\nxrdv 68\nqkwo 66\nwqcu 64\npjvn 62\nvpbt 60\noium 58\nuoas 56\nnhtl 54\nmgsk 50\nlfrj 46\nkeqi 42\njdph 38\nicog 34\nhbnf 30\ngame 26\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef is_perfect_square(n):\n    root = math.isqrt(n)\n    return root * root == n\n\ndef tribonacci(n):\n    if n == 0:\n        return 0\n    elif n == 1 or n == 2:\n        return 1\n    else:\n        a, b, c = 0, 1, 1\n        for _ in range(n - 2):\n            a, b, c = b, c, a + b + c\n        return c\n\ndef search_special_tribonacci(limit):\n    sequence = []\n    for i in range(limit):\n        t = tribonacci(i)\n        if is_perfect_square(t + 1):\n            sequence.append((i, t))\n    return sequence\n\nspecial_sequence = search_special_tribonacci(100)\nfor idx, num in special_sequence:\n    print(f\"T({idx}) = {num}\")"}, {"role": "assistant", "content": "T(0) = 0\nT(7) = 24\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef is_valid_date(date_str):\n    try:\n        datetime.strptime(date_str, '%Y-%m-%d')\n        return True\n    except ValueError:\n        return False\n\ndef find_fridays_13th(start_year, end_year):\n    fridays_13th = []\n    for year in range(start_year, end_year + 1):\n        for month in range(1, 13):\n            date_str = f\"{year}-{month:02d}-13\"\n            if is_valid_date(date_str):\n                date_obj = datetime.strptime(date_str, '%Y-%m-%d')\n                if date_obj.weekday() == 4:\n                    fridays_13th.append(date_str)\n    return fridays_13th\n\nstart_year = 2000\nend_year = 2020\nfridays = find_fridays_13th(start_year, end_year)\n\nfor friday in fridays:\n    print(friday)"}, {"role": "assistant", "content": "2000-10-13\n2001-04-13\n2001-07-13\n2002-09-13\n2002-12-13\n2003-06-13\n2004-02-13\n2004-08-13\n2005-05-13\n2006-01-13\n2006-10-13\n2007-04-13\n2007-07-13\n2008-06-13\n2009-02-13\n2009-03-13\n2009-11-13\n2010-08-13\n2011-05-13\n2012-01-13\n2012-04-13\n2012-07-13\n2013-09-13\n2013-12-13\n2014-06-13\n2015-02-13\n2015-03-13\n2015-11-13\n2016-05-13\n2017-01-13\n2017-10-13\n2018-04-13\n2018-07-13\n2019-09-13\n2019-12-13\n2020-03-13\n2020-11-13\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef search_for_longest_word(text):\n    words = re.findall(r'\\b\\w+\\b', text)\n    print(\"Words extracted:\", words)\n    \n    def binary_search_longest(start, end):\n        if start == end:\n            return words[start]\n        \n        mid = (start + end) // 2\n        \n        left = binary_search_longest(start, mid)\n        right = binary_search_longest(mid + 1, end)\n        \n        print(f\"Comparing: '{left}' and '{right}'\")\n        return left if len(left) < len(right) else right\n    \n    return binary_search_longest(0, len(words) - 1)\n\ntext_data = (\n    \"Algorithms are the heart of computer science. \"\n    \"They are the engines that drive the computations. \"\n    \"Understanding algorithms is crucial for developers.\"\n)\n\nlongest_word = search_for_longest_word(text_data)\nprint(\"Longest word found:\", longest_word)"}, {"role": "assistant", "content": "Words extracted: ['Algorithms', 'are', 'the', 'heart', 'of', 'computer', 'science', 'They', 'are', 'the', 'engines', 'that', 'drive', 'the', 'computations', 'Understanding', 'algorithms', 'is', 'crucial', 'for', 'developers']\nComparing: 'Algorithms' and 'are'\nComparing: 'are' and 'the'\nComparing: 'heart' and 'of'\nComparing: 'of' and 'computer'\nComparing: 'the' and 'of'\nComparing: 'science' and 'They'\nComparing: 'They' and 'are'\nComparing: 'the' and 'engines'\nComparing: 'are' and 'the'\nComparing: 'of' and 'the'\nComparing: 'that' and 'drive'\nComparing: 'that' and 'the'\nComparing: 'computations' and 'Understanding'\nComparing: 'the' and 'computations'\nComparing: 'algorithms' and 'is'\nComparing: 'is' and 'crucial'\nComparing: 'for' and 'developers'\nComparing: 'is' and 'for'\nComparing: 'the' and 'is'\nComparing: 'of' and 'is'\nLongest word found: is\n"}]}
{"messages": [{"role": "user", "content": "from statistics import mean, median, mode\nfrom math import sqrt\n\ndata = [\n    15, 18, 25, 25, 20, 30, 30, 30, 35, 40, 45, 50, 55, 60, 70, 75, 80, 85, 90,\n    95, 100, 105, 110, 115, 120, 125, 130, 135, 140, 145, 150, 155, 160, 165,\n    170, 175, 180, 185, 190, 195, 200, 205, 210, 215, 220, 225, 230, 235, 240,\n    245, 250, 255, 260, 265, 270, 275, 280, 285, 290, 295, 300, 305, 310, 315,\n    320, 325, 330, 335, 340, 345, 350, 355, 360, 365, 370, 375, 380, 385, 390,\n    395, 400, 405, 410, 415, 420, 425, 430, 435, 440, 445, 450, 455, 460, 465,\n    470, 475, 480, 485, 490, 495, 500\n]\n\ndef binary_search_stats(arr, target):\n    low, high = 0, len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return arr[mid]\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    nearest = arr[min(low, len(arr) - 1)]\n    return nearest\n\nmean_val = mean(data)\nmedian_val = median(data)\nmode_val = mode(data)\nstd_dev = sqrt(sum((x - mean_val) ** 2 for x in data) / len(data))\n\nsearch_values = [mean_val, median_val, mode_val, std_dev]\nresults = [binary_search_stats(data, round(val)) for val in search_values]\n\nprint(\"Data Length:\", len(data))\nprint(\"Mean:\", mean_val)\nprint(\"Median:\", median_val)\nprint(\"Mode:\", mode_val)\nprint(\"Standard Deviation:\", std_dev)\nprint(\"Nearest Values in Data:\")\nprint(\" - Nearest to Mean:\", results[0])\nprint(\" - Nearest to Median:\", results[1])\nprint(\" - Nearest to Mode:\", results[2])\nprint(\" - Nearest to Standard Deviation:\", results[3])"}, {"role": "assistant", "content": "Data Length: 101\nMean: 250.22772277227722\nMedian: 250\nMode: 30\nStandard Deviation: 145.32802644724745\nNearest Values in Data:\n - Nearest to Mean: 250\n - Nearest to Median: 250\n - Nearest to Mode: 30\n - Nearest to Standard Deviation: 145\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef prime_factors(n):\n    factors = []\n    while n % 2 == 0:\n        factors.append(2)\n        n //= 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            factors.append(i)\n            n //= i\n    if n > 2:\n        factors.append(n)\n    return factors\n\ndef generate_pattern(n):\n    pattern = []\n    for i in range(1, n + 1):\n        factors = prime_factors(i)\n        pattern.append((i, factors))\n    return pattern\n\ndef search_pattern(pattern, target):\n    for number, factors in pattern:\n        if set(factors) == set(target):\n            return number\n    return None\n\nn = 50\npattern = generate_pattern(n)\ntarget_factors = [2, 3]\nresult = search_pattern(pattern, target_factors)\n\nfor num, factors in pattern:\n    print(f\"Number: {num}, Prime Factors: {factors}\")\n\nprint(f\"\\nFirst number with prime factors {target_factors} is: {result}\")"}, {"role": "assistant", "content": "Number: 1, Prime Factors: []\nNumber: 2, Prime Factors: [2]\nNumber: 3, Prime Factors: [3]\nNumber: 4, Prime Factors: [2, 2]\nNumber: 5, Prime Factors: [5]\nNumber: 6, Prime Factors: [2, 3]\nNumber: 7, Prime Factors: [7]\nNumber: 8, Prime Factors: [2, 2, 2]\nNumber: 9, Prime Factors: [3, 3]\nNumber: 10, Prime Factors: [2, 5]\nNumber: 11, Prime Factors: [11]\nNumber: 12, Prime Factors: [2, 2, 3]\nNumber: 13, Prime Factors: [13]\nNumber: 14, Prime Factors: [2, 7]\nNumber: 15, Prime Factors: [3, 5]\nNumber: 16, Prime Factors: [2, 2, 2, 2]\nNumber: 17, Prime Factors: [17]\nNumber: 18, Prime Factors: [2, 3, 3]\nNumber: 19, Prime Factors: [19]\nNumber: 20, Prime Factors: [2, 2, 5]\nNumber: 21, Prime Factors: [3, 7]\nNumber: 22, Prime Factors: [2, 11]\nNumber: 23, Prime Factors: [23]\nNumber: 24, Prime Factors: [2, 2, 2, 3]\nNumber: 25, Prime Factors: [5, 5]\nNumber: 26, Prime Factors: [2, 13]\nNumber: 27, Prime Factors: [3, 3, 3]\nNumber: 28, Prime Factors: [2, 2, 7]\nNumber: 29, Prime Factors: [29]\nNumber: 30, Prime Factors: [2, 3, 5]\nNumber: 31, Prime Factors: [31]\nNumber: 32, Prime Factors: [2, 2, 2, 2, 2]\nNumber: 33, Prime Factors: [3, 11]\nNumber: 34, Prime Factors: [2, 17]\nNumber: 35, Prime Factors: [5, 7]\nNumber: 36, Prime Factors: [2, 2, 3, 3]\nNumber: 37, Prime Factors: [37]\nNumber: 38, Prime Factors: [2, 19]\nNumber: 39, Prime Factors: [3, 13]\nNumber: 40, Prime Factors: [2, 2, 2, 5]\nNumber: 41, Prime Factors: [41]\nNumber: 42, Prime Factors: [2, 3, 7]\nNumber: 43, Prime Factors: [43]\nNumber: 44, Prime Factors: [2, 2, 11]\nNumber: 45, Prime Factors: [3, 3, 5]\nNumber: 46, Prime Factors: [2, 23]\nNumber: 47, Prime Factors: [47]\nNumber: 48, Prime Factors: [2, 2, 2, 2, 3]\nNumber: 49, Prime Factors: [7, 7]\nNumber: 50, Prime Factors: [2, 5, 5]\n\nFirst number with prime factors [2, 3] is: 6\n"}]}
{"messages": [{"role": "user", "content": "import datetime\nimport math\n\ndef merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        L = arr[:mid]\n        R = arr[mid:]\n\n        merge_sort(L)\n        merge_sort(R)\n\n        i = j = k = 0\n\n        while i < len(L) and j < len(R):\n            if L[i] < R[j]:\n                arr[k] = L[i]\n                i += 1\n            else:\n                arr[k] = R[j]\n                j += 1\n            k += 1\n\n        while i < len(L):\n            arr[k] = L[i]\n            i += 1\n            k += 1\n\n        while j < len(R):\n            arr[k] = R[j]\n            j += 1\n            k += 1\n\ndef get_day_of_year(date):\n    return date.timetuple().tm_yday\n\ndates = [\n    \"2023-12-31\", \"2023-01-01\", \"2023-07-04\", \"2023-10-31\",\n    \"2023-02-14\", \"2023-11-11\", \"2023-05-01\", \"2023-03-17\",\n    \"2023-08-15\", \"2023-04-01\"\n]\n\nparsed_dates = [datetime.datetime.strptime(date, \"%Y-%m-%d\") for date in dates]\nday_of_year_list = [(date, get_day_of_year(date)) for date in parsed_dates]\n\nprint(\"Before sorting:\")\nfor date, day in day_of_year_list:\n    print(f\"Date: {date.strftime('%Y-%m-%d')}, Day of Year: {day}\")\n\nmerge_sort(day_of_year_list)\n\nprint(\"\\nAfter sorting:\")\nfor date, day in day_of_year_list:\n    print(f\"Date: {date.strftime('%Y-%m-%d')}, Day of Year: {day}\")"}, {"role": "assistant", "content": "Before sorting:\nDate: 2023-12-31, Day of Year: 365\nDate: 2023-01-01, Day of Year: 1\nDate: 2023-07-04, Day of Year: 185\nDate: 2023-10-31, Day of Year: 304\nDate: 2023-02-14, Day of Year: 45\nDate: 2023-11-11, Day of Year: 315\nDate: 2023-05-01, Day of Year: 121\nDate: 2023-03-17, Day of Year: 76\nDate: 2023-08-15, Day of Year: 227\nDate: 2023-04-01, Day of Year: 91\n\nAfter sorting:\nDate: 2023-01-01, Day of Year: 1\nDate: 2023-02-14, Day of Year: 45\nDate: 2023-03-17, Day of Year: 76\nDate: 2023-04-01, Day of Year: 91\nDate: 2023-05-01, Day of Year: 121\nDate: 2023-07-04, Day of Year: 185\nDate: 2023-08-15, Day of Year: 227\nDate: 2023-10-31, Day of Year: 304\nDate: 2023-11-11, Day of Year: 315\nDate: 2023-12-31, Day of Year: 365\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\nfrom string import ascii_lowercase\n\ndef vigenere_encrypt(plaintext, key):\n    shifted_alphabet = lambda shift: ascii_lowercase[shift:] + ascii_lowercase[:shift]\n    key_indices = [ascii_lowercase.index(k) for k in key]\n    ciphertext = ''\n\n    for i, letter in enumerate(plaintext):\n        if letter in ascii_lowercase:\n            shift = key_indices[i % len(key)]\n            alphabet = shifted_alphabet(shift)\n            ciphertext += alphabet[ascii_lowercase.index(letter)]\n        else:\n            ciphertext += letter\n\n    return ciphertext\n\ndef timestamp_key():\n    now = datetime.now()\n    return now.strftime(\"%H%M%S\")\n\ndef encrypt_messages(messages):\n    encrypted_messages = []\n    for message in messages:\n        key = timestamp_key()\n        encrypted_message = vigenere_encrypt(message, key)\n        encrypted_messages.append((key, encrypted_message))\n    return encrypted_messages\n\ndef display_encrypted_messages(encrypted_messages):\n    sorted_messages = sorted(encrypted_messages, key=lambda x: x[0])\n    for key, message in sorted_messages:\n        print(f\"Key: {key}, Encrypted Message: {message}\")\n\nmessages = [\n    \"meeting at noon\", \n    \"launch the rocket\", \n    \"retreat immediately\", \n    \"secure the perimeter\", \n    \"send reinforcements\"\n]\n\nencrypted_messages = encrypt_messages(messages)\ndisplay_encrypted_messages(encrypted_messages)"}, {"role": "assistant", "content": "Traceback (most recent call last):\n  File \"<string>\", line 44, in <module>\n  File \"<string>\", line 27, in encrypt_messages\n  File \"<string>\", line 6, in vigenere_encrypt\n  File \"<string>\", line 6, in <listcomp>\nValueError: substring not found\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndata = [\n    {'date': '2023-01-15', 'value': 10},\n    {'date': '2023-02-25', 'value': 15},\n    {'date': '2023-01-05', 'value': 5},\n    {'date': '2023-03-01', 'value': 12},\n    {'date': '2023-01-20', 'value': 8},\n    {'date': '2023-02-10', 'value': 20},\n    {'date': '2023-03-15', 'value': 25},\n    {'date': '2023-01-10', 'value': 7},\n    {'date': '2023-03-05', 'value': 14},\n    {'date': '2023-02-15', 'value': 18}\n]\n\nsorted_data = sorted(data, key=lambda x: datetime.datetime.strptime(x['date'], '%Y-%m-%d'))\n\nmonthly_averages = {}\nfor entry in sorted_data:\n    month = entry['date'][:7]\n    if month not in monthly_averages:\n        monthly_averages[month] = []\n    monthly_averages[month].append(entry['value'])\n\nsorted_months = sorted(monthly_averages)\nfor month in sorted_months:\n    average = sum(monthly_averages[month]) / len(monthly_averages[month])\n    print(f\"{month}: {average:.2f}\")"}, {"role": "assistant", "content": "2023-01: 7.50\n2023-02: 17.67\n2023-03: 17.00\n"}]}
{"messages": [{"role": "user", "content": "def is_valid_move(board, row, col):\n    return 0 <= row < len(board) and 0 <= col < len(board[0]) and board[row][col] == 0\n\ndef knight_tour_search(board, row, col, move_count, moves):\n    if move_count == len(board) * len(board[0]):\n        return True\n\n    for move in moves:\n        new_row, new_col = row + move[0], col + move[1]\n        if is_valid_move(board, new_row, new_col):\n            board[new_row][new_col] = move_count\n            if knight_tour_search(board, new_row, new_col, move_count + 1, moves):\n                return True\n            board[new_row][new_col] = 0\n\n    return False\n\ndef knight_tour(board_size):\n    board = [[0] * board_size for _ in range(board_size)]\n    moves = [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    board[0][0] = 1\n\n    if knight_tour_search(board, 0, 0, 2, moves):\n        return board\n    else:\n        return None\n\ndef print_board(board):\n    for row in board:\n        print(\" \".join(f\"{col:2}\" for col in row))\n\nsize = 8\nsolution = knight_tour(size)\nif solution:\n    print_board(solution)\nelse:\n    print(\"No solution found\")"}, {"role": "assistant", "content": " 1 38 55 34 31 18  9  0\n56 51 32 37 10 35 30 17\n39  2 49 54 33 28 19  8\n50 57 52 27 36 11 16 29\n63 40  3 48 53 24  7 20\n58 47 60 43 26 21 12 15\n41 62 45  4 23 14 25  6\n46 59 42 61 44  5 22 13\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef encode_message(message, key):\n    encoded = []\n    for i, char in enumerate(message):\n        shift = ord(key[i % len(key)]) - ord('a')\n        encoded_char = chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n        encoded.append(encoded_char)\n    return ''.join(encoded)\n\ndef custom_sort(word):\n    vowels = re.findall(r'[aeiou]', word)\n    consonants = re.findall(r'[^aeiou]', word)\n    vowels.sort()\n    consonants.sort()\n    return ''.join(consonants) + ''.join(vowels)\n\ndef encryption_sort(message):\n    sorted_message = []\n    words = message.split()\n    for word in words:\n        sorted_word = custom_sort(word)\n        sorted_message.append(sorted_word)\n    return ' '.join(sorted_message)\n\ndef main():\n    message = \"this is a secret message that needs encoding\"\n    key = \"complex\"\n    \n    print(f\"Original message: {message}\")\n    encoded_message = encode_message(message.replace(\" \", \"\"), key)\n    print(f\"Encoded message without spaces: {encoded_message}\")\n    \n    encrypted_message = encryption_sort(encoded_message)\n    print(f\"Encrypted & sorted message: {encrypted_message}\")\n    \n    sorted_words = encrypted_message.split()\n    for word in sorted_words:\n        print(word)\n\nmain()"}, {"role": "assistant", "content": "Original message: this is a secret message that needs encoding\nEncoded message without spaces: vvuhtwxusogpxjggepriqjofcpiauszrzhfpu\nEncrypted & sorted message: cffggghhjjppppqrrsstvvwxxzzaeiioouuuu\ncffggghhjjppppqrrsstvvwxxzzaeiioouuuu\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef is_point_in_circle(point, center, radius):\n    return math.dist(point, center) <= radius\n\ndef search_largest_circle(points):\n    max_radius = 0\n    best_center = None\n    for i, center in enumerate(points):\n        min_dist = float('inf')\n        for j, point in enumerate(points):\n            if i != j:\n                dist = math.dist(center, point)\n                if dist < min_dist:\n                    min_dist = dist\n        if min_dist > max_radius:\n            max_radius = min_dist\n            best_center = center\n    return best_center, max_radius\n\npoints = [\n    (0, 0), (1, 1), (2, 2), (3, 3), (5, 0), (0, 5), (4, 4),\n    (6, 1), (1, 6), (7, 7), (8, 2), (3, 8), (9, 9), (10, 10)\n]\n\ncenter, radius = search_largest_circle(points)\nresult_points = [(x, y) for x, y in points if is_point_in_circle((x, y), center, radius)]\n\nprint(f\"Largest Circle Center: {center}\")\nprint(f\"Largest Circle Radius: {radius:.2f}\")\nprint(\"Points inside the circle:\")\nfor point in result_points:\n    print(point)"}, {"role": "assistant", "content": "Largest Circle Center: (7, 7)\nLargest Circle Radius: 2.83\nPoints inside the circle:\n(7, 7)\n(9, 9)\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef generate_dates(start_date, num_days):\n    return [start_date + timedelta(days=i) for i in range(num_days)]\n\ndef linear_search(dates, target):\n    for index, date in enumerate(dates):\n        if date == target:\n            print(f\"Date found at index {index}: {date}\")\n            return index\n    print(\"Date not found in the list.\")\n    return -1\n\ndef binary_search(dates, target):\n    low, high = 0, len(dates) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        print(f\"Checking middle index {mid}: {dates[mid]}\")\n        if dates[mid] < target:\n            low = mid + 1\n        elif dates[mid] > target:\n            high = mid - 1\n        else:\n            print(f\"Date found at index {mid}: {dates[mid]}\")\n            return mid\n    print(\"Date not found in the list.\")\n    return -1\n\nstart_date = datetime(2023, 1, 1)\ndates = generate_dates(start_date, 50)\nsearch_date = datetime(2023, 1, 25)\n\nprint(\"Performing Linear Search:\")\nlinear_search(dates, search_date)\n\nprint(\"\\nPerforming Binary Search:\")\nbinary_search(dates, search_date)"}, {"role": "assistant", "content": "Performing Linear Search:\nDate found at index 24: 2023-01-25 00:00:00\n\nPerforming Binary Search:\nChecking middle index 24: 2023-01-25 00:00:00\nDate found at index 24: 2023-01-25 00:00:00\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"\nOnce upon a time, in a land far away, there was a small village. This village was known for its beautiful gardens and kind people. However, it had one mysterious secret: a hidden treasure buried somewhere in the village.\nMany travelers came to the village in search of this treasure, but none succeeded. They all faced the same problem: the map to the treasure was written in a strange language that no one could decipher.\nOne day, a young girl named Lily decided to take on the challenge. She spent days and nights working on the map, analyzing every symbol and pattern. Finally, she discovered that the key was in the repetition of certain phrases. Excited, she followed the map and found the treasure hidden beneath an old oak tree.\nThe village celebrated her success, and Lily became a legend, remembered for her courage and determination.\n\"\"\"\n\npattern = r'\\b\\w+\\b'\nwords = re.findall(pattern, text.lower())\n\nword_count = {}\nfor word in words:\n    word_count[word] = word_count.get(word, 0) + 1\n\nmax_word = max(word_count, key=word_count.get)\nsearch_word = 'village'\n\nprint(f\"Most frequent word: '{max_word}'\")\nprint(f\"Occurrences of '{search_word}': {word_count.get(search_word, 0)}\")\n\ndef binary_search(arr, x):\n    low, high = 0, len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] < x:\n            low = mid + 1\n        elif arr[mid] > x:\n            high = mid - 1\n        else:\n            return mid\n    return -1\n\nsorted_words = sorted(word_count.keys())\nprint(\"Sorted words list:\")\nfor word in sorted_words:\n    print(word)\n\nsearch_result_index = binary_search(sorted_words, search_word)\nif search_result_index != -1:\n    print(f\"'{search_word}' found at index {search_result_index} in sorted list.\")\nelse:\n    print(f\"'{search_word}' not found in sorted list.\")"}, {"role": "assistant", "content": "Most frequent word: 'the'\nOccurrences of 'village': 5\nSorted words list:\na\nall\nan\nanalyzing\nand\naway\nbeautiful\nbecame\nbeneath\nburied\nbut\ncame\ncelebrated\ncertain\nchallenge\ncould\ncourage\nday\ndays\ndecided\ndecipher\ndetermination\ndiscovered\nevery\nexcited\nfaced\nfar\nfinally\nfollowed\nfor\nfound\ngardens\ngirl\nhad\nher\nhidden\nhowever\nin\nit\nits\nkey\nkind\nknown\nland\nlanguage\nlegend\nlily\nmany\nmap\nmysterious\nnamed\nnights\nno\nnone\noak\nof\nold\non\nonce\none\npattern\npeople\nphrases\nproblem\nremembered\nrepetition\nsame\nsearch\nsecret\nshe\nsmall\nsomewhere\nspent\nstrange\nsucceeded\nsuccess\nsymbol\ntake\nthat\nthe\nthere\nthey\nthis\ntime\nto\ntravelers\ntreasure\ntree\nupon\nvillage\nwas\nworking\nwritten\nyoung\n'village' found at index 89 in sorted list.\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef pseudo_encrypt(text, shift):\n    encrypted = \"\"\n    for char in text:\n        if char.isalpha():\n            shifted = ord(char) + shift\n            if char.islower():\n                if shifted > ord('z'):\n                    shifted -= 26\n                encrypted += chr(shifted)\n            elif char.isupper():\n                if shifted > ord('Z'):\n                    shifted -= 26\n                encrypted += chr(shifted)\n        else:\n            encrypted += char\n    return encrypted\n\ndef search_encryption_pattern(text, pattern):\n    print(f\"Searching for pattern: {pattern}\")\n    matches = re.findall(pattern, text)\n    print(f\"Matches found: {matches}\")\n    return matches\n\ndef main():\n    text = \"The quick brown fox jumps over the lazy dog\"\n    shift = 3\n    encrypted_text = pseudo_encrypt(text, shift)\n    print(f\"Encrypted text: {encrypted_text}\")\n\n    pattern = r'\\b[a-zA-Z]{3}\\b'\n    print(\"Finding 3-letter words in the encrypted text...\")\n    matches = search_encryption_pattern(encrypted_text, pattern)\n\n    print(\"\\nFinal Matches:\")\n    for match in matches:\n        print(match)\n\nif __name__ == \"__main__\":\n    main()"}, {"role": "assistant", "content": "Encrypted text: Wkh txlfn eurzq ira mxpsv ryhu wkh odcb grj\nFinding 3-letter words in the encrypted text...\nSearching for pattern: \\b[a-zA-Z]{3}\\b\nMatches found: ['Wkh', 'ira', 'wkh', 'grj']\n\nFinal Matches:\nWkh\nira\nwkh\ngrj\n"}]}
{"messages": [{"role": "user", "content": "import datetime\nimport math\n\ndata = [\n    {'event': 'A', 'timestamp': '2023-10-01 10:05:00'},\n    {'event': 'B', 'timestamp': '2023-10-01 09:55:00'},\n    {'event': 'C', 'timestamp': '2023-10-01 10:15:00'},\n    {'event': 'D', 'timestamp': '2023-10-01 10:25:00'},\n    {'event': 'E', 'timestamp': '2023-10-01 10:35:00'},\n    {'event': 'F', 'timestamp': '2023-10-01 10:45:00'},\n    {'event': 'G', 'timestamp': '2023-10-01 11:05:00'},\n    {'event': 'H', 'timestamp': '2023-10-01 11:15:00'},\n    {'event': 'I', 'timestamp': '2023-10-01 11:25:00'},\n    {'event': 'J', 'timestamp': '2023-10-01 11:35:00'},\n    {'event': 'K', 'timestamp': '2023-10-01 11:45:00'},\n    {'event': 'L', 'timestamp': '2023-10-01 11:55:00'},\n    {'event': 'M', 'timestamp': '2023-10-01 12:05:00'},\n    {'event': 'N', 'timestamp': '2023-10-01 12:15:00'},\n    {'event': 'O', 'timestamp': '2023-10-01 12:25:00'},\n]\n\nsorted_data = sorted(data, key=lambda x: datetime.datetime.strptime(x['timestamp'], '%Y-%m-%d %H:%M:%S'))\n\ntime_gaps = []\nfor i in range(len(sorted_data) - 1):\n    t1 = datetime.datetime.strptime(sorted_data[i]['timestamp'], '%Y-%m-%d %H:%M:%S')\n    t2 = datetime.datetime.strptime(sorted_data[i + 1]['timestamp'], '%Y-%m-%d %H:%M:%S')\n    gap = (t2 - t1).total_seconds()\n    time_gaps.append(gap)\n\naverage_gap = sum(time_gaps) / len(time_gaps)\n\nnormalized_gaps = [gap / average_gap for gap in time_gaps]\n\nfor i, norm_gap in enumerate(normalized_gaps, start=1):\n    print(f\"Event {sorted_data[i]['event']} follows Event {sorted_data[i-1]['event']} with a normalized gap of {norm_gap:.2f}\")"}, {"role": "assistant", "content": "Event A follows Event B with a normalized gap of 0.93\nEvent C follows Event A with a normalized gap of 0.93\nEvent D follows Event C with a normalized gap of 0.93\nEvent E follows Event D with a normalized gap of 0.93\nEvent F follows Event E with a normalized gap of 0.93\nEvent G follows Event F with a normalized gap of 1.87\nEvent H follows Event G with a normalized gap of 0.93\nEvent I follows Event H with a normalized gap of 0.93\nEvent J follows Event I with a normalized gap of 0.93\nEvent K follows Event J with a normalized gap of 0.93\nEvent L follows Event K with a normalized gap of 0.93\nEvent M follows Event L with a normalized gap of 0.93\nEvent N follows Event M with a normalized gap of 0.93\nEvent O follows Event N with a normalized gap of 0.93\n"}]}
{"messages": [{"role": "user", "content": "from math import sqrt\n\ndef calculate_distance(x1, y1, x2, y2):\n    return sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\ndef score_sorting_algorithm(players):\n    def score_key(player):\n        distance = calculate_distance(player['x'], player['y'], 0, 0)\n        return (player['points'], -distance)\n\n    return sorted(players, key=score_key, reverse=True)\n\nplayers_data = [\n    {'name': 'Alice', 'x': 1, 'y': 1, 'points': 10},\n    {'name': 'Bob', 'x': 2, 'y': 2, 'points': 15},\n    {'name': 'Charlie', 'x': 3, 'y': 3, 'points': 10},\n    {'name': 'David', 'x': 1, 'y': 1, 'points': 15},\n    {'name': 'Eve', 'x': 0, 'y': 0, 'points': 15},\n    {'name': 'Frank', 'x': 2, 'y': 2, 'points': 10},\n    {'name': 'Grace', 'x': 3, 'y': 3, 'points': 20},\n    {'name': 'Heidi', 'x': 0, 'y': 0, 'points': 10},\n    {'name': 'Ivan', 'x': 1, 'y': 1, 'points': 5},\n    {'name': 'Judy', 'x': 2, 'y': 2, 'points': 20}\n]\n\nsorted_players = score_sorting_algorithm(players_data)\n\nfor player in sorted_players:\n    print(f\"Name: {player['name']}, Points: {player['points']}, Position: ({player['x']}, {player['y']})\")"}, {"role": "assistant", "content": "Name: Judy, Points: 20, Position: (2, 2)\nName: Grace, Points: 20, Position: (3, 3)\nName: Eve, Points: 15, Position: (0, 0)\nName: David, Points: 15, Position: (1, 1)\nName: Bob, Points: 15, Position: (2, 2)\nName: Heidi, Points: 10, Position: (0, 0)\nName: Alice, Points: 10, Position: (1, 1)\nName: Frank, Points: 10, Position: (2, 2)\nName: Charlie, Points: 10, Position: (3, 3)\nName: Ivan, Points: 5, Position: (1, 1)\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef encode_message(message, key):\n    encoded_chars = [(ord(char) + key) % 256 for char in message]\n    return encoded_chars\n\ndef decode_message(encoded_chars, key):\n    decoded_chars = [chr((char - key) % 256) for char in encoded_chars]\n    return ''.join(decoded_chars)\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef coprime(key, length):\n    return gcd(key, length) == 1\n\ndef encrypt(text, key):\n    encoded_chars = encode_message(text, key)\n    sorted_chars = sorted(encoded_chars)\n    return sorted_chars\n\ndef decrypt(sorted_chars, key):\n    length = len(sorted_chars)\n    if not coprime(key, length):\n        raise ValueError(\"Key and message length must be coprime\")\n    decoded_chars = sorted_chars.copy()\n    for i in range(length):\n        sorted_index = sorted(range(length), key=lambda k: sorted_chars[k])[i]\n        decoded_chars[sorted_index] = (sorted_chars[i] - key) % 256\n    return decode_message(decoded_chars, key)\n\nmessage = \"Encryption is fun!\"\nkey = 7\n\nencrypted_message = encrypt(message, key)\ndecrypted_message = decrypt(encrypted_message, key)\n\nprint(\"Encrypted:\", encrypted_message)\nprint(\"Decrypted:\", decrypted_message)"}, {"role": "assistant", "content": "Encrypted: [39, 39, 40, 76, 106, 109, 112, 112, 117, 117, 117, 118, 119, 121, 122, 123, 124, 128]\nDecrypted: \u0019\u0019\u001a>\\_bbggghiklmnr\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndates = [\n    \"2023-10-12 14:30\",\n    \"2021-05-23 09:00\",\n    \"2022-12-01 17:45\",\n    \"2020-01-15 12:30\",\n    \"2023-01-01 00:00\",\n    \"2023-06-18 13:15\",\n    \"2024-02-29 11:11\",\n    \"2022-07-04 04:04\",\n    \"2021-11-11 11:11\",\n    \"2023-12-31 23:59\"\n]\n\ndate_objects = [datetime.strptime(date, \"%Y-%m-%d %H:%M\") for date in dates]\n\ndate_with_weekday = [(date, date.strftime(\"%A\")) for date in date_objects]\n\nprint(\"Dates with their weekdays:\")\nfor date, weekday in date_with_weekday:\n    print(date.strftime(\"%Y-%m-%d %H:%M\"), \"-\", weekday)\n\nprint(\"\\nSorting dates by weekdays:\")\nsorted_by_weekday = sorted(date_with_weekday, key=lambda x: x[1])\n\nfor date, weekday in sorted_by_weekday:\n    print(date.strftime(\"%Y-%m-%d %H:%M\"), \"-\", weekday)\n\nprint(\"\\nSorting dates by the closest future date from today:\")\ntoday = datetime.now()\nsorted_by_closest_future = sorted(date_objects, key=lambda date: (date - today).days if date > today else float('inf'))\n\nfor date in sorted_by_closest_future:\n    print(date.strftime(\"%Y-%m-%d %H:%M\"))"}, {"role": "assistant", "content": "Dates with their weekdays:\n2023-10-12 14:30 - Thursday\n2021-05-23 09:00 - Sunday\n2022-12-01 17:45 - Thursday\n2020-01-15 12:30 - Wednesday\n2023-01-01 00:00 - Sunday\n2023-06-18 13:15 - Sunday\n2024-02-29 11:11 - Thursday\n2022-07-04 04:04 - Monday\n2021-11-11 11:11 - Thursday\n2023-12-31 23:59 - Sunday\n\nSorting dates by weekdays:\n2022-07-04 04:04 - Monday\n2021-05-23 09:00 - Sunday\n2023-01-01 00:00 - Sunday\n2023-06-18 13:15 - Sunday\n2023-12-31 23:59 - Sunday\n2023-10-12 14:30 - Thursday\n2022-12-01 17:45 - Thursday\n2024-02-29 11:11 - Thursday\n2021-11-11 11:11 - Thursday\n2020-01-15 12:30 - Wednesday\n\nSorting dates by the closest future date from today:\n2023-10-12 14:30\n2021-05-23 09:00\n2022-12-01 17:45\n2020-01-15 12:30\n2023-01-01 00:00\n2023-06-18 13:15\n2024-02-29 11:11\n2022-07-04 04:04\n2021-11-11 11:11\n2023-12-31 23:59\n"}]}
{"messages": [{"role": "user", "content": "def custom_pattern_sort(arr):\n    def pattern_key(x):\n        str_x = str(x)\n        return sum(ord(c) for c in str_x) % 10, len(str_x)\n\n    return sorted(arr, key=pattern_key)\n\ndef generate_patterns(n):\n    patterns = []\n    for i in range(1, n + 1):\n        pattern = ''\n        for j in range(1, i + 1):\n            pattern += chr(65 + (j % 26))\n        patterns.append(pattern)\n    return patterns\n\ndef main():\n    n = 30\n    patterns = generate_patterns(n)\n    print(\"Generated Patterns:\")\n    for p in patterns:\n        print(p)\n    \n    print(\"\\nSorted Patterns:\")\n    sorted_patterns = custom_pattern_sort(patterns)\n    for p in sorted_patterns:\n        print(p)\n\nmain()"}, {"role": "assistant", "content": "Generated Patterns:\nB\nBC\nBCD\nBCDE\nBCDEF\nBCDEFG\nBCDEFGH\nBCDEFGHI\nBCDEFGHIJ\nBCDEFGHIJK\nBCDEFGHIJKL\nBCDEFGHIJKLM\nBCDEFGHIJKLMN\nBCDEFGHIJKLMNO\nBCDEFGHIJKLMNOP\nBCDEFGHIJKLMNOPQ\nBCDEFGHIJKLMNOPQR\nBCDEFGHIJKLMNOPQRS\nBCDEFGHIJKLMNOPQRST\nBCDEFGHIJKLMNOPQRSTU\nBCDEFGHIJKLMNOPQRSTUV\nBCDEFGHIJKLMNOPQRSTUVW\nBCDEFGHIJKLMNOPQRSTUVWX\nBCDEFGHIJKLMNOPQRSTUVWXY\nBCDEFGHIJKLMNOPQRSTUVWXYZ\nBCDEFGHIJKLMNOPQRSTUVWXYZA\nBCDEFGHIJKLMNOPQRSTUVWXYZAB\nBCDEFGHIJKLMNOPQRSTUVWXYZABC\nBCDEFGHIJKLMNOPQRSTUVWXYZABCD\nBCDEFGHIJKLMNOPQRSTUVWXYZABCDE\n\nSorted Patterns:\nBCDE\nBCDEF\nBCDEFGHIJ\nBCDEFGHIJKLMNOPQRSTU\nBCDEFGHIJKLMNOPQRSTUVWXY\nBCDEFGHIJKLMNOPQRSTUVWXYZ\nBCD\nBCDEFG\nBCDEFGHIJKL\nBCDEFGHIJKLMNOPQRS\nBCDEFGHIJKLMNOPQRSTUVWX\nBCDEFGHIJKLMNOPQRSTUVWXYZAB\nBC\nBCDEFGH\nBCDEFGHIJKLMNOPQRSTUVW\nBCDEFGHIJK\nBCDEFGHIJKLMNO\nBCDEFGHIJKLMNOP\nBCDEFGHIJKLMNOPQRST\nBCDEFGHIJKLMNOPQRSTUVWXYZA\nBCDEFGHIJKLMNOPQRSTUVWXYZABCDE\nB\nBCDEFGHI\nBCDEFGHIJKLMN\nBCDEFGHIJKLMNOPQ\nBCDEFGHIJKLMNOPQRSTUV\nBCDEFGHIJKLMNOPQRSTUVWXYZABCD\nBCDEFGHIJKLM\nBCDEFGHIJKLMNOPQR\nBCDEFGHIJKLMNOPQRSTUVWXYZABC\n"}]}
{"messages": [{"role": "user", "content": "from statistics import mean, stdev\nfrom math import sqrt\n\ndef custom_sort(data, key_func):\n    n = len(data)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if key_func(data[j]) > key_func(data[j+1]):\n                data[j], data[j+1] = data[j+1], data[j]\n\ndef z_score_normalization(data):\n    avg = mean(data)\n    std_dev = stdev(data)\n    return [(x - avg) / std_dev for x in data]\n\ndef euclidean_distance(point1, point2):\n    return sqrt(sum((p1 - p2) ** 2 for p1, p2 in zip(point1, point2)))\n\ndata_points = [(2, 3), (5, 8), (1, 1), (7, 6), (4, 7), (8, 2), (3, 5), (6, 4)]\nnormalized_data = [z_score_normalization(point) for point in zip(*data_points)]\nnormalized_data = list(zip(*normalized_data))\n\ncustom_sort(data_points, lambda p: euclidean_distance(p, normalized_data[0]))\n\nfor point in data_points:\n    print(f\"Point: {point}, Distance: {euclidean_distance(point, normalized_data[0]):.3f}\")"}, {"role": "assistant", "content": "Point: (1, 1), Distance: 2.585\nPoint: (2, 3), Distance: 4.709\nPoint: (3, 5), Distance: 6.904\nPoint: (6, 4), Distance: 8.400\nPoint: (4, 7), Distance: 9.119\nPoint: (8, 2), Distance: 9.391\nPoint: (7, 6), Distance: 10.395\nPoint: (5, 8), Distance: 10.508\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndata = [15, 21, 13, 38, 29, 42, 55, 47, 31, 22, 39, 41, 19, 41, 28, 36, 50, 44, 33, 20]\nmedian_value = statistics.median(data)\n\ndef binary_search_median(arr, target):\n    low, high = 0, len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n\nsorted_data = sorted(data)\nmedian_index = binary_search_median(sorted_data, median_value)\n\nfor i in range(len(sorted_data)):\n    position = \"Median\" if i == median_index else \"Not Median\"\n    print(f\"Value: {sorted_data[i]}, Position: {position}\")"}, {"role": "assistant", "content": "Value: 13, Position: Not Median\nValue: 15, Position: Not Median\nValue: 19, Position: Not Median\nValue: 20, Position: Not Median\nValue: 21, Position: Not Median\nValue: 22, Position: Not Median\nValue: 28, Position: Not Median\nValue: 29, Position: Not Median\nValue: 31, Position: Not Median\nValue: 33, Position: Not Median\nValue: 36, Position: Not Median\nValue: 38, Position: Not Median\nValue: 39, Position: Not Median\nValue: 41, Position: Not Median\nValue: 41, Position: Not Median\nValue: 42, Position: Not Median\nValue: 44, Position: Not Median\nValue: 47, Position: Not Median\nValue: 50, Position: Not Median\nValue: 55, Position: Not Median\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\ndata = [\n    \"2023-02-28 14:22:30\",\n    \"2021-11-11 09:12:03\",\n    \"2020-01-01 00:00:00\",\n    \"2022-08-15 18:45:00\",\n    \"2019-05-25 11:50:45\",\n    \"2021-07-19 14:22:30\",\n    \"2023-02-28 06:30:00\",\n    \"2020-12-31 23:59:59\",\n    \"2022-01-01 12:00:00\",\n    \"2018-01-01 10:10:10\"\n]\n\ndate_objects = [datetime.strptime(date_string, \"%Y-%m-%d %H:%M:%S\") for date_string in data]\nsorted_dates = sorted(date_objects)\n\nfor date in sorted_dates:\n    print(datetime.strftime(date, \"%Y-%m-%d %H:%M:%S\"))"}, {"role": "assistant", "content": "2018-01-01 10:10:10\n2019-05-25 11:50:45\n2020-01-01 00:00:00\n2020-12-31 23:59:59\n2021-07-19 14:22:30\n2021-11-11 09:12:03\n2022-01-01 12:00:00\n2022-08-15 18:45:00\n2023-02-28 06:30:00\n2023-02-28 14:22:30\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef is_valid_date(year, month, day):\n    try:\n        datetime.date(year, month, day)\n        return True\n    except ValueError:\n        return False\n\ndef transform_dates(dates):\n    transformed_dates = []\n    for date_str in dates:\n        year, month, day = map(int, date_str.split('-'))\n        if is_valid_date(year, month, day):\n            new_date = datetime.date(year, month, day) + datetime.timedelta(days=1)\n            transformed_dates.append(new_date.strftime('%Y-%m-%d'))\n    return transformed_dates\n\ndef search_dates(dates, target_date):\n    low, high = 0, len(dates) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if dates[mid] == target_date:\n            return mid\n        elif dates[mid] < target_date:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n\ndate_list = [\n    '2023-01-31', '2023-02-28', '2023-03-31', '2023-04-30',\n    '2023-05-31', '2023-06-30', '2023-07-31', '2023-08-31',\n    '2023-09-30', '2023-10-31', '2023-11-30', '2023-12-31'\n]\n\ntransformed = transform_dates(date_list)\ntarget = '2023-04-01'\nindex = search_dates(transformed, target)\n\nprint(\"\\n\".join(transformed))\nprint(f\"Search for {target}: Index {index}\")"}, {"role": "assistant", "content": "2023-02-01\n2023-03-01\n2023-04-01\n2023-05-01\n2023-06-01\n2023-07-01\n2023-08-01\n2023-09-01\n2023-10-01\n2023-11-01\n2023-12-01\n2024-01-01\nSearch for 2023-04-01: Index 2\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"\nSorting algorithms are powerful tools. They are used to order elements in a list.\nSome common sorting algorithms include bubble sort, quicksort, mergesort, and heapsort.\nHowever, sorting has applications beyond simple numerical or alphabetical ordering.\n\"\"\"\n\ndef word_frequency_sort(text):\n    words = re.findall(r'\\b\\w+\\b', text.lower())\n    frequency = {}\n    for word in words:\n        if word not in frequency:\n            frequency[word] = 0\n        frequency[word] += 1\n\n    sorted_words = sorted(frequency.items(), key=lambda x: (-x[1], x[0]))\n    return sorted_words\n\nsorted_word_frequencies = word_frequency_sort(text)\n\nfor word, freq in sorted_word_frequencies:\n    print(f\"{word}: {freq}\")"}, {"role": "assistant", "content": "sorting: 3\nalgorithms: 2\nare: 2\na: 1\nalphabetical: 1\nand: 1\napplications: 1\nbeyond: 1\nbubble: 1\ncommon: 1\nelements: 1\nhas: 1\nheapsort: 1\nhowever: 1\nin: 1\ninclude: 1\nlist: 1\nmergesort: 1\nnumerical: 1\nor: 1\norder: 1\nordering: 1\npowerful: 1\nquicksort: 1\nsimple: 1\nsome: 1\nsort: 1\nthey: 1\nto: 1\ntools: 1\nused: 1\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef digital_root_sort(sequence):\n    def digital_root(n):\n        return n if n < 10 else digital_root(sum(int(d) for d in str(n)))\n\n    def compare(x, y):\n        root_x = digital_root(x)\n        root_y = digital_root(y)\n        if root_x == root_y:\n            return x - y\n        return root_x - root_y\n\n    def quicksort(arr):\n        if len(arr) <= 1:\n            return arr\n        pivot = arr[len(arr) // 2]\n        left = [x for x in arr if compare(x, pivot) < 0]\n        middle = [x for x in arr if compare(x, pivot) == 0]\n        right = [x for x in arr if compare(x, pivot) > 0]\n        return quicksort(left) + middle + quicksort(right)\n\n    return quicksort(sequence)\n\nnumbers = [45, 28, 19, 37, 99, 76, 55, 82, 63, 8, 14, 66, 31, 49, 72, 91]\nsorted_numbers = digital_root_sort(numbers)\nfor number in sorted_numbers:\n    print(number)"}, {"role": "assistant", "content": "19\n28\n37\n55\n82\n91\n66\n31\n49\n76\n14\n8\n45\n63\n72\n99\n"}]}
{"messages": [{"role": "user", "content": "def is_perfect_square(n):\n    return int(n**0.5)**2 == n\n\ndef generate_fibonacci(limit):\n    sequence = [0, 1]\n    while sequence[-1] + sequence[-2] < limit:\n        sequence.append(sequence[-1] + sequence[-2])\n    return sequence\n\ndef find_perfect_square_fibonacci_numbers(limit):\n    fibonacci_numbers = generate_fibonacci(limit)\n    return [num for num in fibonacci_numbers if is_perfect_square(num)]\n\ndef main():\n    limit = 1000000\n    perfect_square_fib_numbers = find_perfect_square_fibonacci_numbers(limit)\n    for number in perfect_square_fib_numbers:\n        print(number)\n\nmain()"}, {"role": "assistant", "content": "0\n1\n1\n144\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\ndef transform_and_search_dates(date_strings, target_date):\n    def binary_search(dates, target):\n        left, right = 0, len(dates) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            print(f\"Searching between {left} and {right}, mid: {mid}\")\n            if dates[mid] == target:\n                return mid\n            elif dates[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n\n    date_objects = []\n    for date_str in date_strings:\n        try:\n            date_obj = datetime.strptime(date_str, '%Y-%m-%d')\n            date_objects.append(date_obj)\n            print(f\"Transformed {date_str} to {date_obj}\")\n        except ValueError as e:\n            print(f\"Error parsing date string {date_str}: {e}\")\n    \n    date_objects.sort()\n    print(\"Sorted dates:\", date_objects)\n    \n    target_date_obj = datetime.strptime(target_date, '%Y-%m-%d')\n    index = binary_search(date_objects, target_date_obj)\n    print(f\"Index of target date ({target_date}): {index}\")\n    return index\n\ndate_list = [\n    \"2023-10-01\", \"2023-09-15\", \"2023-08-23\", \"2023-11-05\",\n    \"2023-07-19\", \"2023-12-31\", \"2023-01-01\", \"2023-06-30\",\n    \"2023-05-21\", \"2023-03-17\", \"2023-02-14\"\n]\n\nsearch_result = transform_and_search_dates(date_list, \"2023-08-23\")\nprint(\"Search result:\", search_result)"}, {"role": "assistant", "content": "Transformed 2023-10-01 to 2023-10-01 00:00:00\nTransformed 2023-09-15 to 2023-09-15 00:00:00\nTransformed 2023-08-23 to 2023-08-23 00:00:00\nTransformed 2023-11-05 to 2023-11-05 00:00:00\nTransformed 2023-07-19 to 2023-07-19 00:00:00\nTransformed 2023-12-31 to 2023-12-31 00:00:00\nTransformed 2023-01-01 to 2023-01-01 00:00:00\nTransformed 2023-06-30 to 2023-06-30 00:00:00\nTransformed 2023-05-21 to 2023-05-21 00:00:00\nTransformed 2023-03-17 to 2023-03-17 00:00:00\nTransformed 2023-02-14 to 2023-02-14 00:00:00\nSorted dates: [datetime.datetime(2023, 1, 1, 0, 0), datetime.datetime(2023, 2, 14, 0, 0), datetime.datetime(2023, 3, 17, 0, 0), datetime.datetime(2023, 5, 21, 0, 0), datetime.datetime(2023, 6, 30, 0, 0), datetime.datetime(2023, 7, 19, 0, 0), datetime.datetime(2023, 8, 23, 0, 0), datetime.datetime(2023, 9, 15, 0, 0), datetime.datetime(2023, 10, 1, 0, 0), datetime.datetime(2023, 11, 5, 0, 0), datetime.datetime(2023, 12, 31, 0, 0)]\nSearching between 0 and 10, mid: 5\nSearching between 6 and 10, mid: 8\nSearching between 6 and 7, mid: 6\nIndex of target date (2023-08-23): 6\nSearch result: 6\n"}]}
{"messages": [{"role": "user", "content": "from collections import Counter\n\ntext = \"\"\"\nSorting algorithms are a fundamental part of computer science. They are used to arrange data in a particular order, and this can be crucial for tasks such as searching, merging, and organizing information. Text processing often involves sorting, especially when dealing with large datasets or when specific orderings are necessary.\n\"\"\"\n\nwords = text.split()\nword_counts = Counter(words)\nsorted_words = sorted(word_counts.items(), key=lambda x: (-x[1], x[0]))\n\nfor word, count in sorted_words:\n    print(f\"{word}: {count}\")"}, {"role": "assistant", "content": "are: 3\na: 2\nand: 2\nwhen: 2\nSorting: 1\nText: 1\nThey: 1\nalgorithms: 1\narrange: 1\nas: 1\nbe: 1\ncan: 1\ncomputer: 1\ncrucial: 1\ndata: 1\ndatasets: 1\ndealing: 1\nespecially: 1\nfor: 1\nfundamental: 1\nin: 1\ninformation.: 1\ninvolves: 1\nlarge: 1\nmerging,: 1\nnecessary.: 1\nof: 1\noften: 1\nor: 1\norder,: 1\norderings: 1\norganizing: 1\npart: 1\nparticular: 1\nprocessing: 1\nscience.: 1\nsearching,: 1\nsorting,: 1\nspecific: 1\nsuch: 1\ntasks: 1\nthis: 1\nto: 1\nused: 1\nwith: 1\n"}]}
{"messages": [{"role": "user", "content": "def pattern_generator(n):\n    pattern = []\n    for i in range(1, n + 1):\n        pattern.append(\" \".join(str(x) for x in range(1, i + 1)))\n\n    sorted_patterns = sorted(pattern, key=lambda x: (len(x.split()), x))\n    return \"\\n\".join(sorted_patterns)\n\nprint(pattern_generator(10))"}, {"role": "assistant", "content": "1\n1 2\n1 2 3\n1 2 3 4\n1 2 3 4 5\n1 2 3 4 5 6\n1 2 3 4 5 6 7\n1 2 3 4 5 6 7 8\n1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9 10\n"}]}
{"messages": [{"role": "user", "content": "def generate_pattern(n):\n    pattern = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            pattern.append('*' * i)\n        else:\n            pattern.append(' ' * i)\n    return pattern\n\ndef search_pattern(pattern, query):\n    for i, line in enumerate(pattern):\n        if query in line:\n            return i\n    return -1\n\ndef main():\n    n = 20\n    query = '**'\n    pattern = generate_pattern(n)\n    result_index = search_pattern(pattern, query)\n    for index, line in enumerate(pattern):\n        if index != result_index:\n            print(line)\n\nmain()"}, {"role": "assistant", "content": " \n   \n****\n     \n******\n       \n********\n         \n**********\n           \n************\n             \n**************\n               \n****************\n                 \n******************\n                   \n********************\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\ndef perimeter(points):\n    return sum(distance(points[i], points[i + 1]) for i in range(-1, len(points) - 1))\n\ndef convex_hull(points):\n    points = sorted(set(points))\n    if len(points) <= 1:\n        return points\n\n    def cross(o, a, b):\n        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\n    lower = []\n    for p in points:\n        while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:\n            lower.pop()\n        lower.append(p)\n\n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:\n            upper.pop()\n        upper.append(p)\n\n    return lower[:-1] + upper[:-1]\n\ndef main():\n    points = [\n        (1, 1), (2, 5), (3, 3), (5, 3), (3, 1), (0, 0),\n        (5, 5), (4, 0), (1, 4), (2, 2), (4, 4), (3, 0)\n    ]\n    \n    hull = convex_hull(points)\n    hull_perimeter = perimeter(hull)\n    formatted_hull = [f\"({p[0]}, {p[1]})\" for p in hull]\n    \n    print(\"Convex Hull Points:\")\n    for point in formatted_hull:\n        print(point)\n    \n    print(f\"\\nPerimeter of Convex Hull: {hull_perimeter:.2f}\")\n\nmain()"}, {"role": "assistant", "content": "Convex Hull Points:\n(0, 0)\n(4, 0)\n(5, 3)\n(5, 5)\n(2, 5)\n(1, 4)\n\nPerimeter of Convex Hull: 17.70\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef is_point_inside_polygon(x, y, poly):\n    n = len(poly)\n    inside = False\n    p1x, p1y = poly[0]\n    for i in range(n + 1):\n        p2x, p2y = poly[i % n]\n        if y > min(p1y, p2y):\n            if y <= max(p1y, p2y):\n                if x <= max(p1x, p2x):\n                    if p1y != p2y:\n                        xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x\n                    if p1x == p2x or x <= xinters:\n                        inside = not inside\n        p1x, p1y = p2x, p2y\n    return inside\n\ndef find_largest_empty_circle(polygon):\n    min_x = min(p[0] for p in polygon)\n    max_x = max(p[0] for p in polygon)\n    min_y = min(p[1] for p in polygon)\n    max_y = max(p[1] for p in polygon)\n    \n    radius = 0\n    center = (0, 0)\n\n    for i in range(100):\n        for j in range(100):\n            x = min_x + (max_x - min_x) * i / 100\n            y = min_y + (max_y - min_y) * j / 100\n            if is_point_inside_polygon(x, y, polygon):\n                dist = min(math.hypot(x - px, y - py) for px, py in polygon)\n                if dist > radius:\n                    radius = dist\n                    center = (x, y)\n\n    return center, radius\n\nhexagon = [\n    (1, 1), (5, 1), (6, 3),\n    (5, 5), (1, 5), (0, 3)\n]\n\ncenter, radius = find_largest_empty_circle(hexagon)\nfor x in range(-1, 8):\n    for y in range(-1, 8):\n        if is_point_inside_polygon(x, y, hexagon):\n            if math.isclose(math.hypot(x - center[0], y - center[1]), radius, rel_tol=1e-1):\n                print(\"o\", end=\"\")\n            else:\n                print(\".\", end=\"\")\n        else:\n            print(\" \", end=\"\")\n    print()"}, {"role": "assistant", "content": "         \n         \n   ...   \n   ....  \n   ....  \n   ....  \n   ...o  \n    o    \n         \n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef find_longest_word(text):\n    words = re.findall(r'\\b\\w+\\b', text)\n    longest_word = max(words, key=len)\n    return longest_word\n\ndef search_texts(texts):\n    longest_words = [find_longest_word(text) for text in texts]\n    sorted_unique_words = sorted(set(longest_words), key=len, reverse=True)\n    return sorted_unique_words\n\ntexts = [\n    \"The quick brown fox jumps over the lazy dog.\",\n    \"Python programming is both fun and educational.\",\n    \"Artificial intelligence is transforming the world.\",\n    \"Data science involves statistics, data analysis and machine learning.\",\n    \"Understanding algorithms is essential for effective programming.\",\n    \"The Internet of Things connects devices around the world.\",\n    \"Natural language processing enables computers to understand human language.\",\n    \"Cybersecurity is crucial for protecting sensitive information.\",\n    \"Quantum computing has the potential to solve complex problems.\",\n    \"Augmented reality enhances the real world with digital information.\"\n]\n\nresult = search_texts(texts)\nfor word in result:\n    print(word)"}, {"role": "assistant", "content": "Cybersecurity\nUnderstanding\nintelligence\ninformation\nprogramming\nprocessing\nstatistics\ncomputing\nInternet\nquick\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndata = [22, 31, 38, 41, 47, 53, 58, 62, 69, 73, 78, 83, 88, 92, 97, 101, 105, 110, 115, 120]\n\ndef binary_search_mean(data):\n    mean_value = statistics.mean(data)\n    low, high = 0, len(data) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if data[mid] < mean_value:\n            low = mid + 1\n        elif data[mid] > mean_value:\n            high = mid - 1\n        else:\n            return mid, data[mid]\n    return low, data[low] if low < len(data) else None\n\nindex, value = binary_search_mean(data)\nprint(f\"Mean of data: {statistics.mean(data):.2f}\")\nprint(f\"Closest value in data to mean: {value} at index {index}\")"}, {"role": "assistant", "content": "Mean of data: 74.15\nClosest value in data to mean: 78 at index 10\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef merge_sort_dates(dates):\n    if len(dates) > 1:\n        mid = len(dates) // 2\n        left_half = dates[:mid]\n        right_half = dates[mid:]\n\n        merge_sort_dates(left_half)\n        merge_sort_dates(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] > right_half[j]:\n                dates[k] = left_half[i]\n                i += 1\n            else:\n                dates[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            dates[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            dates[k] = right_half[j]\n            j += 1\n            k += 1\n\ndef generate_dates(start_date, days):\n    return [start_date + timedelta(days=i * 3) for i in range(days)]\n\nstart_date = datetime(2023, 10, 1)\ndate_sequence = generate_dates(start_date, 50)\nprint(\"Generated Dates:\")\nfor date in date_sequence:\n    print(date.strftime('%Y-%m-%d'))\n\nprint(\"\\nSorting Dates Descending:\")\nmerge_sort_dates(date_sequence)\nfor date in date_sequence:\n    print(date.strftime('%Y-%m-%d'))"}, {"role": "assistant", "content": "Generated Dates:\n2023-10-01\n2023-10-04\n2023-10-07\n2023-10-10\n2023-10-13\n2023-10-16\n2023-10-19\n2023-10-22\n2023-10-25\n2023-10-28\n2023-10-31\n2023-11-03\n2023-11-06\n2023-11-09\n2023-11-12\n2023-11-15\n2023-11-18\n2023-11-21\n2023-11-24\n2023-11-27\n2023-11-30\n2023-12-03\n2023-12-06\n2023-12-09\n2023-12-12\n2023-12-15\n2023-12-18\n2023-12-21\n2023-12-24\n2023-12-27\n2023-12-30\n2024-01-02\n2024-01-05\n2024-01-08\n2024-01-11\n2024-01-14\n2024-01-17\n2024-01-20\n2024-01-23\n2024-01-26\n2024-01-29\n2024-02-01\n2024-02-04\n2024-02-07\n2024-02-10\n2024-02-13\n2024-02-16\n2024-02-19\n2024-02-22\n2024-02-25\n\nSorting Dates Descending:\n2024-02-25\n2024-02-22\n2024-02-19\n2024-02-16\n2024-02-13\n2024-02-10\n2024-02-07\n2024-02-04\n2024-02-01\n2024-01-29\n2024-01-26\n2024-01-23\n2024-01-20\n2024-01-17\n2024-01-14\n2024-01-11\n2024-01-08\n2024-01-05\n2024-01-02\n2023-12-30\n2023-12-27\n2023-12-24\n2023-12-21\n2023-12-18\n2023-12-15\n2023-12-12\n2023-12-09\n2023-12-06\n2023-12-03\n2023-11-30\n2023-11-27\n2023-11-24\n2023-11-21\n2023-11-18\n2023-11-15\n2023-11-12\n2023-11-09\n2023-11-06\n2023-11-03\n2023-10-31\n2023-10-28\n2023-10-25\n2023-10-22\n2023-10-19\n2023-10-16\n2023-10-13\n2023-10-10\n2023-10-07\n2023-10-04\n2023-10-01\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\nimport math\n\ndef parse_dates(date_strings):\n    return [datetime.strptime(date_str, \"%Y-%m-%d\") for date_str in date_strings]\n\ndef find_closest_date(target_date, date_list):\n    low, high = 0, len(date_list) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        mid_date = date_list[mid]\n        print(f\"Checking date: {mid_date.strftime('%Y-%m-%d')} at index {mid}\")\n        if mid_date < target_date:\n            low = mid + 1\n        elif mid_date > target_date:\n            high = mid - 1\n        else:\n            return mid_date\n    closest_date = date_list[low] if low < len(date_list) and (low == 0 or abs((target_date - date_list[low]).days) < abs((target_date - date_list[high]).days)) else date_list[high]\n    print(f\"Closest date found: {closest_date.strftime('%Y-%m-%d')}\")\n    return closest_date\n\ndate_strings = [\n    \"2023-01-01\", \"2023-02-14\", \"2023-03-15\", \"2023-05-21\",\n    \"2023-06-30\", \"2023-08-01\", \"2023-09-10\", \"2023-10-31\",\n    \"2023-12-25\"\n]\n\ndates = parse_dates(date_strings)\ntarget_date = datetime(2023, 7, 15)\nclosest_date = find_closest_date(target_date, dates)\n\nprint(\"\\nAll dates:\")\nfor date in dates:\n    print(date.strftime('%Y-%m-%d'))\n\nprint(f\"\\nTarget Date: {target_date.strftime('%Y-%m-%d')}\")\nprint(f\"Closest Date: {closest_date.strftime('%Y-%m-%d')}\")"}, {"role": "assistant", "content": "Checking date: 2023-06-30 at index 4\nChecking date: 2023-09-10 at index 6\nChecking date: 2023-08-01 at index 5\nClosest date found: 2023-06-30\n\nAll dates:\n2023-01-01\n2023-02-14\n2023-03-15\n2023-05-21\n2023-06-30\n2023-08-01\n2023-09-10\n2023-10-31\n2023-12-25\n\nTarget Date: 2023-07-15\nClosest Date: 2023-06-30\n"}]}
{"messages": [{"role": "user", "content": "def treasure_hunt(grid):\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    start = (0, 0)\n    treasure = 'X'\n    queue = [start]\n    visited = set()\n    path = []\n\n    while queue:\n        current = queue.pop(0)\n        if current in visited:\n            continue\n        visited.add(current)\n        path.append(current)\n\n        if grid[current[0]][current[1]] == treasure:\n            break\n\n        for d in directions:\n            new_row = current[0] + d[0]\n            new_col = current[1] + d[1]\n            if (0 <= new_row < len(grid)) and (0 <= new_col < len(grid[0])):\n                queue.append((new_row, new_col))\n\n    return path\n\ngrid = [\n    [' ', ' ', ' ', ' ', ' ', 'X'],\n    [' ', ' ', ' ', ' ', ' ', ' '],\n    [' ', ' ', ' ', ' ', ' ', ' '],\n    [' ', ' ', ' ', ' ', ' ', ' '],\n    [' ', ' ', ' ', ' ', ' ', ' '],\n    [' ', ' ', ' ', ' ', ' ', ' ']\n]\n\npath = treasure_hunt(grid)\nfor step in path:\n    print(step)"}, {"role": "assistant", "content": "(0, 0)\n(0, 1)\n(1, 0)\n(0, 2)\n(1, 1)\n(2, 0)\n(0, 3)\n(1, 2)\n(2, 1)\n(3, 0)\n(0, 4)\n(1, 3)\n(2, 2)\n(3, 1)\n(4, 0)\n(0, 5)\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndates = [\n    \"2023-02-01 14:00:00\",\n    \"2023-02-05 09:30:00\",\n    \"2023-01-20 12:45:00\",\n    \"2023-02-10 16:00:00\",\n    \"2023-01-15 18:00:00\",\n    \"2023-02-07 08:00:00\",\n    \"2023-01-30 14:30:00\",\n    \"2023-02-03 10:00:00\",\n    \"2023-02-02 11:00:00\",\n    \"2023-01-25 17:00:00\",\n]\n\ndate_objects = [datetime.strptime(date, \"%Y-%m-%d %H:%M:%S\") for date in dates]\n\nsorted_dates = sorted(date_objects)\n\nweekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n\noutput = []\n\nfor date in sorted_dates:\n    if date.weekday() < 5:  # Weekdays only\n        output.append(f\"{date.strftime('%Y-%m-%d %H:%M:%S')} ({weekdays[date.weekday()]})\")\n\nfor i in range(len(output) - 1):\n    day_diff = (output[i + 1], (sorted_dates[i + 1] - sorted_dates[i]).days)\n    output[i] = (output[i], day_diff)\n\noutput.pop()\n\noutput.sort(key=lambda x: x[1][1], reverse=True)\n\nfor entry in output:\n    print(f\"Date: {entry[0]}, Next Date: {entry[1][0]}, Days until next: {entry[1][1]}\")"}, {"role": "assistant", "content": "Date: 2023-01-25 17:00:00 (Wednesday), Next Date: 2023-01-30 14:30:00 (Monday), Days until next: 5\nDate: 2023-01-20 12:45:00 (Friday), Next Date: 2023-01-25 17:00:00 (Wednesday), Days until next: 4\nDate: 2023-01-30 14:30:00 (Monday), Next Date: 2023-02-01 14:00:00 (Wednesday), Days until next: 4\nDate: 2023-02-01 14:00:00 (Wednesday), Next Date: 2023-02-02 11:00:00 (Thursday), Days until next: 1\nDate: 2023-02-07 08:00:00 (Tuesday), Next Date: 2023-02-10 16:00:00 (Friday), Days until next: 1\nDate: 2023-02-02 11:00:00 (Thursday), Next Date: 2023-02-03 10:00:00 (Friday), Days until next: 0\nDate: 2023-02-03 10:00:00 (Friday), Next Date: 2023-02-07 08:00:00 (Tuesday), Days until next: 0\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef encode_message(message, shift):\n    encoded = []\n    for char in message:\n        if char.isalpha():\n            shift_amount = 65 if char.isupper() else 97\n            encoded_char = chr((ord(char) + shift - shift_amount) % 26 + shift_amount)\n            encoded.append(encoded_char)\n        else:\n            encoded.append(char)\n    return ''.join(encoded)\n\ndef decode_message(encoded_message, shift):\n    decoded = []\n    for char in encoded_message:\n        if char.isalpha():\n            shift_amount = 65 if char.isupper() else 97\n            decoded_char = chr((ord(char) - shift - shift_amount) % 26 + shift_amount)\n            decoded.append(decoded_char)\n        else:\n            decoded.append(char)\n    return ''.join(decoded)\n\ndef find_shift(encoded_message, keyword):\n    for shift in range(1, 26):\n        decoded = decode_message(encoded_message, shift)\n        if keyword in decoded:\n            return shift, decoded\n    return None, None\n\noriginal_message = \"The quick brown fox jumps over the lazy dog\"\nkeyword = \"quick\"\nshift = 5\n\nencoded_message = encode_message(original_message, shift)\nprint(f\"Encoded Message: {encoded_message}\")\n\nfound_shift, decoded_message = find_shift(encoded_message, keyword)\nif found_shift:\n    print(f\"Found Shift: {found_shift}\")\n    print(f\"Decoded Message: {decoded_message}\")\nelse:\n    print(\"No valid shift found.\")\n\nencoded_message_with_noise = re.sub(r'[aeiou]', '*', encoded_message)\nprint(f\"Encoded Message With Noise: {encoded_message_with_noise}\")\n\nfound_shift_with_noise, decoded_message_with_noise = find_shift(encoded_message_with_noise, keyword)\nif found_shift_with_noise:\n    print(f\"Found Shift With Noise: {found_shift_with_noise}\")\n    print(f\"Decoded Message With Noise: {decoded_message_with_noise}\")\nelse:\n    print(\"No valid shift found with noise.\")"}, {"role": "assistant", "content": "Encoded Message: Ymj vznhp gwtbs ktc ozrux tajw ymj qfed itl\nFound Shift: 5\nDecoded Message: The quick brown fox jumps over the lazy dog\nEncoded Message With Noise: Ymj vznhp gwtbs ktc *zr*x t*jw ymj qf*d *tl\nFound Shift With Noise: 5\nDecoded Message With Noise: The quick brown fox *um*s o*er the la*y *og\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef perimeter_of_polygon(vertices):\n    perimeter = 0\n    for i in range(len(vertices)):\n        j = (i + 1) % len(vertices)\n        dx = vertices[j][0] - vertices[i][0]\n        dy = vertices[j][1] - vertices[i][1]\n        perimeter += math.sqrt(dx * dx + dy * dy)\n    return perimeter\n\npolygons = [\n    [(1, 2), (3, 4), (5, 0), (4, -2)],\n    [(0, 0), (0, 2), (2, 2), (2, 0)],\n    [(2, 1), (4, 5), (7, 8), (6, 3)],\n    [(0, 0), (3, 0), (3, 4)],\n    [(1, 1), (1, 4), (5, 1)],\n    [(0, 0), (1, 1), (0, 2), (-1, 1)]\n]\n\nperimeters = [(polygon, perimeter_of_polygon(polygon)) for polygon in polygons]\nsorted_polygons = sorted(perimeters, key=lambda x: x[1])\n\nfor idx, (polygon, perim) in enumerate(sorted_polygons, 1):\n    print(f\"Polygon {idx}:\")\n    for vertex in polygon:\n        print(vertex)\n    print(f\"Perimeter: {perim:.2f}\\n\")"}, {"role": "assistant", "content": "Polygon 1:\n(0, 0)\n(1, 1)\n(0, 2)\n(-1, 1)\nPerimeter: 5.66\n\nPolygon 2:\n(0, 0)\n(0, 2)\n(2, 2)\n(2, 0)\nPerimeter: 8.00\n\nPolygon 3:\n(0, 0)\n(3, 0)\n(3, 4)\nPerimeter: 12.00\n\nPolygon 4:\n(1, 1)\n(1, 4)\n(5, 1)\nPerimeter: 12.00\n\nPolygon 5:\n(1, 2)\n(3, 4)\n(5, 0)\n(4, -2)\nPerimeter: 14.54\n\nPolygon 6:\n(2, 1)\n(4, 5)\n(7, 8)\n(6, 3)\nPerimeter: 18.29\n\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndates = [\n    \"2023-04-15 10:00:00\",\n    \"2022-09-01 09:30:00\",\n    \"2023-01-05 11:15:00\",\n    \"2023-06-20 14:45:00\",\n    \"2023-03-18 18:30:00\",\n    \"2022-12-25 22:00:00\",\n    \"2023-07-04 08:15:00\",\n    \"2023-08-19 20:30:00\",\n    \"2023-05-01 07:00:00\",\n    \"2023-11-11 23:45:00\",\n]\n\ndate_objects = [datetime.strptime(date, \"%Y-%m-%d %H:%M:%S\") for date in dates]\n\nsorted_dates = sorted(date_objects, key=lambda x: (x.month, x.day, x.hour))\n\ncurrent_date = datetime.now()\n\nfor date in sorted_dates:\n    days_difference = (date - current_date).days\n    formatted_date = date.strftime(\"%Y-%m-%d %H:%M:%S\")\n    if days_difference >= 0:\n        print(f\"{formatted_date} is in the future, {days_difference} days away.\")\n    else:\n        print(f\"{formatted_date} is in the past, {-days_difference} days ago.\")"}, {"role": "assistant", "content": "2023-01-05 11:15:00 is in the past, 818 days ago.\n2023-03-18 18:30:00 is in the past, 745 days ago.\n2023-04-15 10:00:00 is in the past, 718 days ago.\n2023-05-01 07:00:00 is in the past, 702 days ago.\n2023-06-20 14:45:00 is in the past, 652 days ago.\n2023-07-04 08:15:00 is in the past, 638 days ago.\n2023-08-19 20:30:00 is in the past, 591 days ago.\n2022-09-01 09:30:00 is in the past, 944 days ago.\n2023-11-11 23:45:00 is in the past, 507 days ago.\n2022-12-25 22:00:00 is in the past, 828 days ago.\n"}]}
{"messages": [{"role": "user", "content": "from math import cos, sin, pi\n\ndef generate_pattern(size):\n    pattern = []\n    for i in range(size):\n        row = []\n        for j in range(size):\n            angle = 2 * pi * (i * j) / size\n            value = int((cos(angle) + sin(angle)) * 10)\n            row.append(value)\n        pattern.append(row)\n    return pattern\n\ndef search_pattern(pattern, target):\n    for i, row in enumerate(pattern):\n        for j, value in enumerate(row):\n            if value == target:\n                print(f'Found target {target} at position ({i}, {j})')\n                return (i, j)\n    print(f'Target {target} not found')\n    return None\n\nsize = 20\npattern = generate_pattern(size)\n\nfor i, row in enumerate(pattern):\n    print(f'Row {i}: {row}')\n\nsearch_target = 5\nprint(f'Searching for target: {search_target}')\nposition = search_pattern(pattern, search_target)\n\nif position:\n    print(f'Target {search_target} found at {position}')\nelse:\n    print(f'Target {search_target} not found in the pattern')"}, {"role": "assistant", "content": "Row 0: [10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10]\nRow 1: [10, 12, 13, 13, 12, 10, 6, 2, -2, -6, -9, -12, -13, -13, -12, -10, -6, -2, 2, 6]\nRow 2: [10, 13, 12, 6, -2, -9, -13, -12, -6, 2, 9, 13, 12, 6, -2, -9, -13, -12, -6, 2]\nRow 3: [10, 13, 6, -6, -13, -10, 2, 12, 12, 2, -9, -13, -6, 6, 13, 10, -2, -12, -12, -2]\nRow 4: [10, 12, -2, -13, -6, 9, 12, -2, -13, -6, 9, 12, -2, -13, -6, 9, 12, -2, -13, -6]\nRow 5: [10, 10, -9, -10, 9, 10, -9, -10, 9, 10, -9, -9, 9, 10, -9, -10, 9, 9, -9, -9]\nRow 6: [10, 6, -13, 2, 12, -9, -6, 13, -2, -12, 9, 6, -13, 2, 12, -9, -6, 13, -2, -12]\nRow 7: [10, 2, -12, 12, -2, -10, 13, -6, -6, 13, -9, -2, 12, -12, 2, 9, -13, 6, 6, -13]\nRow 8: [10, -2, -6, 12, -13, 9, -2, -6, 12, -13, 9, -2, -6, 12, -13, 9, -2, -6, 12, -13]\nRow 9: [10, -6, 2, 2, -6, 10, -12, 13, -13, 12, -9, 6, -2, -2, 6, -10, 12, -13, 13, -12]\nRow 10: [10, -9, 9, -9, 9, -9, 9, -9, 9, -9, 9, -10, 9, -9, 9, -9, 9, -10, 9, -10]\nRow 11: [10, -12, 13, -13, 12, -9, 6, -2, -2, 6, -10, 12, -13, 13, -12, 10, -6, 2, 2, -6]\nRow 12: [10, -13, 12, -6, -2, 9, -13, 12, -6, -2, 9, -13, 12, -6, -2, 9, -13, 12, -6, -2]\nRow 13: [10, -13, 6, 6, -13, 10, 2, -12, 12, -2, -9, 13, -6, -6, 13, -10, -2, 12, -12, 2]\nRow 14: [10, -12, -2, 13, -6, -9, 12, 2, -13, 6, 9, -12, -2, 13, -6, -10, 12, 2, -13, 6]\nRow 15: [10, -10, -9, 10, 9, -10, -9, 9, 9, -10, -9, 10, 9, -10, -10, 10, 9, -10, -9, 9]\nRow 16: [10, -6, -13, -2, 12, 9, -6, -13, -2, 12, 9, -6, -13, -2, 12, 9, -6, -13, -2, 12]\nRow 17: [10, -2, -12, -12, -2, 9, 13, 6, -6, -13, -10, 2, 12, 12, 2, -10, -13, -6, 6, 13]\nRow 18: [10, 2, -6, -12, -13, -9, -2, 6, 12, 13, 9, 2, -6, -12, -13, -9, -2, 6, 12, 13]\nRow 19: [10, 6, 2, -2, -6, -9, -12, -13, -13, -12, -10, -6, -2, 2, 6, 9, 12, 13, 13, 12]\nSearching for target: 5\nTarget 5 not found\nTarget 5 not found in the pattern\n"}]}
{"messages": [{"role": "user", "content": "def sort_players_by_score(players):\n    return sorted(players, key=lambda x: x[1])\n\nplayers = [\n    (\"Alice\", 500),\n    (\"Bob\", 300),\n    (\"Charlie\", 400),\n    (\"David\", 200),\n    (\"Eve\", 600),\n    (\"Frank\", 100),\n    (\"Grace\", 700),\n    (\"Heidi\", 800),\n    (\"Ivan\", 900),\n    (\"Judy\", 1000)\n]\n\nsorted_players = sort_players_by_score(players)\n\nfor player, score in sorted_players:\n    print(f\"{player}: {score}\")"}, {"role": "assistant", "content": "Frank: 100\nDavid: 200\nBob: 300\nCharlie: 400\nAlice: 500\nEve: 600\nGrace: 700\nHeidi: 800\nIvan: 900\nJudy: 1000\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef is_perfect_square(x):\n    s = int(math.sqrt(x))\n    return s * s == x\n\ndef generate_fib_sequence(n):\n    fib_sequence = [0, 1]\n    while len(fib_sequence) < n:\n        fib_sequence.append(fib_sequence[-1] + fib_sequence[-2])\n    return fib_sequence\n\ndef find_special_numbers(sequence):\n    special_numbers = []\n    for num in sequence:\n        if is_perfect_square(num):\n            special_numbers.append(num)\n    return special_numbers\n\nn = 100\nfib_sequence = generate_fib_sequence(n)\nspecial_numbers = find_special_numbers(fib_sequence)\n\nfor number in special_numbers:\n    print(number)"}, {"role": "assistant", "content": "0\n1\n1\n144\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\ndef parse_dates(date_strings):\n    return [datetime.strptime(date, \"%Y-%m-%d\") for date in date_strings]\n\ndef sort_dates_chronologically(dates):\n    return sorted(dates, key=lambda x: x.month)\n\ndate_strings = [\n    \"2023-07-25\", \"2022-05-14\", \"2021-12-30\", \"2023-01-01\",\n    \"2022-11-11\", \"2021-06-22\", \"2023-04-18\", \"2022-09-09\",\n    \"2021-08-26\", \"2023-02-10\", \"2022-03-03\", \"2021-07-15\",\n    \"2023-10-05\", \"2022-02-20\", \"2021-01-31\", \"2023-12-15\",\n    \"2022-08-08\", \"2021-11-19\", \"2023-03-09\", \"2022-06-06\"\n]\n\nparsed_dates = parse_dates(date_strings)\nsorted_dates = sort_dates_chronologically(parsed_dates)\n\nfor date in sorted_dates:\n    print(date.strftime(\"%Y-%m-%d\"))"}, {"role": "assistant", "content": "2023-01-01\n2021-01-31\n2023-02-10\n2022-02-20\n2022-03-03\n2023-03-09\n2023-04-18\n2022-05-14\n2021-06-22\n2022-06-06\n2023-07-25\n2021-07-15\n2021-08-26\n2022-08-08\n2022-09-09\n2023-10-05\n2022-11-11\n2021-11-19\n2021-12-30\n2023-12-15\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef find_median_of_means(data, window_size):\n    means = []\n    for i in range(len(data) - window_size + 1):\n        window = data[i:i + window_size]\n        mean = statistics.mean(window)\n        means.append(mean)\n        print(f\"Window {window} -> Mean: {mean}\")\n    \n    print(f\"All window means: {means}\")\n    \n    median = statistics.mean(means)  # This line contains an error: should use median instead of mean\n    print(f\"Calculated median of means: {median}\")\n    return median\n\ndata_series = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25]\nwindow_size = 3\n\nresult = find_median_of_means(data_series, window_size)\nprint(f\"Final median of means: {result}\")"}, {"role": "assistant", "content": "Window [1, 3, 5] -> Mean: 3\nWindow [3, 5, 7] -> Mean: 5\nWindow [5, 7, 9] -> Mean: 7\nWindow [7, 9, 11] -> Mean: 9\nWindow [9, 11, 13] -> Mean: 11\nWindow [11, 13, 15] -> Mean: 13\nWindow [13, 15, 17] -> Mean: 15\nWindow [15, 17, 19] -> Mean: 17\nWindow [17, 19, 21] -> Mean: 19\nWindow [19, 21, 23] -> Mean: 21\nWindow [21, 23, 25] -> Mean: 23\nAll window means: [3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23]\nCalculated median of means: 13\nFinal median of means: 13\n"}]}
{"messages": [{"role": "user", "content": "import math\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def distance(self, other):\n        return math.sqrt((self.x - other.x) ** 2 + (self.y - other.y) ** 2)\n\nclass Polygon:\n    def __init__(self, vertices):\n        self.vertices = vertices\n\n    def perimeter(self):\n        return sum(self.vertices[i].distance(self.vertices[(i + 1) % len(self.vertices)]) for i in range(len(self.vertices)))\n\ndef angle_sort_key(point, center):\n    return math.atan2(point.y - center.y, point.x - center.x)\n\ndef convex_hull(points):\n    points = sorted(points, key=lambda p: (p.x, p.y))\n    lower = []\n    for p in points:\n        while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:\n            lower.pop()\n        lower.append(p)\n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:\n            upper.pop()\n        upper.append(p)\n    return lower[:-1] + upper[:-1]\n\ndef cross(o, a, b):\n    return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x)\n\npoints = [\n    Point(0, 0), Point(1, 1), Point(2, 2), Point(3, 1), Point(0, 3),\n    Point(3, 3), Point(1, 2), Point(2, 0), Point(1, 0), Point(2, 3),\n    Point(3, 0), Point(0, 1), Point(0, 2), Point(3, 2), Point(1, 3)\n]\n\nhull_points = convex_hull(points)\ncenter = Point(sum(p.x for p in hull_points) / len(hull_points), sum(p.y for p in hull_points) / len(hull_points))\nsorted_hull_points = sorted(hull_points, key=lambda p: angle_sort_key(p, center))\n\npolygon = Polygon(sorted_hull_points)\nprint(f\"Convex Hull Perimeter: {polygon.perimeter():.2f}\")\nfor p in sorted_hull_points:\n    print(f\"Point({p.x}, {p.y})\")"}, {"role": "assistant", "content": "Convex Hull Perimeter: 12.00\nPoint(0, 0)\nPoint(3, 0)\nPoint(3, 3)\nPoint(0, 3)\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef create_points(n):\n    angle_increment = 2 * math.pi / n\n    points = [(math.cos(i * angle_increment), math.sin(i * angle_increment)) for i in range(n)]\n    return points\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef closest_pair(points):\n    if len(points) < 2:\n        return float('inf'), None, None\n    min_dist = float('inf')\n    p1, p2 = None, None\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            d = distance(points[i], points[j])\n            if d < min_dist:\n                min_dist = d\n                p1, p2 = points[i], points[j]\n    return min_dist, p1, p2\n\ncircle_points = create_points(50)\nmin_dist, point1, point2 = closest_pair(circle_points)\n\nprint(f\"Closest pair of points: {point1} and {point2}\")\nprint(f\"Distance between them: {min_dist:.5f}\")"}, {"role": "assistant", "content": "Closest pair of points: (-0.42577929156507216, -0.9048270524660198) and (-0.30901699437494756, -0.9510565162951535)\nDistance between them: 0.12558\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef sort_employees_by_join_date(employees):\n    return sorted(employees, key=lambda x: datetime.datetime.strptime(x[1], '%Y-%m-%d'))\n\nemployees = [\n    (\"John Doe\", \"2022-03-15\"),\n    (\"Jane Smith\", \"2019-06-23\"),\n    (\"Alice Johnson\", \"2020-01-10\"),\n    (\"Chris Lee\", \"2022-08-30\"),\n    (\"Michael Brown\", \"2018-12-11\"),\n    (\"Emily Davis\", \"2021-05-17\"),\n    (\"Jessica Wilson\", \"2020-11-01\"),\n    (\"David Martinez\", \"2019-02-14\"),\n    (\"Sarah Taylor\", \"2021-09-05\"),\n    (\"Paul Anderson\", \"2022-02-28\"),\n    (\"Laura Thompson\", \"2018-11-19\"),\n    (\"Daniel White\", \"2019-08-30\"),\n    (\"Sophia Harris\", \"2020-07-12\"),\n    (\"Ryan Martin\", \"2021-03-20\"),\n    (\"Lucas Clark\", \"2019-11-11\"),\n    (\"Megan Lewis\", \"2022-06-25\"),\n    (\"Andrew Robinson\", \"2020-04-15\"),\n    (\"Natalie Walker\", \"2021-12-30\"),\n    (\"Olivia Young\", \"2018-05-25\"),\n    (\"Liam Hall\", \"2019-03-19\"),\n]\n\nsorted_employees = sort_employees_by_join_date(employees)\n\nfor emp in sorted_employees:\n    print(f\"{emp[0]} joined on {emp[1]}\")"}, {"role": "assistant", "content": "Olivia Young joined on 2018-05-25\nLaura Thompson joined on 2018-11-19\nMichael Brown joined on 2018-12-11\nDavid Martinez joined on 2019-02-14\nLiam Hall joined on 2019-03-19\nJane Smith joined on 2019-06-23\nDaniel White joined on 2019-08-30\nLucas Clark joined on 2019-11-11\nAlice Johnson joined on 2020-01-10\nAndrew Robinson joined on 2020-04-15\nSophia Harris joined on 2020-07-12\nJessica Wilson joined on 2020-11-01\nRyan Martin joined on 2021-03-20\nEmily Davis joined on 2021-05-17\nSarah Taylor joined on 2021-09-05\nNatalie Walker joined on 2021-12-30\nPaul Anderson joined on 2022-02-28\nJohn Doe joined on 2022-03-15\nMegan Lewis joined on 2022-06-25\nChris Lee joined on 2022-08-30\n"}]}
{"messages": [{"role": "user", "content": "def custom_encode(text, key):\n    encoded = []\n    for char in text:\n        shifted = chr((ord(char) + key) % 256)\n        encoded.append(shifted)\n    return ''.join(encoded)\n\ndef custom_decode(encoded_text, key):\n    decoded = []\n    for char in encoded_text:\n        shifted = chr((ord(char) - key) % 256)\n        decoded.append(shifted)\n    return ''.join(decoded)\n\ndef sort_encoded(encoded_list):\n    return sorted(encoded_list, key=lambda x: sum(ord(c) for c in x))\n\ndef main():\n    messages = [\n        \"encryption\",\n        \"algorithm\",\n        \"security\",\n        \"ciphertext\",\n        \"plaintext\",\n        \"complexity\",\n        \"cryptology\",\n        \"datasecurity\",\n        \"encoding\",\n        \"decoding\"\n    ]\n\n    key = 4\n    encoded_messages = [custom_encode(msg, key) for msg in messages]\n    sorted_encoded_messages = sort_encoded(encoded_messages)\n\n    for encoded in sorted_encoded_messages:\n        decoded_message = custom_decode(encoded, key)\n        print(f\"Encoded: {encoded} -> Decoded: {decoded_message}\")\n\nmain()"}, {"role": "assistant", "content": "Encoded: higshmrk -> Decoded: decoding\nEncoded: irgshmrk -> Decoded: encoding\nEncoded: wigyvmx} -> Decoded: security\nEncoded: epksvmxlq -> Decoded: algorithm\nEncoded: tpemrxi|x -> Decoded: plaintext\nEncoded: gmtlivxi|x -> Decoded: ciphertext\nEncoded: irgv}txmsr -> Decoded: encryption\nEncoded: gsqtpi|mx} -> Decoded: complexity\nEncoded: gv}txspsk} -> Decoded: cryptology\nEncoded: hexewigyvmx} -> Decoded: datasecurity\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\nclass Move:\n    def __init__(self, player, position):\n        self.player = player\n        self.position = position\n\ndef is_winner(board, player):\n    winning_positions = [(0, 1, 2), (3, 4, 5), (6, 7, 8), \n                         (0, 3, 6), (1, 4, 7), (2, 5, 8), \n                         (0, 4, 8), (2, 4, 6)]\n    for pos in winning_positions:\n        if all(board[i] == player for i in pos):\n            return True\n    return False\n\ndef search_winner(moves, players):\n    board = [' '] * 9\n    for move in moves:\n        board[move.position] = move.player\n        if is_winner(board, move.player):\n            return move.player\n    return None\n\ndef game_simulation():\n    players = ['X', 'O']\n    moves = [\n        Move('X', 0), Move('O', 1), Move('X', 2),\n        Move('O', 4), Move('X', 3), Move('O', 5),\n        Move('X', 6), Move('O', 7), Move('X', 8)\n    ]\n\n    winner = search_winner(moves, players)\n    board_status = ''.join(moves[i].player if i < len(moves) else ' ' for i in range(9))\n    return winner, board_status\n\ndef display_results():\n    winner, board_status = game_simulation()\n    timestamp = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n    print(f\"Timestamp: {timestamp}\")\n    print(\"Board Status:\")\n    print(f\"{board_status[0:3]}\\n{board_status[3:6]}\\n{board_status[6:9]}\")\n    if winner:\n        print(f\"Winner: {winner}\")\n    else:\n        print(\"Result: Draw\")\n\ndisplay_results()"}, {"role": "assistant", "content": "Timestamp: 2025-04-01 16:08:54\nBoard Status:\nXOX\nOXO\nXOX\nWinner: X\n"}]}
{"messages": [{"role": "user", "content": "def is_goal_state(state):\n    return sum(state) == 0\n\ndef generate_moves(state):\n    moves = []\n    for i in range(len(state)):\n        if state[i] > 0:\n            new_state = state[:]\n            new_state[i] -= 1\n            moves.append(new_state)\n    return moves\n\ndef search(initial_state):\n    stack = [(initial_state, [])]\n    visited = set()\n    \n    while stack:\n        state, path = stack.pop()\n        state_tuple = tuple(state)\n        \n        if state_tuple in visited:\n            continue\n        visited.add(state_tuple)\n        \n        if is_goal_state(state):\n            return path\n        \n        for move in generate_moves(state):\n            stack.append((move, path + [move]))\n    \n    return None\n\ninitial_state = [3, 4, 5]\nsolution = search(initial_state)\n\nif solution:\n    for step in solution:\n        print(step)\nelse:\n    print(\"No solution found.\")"}, {"role": "assistant", "content": "[3, 4, 4]\n[3, 4, 3]\n[3, 4, 2]\n[3, 4, 1]\n[3, 4, 0]\n[3, 3, 0]\n[3, 2, 0]\n[3, 1, 0]\n[3, 0, 0]\n[2, 0, 0]\n[1, 0, 0]\n[0, 0, 0]\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef generate_pattern(n):\n    return [(int(math.sin(i) * 10) + 10) for i in range(n)]\n\ndef pattern_key(x):\n    return math.sqrt(abs(50 - x))\n\ndef sort_and_print_pattern(n):\n    pattern = generate_pattern(n)\n    print(\"Generated pattern:\", pattern)\n    sorted_pattern = sorted(pattern, key=pattern_key)\n    print(\"Pattern key values:\", [pattern_key(x) for x in pattern])\n    print(\"Sorted pattern:\", sorted_pattern)\n    for value in sorted_pattern:\n        print('*' * value)\n\nn = 50\nsort_and_print_pattern(n)"}, {"role": "assistant", "content": "Generated pattern: [10, 18, 19, 11, 3, 1, 8, 16, 19, 14, 5, 1, 5, 14, 19, 16, 8, 1, 3, 11, 19, 18, 10, 2, 1, 9, 17, 19, 12, 4, 1, 6, 15, 19, 15, 6, 1, 4, 12, 19, 17, 9, 1, 2, 10, 18, 19, 11, 3, 1]\nPattern key values: [6.324555320336759, 5.656854249492381, 5.5677643628300215, 6.244997998398398, 6.855654600401044, 7.0, 6.48074069840786, 5.830951894845301, 5.5677643628300215, 6.0, 6.708203932499369, 7.0, 6.708203932499369, 6.0, 5.5677643628300215, 5.830951894845301, 6.48074069840786, 7.0, 6.855654600401044, 6.244997998398398, 5.5677643628300215, 5.656854249492381, 6.324555320336759, 6.928203230275509, 7.0, 6.4031242374328485, 5.744562646538029, 5.5677643628300215, 6.164414002968976, 6.782329983125268, 7.0, 6.6332495807108, 5.916079783099616, 5.5677643628300215, 5.916079783099616, 6.6332495807108, 7.0, 6.782329983125268, 6.164414002968976, 5.5677643628300215, 5.744562646538029, 6.4031242374328485, 7.0, 6.928203230275509, 6.324555320336759, 5.656854249492381, 5.5677643628300215, 6.244997998398398, 6.855654600401044, 7.0]\nSorted pattern: [19, 19, 19, 19, 19, 19, 19, 19, 18, 18, 18, 17, 17, 16, 16, 15, 15, 14, 14, 12, 12, 11, 11, 11, 10, 10, 10, 9, 9, 8, 8, 6, 6, 5, 5, 4, 4, 3, 3, 3, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1]\n*******************\n*******************\n*******************\n*******************\n*******************\n*******************\n*******************\n*******************\n******************\n******************\n******************\n*****************\n*****************\n****************\n****************\n***************\n***************\n**************\n**************\n************\n************\n***********\n***********\n***********\n**********\n**********\n**********\n*********\n*********\n********\n********\n******\n******\n*****\n*****\n****\n****\n***\n***\n***\n**\n**\n*\n*\n*\n*\n*\n*\n*\n*\n"}]}
{"messages": [{"role": "user", "content": "import string\n\ndef encode_message(message, shift):\n    encoded = ''\n    for char in message:\n        if char in string.ascii_lowercase:\n            new_pos = (ord(char) - ord('a') + shift) % 26\n            encoded += chr(ord('a') + new_pos)\n        elif char in string.ascii_uppercase:\n            new_pos = (ord(char) - ord('A') + shift) % 26\n            encoded += chr(ord('A') + new_pos)\n        else:\n            encoded += char\n    return encoded\n\ndef decode_message(encoded_message, shift):\n    decoded = ''\n    for char in encoded_message:\n        if char in string.ascii_lowercase:\n            new_pos = (ord(char) - ord('a') - shift) % 26\n            decoded += chr(ord('a') + new_pos)\n        elif char in string.ascii_uppercase:\n            new_pos = (ord(char) - ord('A') - shift) % 26\n            decoded += chr(ord('A') + new_pos)\n        else:\n            decoded += char\n    return decoded\n\ndef search_for_keyword(encoded_message, keyword):\n    for shift in range(1, 26):\n        decoded_message = decode_message(encoded_message, shift)\n        print(f\"Trying shift {shift}: {decoded_message}\")\n        if keyword.lower() in decoded_message.lower():\n            print(f\"Keyword '{keyword}' found with shift {shift}: {decoded_message}\")\n            return shift, decoded_message\n    return None, None\n\noriginal_message = \"The quick brown fox jumps over the lazy dog.\"\nshift_value = 5\nkeyword = \"lazy\"\nencoded_message = encode_message(original_message, shift_value)\n\nprint(f\"Encoded message: {encoded_message}\")\nfound_shift, decoded_message = search_for_keyword(encoded_message, keyword)\n\nif found_shift:\n    print(f\"Decoded message with shift {found_shift}: {decoded_message}\")\nelse:\n    print(\"Keyword not found in any shift.\")"}, {"role": "assistant", "content": "Encoded message: Ymj vznhp gwtbs ktc ozrux tajw ymj qfed itl.\nTrying shift 1: Xli uymgo fvsar jsb nyqtw sziv xli pedc hsk.\nTrying shift 2: Wkh txlfn eurzq ira mxpsv ryhu wkh odcb grj.\nTrying shift 3: Vjg swkem dtqyp hqz lworu qxgt vjg ncba fqi.\nTrying shift 4: Uif rvjdl cspxo gpy kvnqt pwfs uif mbaz eph.\nTrying shift 5: The quick brown fox jumps over the lazy dog.\nKeyword 'lazy' found with shift 5: The quick brown fox jumps over the lazy dog.\nDecoded message with shift 5: The quick brown fox jumps over the lazy dog.\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"\nPython is a widely used high-level programming language for general-purpose programming.\nIt was created by Guido van Rossum and first released in 1991. An interpreted language, \nPython has a design philosophy that emphasizes code readability, notably using significant whitespace.\n\"\"\"\n\nwords = re.findall(r'\\b\\w+\\b', text.lower())\nunique_words = list(set(words))\nunique_words.sort()\n\ndef binary_search(word_list, target):\n    left, right = 0, len(word_list) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if word_list[mid] < target:\n            left = mid + 1\n        elif word_list[mid] > target:\n            right = mid - 1\n        else:\n            return mid\n    return -1\n\nsearch_words = [\"python\", \"programming\", \"guido\", \"language\", \"whitespace\", \"design\", \"high-level\", \"nonexistent\"]\n\nfor word in search_words:\n    print(f\"Searching for '{word}'...\")\n    index = binary_search(unique_words, word)\n    if index != -1:\n        print(f\"'{word}' found in unique words at index {index}.\")\n    else:\n        print(f\"'{word}' not found in unique words.\")\n\nprint(\"Unique words in the text:\")\nfor i, word in enumerate(unique_words):\n    print(f\"{i+1}: {word}\")"}, {"role": "assistant", "content": "Searching for 'python'...\n'python' found in unique words at index 25.\nSearching for 'programming'...\n'programming' found in unique words at index 23.\nSearching for 'guido'...\n'guido' found in unique words at index 12.\nSearching for 'language'...\n'language' found in unique words at index 19.\nSearching for 'whitespace'...\n'whitespace' found in unique words at index 35.\nSearching for 'design'...\n'design' found in unique words at index 7.\nSearching for 'high-level'...\n'high-level' not found in unique words.\nSearching for 'nonexistent'...\n'nonexistent' not found in unique words.\nUnique words in the text:\n1: 1991\n2: a\n3: an\n4: and\n5: by\n6: code\n7: created\n8: design\n9: emphasizes\n10: first\n11: for\n12: general\n13: guido\n14: has\n15: high\n16: in\n17: interpreted\n18: is\n19: it\n20: language\n21: level\n22: notably\n23: philosophy\n24: programming\n25: purpose\n26: python\n27: readability\n28: released\n29: rossum\n30: significant\n31: that\n32: used\n33: using\n34: van\n35: was\n36: whitespace\n37: widely\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef calculate_median_deviation(data):\n    sorted_data = sorted(data)\n    median_value = statistics.median(sorted_data)\n    deviations = [abs(x - median_value) for x in sorted_data]\n    return statistics.median(deviations)\n\ndata = [\n    4, 2, 5, 8, 6, 3, 7, 9, 1, 10, 13, 15, 12, 14, 11, 18, 17, 16, 19, 20,\n    24, 22, 23, 21, 25, 28, 26, 27, 30, 29, 34, 32, 33, 31, 36, 35, 37, 38,\n    40, 39, 42, 41, 44, 43, 46, 45, 48, 47, 50, 49, 52, 51, 54, 53, 55, 56,\n    58, 57, 60, 59, 62, 61, 64, 63, 66, 65, 67, 68, 70, 69, 72, 71, 74, 73,\n    76, 75, 78, 77, 80, 79, 82, 81, 84, 83, 86, 85, 88, 87, 90, 89, 92, 91,\n    94, 93, 96, 95, 98, 97, 100, 99\n]\n\nprint(calculate_median_deviation(data))"}, {"role": "assistant", "content": "25.0\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef custom_sort(data):\n    return sorted(data, key=lambda x: (x.split('-')[1], x.split('-')[2], x.split('-')[0]))\n\ndef date_transform(date_list):\n    result = []\n    for date in date_list:\n        year, month, day = map(int, date.split('-'))\n        new_date = datetime.date(year, month, day).strftime('%d/%m/%Y')\n        result.append(new_date)\n    return result\n\ndates = [\n    \"2022-12-25\", \"2021-01-01\", \"2022-07-04\", \"2021-12-31\", \n    \"2020-05-25\", \"2023-03-15\", \"2021-11-11\", \"2022-06-21\",\n    \"2020-09-09\", \"2023-01-01\", \"2022-10-31\", \"2021-04-20\"\n]\n\nprint(\"Original Dates:\")\nfor date in dates:\n    print(date)\n\nsorted_dates = custom_sort(dates)\nprint(\"\\nSorted Dates:\")\nfor date in sorted_dates:\n    print(date)\n\ntransformed_dates = date_transform(sorted_dates)\nprint(\"\\nTransformed Dates:\")\nfor date in transformed_dates:\n    print(date)"}, {"role": "assistant", "content": "Original Dates:\n2022-12-25\n2021-01-01\n2022-07-04\n2021-12-31\n2020-05-25\n2023-03-15\n2021-11-11\n2022-06-21\n2020-09-09\n2023-01-01\n2022-10-31\n2021-04-20\n\nSorted Dates:\n2021-01-01\n2023-01-01\n2023-03-15\n2021-04-20\n2020-05-25\n2022-06-21\n2022-07-04\n2020-09-09\n2022-10-31\n2021-11-11\n2022-12-25\n2021-12-31\n\nTransformed Dates:\n01/01/2021\n01/01/2023\n15/03/2023\n20/04/2021\n25/05/2020\n21/06/2022\n04/07/2022\n09/09/2020\n31/10/2022\n11/11/2021\n25/12/2022\n31/12/2021\n"}]}
{"messages": [{"role": "user", "content": "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort(left_half)\n        merge_sort(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n\ndef calculate_divisor_sums(n):\n    divisor_sums = []\n    for i in range(1, n+1):\n        sum_divisors = sum(j for j in range(1, i) if i % j == 0)\n        divisor_sums.append((i, sum_divisors))\n    return divisor_sums\n\ndivisor_sums_list = calculate_divisor_sums(30)\nmerge_sort(divisor_sums_list)\n\nfor num, div_sum in divisor_sums_list:\n    print(f\"Number: {num}, Sum of Divisors: {div_sum}\")"}, {"role": "assistant", "content": "Number: 1, Sum of Divisors: 0\nNumber: 2, Sum of Divisors: 1\nNumber: 3, Sum of Divisors: 1\nNumber: 4, Sum of Divisors: 3\nNumber: 5, Sum of Divisors: 1\nNumber: 6, Sum of Divisors: 6\nNumber: 7, Sum of Divisors: 1\nNumber: 8, Sum of Divisors: 7\nNumber: 9, Sum of Divisors: 4\nNumber: 10, Sum of Divisors: 8\nNumber: 11, Sum of Divisors: 1\nNumber: 12, Sum of Divisors: 16\nNumber: 13, Sum of Divisors: 1\nNumber: 14, Sum of Divisors: 10\nNumber: 15, Sum of Divisors: 9\nNumber: 16, Sum of Divisors: 15\nNumber: 17, Sum of Divisors: 1\nNumber: 18, Sum of Divisors: 21\nNumber: 19, Sum of Divisors: 1\nNumber: 20, Sum of Divisors: 22\nNumber: 21, Sum of Divisors: 11\nNumber: 22, Sum of Divisors: 14\nNumber: 23, Sum of Divisors: 1\nNumber: 24, Sum of Divisors: 36\nNumber: 25, Sum of Divisors: 6\nNumber: 26, Sum of Divisors: 16\nNumber: 27, Sum of Divisors: 13\nNumber: 28, Sum of Divisors: 28\nNumber: 29, Sum of Divisors: 1\nNumber: 30, Sum of Divisors: 42\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef transform_data(data):\n    return [re.sub(r'\\d', '', item) for item in data]\n\ndef binary_search_transformed(data, target):\n    low, high = 0, len(data) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        print(f\"Searching between indices {low} and {high}, middle: {mid}\")\n        if data[mid] < target:\n            print(f\"'{data[mid]}' is less than '{target}', searching right half\")\n            low = mid + 1\n        elif data[mid] > target:\n            print(f\"'{data[mid]}' is greater than '{target}', searching left half\")\n            high = mid - 1\n        else:\n            print(f\"Found '{target}' at index {mid}\")\n            return mid\n    print(f\"'{target}' not found in the list\")\n    return -1\n\ndata = [\n    \"a1b2c3\", \"d4e5f6\", \"g7h8i9\", \"j10k11l12\",\n    \"m13n14o15\", \"p16q17r18\", \"s19t20u21\", \"v22w23x24\",\n    \"y25z26a27\", \"b28c29d30\", \"e31f32g33\", \"h34i35j36\",\n    \"k37l38m39\", \"n40o41p42\", \"q43r44s45\", \"t46u47v48\",\n    \"w49x50y51\", \"z52a53b54\", \"c55d56e57\", \"f58g59h60\"\n]\n\ntransformed_data = transform_data(data)\ntransformed_data.sort()\ntarget = \"abcdefghijkl\"\n\nprint(\"Transformed and sorted data:\")\nfor i, item in enumerate(transformed_data):\n    print(f\"{i}: {item}\")\n\nbinary_search_transformed(transformed_data, target)"}, {"role": "assistant", "content": "Transformed and sorted data:\n0: abc\n1: bcd\n2: cde\n3: def\n4: efg\n5: fgh\n6: ghi\n7: hij\n8: jkl\n9: klm\n10: mno\n11: nop\n12: pqr\n13: qrs\n14: stu\n15: tuv\n16: vwx\n17: wxy\n18: yza\n19: zab\nSearching between indices 0 and 19, middle: 9\n'klm' is greater than 'abcdefghijkl', searching left half\nSearching between indices 0 and 8, middle: 4\n'efg' is greater than 'abcdefghijkl', searching left half\nSearching between indices 0 and 3, middle: 1\n'bcd' is greater than 'abcdefghijkl', searching left half\nSearching between indices 0 and 0, middle: 0\n'abc' is less than 'abcdefghijkl', searching right half\n'abcdefghijkl' not found in the list\n"}]}
{"messages": [{"role": "user", "content": "import re\nfrom math import gcd\n\ndef vigenere_encode(plain_text, key):\n    encoded_chars = []\n    for i, char in enumerate(plain_text):\n        if char.isalpha():\n            shift = ord(key[i % len(key)].lower()) - ord('a')\n            encoded_char = chr((ord(char.lower()) - ord('a') + shift) % 26 + ord('a'))\n            encoded_chars.append(encoded_char)\n        else:\n            encoded_chars.append(char)\n    return ''.join(encoded_chars)\n\ndef find_key(encoded_text, known_word):\n    for shift in range(1, 26):\n        decoded_chars = []\n        for char in encoded_text:\n            if char.isalpha():\n                shifted_char = chr((ord(char) - ord('a') - shift) % 26 + ord('a'))\n                decoded_chars.append(shifted_char)\n            else:\n                decoded_chars.append(char)\n        decoded_text = ''.join(decoded_chars)\n        if re.search(known_word, decoded_text):\n            print(f\"Potential key shift found: {shift}\")\n            return decoded_text\n    return \"No key found\"\n\nplain_text = \"encryption is fun and mysterious\"\nkey = \"cipher\"\nencoded_text = vigenere_encode(plain_text, key)\n\nprint(\"Encoded Text:\", encoded_text)\n\nknown_word = \"mysterious\"\ndecoded_text = find_key(encoded_text, known_word)\n\nprint(\"Decoded Text:\", decoded_text)\n\nfor i in range(2, 15):\n    print(f\"GCD of {i} and 15:\", gcd(i, 15))"}, {"role": "assistant", "content": "Encoded Text: gvrycgvqdu zu ubr cvs qpubtymfwa\nDecoded Text: No key found\nGCD of 2 and 15: 1\nGCD of 3 and 15: 3\nGCD of 4 and 15: 1\nGCD of 5 and 15: 5\nGCD of 6 and 15: 3\nGCD of 7 and 15: 1\nGCD of 8 and 15: 1\nGCD of 9 and 15: 3\nGCD of 10 and 15: 5\nGCD of 11 and 15: 1\nGCD of 12 and 15: 3\nGCD of 13 and 15: 1\nGCD of 14 and 15: 1\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndata = [\n    \"2023-10-01 14:22:30\",\n    \"2023-09-30 12:15:20\",\n    \"2023-10-02 09:05:10\",\n    \"2023-09-28 18:45:50\",\n    \"2023-10-01 16:30:00\",\n    \"2023-09-29 20:00:00\"\n]\n\nconverted_data = [datetime.strptime(d, \"%Y-%m-%d %H:%M:%S\") for d in data]\nsorted_data = sorted(converted_data, key=lambda x: (x.date(), x.time()))\n\nfor date_time in sorted_data:\n    print(f\"Original: {date_time}, Time to Midnight: {str(timedelta(days=1) - timedelta(hours=date_time.hour, minutes=date_time.minute, seconds=date_time.second))}\")\n    print(\"Debug: Sorted Date and Time:\", date_time)\n\ntransformed_data = [(dt.strftime(\"%Y-%m-%d %H:%M:%S\"), str(timedelta(days=1) - timedelta(hours=dt.hour, minutes=dt.minute, seconds=dt.second))) for dt in sorted_data]\n\nprint(\"\\nTransformed Data:\")\nfor original, time_to_midnight in transformed_data:\n    print(f\"Original: {original}, Time to Midnight: {time_to_midnight}\")"}, {"role": "assistant", "content": "Original: 2023-09-28 18:45:50, Time to Midnight: 5:14:10\nDebug: Sorted Date and Time: 2023-09-28 18:45:50\nOriginal: 2023-09-29 20:00:00, Time to Midnight: 4:00:00\nDebug: Sorted Date and Time: 2023-09-29 20:00:00\nOriginal: 2023-09-30 12:15:20, Time to Midnight: 11:44:40\nDebug: Sorted Date and Time: 2023-09-30 12:15:20\nOriginal: 2023-10-01 14:22:30, Time to Midnight: 9:37:30\nDebug: Sorted Date and Time: 2023-10-01 14:22:30\nOriginal: 2023-10-01 16:30:00, Time to Midnight: 7:30:00\nDebug: Sorted Date and Time: 2023-10-01 16:30:00\nOriginal: 2023-10-02 09:05:10, Time to Midnight: 14:54:50\nDebug: Sorted Date and Time: 2023-10-02 09:05:10\n\nTransformed Data:\nOriginal: 2023-09-28 18:45:50, Time to Midnight: 5:14:10\nOriginal: 2023-09-29 20:00:00, Time to Midnight: 4:00:00\nOriginal: 2023-09-30 12:15:20, Time to Midnight: 11:44:40\nOriginal: 2023-10-01 14:22:30, Time to Midnight: 9:37:30\nOriginal: 2023-10-01 16:30:00, Time to Midnight: 7:30:00\nOriginal: 2023-10-02 09:05:10, Time to Midnight: 14:54:50\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndates = [\n    datetime(2023, 10, 25, 14, 30),\n    datetime(2023, 1, 12, 9, 45),\n    datetime(2023, 7, 4, 18, 15),\n    datetime(2023, 3, 17, 11, 20),\n    datetime(2023, 6, 1, 16, 55),\n    datetime(2023, 8, 14, 20, 5),\n    datetime(2023, 5, 21, 7, 30),\n    datetime(2023, 2, 28, 13, 40),\n    datetime(2023, 4, 10, 10, 10),\n    datetime(2023, 9, 30, 22, 25)\n]\n\nsorted_dates = sorted(dates, key=lambda x: (x.month, x.day, x.hour, x.minute))\n\nfor date in sorted_dates:\n    print(date.strftime('%Y-%m-%d %H:%M'))"}, {"role": "assistant", "content": "2023-01-12 09:45\n2023-02-28 13:40\n2023-03-17 11:20\n2023-04-10 10:10\n2023-05-21 07:30\n2023-06-01 16:55\n2023-07-04 18:15\n2023-08-14 20:05\n2023-09-30 22:25\n2023-10-25 14:30\n"}]}
{"messages": [{"role": "user", "content": "def generate_pattern(n):\n    pattern = []\n    for i in range(n):\n        pattern.append(''.join(['*' if (i + j) % 2 == 0 else ' ' for j in range(n)]))\n    return pattern\n\ndef custom_sort(pattern):\n    return sorted(pattern, key=lambda x: x.count('*'), reverse=True)\n\nn = 10\npattern = generate_pattern(n)\nsorted_pattern = custom_sort(pattern)\n\nfor line in sorted_pattern:\n    print(line)"}, {"role": "assistant", "content": "* * * * * \n * * * * *\n* * * * * \n * * * * *\n* * * * * \n * * * * *\n* * * * * \n * * * * *\n* * * * * \n * * * * *\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef calculate_polygon_area(vertices):\n    n = len(vertices)\n    area = 0.0\n    for i in range(n):\n        j = (i + 1) % n\n        area += vertices[i][0] * vertices[j][1]\n        area -= vertices[j][0] * vertices[i][1]\n    area = abs(area) / 2.0\n    return area\n\ndef sort_polygons_by_area(polygons):\n    return sorted(polygons, key=calculate_polygon_area)\n\npolygons = [\n    [(0, 0), (4, 0), (4, 3)],\n    [(0, 0), (2, 0), (2, 2), (0, 2)],\n    [(0, 0), (3, 0), (3, 3), (0, 3)],\n    [(0, 0), (1, 0), (1, 1), (0, 1)],\n    [(0, 0), (5, 0), (5, 5), (0, 5)]\n]\n\nsorted_polygons = sort_polygons_by_area(polygons)\n\nfor polygon in sorted_polygons:\n    area = calculate_polygon_area(polygon)\n    print(f\"Vertices: {polygon}, Area: {area:.2f}\")"}, {"role": "assistant", "content": "Vertices: [(0, 0), (1, 0), (1, 1), (0, 1)], Area: 1.00\nVertices: [(0, 0), (2, 0), (2, 2), (0, 2)], Area: 4.00\nVertices: [(0, 0), (4, 0), (4, 3)], Area: 6.00\nVertices: [(0, 0), (3, 0), (3, 3), (0, 3)], Area: 9.00\nVertices: [(0, 0), (5, 0), (5, 5), (0, 5)], Area: 25.00\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\ndef calculate_game_points(scores):\n    return sum(scores) + max(scores) * 2\n\ndef sort_games_by_points(games):\n    return sorted(games, key=lambda game: game['points'], reverse=True)\n\ngames = [\n    {\"name\": \"Adventure Quest\", \"scores\": [5, 7, 3, 9]},\n    {\"name\": \"Mystery Mansion\", \"scores\": [4, 8, 6, 7]},\n    {\"name\": \"Puzzle World\", \"scores\": [6, 5, 8, 8]},\n    {\"name\": \"Action Arena\", \"scores\": [7, 7, 7, 7]},\n    {\"name\": \"Fantasy Land\", \"scores\": [9, 5, 6, 4]}\n]\n\nfor game in games:\n    game['points'] = calculate_game_points(game['scores'])\n\nsorted_games = sort_games_by_points(games)\n\nprint(\"Games sorted by points:\")\nfor game in sorted_games:\n    print(f\"{game['name']}: {game['points']} points\")\n\ncurrent_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\nprint(\"\\nReport generated at:\", current_time)"}, {"role": "assistant", "content": "Games sorted by points:\nPuzzle World: 43 points\nAdventure Quest: 42 points\nAction Arena: 42 points\nFantasy Land: 42 points\nMystery Mansion: 41 points\n\nReport generated at: 2025-04-01 16:09:00\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef area_of_polygon(vertices):\n    n = len(vertices)\n    area = 0.0\n    for i in range(n):\n        x1, y1 = vertices[i]\n        x2, y2 = vertices[(i + 1) % n]\n        area += x1 * y2 - x2 * y1\n    return abs(area) / 2.0\n\ndef is_point_inside_polygon(point, vertices):\n    n = len(vertices)\n    x, y = point\n    inside = False\n    xints = 0\n    p1x, p1y = vertices[0]\n    for i in range(1, n + 1):\n        p2x, p2y = vertices[i % n]\n        if y > min(p1y, p2y):\n            if y <= max(p1y, p2y):\n                if x <= max(p1x, p2x):\n                    if p1y != p2y:\n                        xints = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x\n                    if p1x == p2x or x <= xints:\n                        inside = not inside\n        p1x, p1y = p2x, p2y\n    return inside\n\ndef find_largest_polygon(points):\n    n = len(points)\n    max_area = 0\n    max_polygon = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                for l in range(k + 1, n):\n                    polygon = [points[i], points[j], points[k], points[l]]\n                    area = area_of_polygon(polygon)\n                    if area > max_area:\n                        max_area = area\n                        max_polygon = polygon\n    return max_polygon\n\npoints = [(1, 2), (3, 5), (5, 3), (7, 8), (9, 1), (4, 7), (2, 9), (6, 6)]\nlargest_polygon = find_largest_polygon(points)\nfor point in points:\n    inside = is_point_inside_polygon(point, largest_polygon)\n    print(f\"Point {point} is {'inside' if inside else 'outside'} the largest polygon.\")"}, {"role": "assistant", "content": "Point (1, 2) is outside the largest polygon.\nPoint (3, 5) is outside the largest polygon.\nPoint (5, 3) is inside the largest polygon.\nPoint (7, 8) is outside the largest polygon.\nPoint (9, 1) is outside the largest polygon.\nPoint (4, 7) is outside the largest polygon.\nPoint (2, 9) is outside the largest polygon.\nPoint (6, 6) is inside the largest polygon.\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef binary_search(lst, target):\n    low, high = 0, len(lst) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if lst[mid] == target:\n            return mid\n        elif lst[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n\ndef analyze_data(data):\n    data.sort()\n    median = statistics.median(data)\n    mean = statistics.mean(data)\n    mode = statistics.mode(data)\n    median_pos = binary_search(data, median)\n    mean_pos = binary_search(data, mean)\n    mode_pos = binary_search(data, mode)\n    return median, median_pos, mean, mean_pos, mode, mode_pos\n\ndata = [\n    23, 45, 67, 89, 23, 45, 67, 23, 56, 78, 90, 34, 56, 78, 45, 34, 56, 23, 89, 90, 23,\n    45, 34, 67, 23, 56, 78, 89, 90, 23, 45, 67, 89, 56, 78, 90, 34, 23, 45, 67, 89, 90,\n    34, 56, 78, 23, 45, 67, 89, 90, 23, 45, 34, 67, 89, 90, 23, 45, 56, 78, 34, 56, 78,\n    23, 45, 67, 89, 90, 23, 45, 67, 89, 34, 56, 78, 23, 45, 67, 89, 90, 23, 45, 67, 89,\n    23, 56, 78, 90, 34, 56, 78, 45, 34, 56, 23, 89, 90, 23, 45, 34, 67\n]\n\nmedian, median_pos, mean, mean_pos, mode, mode_pos = analyze_data(data)\nprint(f\"Median: {median}, Position: {median_pos}\")\nprint(f\"Mean: {mean}, Position: {mean_pos}\")\nprint(f\"Mode: {mode}, Position: {mode_pos}\")"}, {"role": "assistant", "content": "Median: 56, Position: 50\nMean: 57.198019801980195, Position: -1\nMode: 23, Position: 11\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef generate_dates(base_date, count):\n    dates = []\n    for i in range(count):\n        dates.append(base_date + timedelta(days=i))\n    return dates\n\ndef date_ordinal(date):\n    return date.toordinal()\n\ndef bubble_sort_dates(dates):\n    n = len(dates)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if date_ordinal(dates[j]) > date_ordinal(dates[j+1]):\n                dates[j], dates[j+1] = dates[j+1], dates[j]\n    return dates\n\nbase_date = datetime(2021, 1, 1)\ndates = generate_dates(base_date, 50)\nsorted_dates = bubble_sort_dates(dates)\n\nprint(\"Unsorted Dates:\")\nfor date in dates:\n    print(date.strftime(\"%Y-%m-%d\"))\n\nprint(\"\\nSorted Dates:\")\nfor date in sorted_dates:\n    print(date.strftime(\"%Y-%m-%d\"))"}, {"role": "assistant", "content": "Unsorted Dates:\n2021-01-01\n2021-01-02\n2021-01-03\n2021-01-04\n2021-01-05\n2021-01-06\n2021-01-07\n2021-01-08\n2021-01-09\n2021-01-10\n2021-01-11\n2021-01-12\n2021-01-13\n2021-01-14\n2021-01-15\n2021-01-16\n2021-01-17\n2021-01-18\n2021-01-19\n2021-01-20\n2021-01-21\n2021-01-22\n2021-01-23\n2021-01-24\n2021-01-25\n2021-01-26\n2021-01-27\n2021-01-28\n2021-01-29\n2021-01-30\n2021-01-31\n2021-02-01\n2021-02-02\n2021-02-03\n2021-02-04\n2021-02-05\n2021-02-06\n2021-02-07\n2021-02-08\n2021-02-09\n2021-02-10\n2021-02-11\n2021-02-12\n2021-02-13\n2021-02-14\n2021-02-15\n2021-02-16\n2021-02-17\n2021-02-18\n2021-02-19\n\nSorted Dates:\n2021-01-01\n2021-01-02\n2021-01-03\n2021-01-04\n2021-01-05\n2021-01-06\n2021-01-07\n2021-01-08\n2021-01-09\n2021-01-10\n2021-01-11\n2021-01-12\n2021-01-13\n2021-01-14\n2021-01-15\n2021-01-16\n2021-01-17\n2021-01-18\n2021-01-19\n2021-01-20\n2021-01-21\n2021-01-22\n2021-01-23\n2021-01-24\n2021-01-25\n2021-01-26\n2021-01-27\n2021-01-28\n2021-01-29\n2021-01-30\n2021-01-31\n2021-02-01\n2021-02-02\n2021-02-03\n2021-02-04\n2021-02-05\n2021-02-06\n2021-02-07\n2021-02-08\n2021-02-09\n2021-02-10\n2021-02-11\n2021-02-12\n2021-02-13\n2021-02-14\n2021-02-15\n2021-02-16\n2021-02-17\n2021-02-18\n2021-02-19\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"\nIn the world of software development, algorithms play a crucial role. Searching algorithms, in particular, are used \nto locate specific elements within data structures. Text processing often involves searching through text to find \npatterns or specific information. Today, we will demonstrate an advanced application of searching algorithms in \ntext processing. Our goal is to find the longest sentence in a given text based on word count. This problem requires \nan efficient search through the text to determine where sentences begin and end, and then comparing their lengths.\n\"\"\"\n\ndef sentence_lengths(text):\n    sentences = re.split(r'(?:\\.|\\?|!)\\s*', text.strip())\n    lengths = []\n    for sentence in sentences:\n        if sentence:\n            words = re.findall(r'\\b\\w+\\b', sentence)\n            lengths.append((len(words), sentence))\n    return lengths\n\ndef longest_sentence(text):\n    lengths = sentence_lengths(text)\n    lengths.sort(key=lambda x: x[0], reverse=True)\n    return lengths[0][1]\n\nprint(\"Analyzing text...\")\nlengths = sentence_lengths(text)\nprint(f\"Found {len(lengths)} sentences.\")\n\nfor i, (length, sentence) in enumerate(lengths):\n    print(f\"Sentence {i + 1}: '{sentence[:50]}...' has {length} words.\")\n\nlongest = longest_sentence(text)\nprint(\"\\nThe longest sentence found is:\")\nprint(longest)"}, {"role": "assistant", "content": "Analyzing text...\nFound 6 sentences.\nSentence 1: 'In the world of software development, algorithms p...' has 11 words.\nSentence 2: 'Searching algorithms, in particular, are used \nto ...' has 13 words.\nSentence 3: 'Text processing often involves searching through t...' has 13 words.\nSentence 4: 'Today, we will demonstrate an advanced application...' has 13 words.\nSentence 5: 'Our goal is to find the longest sentence in a give...' has 16 words.\nSentence 6: 'This problem requires \nan efficient search through...' has 21 words.\n\nThe longest sentence found is:\nThis problem requires \nan efficient search through the text to determine where sentences begin and end, and then comparing their lengths\n"}]}
{"messages": [{"role": "user", "content": "import math\n\npoints = [\n    (1, 2), (3, 4), (5, 6), (7, 8), (2, 1),\n    (4, 3), (6, 5), (8, 7), (1, 3), (3, 1),\n    (5, 7), (7, 5), (2, 4), (4, 2), (6, 8),\n    (8, 6), (0, 0), (9, 9), (1, 1), (2, 2)\n]\n\ndef distance_from_origin(point):\n    x, y = point\n    return math.sqrt(x**2 + y**2)\n\nsorted_points = sorted(points, key=distance_from_origin)\n\nprint(\"Points sorted by distance from origin:\")\nfor point in sorted_points:\n    print(point, \"Distance:\", distance_from_origin(point))"}, {"role": "assistant", "content": "Points sorted by distance from origin:\n(0, 0) Distance: 0.0\n(1, 1) Distance: 1.4142135623730951\n(1, 2) Distance: 2.23606797749979\n(2, 1) Distance: 2.23606797749979\n(2, 2) Distance: 2.8284271247461903\n(1, 3) Distance: 3.1622776601683795\n(3, 1) Distance: 3.1622776601683795\n(2, 4) Distance: 4.47213595499958\n(4, 2) Distance: 4.47213595499958\n(3, 4) Distance: 5.0\n(4, 3) Distance: 5.0\n(5, 6) Distance: 7.810249675906654\n(6, 5) Distance: 7.810249675906654\n(5, 7) Distance: 8.602325267042627\n(7, 5) Distance: 8.602325267042627\n(6, 8) Distance: 10.0\n(8, 6) Distance: 10.0\n(7, 8) Distance: 10.63014581273465\n(8, 7) Distance: 10.63014581273465\n(9, 9) Distance: 12.727922061357855\n"}]}
{"messages": [{"role": "user", "content": "def find_diagonal_patterns(grid_size):\n    diagonal_patterns = []\n    for i in range(grid_size):\n        pattern = []\n        for j in range(grid_size):\n            if i == j:\n                pattern.append('X')\n            else:\n                pattern.append('-')\n        diagonal_patterns.append(''.join(pattern))\n    return diagonal_patterns\n\ndef search_horizontal_patterns(grid_size):\n    patterns = find_diagonal_patterns(grid_size)\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if patterns[j][i] == 'X':\n                patterns[j] = patterns[j][:i] + 'O' + patterns[j][i+1:]\n    return patterns\n\ndef display_patterns(grid_size):\n    patterns = search_horizontal_patterns(grid_size)\n    for pattern in patterns:\n        print(pattern)\n\ndisplay_patterns(10)"}, {"role": "assistant", "content": "O---------\n-O--------\n--O-------\n---O------\n----O-----\n-----O----\n------O---\n-------O--\n--------O-\n---------O\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef search_next_friday_13th(start_date):\n    date = start_date\n    found_dates = []\n    while len(found_dates) < 10:\n        date += timedelta(days=1)\n        if date.day == 13 and date.weekday() == 4:\n            found_dates.append(date)\n            print(f\"Found: {date.strftime('%Y-%m-%d')}\")\n\n    return found_dates\n\nstart_date = datetime(2023, 1, 1)\ndates = search_next_friday_13th(start_date)\n\nfor idx, date in enumerate(dates):\n    print(f\"Result {idx+1}: {date.strftime('%Y-%m-%d')}\")"}, {"role": "assistant", "content": "Found: 2023-01-13\nFound: 2023-10-13\nFound: 2024-09-13\nFound: 2024-12-13\nFound: 2025-06-13\nFound: 2026-02-13\nFound: 2026-03-13\nFound: 2026-11-13\nFound: 2027-08-13\nFound: 2028-10-13\nResult 1: 2023-01-13\nResult 2: 2023-10-13\nResult 3: 2024-09-13\nResult 4: 2024-12-13\nResult 5: 2025-06-13\nResult 6: 2026-02-13\nResult 7: 2026-03-13\nResult 8: 2026-11-13\nResult 9: 2027-08-13\nResult 10: 2028-10-13\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef is_perfect_square(n):\n    return n == math.isqrt(n) ** 2\n\ndef fibonacci_like_sequence(n, a, b):\n    sequence = [a, b]\n    for _ in range(n - 2):\n        sequence.append(sequence[-1] + sequence[-2])\n    return sequence\n\ndef search_perfect_squares(sequence):\n    return [x for x in sequence if is_perfect_square(x)]\n\nsequence_length = 50\nstarting_values = (3, 5)\nsequence = fibonacci_like_sequence(sequence_length, *starting_values)\nperfect_squares = search_perfect_squares(sequence)\n\nfor value in perfect_squares:\n    print(value)"}, {"role": "assistant", "content": "144\n"}]}
{"messages": [{"role": "user", "content": "def selection_sort(lst):\n    for i in range(len(lst)):\n        min_idx = i\n        for j in range(i+1, len(lst)):\n            if lst[j] < lst[min_idx]:\n                min_idx = j\n        lst[i], lst[min_idx] = lst[min_idx], lst[i]\n\ndef encrypt_message(message, key):\n    key = list(key)\n    selection_sort(key)\n    encrypted = []\n    for i, char in enumerate(message):\n        key_idx = i % len(key)\n        shift = ord(key[key_idx]) - ord('a') + 1\n        encrypted_char = chr((ord(char) + shift - 32) % 95 + 32)\n        encrypted.append(encrypted_char)\n    return ''.join(encrypted)\n\ndef decrypt_message(encrypted, key):\n    key = list(key)\n    selection_sort(key)\n    decrypted = []\n    for i, char in enumerate(encrypted):\n        key_idx = i % len(key)\n        shift = ord(key[key_idx]) - ord('a') + 1\n        decrypted_char = chr((ord(char) - shift - 32) % 95 + 32)\n        decrypted.append(decrypted_char)\n    return ''.join(decrypted)\n\nmessage = \"AdvancedEncryption\"\nkey = \"cipher\"\n\nencrypted = encrypt_message(message, key)\ndecrypted = decrypt_message(encrypted, key)\n\nprint(\"Original Message:\", message)\nprint(\"Encrypted Message:\", encrypted)\nprint(\"Decrypted Message:\", decrypted)"}, {"role": "assistant", "content": "Original Message: AdvancedEncryption\nEncrypted Message: Di~j~uhiMws%|u|r !\nDecrypted Message: AdvancedEncryption\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndata_points = [\n    15, 21, 14, 35, 42, 56, 77, 89, 95, 110,\n    130, 145, 154, 160, 175, 187, 205, 222, 235, 250\n]\n\nthresholds = [30, 60, 90, 120, 150, 180, 210, 240]\n\nsorted_data = sorted(data_points)\n\ndef binary_search_threshold(sorted_data, threshold):\n    low, high = 0, len(sorted_data) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if sorted_data[mid] == threshold:\n            return mid\n        elif sorted_data[mid] < threshold:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return low\n\nsearch_results = []\nfor threshold in thresholds:\n    index = binary_search_threshold(sorted_data, threshold)\n    search_results.append((threshold, index, sorted_data[:index]))\n\nfor result in search_results:\n    threshold, index, subset = result\n    if subset:\n        mean = statistics.mean(subset)\n        median = statistics.median(subset)\n        print(f\"Threshold: {threshold}, Index: {index}, Mean: {mean:.2f}, Median: {median}\")\n    else:\n        print(f\"Threshold: {threshold}, Index: {index}, No data below threshold\")"}, {"role": "assistant", "content": "Threshold: 30, Index: 3, Mean: 16.67, Median: 15\nThreshold: 60, Index: 6, Mean: 30.50, Median: 28.0\nThreshold: 90, Index: 8, Mean: 43.62, Median: 38.5\nThreshold: 120, Index: 10, Mean: 55.40, Median: 49.0\nThreshold: 150, Index: 12, Mean: 69.08, Median: 66.5\nThreshold: 180, Index: 15, Mean: 87.87, Median: 89\nThreshold: 210, Index: 17, Mean: 100.59, Median: 95\nThreshold: 240, Index: 19, Mean: 114.05, Median: 110\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef calculate_median_age(people_ages):\n    sorted_ages = sorted(people_ages)\n    median_age = statistics.median(sorted_ages)\n    print(f\"Sorted ages: {sorted_ages}\")\n    return median_age\n\nages = [34, 23, 31, 45, 22, 31, 34, 40, 41, 27, 30, 29, 36, 33]\nmedian_age = calculate_median_age(ages)\nprint(f\"Median age: {median_age}\")\n\ndef calculate_average_age(people_ages):\n    sorted_ages = sorted(people_ages, reverse=True)\n    print(f\"Reverse sorted ages: {sorted_ages}\")\n    average_age = statistics.median(sorted_ages)\n    return average_age\n\naverage_age = calculate_average_age(ages)\nprint(f\"Average age: {average_age}\")"}, {"role": "assistant", "content": "Sorted ages: [22, 23, 27, 29, 30, 31, 31, 33, 34, 34, 36, 40, 41, 45]\nMedian age: 32.0\nReverse sorted ages: [45, 41, 40, 36, 34, 34, 33, 31, 31, 30, 29, 27, 23, 22]\nAverage age: 32.0\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef custom_sort_key(word):\n    vowels = 'aeiouAEIOU'\n    count = sum(1 for char in word if char in vowels)\n    return count, word.lower()\n\ndef sort_words_by_vowel_count(text):\n    words = re.findall(r'\\b\\w+\\b', text)\n    words.sort(key=custom_sort_key, reverse=True)\n    return words\n\ntext = \"The quick brown fox jumps over the lazy dog. An elephant walked under an evergreen tree.\"\nsorted_words = sort_words_by_vowel_count(text)\n\nfor word in sorted_words:\n    print(word)"}, {"role": "assistant", "content": "evergreen\nelephant\nwalked\nunder\ntree\nquick\nover\nThe\nthe\nlazy\njumps\nfox\ndog\nbrown\nAn\nan\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef is_leap_year(year):\n    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n\ndef days_in_month(year, month):\n    if month == 2:\n        return 29 if is_leap_year(year) else 28\n    return 30 if month in [4, 6, 9, 11] else 31\n\ndef date_to_ordinal(year, month, day):\n    ordinal = 0\n    for y in range(1, year):\n        ordinal += 366 if is_leap_year(y) else 365\n    for m in range(1, month):\n        ordinal += days_in_month(year, m)\n    return ordinal + day\n\ndef ordinal_to_date(ordinal):\n    year = 1\n    while ordinal > 366:\n        days_in_year = 366 if is_leap_year(year) else 365\n        if ordinal > days_in_year:\n            ordinal -= days_in_year\n            year += 1\n        else:\n            break\n    month = 1\n    while ordinal > days_in_month(year, month):\n        ordinal -= days_in_month(year, month)\n        month += 1\n    return datetime(year, month, ordinal)\n\nstart_date = datetime(1900, 1, 1)\nend_date = datetime(2023, 10, 1)\ntarget_ordinal = date_to_ordinal(1970, 1, 1)\n\ncurrent_date = start_date\nwhile current_date <= end_date:\n    if date_to_ordinal(current_date.year, current_date.month, current_date.day) == target_ordinal:\n        break\n    current_date += timedelta(days=1)\n\nordinals = []\nwhile current_date <= end_date:\n    ordinals.append(date_to_ordinal(current_date.year, current_date.month, current_date.day))\n    current_date += timedelta(days=1)\n\nconverted_dates = [ordinal_to_date(o) for o in ordinals]\n\nfor date in converted_dates[:100]:\n    print(date.strftime(\"%Y-%m-%d\"))"}, {"role": "assistant", "content": "Traceback (most recent call last):\n  File \"<string>\", line 49, in <module>\n  File \"<string>\", line 49, in <listcomp>\n  File \"<string>\", line 32, in ordinal_to_date\nValueError: month must be in 1..12\n"}]}
{"messages": [{"role": "user", "content": "def knight_moves(board_size, start, end):\n    directions = [\n        (2, 1), (1, 2), (-1, 2), (-2, 1),\n        (-2, -1), (-1, -2), (1, -2), (2, -1)\n    ]\n    \n    def is_within_bounds(x, y):\n        return 0 <= x < board_size and 0 <= y < board_size\n    \n    visited = [[False] * board_size for _ in range(board_size)]\n    queue = [(start[0], start[1], 0)]\n    visited[start[0]][start[1]] = True\n\n    while queue:\n        x, y, depth = queue.pop(0)\n        if (x, y) == end:\n            return depth\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if is_within_bounds(nx, ny) and not visited[nx][ny]:\n                visited[nx][ny] = True\n                queue.append((nx, ny, depth + 1))\n\n    return -1\n\nboard_size = 8\nstart = (0, 0)\nend_positions = [(i, j) for i in range(board_size) for j in range(board_size)]\nresults = [(end, knight_moves(board_size, start, end)) for end in end_positions]\n\nfor position, moves in results:\n    print(f\"End: {position}, Moves: {moves}\")"}, {"role": "assistant", "content": "End: (0, 0), Moves: 0\nEnd: (0, 1), Moves: 3\nEnd: (0, 2), Moves: 2\nEnd: (0, 3), Moves: 3\nEnd: (0, 4), Moves: 2\nEnd: (0, 5), Moves: 3\nEnd: (0, 6), Moves: 4\nEnd: (0, 7), Moves: 5\nEnd: (1, 0), Moves: 3\nEnd: (1, 1), Moves: 4\nEnd: (1, 2), Moves: 1\nEnd: (1, 3), Moves: 2\nEnd: (1, 4), Moves: 3\nEnd: (1, 5), Moves: 4\nEnd: (1, 6), Moves: 3\nEnd: (1, 7), Moves: 4\nEnd: (2, 0), Moves: 2\nEnd: (2, 1), Moves: 1\nEnd: (2, 2), Moves: 4\nEnd: (2, 3), Moves: 3\nEnd: (2, 4), Moves: 2\nEnd: (2, 5), Moves: 3\nEnd: (2, 6), Moves: 4\nEnd: (2, 7), Moves: 5\nEnd: (3, 0), Moves: 3\nEnd: (3, 1), Moves: 2\nEnd: (3, 2), Moves: 3\nEnd: (3, 3), Moves: 2\nEnd: (3, 4), Moves: 3\nEnd: (3, 5), Moves: 4\nEnd: (3, 6), Moves: 3\nEnd: (3, 7), Moves: 4\nEnd: (4, 0), Moves: 2\nEnd: (4, 1), Moves: 3\nEnd: (4, 2), Moves: 2\nEnd: (4, 3), Moves: 3\nEnd: (4, 4), Moves: 4\nEnd: (4, 5), Moves: 3\nEnd: (4, 6), Moves: 4\nEnd: (4, 7), Moves: 5\nEnd: (5, 0), Moves: 3\nEnd: (5, 1), Moves: 4\nEnd: (5, 2), Moves: 3\nEnd: (5, 3), Moves: 4\nEnd: (5, 4), Moves: 3\nEnd: (5, 5), Moves: 4\nEnd: (5, 6), Moves: 5\nEnd: (5, 7), Moves: 4\nEnd: (6, 0), Moves: 4\nEnd: (6, 1), Moves: 3\nEnd: (6, 2), Moves: 4\nEnd: (6, 3), Moves: 3\nEnd: (6, 4), Moves: 4\nEnd: (6, 5), Moves: 5\nEnd: (6, 6), Moves: 4\nEnd: (6, 7), Moves: 5\nEnd: (7, 0), Moves: 5\nEnd: (7, 1), Moves: 4\nEnd: (7, 2), Moves: 5\nEnd: (7, 3), Moves: 4\nEnd: (7, 4), Moves: 5\nEnd: (7, 5), Moves: 4\nEnd: (7, 6), Moves: 5\nEnd: (7, 7), Moves: 6\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef custom_sort_key(event):\n    return event[1], event[0]\n\nevents = [\n    (\"Event A\", datetime.datetime(2023, 10, 25, 14, 0)),\n    (\"Event B\", datetime.datetime(2023, 10, 25, 9, 0)),\n    (\"Event C\", datetime.datetime(2023, 10, 24, 18, 0)),\n    (\"Event D\", datetime.datetime(2023, 10, 26, 10, 0)),\n    (\"Event E\", datetime.datetime(2023, 10, 24, 8, 0)),\n    (\"Event F\", datetime.datetime(2023, 10, 25, 16, 0)),\n    (\"Event G\", datetime.datetime(2023, 10, 24, 12, 0)),\n    (\"Event H\", datetime.datetime(2023, 10, 25, 11, 0)),\n]\n\nsorted_events = sorted(events, key=custom_sort_key)\n\nprint(\"Unsorted Events:\")\nfor event in events:\n    print(event[0], \"at\", event[1].strftime(\"%Y-%m-%d %H:%M\"))\n\nprint(\"\\nSorted Events:\")\nfor event in sorted_events:\n    print(event[0], \"at\", event[1].strftime(\"%Y-%m-%d %H:%M\"))"}, {"role": "assistant", "content": "Unsorted Events:\nEvent A at 2023-10-25 14:00\nEvent B at 2023-10-25 09:00\nEvent C at 2023-10-24 18:00\nEvent D at 2023-10-26 10:00\nEvent E at 2023-10-24 08:00\nEvent F at 2023-10-25 16:00\nEvent G at 2023-10-24 12:00\nEvent H at 2023-10-25 11:00\n\nSorted Events:\nEvent E at 2023-10-24 08:00\nEvent G at 2023-10-24 12:00\nEvent C at 2023-10-24 18:00\nEvent B at 2023-10-25 09:00\nEvent H at 2023-10-25 11:00\nEvent A at 2023-10-25 14:00\nEvent F at 2023-10-25 16:00\nEvent D at 2023-10-26 10:00\n"}]}
{"messages": [{"role": "user", "content": "from itertools import permutations\n\ndef calculate_score(deck):\n    score = 0\n    for i in range(len(deck) - 1):\n        if deck[i] < deck[i + 1]:\n            score += 1\n    return score\n\ncards = ['A', 'K', 'Q', 'J', '10', '9', '8', '7', '6', '5', '4', '3', '2']\ndeck_permutations = list(permutations(cards, 5))\n\nscore_decks = [(calculate_score(deck), deck) for deck in deck_permutations]\n\nprint(\"Sorting decks based on scores...\")\nsorted_score_decks = sorted(score_decks, key=lambda x: x[0], reverse=True)\n\nprint(\"Top 10 decks by increasing score:\")\nfor i, (score, deck) in enumerate(sorted_score_decks[-10:], 1):\n    print(f\"{i}. Score: {score}, Deck: {deck}\")\n\nprint(\"\\nBottom 10 decks by decreasing score:\")\nfor i, (score, deck) in enumerate(sorted_score_decks[:10], 1):\n    print(f\"{i}. Score: {score}, Deck: {deck}\")"}, {"role": "assistant", "content": "Sorting decks based on scores...\nTop 10 decks by increasing score:\n1. Score: 0, Deck: ('7', '5', '4', '3', '2')\n2. Score: 0, Deck: ('7', '5', '4', '2', '10')\n3. Score: 0, Deck: ('7', '5', '3', '2', '10')\n4. Score: 0, Deck: ('7', '4', '3', '2', '10')\n5. Score: 0, Deck: ('6', '5', '4', '3', '10')\n6. Score: 0, Deck: ('6', '5', '4', '3', '2')\n7. Score: 0, Deck: ('6', '5', '4', '2', '10')\n8. Score: 0, Deck: ('6', '5', '3', '2', '10')\n9. Score: 0, Deck: ('6', '4', '3', '2', '10')\n10. Score: 0, Deck: ('5', '4', '3', '2', '10')\n\nBottom 10 decks by decreasing score:\n1. Score: 4, Deck: ('10', 'A', 'J', 'K', 'Q')\n2. Score: 4, Deck: ('10', '9', 'A', 'K', 'Q')\n3. Score: 4, Deck: ('10', '9', 'A', 'J', 'K')\n4. Score: 4, Deck: ('10', '9', 'A', 'J', 'Q')\n5. Score: 4, Deck: ('10', '9', 'J', 'K', 'Q')\n6. Score: 4, Deck: ('10', '8', 'A', 'K', 'Q')\n7. Score: 4, Deck: ('10', '8', 'A', 'J', 'K')\n8. Score: 4, Deck: ('10', '8', 'A', 'J', 'Q')\n9. Score: 4, Deck: ('10', '8', 'J', 'K', 'Q')\n10. Score: 4, Deck: ('10', '8', '9', 'A', 'K')\n"}]}
{"messages": [{"role": "user", "content": "def generate_pattern(n):\n    pattern = []\n    for i in range(n):\n        row = [chr(65 + ((j + i) % 26)) for j in range(n)]\n        pattern.append(\"\".join(row))\n    return pattern\n\ndef custom_sort(pattern):\n    sorted_pattern = sorted(pattern, key=lambda x: (x[0], x[::-1]))\n    return sorted_pattern\n\npattern_size = 10\npattern = generate_pattern(pattern_size)\nprint(\"Generated Pattern:\")\nfor line in pattern:\n    print(line)\n\nsorted_pattern = custom_sort(pattern)\nprint(\"\\nSorted Pattern:\")\nfor line in sorted_pattern:\n    print(line)"}, {"role": "assistant", "content": "Generated Pattern:\nABCDEFGHIJ\nBCDEFGHIJK\nCDEFGHIJKL\nDEFGHIJKLM\nEFGHIJKLMN\nFGHIJKLMNO\nGHIJKLMNOP\nHIJKLMNOPQ\nIJKLMNOPQR\nJKLMNOPQRS\n\nSorted Pattern:\nABCDEFGHIJ\nBCDEFGHIJK\nCDEFGHIJKL\nDEFGHIJKLM\nEFGHIJKLMN\nFGHIJKLMNO\nGHIJKLMNOP\nHIJKLMNOPQ\nIJKLMNOPQR\nJKLMNOPQRS\n"}]}
{"messages": [{"role": "user", "content": "import re\nfrom collections import Counter\n\ntext = \"\"\"\nIn a village of La Mancha, the name of which I have no desire to call to mind, \nthere lived not long since one of those gentlemen that keep a lance in the lance-rack, \nan old buckler, a lean hack, and a greyhound for coursing. An olla of rather more beef \nthan mutton, a salad on most nights, scraps on Saturdays, lentils on Fridays, and a \npigeon or so extra on Sundays, made away with three-quarters of his income.\n\"\"\"\n\ndef sort_words_by_frequency(text):\n    words = re.findall(r'\\b\\w+\\b', text.lower())\n    frequency = Counter(words)\n    sorted_words = sorted(frequency.items(), key=lambda x: (-x[1], x[0]))\n    return sorted_words\n\ndef print_least_frequent_words(sorted_words, top_n=10):\n    for word, freq in sorted_words[-top_n:]:\n        print(f\"{word}: {freq}\")\n\nsorted_words = sort_words_by_frequency(text)\nprint_least_frequent_words(sorted_words)"}, {"role": "assistant", "content": "so: 1\nsundays: 1\nthan: 1\nthat: 1\nthere: 1\nthose: 1\nthree: 1\nvillage: 1\nwhich: 1\nwith: 1\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef sort_dates(dates):\n    return sorted(dates, key=lambda date: datetime.datetime.strptime(date, '%Y-%m-%d'))\n\ndates = [\n    \"2023-03-01\", \"2022-11-15\", \"2024-06-18\", \"2021-07-25\",\n    \"2023-12-31\", \"2022-01-01\", \"2024-08-09\", \"2020-12-12\",\n    \"2023-05-05\", \"2022-09-19\", \"2021-03-03\", \"2020-10-10\",\n    \"2024-02-20\", \"2023-04-04\", \"2022-06-06\", \"2021-02-22\"\n]\n\nsorted_dates = sort_dates(dates)\n\nfor date in sorted_dates:\n    print(date)"}, {"role": "assistant", "content": "2020-10-10\n2020-12-12\n2021-02-22\n2021-03-03\n2021-07-25\n2022-01-01\n2022-06-06\n2022-09-19\n2022-11-15\n2023-03-01\n2023-04-04\n2023-05-05\n2023-12-31\n2024-02-20\n2024-06-18\n2024-08-09\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef calculate_standard_deviation(data):\n    n = len(data)\n    mean = sum(data) / n\n    variance = sum((x - mean) ** 2 for x in data) / n\n    return math.sqrt(variance)\n\ndef median(data):\n    sorted_data = sorted(data)\n    n = len(sorted_data)\n    mid = n // 2\n    if n % 2 == 0:\n        return (sorted_data[mid - 1] + sorted_data[mid]) / 2\n    else:\n        return sorted_data[mid]\n\ndef get_outliers(data):\n    sorted_data = sorted(data)\n    q1_idx = len(sorted_data) // 4\n    q3_idx = 3 * len(sorted_data) // 4\n    Q1 = sorted_data[q1_idx]\n    Q3 = sorted_data[q3_idx]\n    IQR = Q3 - Q1\n    lower_bound = Q1 - 1.5 * IQR\n    upper_bound = Q3 + 1.5 * IQR\n    return [x for x in data if x < lower_bound or x > upper_bound]\n\ndata = [12, 15, 14, 10, 12, 18, 20, 22, 24, 25, 10, 14, 15, 18, 16, 14, 13, 19, 21, 23, 17, 16, 15]\nprint(\"Original Data: \", data)\nprint(\"Sorted Data: \", sorted(data))\n\nstd_dev = calculate_standard_deviation(data)\nprint(\"Standard Deviation: \", std_dev)\n\nmed = median(data)\nprint(\"Median: \", med)\n\noutliers = get_outliers(data)\nprint(\"Outliers: \", outliers)\n\nsorted_data = sorted(data)\nunique_values = list(dict.fromkeys(sorted_data))\nprint(\"Unique Sorted Values: \", unique_values)\n\nfor value in unique_values:\n    count = data.count(value)\n    print(f\"Value {value} appears {count} times\")"}, {"role": "assistant", "content": "Original Data:  [12, 15, 14, 10, 12, 18, 20, 22, 24, 25, 10, 14, 15, 18, 16, 14, 13, 19, 21, 23, 17, 16, 15]\nSorted Data:  [10, 10, 12, 12, 13, 14, 14, 14, 15, 15, 15, 16, 16, 17, 18, 18, 19, 20, 21, 22, 23, 24, 25]\nStandard Deviation:  4.207743334586159\nMedian:  16\nOutliers:  []\nUnique Sorted Values:  [10, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]\nValue 10 appears 2 times\nValue 12 appears 2 times\nValue 13 appears 1 times\nValue 14 appears 3 times\nValue 15 appears 3 times\nValue 16 appears 2 times\nValue 17 appears 1 times\nValue 18 appears 2 times\nValue 19 appears 1 times\nValue 20 appears 1 times\nValue 21 appears 1 times\nValue 22 appears 1 times\nValue 23 appears 1 times\nValue 24 appears 1 times\nValue 25 appears 1 times\n"}]}
{"messages": [{"role": "user", "content": "import string\n\ndef encode_message(message, key):\n    shifted_alphabet = string.ascii_lowercase[key:] + string.ascii_lowercase[:key]\n    table = str.maketrans(string.ascii_lowercase, shifted_alphabet)\n    return message.translate(table)\n\ndef sort_encoded_words(words):\n    word_keys = {word: sum(ord(char) for char in word) for word in words}\n    print(\"Word keys:\", word_keys)\n    sorted_words = sorted(words, key=lambda w: word_keys[w])\n    print(\"Sorted words:\", sorted_words)\n    return sorted_words\n\noriginal_message = \"this is a secret message for sorting\"\nencoded_message = encode_message(original_message.replace(\" \", \"\"), 3)\nprint(\"Encoded message:\", encoded_message)\n\nwords = [encoded_message[i:i+5] for i in range(0, len(encoded_message), 5)]\nprint(\"Words:\", words)\n\nsorted_words = sort_encoded_words(words)\n\nfor word in sorted_words:\n    print(word)"}, {"role": "assistant", "content": "Encoded message: wklvlvdvhfuhwphvvdjhiruvruwlqj\nWords: ['wklvl', 'vdvhf', 'uhwph', 'vvdjh', 'iruvr', 'uwlqj']\nWord keys: {'wklvl': 560, 'vdvhf': 542, 'uhwph': 556, 'vvdjh': 546, 'iruvr': 568, 'uwlqj': 563}\nSorted words: ['vdvhf', 'vvdjh', 'uhwph', 'wklvl', 'uwlqj', 'iruvr']\nvdvhf\nvvdjh\nuhwph\nwklvl\nuwlqj\niruvr\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef transform_dates(dates):\n    transformed = []\n    for date in dates:\n        dt = datetime.strptime(date, '%Y-%m-%d')\n        transformed.append(dt)\n    return transformed\n\ndef binary_search(arr, target, low, high):\n    if low > high:\n        return None\n    mid = (low + high) // 2\n    print(f\"Searching: low={low}, high={high}, mid={mid}, target={target}\")\n    if arr[mid] == target:\n        return mid\n    elif arr[mid] < target:\n        return binary_search(arr, target, mid + 1, high)\n    else:\n        return binary_search(arr, target, low, mid - 1)\n\ndef find_nearest_date(dates, target_date):\n    dates = transform_dates(dates)\n    dates.sort()\n    target_dt = datetime.strptime(target_date, '%Y-%m-%d')\n    index = binary_search(dates, target_dt, 0, len(dates) - 1)\n    \n    if index is not None:\n        return dates[index].strftime('%Y-%m-%d')\n    \n    closest = min(dates, key=lambda d: abs(d - target_dt))\n    return closest.strftime('%Y-%m-%d')\n\ndate_list = [\n    \"2023-01-01\", \"2024-05-23\", \"2025-11-15\", \"2022-08-30\", \"2023-07-04\",\n    \"2021-12-25\", \"2020-06-14\", \"2026-04-19\", \"2023-10-31\", \"2022-03-11\"\n]\n\ntarget = \"2023-09-15\"\nnearest_date = find_nearest_date(date_list, target)\nprint(f\"Nearest date to {target}: {nearest_date}\")"}, {"role": "assistant", "content": "Searching: low=0, high=9, mid=4, target=2023-09-15 00:00:00\nSearching: low=5, high=9, mid=7, target=2023-09-15 00:00:00\nSearching: low=5, high=6, mid=5, target=2023-09-15 00:00:00\nSearching: low=6, high=6, mid=6, target=2023-09-15 00:00:00\nNearest date to 2023-09-15: 2023-10-31\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndates = [\n    \"2023-11-15 13:45:30\",\n    \"2023-11-12 08:30:00\",\n    \"2023-11-18 09:15:45\",\n    \"2023-11-10 22:05:15\",\n    \"2023-11-20 16:30:25\",\n    \"2023-11-14 11:00:00\",\n    \"2023-11-16 17:25:10\",\n    \"2023-11-13 05:50:50\",\n    \"2023-11-19 20:35:00\",\n    \"2023-11-11 14:40:30\"\n]\n\ndate_objects = [datetime.strptime(date, \"%Y-%m-%d %H:%M:%S\") for date in dates]\n\nthreshold_date = datetime.strptime(\"2023-11-15 00:00:00\", \"%Y-%m-%d %H:%M:%S\")\nfiltered_dates = [date for date in date_objects if date > threshold_date]\n\nprint(\"Filtered Dates:\")\nfor date in filtered_dates:\n    print(date.strftime(\"%Y-%m-%d %H:%M:%S\"))\n\nsorted_dates = sorted(filtered_dates, key=lambda x: x.hour * 60 + x.minute)\n\nprint(\"\\nSorted Dates by Time of Day:\")\nfor date in sorted_dates:\n    print(date.strftime(\"%Y-%m-%d %H:%M:%S\"))\n\nmin_date = min(filtered_dates)\nmax_date = max(filtered_dates)\n\ntime_difference = max_date - min_date\n\nprint(\"\\nMin Date:\", min_date.strftime(\"%Y-%m-%d %H:%M:%S\"))\nprint(\"Max Date:\", max_date.strftime(\"%Y-%m-%d %H:%M:%S\"))\nprint(\"Time Difference:\", time_difference)\n\nprint(\"\\nTime sorted within same day:\")\nday_sorted_dates = sorted(filtered_dates, key=lambda x: (x.date(), x.hour, x.minute))\nfor date in day_sorted_dates:\n    print(date.strftime(\"%Y-%m-%d %H:%M:%S\"))"}, {"role": "assistant", "content": "Filtered Dates:\n2023-11-15 13:45:30\n2023-11-18 09:15:45\n2023-11-20 16:30:25\n2023-11-16 17:25:10\n2023-11-19 20:35:00\n\nSorted Dates by Time of Day:\n2023-11-18 09:15:45\n2023-11-15 13:45:30\n2023-11-20 16:30:25\n2023-11-16 17:25:10\n2023-11-19 20:35:00\n\nMin Date: 2023-11-15 13:45:30\nMax Date: 2023-11-20 16:30:25\nTime Difference: 5 days, 2:44:55\n\nTime sorted within same day:\n2023-11-15 13:45:30\n2023-11-16 17:25:10\n2023-11-18 09:15:45\n2023-11-19 20:35:00\n2023-11-20 16:30:25\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndata = [\n    {\"name\": \"Alice\", \"scores\": [88, 92, 79]},\n    {\"name\": \"Bob\", \"scores\": [95, 85, 91]},\n    {\"name\": \"Charlie\", \"scores\": [70, 89, 84]},\n    {\"name\": \"David\", \"scores\": [88, 92, 100]},\n    {\"name\": \"Eve\", \"scores\": [91, 85, 87]},\n]\n\ndef median_score(student):\n    median = statistics.median(student[\"scores\"])\n    print(f\"Calculating median for {student['name']}: {median}\")\n    return median\n\nsorted_students = sorted(data, key=median_score)\n\nfor student in sorted_students:\n    print(f\"{student['name']} - Scores: {student['scores']}, Median: {statistics.median(student['scores'])}\")"}, {"role": "assistant", "content": "Calculating median for Alice: 88\nCalculating median for Bob: 91\nCalculating median for Charlie: 84\nCalculating median for David: 92\nCalculating median for Eve: 87\nCharlie - Scores: [70, 89, 84], Median: 84\nEve - Scores: [91, 85, 87], Median: 87\nAlice - Scores: [88, 92, 79], Median: 88\nBob - Scores: [95, 85, 91], Median: 91\nDavid - Scores: [88, 92, 100], Median: 92\n"}]}
{"messages": [{"role": "user", "content": "from itertools import permutations\n\ndef lexicographic_sort(n):\n    digits = [str(i) for i in range(n)]\n    perm = [''.join(p) for p in permutations(digits)]\n    print(\"Initial permutations:\")\n    print(perm[:10], \"...\")  # Show a sample of permutations\n    perm.sort()\n    print(\"Sorted permutations:\")\n    print(perm[:10], \"...\")  # Show a sample of sorted permutations\n    return perm\n\ndef find_gap_sequence(perm):\n    print(\"Calculating gaps...\")\n    gap_sequence = []\n    for i in range(1, len(perm)):\n        prev_value = int(perm[i-1])\n        curr_value = int(perm[i])\n        gap = abs(curr_value - prev_value)\n        gap_sequence.append(gap)\n        if i < 10:  # Show a sample of the gap sequence\n            print(f\"Gap between {perm[i-1]} and {perm[i]}: {gap}\")\n    return gap_sequence\n\ndef main():\n    n = 5\n    print(f\"Generating lexicographic permutations for digits 0 to {n-1}\")\n    perm = lexicographic_sort(n)\n    gap_sequence = find_gap_sequence(perm)\n    print(\"Final gap sequence (first 100):\")\n    print(gap_sequence[:100])\n\nmain()"}, {"role": "assistant", "content": "Generating lexicographic permutations for digits 0 to 4\nInitial permutations:\n['01234', '01243', '01324', '01342', '01423', '01432', '02134', '02143', '02314', '02341'] ...\nSorted permutations:\n['01234', '01243', '01324', '01342', '01423', '01432', '02134', '02143', '02314', '02341'] ...\nCalculating gaps...\nGap between 01234 and 01243: 9\nGap between 01243 and 01324: 81\nGap between 01324 and 01342: 18\nGap between 01342 and 01423: 81\nGap between 01423 and 01432: 9\nGap between 01432 and 02134: 702\nGap between 02134 and 02143: 9\nGap between 02143 and 02314: 171\nGap between 02314 and 02341: 27\nFinal gap sequence (first 100):\n[9, 81, 18, 81, 9, 702, 9, 171, 27, 72, 18, 693, 18, 72, 27, 171, 9, 702, 9, 81, 18, 81, 9, 5913, 9, 81, 18, 81, 9, 1602, 9, 261, 36, 63, 27, 594, 18, 162, 36, 162, 18, 603, 9, 171, 27, 72, 18, 5814, 9, 171, 27, 72, 18, 603, 9, 261, 36, 63, 27, 1584, 27, 63, 36, 261, 9, 603, 18, 72, 27, 171, 9, 5814, 18, 72, 27, 171, 9, 603, 18, 162, 36, 162, 18, 594, 27, 63, 36, 261, 9, 1602, 9, 81, 18, 81, 9, 5913, 9, 81, 18, 81]\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef sort_sentences_by_word_count(text):\n    sentences = re.split(r'[.!?]', text)\n    sentences = [s.strip() for s in sentences if s.strip()]\n    sorted_sentences = sorted(sentences, key=lambda s: len(s.split()), reverse=True)\n    return sorted_sentences\n\ntext = \"\"\"\nOnce upon a time in a land far away, there was a beautiful princess who lived in a grand castle.\nShe loved to explore the gardens and often wandered into the forest to find new adventures.\nOne day, she found an enchanted pond that shimmered in the sunlight.\nThe pond was home to many magical creatures, including a talking frog who loved to tell stories.\nThe princess and the frog became fast friends, sharing tales of wonder and mystery from their respective worlds.\nAs the days turned into weeks, their friendship blossomed, and they learned much from each other.\n\"\"\"\n\nsorted_sentences = sort_sentences_by_word_count(text)\nfor idx, sentence in enumerate(sorted_sentences, 1):\n    print(f\"{idx}: {sentence}\")"}, {"role": "assistant", "content": "1: Once upon a time in a land far away, there was a beautiful princess who lived in a grand castle\n2: The princess and the frog became fast friends, sharing tales of wonder and mystery from their respective worlds\n3: The pond was home to many magical creatures, including a talking frog who loved to tell stories\n4: She loved to explore the gardens and often wandered into the forest to find new adventures\n5: As the days turned into weeks, their friendship blossomed, and they learned much from each other\n6: One day, she found an enchanted pond that shimmered in the sunlight\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef is_close(value, target, tolerance=0.1):\n    return abs(value - target) <= tolerance\n\ndef find_closest_square_root(numbers, target):\n    closest = None\n    closest_diff = float('inf')\n    \n    for number in numbers:\n        sqrt_value = math.sqrt(number)\n        diff = abs(sqrt_value - target)\n        print(f\"Number: {number}, Sqrt: {sqrt_value}, Target: {target}, Diff: {diff}\")\n        if diff < closest_diff:\n            closest_diff = diff\n            closest = number\n            print(f\"New closest: {closest} with diff: {closest_diff}\")\n    \n    return closest\n\nnumbers = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71]\ntarget_sqrt = 5.2\ntolerance = 0.1\n\nclosest_number = find_closest_square_root(numbers, target_sqrt)\nprint(f\"Closest number with a square root near {target_sqrt}: {closest_number}\")"}, {"role": "assistant", "content": "Number: 2, Sqrt: 1.4142135623730951, Target: 5.2, Diff: 3.7857864376269053\nNew closest: 2 with diff: 3.7857864376269053\nNumber: 3, Sqrt: 1.7320508075688772, Target: 5.2, Diff: 3.467949192431123\nNew closest: 3 with diff: 3.467949192431123\nNumber: 5, Sqrt: 2.23606797749979, Target: 5.2, Diff: 2.9639320225002104\nNew closest: 5 with diff: 2.9639320225002104\nNumber: 7, Sqrt: 2.6457513110645907, Target: 5.2, Diff: 2.5542486889354095\nNew closest: 7 with diff: 2.5542486889354095\nNumber: 11, Sqrt: 3.3166247903554, Target: 5.2, Diff: 1.8833752096446004\nNew closest: 11 with diff: 1.8833752096446004\nNumber: 13, Sqrt: 3.605551275463989, Target: 5.2, Diff: 1.594448724536011\nNew closest: 13 with diff: 1.594448724536011\nNumber: 17, Sqrt: 4.123105625617661, Target: 5.2, Diff: 1.0768943743823396\nNew closest: 17 with diff: 1.0768943743823396\nNumber: 19, Sqrt: 4.358898943540674, Target: 5.2, Diff: 0.8411010564593262\nNew closest: 19 with diff: 0.8411010564593262\nNumber: 23, Sqrt: 4.795831523312719, Target: 5.2, Diff: 0.40416847668728106\nNew closest: 23 with diff: 0.40416847668728106\nNumber: 29, Sqrt: 5.385164807134504, Target: 5.2, Diff: 0.18516480713450356\nNew closest: 29 with diff: 0.18516480713450356\nNumber: 31, Sqrt: 5.5677643628300215, Target: 5.2, Diff: 0.36776436283002134\nNumber: 37, Sqrt: 6.082762530298219, Target: 5.2, Diff: 0.8827625302982192\nNumber: 41, Sqrt: 6.4031242374328485, Target: 5.2, Diff: 1.2031242374328484\nNumber: 43, Sqrt: 6.557438524302, Target: 5.2, Diff: 1.3574385243020002\nNumber: 47, Sqrt: 6.855654600401044, Target: 5.2, Diff: 1.6556546004010437\nNumber: 53, Sqrt: 7.280109889280518, Target: 5.2, Diff: 2.080109889280518\nNumber: 59, Sqrt: 7.681145747868608, Target: 5.2, Diff: 2.4811457478686076\nNumber: 61, Sqrt: 7.810249675906654, Target: 5.2, Diff: 2.610249675906654\nNumber: 67, Sqrt: 8.18535277187245, Target: 5.2, Diff: 2.98535277187245\nNumber: 71, Sqrt: 8.426149773176359, Target: 5.2, Diff: 3.226149773176359\nClosest number with a square root near 5.2: 29\n"}]}
{"messages": [{"role": "user", "content": "import math\n\npoints = [(2, 3), (1, 7), (4, 4), (6, 2), (5, 8), (3, 1)]\n\ndef distance_from_origin(point):\n    return math.sqrt(point[0]**2 + point[1]**2)\n\ndef sort_points_by_distance(points):\n    print(f\"Original points: {points}\")\n    sorted_points = sorted(points, key=distance_from_origin)\n    print(f\"Points sorted by distance from origin: {sorted_points}\")\n    return sorted_points\n\ndef calculate_polygon_area(points):\n    print(f\"Calculating area for points: {points}\")\n    n = len(points)\n    area = 0.0\n    for i in range(n):\n        j = (i + 1) % n\n        area += points[i][0] * points[j][1]\n        area -= points[j][0] * points[i][1]\n    area = abs(area) / 2.0\n    print(f\"Calculated area: {area}\\n\")\n    return area\n\nsorted_points = sort_points_by_distance(points)\n\nprint(\"Areas of polygons formed by sorted points:\")\nareas = []\nfor i in range(2, len(sorted_points) + 1):\n    polygon_points = sorted_points[:i]\n    area = calculate_polygon_area(polygon_points)\n    areas.append(area)\n\nprint(\"Final list of polygon areas:\")\nfor a in areas:\n    print(a)"}, {"role": "assistant", "content": "Original points: [(2, 3), (1, 7), (4, 4), (6, 2), (5, 8), (3, 1)]\nPoints sorted by distance from origin: [(3, 1), (2, 3), (4, 4), (6, 2), (1, 7), (5, 8)]\nAreas of polygons formed by sorted points:\nCalculating area for points: [(3, 1), (2, 3)]\nCalculated area: 0.0\n\nCalculating area for points: [(3, 1), (2, 3), (4, 4)]\nCalculated area: 2.5\n\nCalculating area for points: [(3, 1), (2, 3), (4, 4), (6, 2)]\nCalculated area: 6.5\n\nCalculating area for points: [(3, 1), (2, 3), (4, 4), (6, 2), (1, 7)]\nCalculated area: 3.5\n\nCalculating area for points: [(3, 1), (2, 3), (4, 4), (6, 2), (1, 7), (5, 8)]\nCalculated area: 9.5\n\nFinal list of polygon areas:\n0.0\n2.5\n6.5\n3.5\n9.5\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef sort_dates_by_day_of_week(dates):\n    return sorted(dates, key=lambda date: date.weekday())\n\ndef transform_dates(dates):\n    transformed = []\n    for date in dates:\n        if date.weekday() in [0, 1, 2]:  # Mon, Tue, Wed\n            transformed.append(date + timedelta(days=3))  # Move to Thu, Fri, Sat\n        elif date.weekday() in [3, 4]:  # Thu, Fri\n            transformed.append(date - timedelta(days=2))  # Move to Tue, Wed\n        else:  # Sat, Sun\n            transformed.append(date + timedelta(days=1))  # Move to Sun, Mon\n    return transformed\n\ninitial_dates = [\n    datetime(2023, 10, 1),  # Sunday\n    datetime(2023, 10, 2),  # Monday\n    datetime(2023, 10, 3),  # Tuesday\n    datetime(2023, 10, 4),  # Wednesday\n    datetime(2023, 10, 5),  # Thursday\n    datetime(2023, 10, 6),  # Friday\n    datetime(2023, 10, 7),  # Saturday\n]\n\nprint(\"Initial Dates:\")\nfor date in initial_dates:\n    print(date.strftime(\"%A, %Y-%m-%d\"))\n\ntransformed_dates = transform_dates(initial_dates)\n\nprint(\"\\nTransformed Dates:\")\nfor date in transformed_dates:\n    print(date.strftime(\"%A, %Y-%m-%d\"))\n\nsorted_transformed_dates = sort_dates_by_day_of_week(transformed_dates)\n\nprint(\"\\nSorted Transformed Dates by Day of Week:\")\nfor date in sorted_transformed_dates:\n    print(date.strftime(\"%A, %Y-%m-%d\"))"}, {"role": "assistant", "content": "Initial Dates:\nSunday, 2023-10-01\nMonday, 2023-10-02\nTuesday, 2023-10-03\nWednesday, 2023-10-04\nThursday, 2023-10-05\nFriday, 2023-10-06\nSaturday, 2023-10-07\n\nTransformed Dates:\nMonday, 2023-10-02\nThursday, 2023-10-05\nFriday, 2023-10-06\nSaturday, 2023-10-07\nTuesday, 2023-10-03\nWednesday, 2023-10-04\nSunday, 2023-10-08\n\nSorted Transformed Dates by Day of Week:\nMonday, 2023-10-02\nTuesday, 2023-10-03\nWednesday, 2023-10-04\nThursday, 2023-10-05\nFriday, 2023-10-06\nSaturday, 2023-10-07\nSunday, 2023-10-08\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef find_nearest_date(dates, target):\n    low, high = 0, len(dates) - 1\n    closest_date = dates[0]\n    \n    while low <= high:\n        mid = (low + high) // 2\n        mid_date = dates[mid]\n        \n        if mid_date < target:\n            low = mid + 1\n        elif mid_date > target:\n            high = mid - 1\n        else:\n            return mid_date\n        \n        if abs((mid_date - target).days) < abs((closest_date - target).days):\n            closest_date = mid_date\n    \n    return closest_date\n\ndates = [datetime.date(2022, 7, 1),\n         datetime.date(2022, 8, 15),\n         datetime.date(2022, 9, 10),\n         datetime.date(2022, 10, 5),\n         datetime.date(2022, 11, 12),\n         datetime.date(2022, 12, 25)]\n\ntarget_date = datetime.date(2022, 10, 1)\nnearest_date = find_nearest_date(dates, target_date)\n\nfor dt in dates:\n    is_nearest = \" <- Nearest\" if dt == nearest_date else \"\"\n    print(f\"{dt}{is_nearest}\")"}, {"role": "assistant", "content": "2022-07-01\n2022-08-15\n2022-09-10\n2022-10-05 <- Nearest\n2022-11-12\n2022-12-25\n"}]}
{"messages": [{"role": "user", "content": "def fibonacci_sequence(n):\n    fib_seq = [0, 1]\n    for i in range(2, n):\n        fib_seq.append(fib_seq[-1] + fib_seq[-2])\n    return fib_seq\n\ndef is_in_sequence(sequence, number):\n    low, high = 0, len(sequence) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if sequence[mid] == number:\n            return True\n        elif sequence[mid] < number:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return False\n\nfib_seq = fibonacci_sequence(100)\nsearch_numbers = [8, 14, 21, 4, 55, 89, 144, 233]\n\nresults = {}\nfor number in search_numbers:\n    results[number] = is_in_sequence(fib_seq, number)\n\nfor number, found in sorted(results.items()):\n    print(f\"{number}: {'Found' if found else 'Not Found'}\")"}, {"role": "assistant", "content": "4: Not Found\n8: Found\n14: Not Found\n21: Found\n55: Found\n89: Found\n144: Found\n233: Found\n"}]}
{"messages": [{"role": "user", "content": "def merge_sort(cards):\n    if len(cards) > 1:\n        mid = len(cards) // 2\n        left_half = cards[:mid]\n        right_half = cards[mid:]\n\n        merge_sort(left_half)\n        merge_sort(right_half)\n\n        i = j = k = 0\n        \n        while i < len(left_half) and j < len(right_half):\n            if left_half[i][1] < right_half[j][1]:\n                cards[k] = left_half[i]\n                i += 1\n            else:\n                cards[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            cards[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            cards[k] = right_half[j]\n            j += 1\n            k += 1\n\ncard_deck = [\n    ('Ace', 1), ('King', 13), ('Queen', 12), ('Jack', 11),\n    ('Ten', 10), ('Nine', 9), ('Eight', 8), ('Seven', 7), \n    ('Six', 6), ('Five', 5), ('Four', 4), ('Three', 3), ('Two', 2)\n]\n\nplayer_hand = [\n    ('King', 13), ('Five', 5), ('Ace', 1), ('Nine', 9), \n    ('Two', 2), ('Queen', 12), ('Seven', 7)\n]\n\nmerge_sort(player_hand)\n\nfor card in player_hand:\n    print(card)"}, {"role": "assistant", "content": "('Ace', 1)\n('Two', 2)\n('Five', 5)\n('Seven', 7)\n('Nine', 9)\n('Queen', 12)\n('King', 13)\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef encode_message(message):\n    words = message.split()\n    encoded_words = []\n    for word in words:\n        sorted_word = ''.join(sorted(word))\n        encoded_words.append(sorted_word)\n    return ' '.join(encoded_words)\n\ndef decode_message(encoded_message):\n    words = encoded_message.split()\n    decoded_words = []\n    for word in words:\n        possible_words = []\n        for i in range(len(word)):\n            for j in range(i+1, len(word)+1):\n                possible_word = word[i:j]\n                possible_words.append(possible_word)\n        possible_words = list(set(possible_words))\n        decoded_words.append(sorted(possible_words))\n    return decoded_words\n\nmessage = \"encryption is fun and challenging\"\nencoded_message = encode_message(message)\ndecoded_words_list = decode_message(encoded_message)\n\nprint(\"Original Message:\")\nprint(message)\nprint(\"\\nEncoded Message:\")\nprint(encoded_message)\nprint(\"\\nDecoded Words List:\")\nfor i, words in enumerate(decoded_words_list):\n    print(f\"Word {i+1}: {words}\")"}, {"role": "assistant", "content": "Original Message:\nencryption is fun and challenging\n\nEncoded Message:\nceinnoprty is fnu adn acegghillnn\n\nDecoded Words List:\nWord 1: ['c', 'ce', 'cei', 'cein', 'ceinn', 'ceinno', 'ceinnop', 'ceinnopr', 'ceinnoprt', 'ceinnoprty', 'e', 'ei', 'ein', 'einn', 'einno', 'einnop', 'einnopr', 'einnoprt', 'einnoprty', 'i', 'in', 'inn', 'inno', 'innop', 'innopr', 'innoprt', 'innoprty', 'n', 'nn', 'nno', 'nnop', 'nnopr', 'nnoprt', 'nnoprty', 'no', 'nop', 'nopr', 'noprt', 'noprty', 'o', 'op', 'opr', 'oprt', 'oprty', 'p', 'pr', 'prt', 'prty', 'r', 'rt', 'rty', 't', 'ty', 'y']\nWord 2: ['i', 'is', 's']\nWord 3: ['f', 'fn', 'fnu', 'n', 'nu', 'u']\nWord 4: ['a', 'ad', 'adn', 'd', 'dn', 'n']\nWord 5: ['a', 'ac', 'ace', 'aceg', 'acegg', 'aceggh', 'acegghi', 'acegghil', 'acegghill', 'acegghilln', 'acegghillnn', 'c', 'ce', 'ceg', 'cegg', 'ceggh', 'cegghi', 'cegghil', 'cegghill', 'cegghilln', 'cegghillnn', 'e', 'eg', 'egg', 'eggh', 'egghi', 'egghil', 'egghill', 'egghilln', 'egghillnn', 'g', 'gg', 'ggh', 'gghi', 'gghil', 'gghill', 'gghilln', 'gghillnn', 'gh', 'ghi', 'ghil', 'ghill', 'ghilln', 'ghillnn', 'h', 'hi', 'hil', 'hill', 'hilln', 'hillnn', 'i', 'il', 'ill', 'illn', 'illnn', 'l', 'll', 'lln', 'llnn', 'ln', 'lnn', 'n', 'nn']\n"}]}
{"messages": [{"role": "user", "content": "import itertools\n\ndef board_to_string(board):\n    return '\\n'.join(' '.join(row) for row in board)\n\ndef get_neighbors(position, board_size):\n    x, y = position\n    neighbors = []\n    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        nx, ny = x + dx, y + dy\n        if 0 <= nx < board_size and 0 <= ny < board_size:\n            neighbors.append((nx, ny))\n    return neighbors\n\ndef bfs_paths(start, goal, board_size):\n    queue = [(start, [start])]\n    while queue:\n        (vertex, path) = queue.pop(0)\n        for next in set(get_neighbors(vertex, board_size)) - set(path):\n            if next == goal:\n                yield path + [next]\n            else:\n                queue.append((next, path + [next]))\n\ndef search_knight_moves(board_size):\n    board = [['.' for _ in range(board_size)] for _ in range(board_size)]\n    start = (0, 0)\n    goal = (board_size - 1, board_size - 1)\n\n    all_paths = list(bfs_paths(start, goal, board_size))\n    best_path = min(all_paths, key=len)\n\n    for x, y in best_path:\n        board[x][y] = 'X'\n        print(board_to_string(board))\n        print(\"----\")\n\nsearch_knight_moves(5)"}, {"role": "assistant", "content": "X . . . .\n. . . . .\n. . . . .\n. . . . .\n. . . . .\n----\nX . . . .\nX . . . .\n. . . . .\n. . . . .\n. . . . .\n----\nX . . . .\nX X . . .\n. . . . .\n. . . . .\n. . . . .\n----\nX . . . .\nX X X . .\n. . . . .\n. . . . .\n. . . . .\n----\nX . . . .\nX X X X .\n. . . . .\n. . . . .\n. . . . .\n----\nX . . . .\nX X X X .\n. . . X .\n. . . . .\n. . . . .\n----\nX . . . .\nX X X X .\n. . . X X\n. . . . .\n. . . . .\n----\nX . . . .\nX X X X .\n. . . X X\n. . . . X\n. . . . .\n----\nX . . . .\nX X X X .\n. . . X X\n. . . . X\n. . . . X\n----\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef encode_message(message):\n    encoded = []\n    for char in message:\n        encoded.append(ord(char) * 3)\n    return encoded\n\ndef binary_search_encode(arr, target):\n    low, high = 0, len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        print(f\"Searching: low={low}, mid={mid}, high={high}\")\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n\ndef decode_message(encoded):\n    decoded = ''\n    for num in encoded:\n        decoded += chr(num // 3)\n    return decoded\n\ndef main():\n    secret_message = \"Advanced Encryption\"\n    print(f\"Secret Message: {secret_message}\")\n\n    encoded_msg = encode_message(secret_message)\n    print(f\"Encoded Message: {encoded_msg}\")\n\n    target_value = 999  # Arbitrary target for search, doesn't exist in encoded_msg\n    found_index = binary_search_encode(encoded_msg, target_value)\n    print(f\"Target {target_value} found at index: {found_index}\")\n\n    if found_index != -1:\n        print(f\"Decoding found value: {decode_message([encoded_msg[found_index]])}\")\n    else:\n        print(\"Target value not found in encoded message.\")\n\n    decoded_msg = decode_message(encoded_msg)\n    print(f\"Decoded Message: {decoded_msg}\")\n\nmain()"}, {"role": "assistant", "content": "Secret Message: Advanced Encryption\nEncoded Message: [195, 300, 354, 291, 330, 297, 303, 300, 96, 207, 330, 297, 342, 363, 336, 348, 315, 333, 330]\nSearching: low=0, mid=9, high=18\nSearching: low=10, mid=14, high=18\nSearching: low=15, mid=16, high=18\nSearching: low=17, mid=17, high=18\nSearching: low=18, mid=18, high=18\nTarget 999 found at index: -1\nTarget value not found in encoded message.\nDecoded Message: Advanced Encryption\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"\nIn a village of La Mancha, the name of which I have no desire to call to mind, there lived not long since one of those gentlemen that keep a lance in the lance-rack, an old buckler, a lean hack, and a greyhound for coursing. An olla of rather more beef than mutton, a salad on most nights, scraps on Saturdays, lentils on Fridays, and a pigeon or so extra on Sundays, made away with three-quarters of his income.\n\"\"\"\n\ndef knuth_morris_pratt(text, pattern):\n    def build_kmp_table(pattern):\n        table = [0] * len(pattern)\n        j = 0\n        for i in range(1, len(pattern)):\n            while j > 0 and pattern[i] != pattern[j]:\n                j = table[j - 1]\n            if pattern[i] == pattern[j]:\n                j += 1\n            table[i] = j\n        return table\n\n    table = build_kmp_table(pattern)\n    j = 0\n    matches = []\n    for i in range(len(text)):\n        while j > 0 and text[i] != pattern[j]:\n            j = table[j - 1]\n        if text[i] == pattern[j]:\n            j += 1\n        if j == len(pattern):\n            matches.append(i - j + 1)\n            j = table[j - 1]\n    return matches\n\npattern = 'of'\nmatches = knuth_morris_pratt(text, pattern)\nfor start in matches:\n    print(f\"Match found at index {start}: {text[start:start+len(pattern)]}\")"}, {"role": "assistant", "content": "Match found at index 14: of\nMatch found at index 37: of\nMatch found at index 111: of\nMatch found at index 234: of\nMatch found at index 399: of\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef generate_pattern(n):\n    pattern = []\n    for i in range(1, n + 1):\n        row = []\n        for j in range(1, n + 1):\n            val = (i * j) % 10\n            row.append(val)\n        pattern.append(row)\n    return pattern\n\ndef pattern_to_string(pattern):\n    return [' '.join(str(x) for x in row) for row in pattern]\n\ndef sort_pattern_lines(pattern_lines):\n    def custom_sort_key(line):\n        return sum(int(x) for x in line.split()) / len(line)\n    sorted_lines = sorted(pattern_lines, key=custom_sort_key, reverse=True)\n    return sorted_lines\n\nn = 10\npattern = generate_pattern(n)\npattern_lines = pattern_to_string(pattern)\nsorted_pattern = sort_pattern_lines(pattern_lines)\n\nfor line in sorted_pattern:\n    print(line)"}, {"role": "assistant", "content": "1 2 3 4 5 6 7 8 9 0\n3 6 9 2 5 8 1 4 7 0\n7 4 1 8 5 2 9 6 3 0\n9 8 7 6 5 4 3 2 1 0\n2 4 6 8 0 2 4 6 8 0\n4 8 2 6 0 4 8 2 6 0\n6 2 8 4 0 6 2 8 4 0\n8 6 4 2 0 8 6 4 2 0\n5 0 5 0 5 0 5 0 5 0\n0 0 0 0 0 0 0 0 0 0\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef generate_pattern(n):\n    pattern = ''\n    for i in range(1, n + 1):\n        pattern += str(i) * i + '\\n'\n    return pattern\n\ndef search_pattern(pattern, target):\n    lines = pattern.strip().split('\\n')\n    for line in lines:\n        if re.search(target, line):\n            return line\n    return \"Not Found\"\n\ndef main():\n    n = 10\n    pattern = generate_pattern(n)\n    target_pattern = \"5{5}\"\n    found_line = search_pattern(pattern, target_pattern)\n    print(found_line)\n\nif __name__ == \"__main__\":\n    main()"}, {"role": "assistant", "content": "55555\n"}]}
{"messages": [{"role": "user", "content": "import math\nimport statistics\n\ndef find_closest_mean(data):\n    mean = statistics.mean(data)\n    closest_value = data[0]\n    min_diff = float('inf')\n    for value in data:\n        diff = abs(value - mean)\n        if diff < min_diff:\n            min_diff = diff\n            closest_value = value\n    return closest_value\n\ndef search_median(data):\n    data = sorted(data)\n    n = len(data)\n    if n % 2 == 0:\n        return (data[n // 2 - 1] + data[n // 2]) / 2\n    else:\n        return data[n // 2]\n\ndef process_data(data):\n    closest_median = find_closest_mean(data)\n    median_value = search_median(data)\n    return closest_median, median_value\n\ndata = [3, 6, 9, 12, 15, 18, 21, 24, 27, 30]\nclosest_median, median_value = process_data(data)\n\nprint(f\"Closest to median: {closest_median}\")\nprint(f\"Median: {median_value}\")"}, {"role": "assistant", "content": "Closest to median: 15\nMedian: 16.5\n"}]}
{"messages": [{"role": "user", "content": "import math\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def distance(self, other):\n        return math.sqrt((self.x - other.x) ** 2 + (self.y - other.y) ** 2)\n\nclass Polygon:\n    def __init__(self, vertices):\n        self.vertices = vertices\n\n    def perimeter(self):\n        return sum(self.vertices[i].distance(self.vertices[(i + 1) % len(self.vertices)])\n                   for i in range(len(self.vertices)))\n\ndef search_polygon_with_target_perimeter(polygons, target, tolerance=1e-6):\n    polygons.sort(key=lambda p: p.perimeter())\n    low, high = 0, len(polygons) - 1\n    \n    while low <= high:\n        mid = (low + high) // 2\n        perimeter = polygons[mid].perimeter()\n        \n        if abs(perimeter - target) <= tolerance:\n            return polygons[mid]\n        elif perimeter < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return None\n\npolygons = [\n    Polygon([Point(0, 0), Point(3, 0), Point(3, 4)]),\n    Polygon([Point(0, 0), Point(1, 0), Point(1, 1), Point(0, 1)]),\n    Polygon([Point(0, 0), Point(0, 2), Point(2, 2), Point(2, 0)]),\n    Polygon([Point(0, 0), Point(4, 0), Point(4, 3), Point(0, 3)]),\n    Polygon([Point(0, 0), Point(5, 0), Point(5, 5), Point(0, 5)])\n]\n\ntarget_perimeter = 12\nresult_polygon = search_polygon_with_target_perimeter(polygons, target_perimeter)\n\nif result_polygon:\n    for vertex in result_polygon.vertices:\n        print(f\"({vertex.x}, {vertex.y})\")\nelse:\n    print(\"No polygon found with the target perimeter.\")"}, {"role": "assistant", "content": "(0, 0)\n(3, 0)\n(3, 4)\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef find_friday_13ths(start_year, end_year):\n    friday_13ths = []\n    for year in range(start_year, end_year + 1):\n        for month in range(1, 13):\n            date = datetime(year, month, 13)\n            if date.weekday() == 4:\n                friday_13ths.append(date.strftime(\"%Y-%m-%d\"))\n    return friday_13ths\n\ndef search_nearest_friday_13th(reference_date_str):\n    reference_date = datetime.strptime(reference_date_str, \"%Y-%m-%d\")\n    start_year = reference_date.year - 1\n    end_year = reference_date.year + 1\n    all_friday_13ths = find_friday_13ths(start_year, end_year)\n    nearest_date = min(all_friday_13ths, key=lambda d: abs((datetime.strptime(d, \"%Y-%m-%d\") - reference_date).days))\n    return nearest_date\n\nreference_date = \"2022-07-23\"\nnearest_friday_13th = search_nearest_friday_13th(reference_date)\nprint(nearest_friday_13th)\n\nall_friday_13ths = find_friday_13ths(2000, 2025)\nfor date in all_friday_13ths:\n    print(date)"}, {"role": "assistant", "content": "2022-05-13\n2000-10-13\n2001-04-13\n2001-07-13\n2002-09-13\n2002-12-13\n2003-06-13\n2004-02-13\n2004-08-13\n2005-05-13\n2006-01-13\n2006-10-13\n2007-04-13\n2007-07-13\n2008-06-13\n2009-02-13\n2009-03-13\n2009-11-13\n2010-08-13\n2011-05-13\n2012-01-13\n2012-04-13\n2012-07-13\n2013-09-13\n2013-12-13\n2014-06-13\n2015-02-13\n2015-03-13\n2015-11-13\n2016-05-13\n2017-01-13\n2017-10-13\n2018-04-13\n2018-07-13\n2019-09-13\n2019-12-13\n2020-03-13\n2020-11-13\n2021-08-13\n2022-05-13\n2023-01-13\n2023-10-13\n2024-09-13\n2024-12-13\n2025-06-13\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\ndata = [\n    {'name': 'Alice', 'birthdate': '1990-04-12'},\n    {'name': 'Bob', 'birthdate': '1985-06-23'},\n    {'name': 'Charlie', 'birthdate': '1992-01-15'},\n    {'name': 'David', 'birthdate': '1988-12-30'},\n    {'name': 'Eva', 'birthdate': '1995-07-04'},\n    {'name': 'Frank', 'birthdate': '1982-09-21'},\n    {'name': 'Grace', 'birthdate': '1991-11-11'},\n    {'name': 'Hannah', 'birthdate': '1987-03-03'},\n    {'name': 'Ian', 'birthdate': '1989-05-14'},\n    {'name': 'Judy', 'birthdate': '1983-08-25'}\n]\n\nfor person in data:\n    person['age'] = (datetime.now() - datetime.strptime(person['birthdate'], '%Y-%m-%d')).days // 365\n\ndata_sorted_by_age = sorted(data, key=lambda x: x['age'])\n\nfor person in data_sorted_by_age:\n    print(f\"{person['name']} is {person['age']} years old\")"}, {"role": "assistant", "content": "Eva is 29 years old\nCharlie is 33 years old\nGrace is 33 years old\nAlice is 34 years old\nIan is 35 years old\nDavid is 36 years old\nHannah is 38 years old\nBob is 39 years old\nJudy is 41 years old\nFrank is 42 years old\n"}]}
{"messages": [{"role": "user", "content": "def simulate_player_scores(players, rounds):\n    scores = [0] * players\n    for round_num in range(1, rounds + 1):\n        for player in range(players):\n            scores[player] += (player + 1) * round_num\n    return scores\n\ndef determine_ranking(scores):\n    indexed_scores = list(enumerate(scores))\n    indexed_scores.sort(key=lambda x: x[1], reverse=True)\n    return [index for index, score in indexed_scores]\n\nplayers = 10\nrounds = 5\nscores = simulate_player_scores(players, rounds)\nranking = determine_ranking(scores)\n\nresults = []\nfor rank, player_index in enumerate(ranking, start=1):\n    results.append(f\"Rank {rank}: Player {player_index + 1} with score {scores[player_index]}\")\n\nfor result in results:\n    print(result)"}, {"role": "assistant", "content": "Rank 1: Player 10 with score 150\nRank 2: Player 9 with score 135\nRank 3: Player 8 with score 120\nRank 4: Player 7 with score 105\nRank 5: Player 6 with score 90\nRank 6: Player 5 with score 75\nRank 7: Player 4 with score 60\nRank 8: Player 3 with score 45\nRank 9: Player 2 with score 30\nRank 10: Player 1 with score 15\n"}]}
{"messages": [{"role": "user", "content": "def merge_sort_descending(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        L = arr[:mid]\n        R = arr[mid:]\n\n        merge_sort_descending(L)\n        merge_sort_descending(R)\n\n        i = j = k = 0\n\n        while i < len(L) and j < len(R):\n            if L[i] < R[j]:\n                arr[k] = L[i]\n                i += 1\n            else:\n                arr[k] = R[j]\n                j += 1\n            k += 1\n\n        while i < len(L):\n            arr[k] = L[i]\n            i += 1\n            k += 1\n\n        while j < len(R):\n            arr[k] = R[j]\n            j += 1\n            k += 1\n\nnumbers = [34, 7, 23, 32, 5, 62, 31, 3, 2, 21, 4, 8, 15, 13, 20, 18, 12, 11, 19, 6]\nmerge_sort_descending(numbers)\nprint(numbers)"}, {"role": "assistant", "content": "[2, 3, 4, 5, 6, 7, 8, 11, 12, 13, 15, 18, 19, 20, 21, 23, 31, 32, 34, 62]\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef encode_message(message):\n    encoded_chars = [(ord(char) * 3) % 256 for char in message]\n    return encoded_chars\n\ndef decode_message(encoded_chars):\n    decoded_chars = [chr((num * pow(3, -1, 256)) % 256) for num in encoded_chars]\n    return ''.join(decoded_chars)\n\ndef custom_sort(encoded_chars):\n    print(f\"Before sorting: {encoded_chars}\")\n    n = len(encoded_chars)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if (encoded_chars[j] % 13) > (encoded_chars[j+1] % 13):\n                encoded_chars[j], encoded_chars[j+1] = encoded_chars[j+1], encoded_chars[j]\n    print(f\"After sorting: {encoded_chars}\")\n    return encoded_chars\n\nmessage = \"Advanced Encryption\"\nprint(f\"Original message: {message}\")\n\nencoded = encode_message(message)\nprint(f\"Encoded message: {encoded}\")\n\nsorted_encoded = custom_sort(encoded)\n\ndecoded = decode_message(sorted_encoded)\nprint(f\"Decoded message: {decoded}\")\n\nsorted_encoded_pairs = list(zip(sorted_encoded, range(len(sorted_encoded))))\nsorted_encoded_pairs.sort(key=lambda x: (x[0] % 13, x[1]))\n\nprint(\"Final sorted encoded pairs:\")\nfor char, index in sorted_encoded_pairs:\n    print(f\"Encoded: {char}, Original Index: {index}\")"}, {"role": "assistant", "content": "Original message: Advanced Encryption\nEncoded message: [195, 44, 98, 35, 74, 41, 47, 44, 96, 207, 74, 41, 86, 107, 80, 92, 59, 77, 74]\nBefore sorting: [195, 44, 98, 35, 74, 41, 47, 44, 96, 207, 74, 41, 86, 107, 80, 92, 59, 77, 74]\nAfter sorting: [195, 92, 41, 41, 80, 107, 44, 44, 96, 98, 59, 47, 86, 35, 74, 74, 74, 207, 77]\nDecoded message: Atccpydd vierannnEo\nFinal sorted encoded pairs:\nEncoded: 195, Original Index: 0\nEncoded: 92, Original Index: 1\nEncoded: 41, Original Index: 2\nEncoded: 41, Original Index: 3\nEncoded: 80, Original Index: 4\nEncoded: 107, Original Index: 5\nEncoded: 44, Original Index: 6\nEncoded: 44, Original Index: 7\nEncoded: 96, Original Index: 8\nEncoded: 98, Original Index: 9\nEncoded: 59, Original Index: 10\nEncoded: 47, Original Index: 11\nEncoded: 86, Original Index: 12\nEncoded: 35, Original Index: 13\nEncoded: 74, Original Index: 14\nEncoded: 74, Original Index: 15\nEncoded: 74, Original Index: 16\nEncoded: 207, Original Index: 17\nEncoded: 77, Original Index: 18\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef parse_date(date_string):\n    return datetime.strptime(date_string, \"%Y-%m-%d\")\n\nevents = [\n    (\"Event A\", \"2023-10-15\"),\n    (\"Event B\", \"2022-12-01\"),\n    (\"Event C\", \"2023-03-20\"),\n    (\"Event D\", \"2023-07-04\"),\n    (\"Event E\", \"2023-01-01\"),\n    (\"Event F\", \"2023-05-05\"),\n    (\"Event G\", \"2023-08-23\"),\n    (\"Event H\", \"2023-11-11\"),\n    (\"Event I\", \"2023-09-09\"),\n    (\"Event J\", \"2023-04-14\")\n]\n\nsorted_events = sorted(events, key=lambda event: parse_date(event[1]))\n\nfor event_name, date_str in sorted_events:\n    date_obj = parse_date(date_str)\n    days_until = (date_obj - datetime.now()).days\n    print(f\"{event_name}: {date_str} ({days_until} days from now)\")"}, {"role": "assistant", "content": "Event B: 2022-12-01 (-853 days from now)\nEvent E: 2023-01-01 (-822 days from now)\nEvent C: 2023-03-20 (-744 days from now)\nEvent J: 2023-04-14 (-719 days from now)\nEvent F: 2023-05-05 (-698 days from now)\nEvent D: 2023-07-04 (-638 days from now)\nEvent G: 2023-08-23 (-588 days from now)\nEvent I: 2023-09-09 (-571 days from now)\nEvent A: 2023-10-15 (-535 days from now)\nEvent H: 2023-11-11 (-508 days from now)\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef sort_dates_by_day_of_week(date_list):\n    def day_of_week(date_str):\n        date_obj = datetime.datetime.strptime(date_str, '%Y-%m-%d')\n        return date_obj.weekday(), date_obj\n\n    sorted_dates = sorted(date_list, key=day_of_week)\n    return [date.strftime('%Y-%m-%d (%A)') for _, date in sorted_dates]\n\ndates = [\n    '2023-10-17', '2023-10-16', '2023-10-15', '2023-10-14',\n    '2023-10-13', '2023-10-12', '2023-10-11', '2023-10-10',\n    '2023-10-09', '2023-10-08', '2023-10-07', '2023-10-06',\n    '2023-10-05', '2023-10-04', '2023-10-03', '2023-10-02',\n    '2023-10-01', '2023-09-30', '2023-09-29', '2023-09-28'\n]\n\nprint(\"Original Dates:\")\nfor date in dates:\n    print(date)\n\nsorted_dates = sort_dates_by_day_of_week(dates)\n\nprint(\"\\nSorted Dates by Day of the Week:\")\nfor date in sorted_dates:\n    print(date)"}, {"role": "assistant", "content": "Traceback (most recent call last):\n  File \"<string>\", line 23, in <module>\n  File \"<string>\", line 9, in sort_dates_by_day_of_week\n  File \"<string>\", line 9, in <listcomp>\nValueError: too many values to unpack (expected 2)\n"}]}
{"messages": [{"role": "user", "content": "import math\nimport statistics\n\ndef find_closest_mean(data):\n    mean_value = statistics.mean(data)\n    print(f\"Mean Value: {mean_value}\")\n    closest_value = data[0]\n    min_diff = math.inf\n    \n    for value in data:\n        diff = abs(value - mean_value)\n        print(f\"Checking value: {value}, Difference: {diff}\")\n        if diff < min_diff:\n            min_diff = diff\n            closest_value = value\n            print(f\"New closest value found: {closest_value} with difference {min_diff}\")\n    \n    return closest_value\n\ndata = [15, 25, 35, 45, 55, 65, 75, 85, 95, 105,\n        115, 125, 135, 145, 155, 165, 175, 185, 195, 205]\n\nclosest_value = find_closest_mean(data)\nprint(f\"Value closest to the mean: {closest_value}\")"}, {"role": "assistant", "content": "Mean Value: 110\nChecking value: 15, Difference: 95\nNew closest value found: 15 with difference 95\nChecking value: 25, Difference: 85\nNew closest value found: 25 with difference 85\nChecking value: 35, Difference: 75\nNew closest value found: 35 with difference 75\nChecking value: 45, Difference: 65\nNew closest value found: 45 with difference 65\nChecking value: 55, Difference: 55\nNew closest value found: 55 with difference 55\nChecking value: 65, Difference: 45\nNew closest value found: 65 with difference 45\nChecking value: 75, Difference: 35\nNew closest value found: 75 with difference 35\nChecking value: 85, Difference: 25\nNew closest value found: 85 with difference 25\nChecking value: 95, Difference: 15\nNew closest value found: 95 with difference 15\nChecking value: 105, Difference: 5\nNew closest value found: 105 with difference 5\nChecking value: 115, Difference: 5\nChecking value: 125, Difference: 15\nChecking value: 135, Difference: 25\nChecking value: 145, Difference: 35\nChecking value: 155, Difference: 45\nChecking value: 165, Difference: 55\nChecking value: 175, Difference: 65\nChecking value: 185, Difference: 75\nChecking value: 195, Difference: 85\nChecking value: 205, Difference: 95\nValue closest to the mean: 105\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"\nSorting algorithms are a fundamental part of computer science.\nThey are used to arrange data in a particular order.\nCommon sorting algorithms include bubble sort, insertion sort, and merge sort.\nHowever, there are many more sorting algorithms that have been developed.\nSome are more efficient than others depending on the data and the context.\n\"\"\"\n\nword_list = re.findall(r'\\b\\w+\\b', text.lower())\n\ndef sort_by_vowel_count(words):\n    def vowel_count(word):\n        return sum(1 for char in word if char in 'aeiou')\n    return sorted(words, key=lambda word: (-vowel_count(word), word))\n\nsorted_words = sort_by_vowel_count(word_list)\n\nprint(\"Intermediate output: Sorted words by vowel count and alphabetically:\")\nfor word in sorted_words:\n    print(word)\n\nprint(\"\\nFinal output: Unique words sorted by vowel count and alphabetically:\")\nunique_sorted_words = sorted(set(sorted_words), key=lambda word: (-sum(1 for char in word if char in 'aeiou'), word))\nfor word in unique_sorted_words:\n    print(word)"}, {"role": "assistant", "content": "Intermediate output: Sorted words by vowel count and alphabetically:\ndeveloped\nefficient\nfundamental\ninsertion\nparticular\nalgorithms\nalgorithms\nalgorithms\narrange\ncomputer\ndepending\nhowever\ninclude\nscience\nare\nare\nare\nare\nbeen\nbubble\ncommon\ncontext\ndata\ndata\nhave\nmerge\nmore\nmore\norder\nothers\nsome\nsorting\nsorting\nsorting\nthere\nused\na\na\nand\nand\nin\nmany\nof\non\npart\nsort\nsort\nsort\nthan\nthat\nthe\nthe\nthey\nto\n\nFinal output: Unique words sorted by vowel count and alphabetically:\ndeveloped\nefficient\nfundamental\ninsertion\nparticular\nalgorithms\narrange\ncomputer\ndepending\nhowever\ninclude\nscience\nare\nbeen\nbubble\ncommon\ncontext\ndata\nhave\nmerge\nmore\norder\nothers\nsome\nsorting\nthere\nused\na\nand\nin\nmany\nof\non\npart\nsort\nthan\nthat\nthe\nthey\nto\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef distance(point1, point2):\n    return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2)\n\ndef find_closest_point(points, target):\n    min_distance = float('inf')\n    closest_point = None\n    \n    for point in points:\n        dist = distance(point, target)\n        print(f\"Checking point {point} with distance {dist:.2f} to target {target}\")\n        if dist < min_distance:\n            min_distance = dist\n            closest_point = point\n            print(f\"New closest point found: {closest_point} with distance {min_distance:.2f}\")\n    \n    return closest_point\n\npoints = [(1, 2), (3, 4), (5, 6), (7, 8), (2, 1), (6, 5), (8, 7), (4, 3), (3, 1), (7, 3)]\ntarget = (4, 5)\n\nclosest_point = find_closest_point(points, target)\nprint(f\"The closest point to {target} is {closest_point}\")"}, {"role": "assistant", "content": "Checking point (1, 2) with distance 4.24 to target (4, 5)\nNew closest point found: (1, 2) with distance 4.24\nChecking point (3, 4) with distance 1.41 to target (4, 5)\nNew closest point found: (3, 4) with distance 1.41\nChecking point (5, 6) with distance 1.41 to target (4, 5)\nChecking point (7, 8) with distance 4.24 to target (4, 5)\nChecking point (2, 1) with distance 4.47 to target (4, 5)\nChecking point (6, 5) with distance 2.00 to target (4, 5)\nChecking point (8, 7) with distance 4.47 to target (4, 5)\nChecking point (4, 3) with distance 2.00 to target (4, 5)\nChecking point (3, 1) with distance 4.12 to target (4, 5)\nChecking point (7, 3) with distance 3.61 to target (4, 5)\nThe closest point to (4, 5) is (3, 4)\n"}]}
{"messages": [{"role": "user", "content": "import string\n\ndef caesar_cipher_encrypt(text, shift):\n    encrypted_text = ''\n    for char in text:\n        if char in string.ascii_lowercase:\n            encrypted_text += string.ascii_lowercase[(string.ascii_lowercase.index(char) + shift) % 26]\n        elif char in string.ascii_uppercase:\n            encrypted_text += string.ascii_uppercase[(string.ascii_uppercase.index(char) + shift) % 26]\n        else:\n            encrypted_text += char\n    return encrypted_text\n\ndef find_encryption(text, word):\n    for shift in range(1, 26):\n        potential_match = caesar_cipher_encrypt(text, shift)\n        if word in potential_match:\n            return shift\n    return -1\n\nencrypted_message = \"Uifsf jt b tfdsfu dpef jo uijt nfttbhf\"\nkeyword = \"secret\"\n\ndetected_shift = find_encryption(encrypted_message, keyword)\ndecrypted_message = caesar_cipher_encrypt(encrypted_message, 26 - detected_shift)\n\nprint(\"Detected Shift:\", detected_shift)\nprint(\"Decrypted Message:\")\nfor line in decrypted_message.split():\n    print(line)"}, {"role": "assistant", "content": "Detected Shift: 25\nDecrypted Message:\nVjgtg\nku\nc\nugetgv\neqfg\nkp\nvjku\noguucig\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef date_str_to_obj(date_str):\n    return datetime.datetime.strptime(date_str, \"%Y-%m-%d\")\n\ndef sort_dates(dates):\n    return sorted(dates, key=date_str_to_obj)\n\nunsorted_dates = [\n    \"2023-05-14\", \"2022-11-23\", \"2023-01-01\", \"2022-08-19\",\n    \"2023-03-05\", \"2022-06-30\", \"2023-09-17\", \"2022-12-31\",\n    \"2023-07-01\", \"2022-01-15\", \"2023-04-25\", \"2022-07-04\",\n    \"2023-02-14\", \"2022-10-10\", \"2023-08-06\", \"2022-03-30\"\n]\n\nsorted_dates = sort_dates(unsorted_dates)\n\nfor date in sorted_dates:\n    print(date)"}, {"role": "assistant", "content": "2022-01-15\n2022-03-30\n2022-06-30\n2022-07-04\n2022-08-19\n2022-10-10\n2022-11-23\n2022-12-31\n2023-01-01\n2023-02-14\n2023-03-05\n2023-04-25\n2023-05-14\n2023-07-01\n2023-08-06\n2023-09-17\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef distance(point1, point2):\n    return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2)\n\ndef area_of_triangle(points):\n    a = distance(points[0], points[1])\n    b = distance(points[1], points[2])\n    c = distance(points[2], points[0])\n    s = (a + b + c) / 2\n    return math.sqrt(s * (s - a) * (s - b) * (s - c))\n\ndef sort_triangles_by_area(triangles):\n    print(\"Unsorted triangles (by area):\")\n    for triangle in triangles:\n        print(triangle, \"Area:\", area_of_triangle(triangle))\n    sorted_triangles = sorted(triangles, key=area_of_triangle)\n    print(\"\\nSorted triangles (by area):\")\n    for triangle in sorted_triangles:\n        print(triangle, \"Area:\", area_of_triangle(triangle))\n    return sorted_triangles\n\ntriangles = [\n    [(0, 0), (1, 0), (0, 1)],\n    [(0, 0), (2, 0), (0, 3)],\n    [(0, 0), (1, 0), (0, 2)],\n    [(0, 0), (3, 0), (0, 1)],\n    [(0, 0), (2, 0), (0, 2)],\n    [(0, 0), (1, 1), (1, 0)]\n]\n\nsorted_triangles = sort_triangles_by_area(triangles)\n\nprint(\"\\nFinal sorted list of triangles by area:\")\nfor triangle in sorted_triangles:\n    print(triangle, \"Area:\", area_of_triangle(triangle))"}, {"role": "assistant", "content": "Unsorted triangles (by area):\n[(0, 0), (1, 0), (0, 1)] Area: 0.49999999999999983\n[(0, 0), (2, 0), (0, 3)] Area: 3.000000000000001\n[(0, 0), (1, 0), (0, 2)] Area: 1.0\n[(0, 0), (3, 0), (0, 1)] Area: 1.5000000000000007\n[(0, 0), (2, 0), (0, 2)] Area: 1.9999999999999993\n[(0, 0), (1, 1), (1, 0)] Area: 0.4999999999999998\n\nSorted triangles (by area):\n[(0, 0), (1, 1), (1, 0)] Area: 0.4999999999999998\n[(0, 0), (1, 0), (0, 1)] Area: 0.49999999999999983\n[(0, 0), (1, 0), (0, 2)] Area: 1.0\n[(0, 0), (3, 0), (0, 1)] Area: 1.5000000000000007\n[(0, 0), (2, 0), (0, 2)] Area: 1.9999999999999993\n[(0, 0), (2, 0), (0, 3)] Area: 3.000000000000001\n\nFinal sorted list of triangles by area:\n[(0, 0), (1, 1), (1, 0)] Area: 0.4999999999999998\n[(0, 0), (1, 0), (0, 1)] Area: 0.49999999999999983\n[(0, 0), (1, 0), (0, 2)] Area: 1.0\n[(0, 0), (3, 0), (0, 1)] Area: 1.5000000000000007\n[(0, 0), (2, 0), (0, 2)] Area: 1.9999999999999993\n[(0, 0), (2, 0), (0, 3)] Area: 3.000000000000001\n"}]}
{"messages": [{"role": "user", "content": "def process_game_state(state):\n    return sum(state)\n\ndef generate_moves(state, player):\n    moves = []\n    for i, value in enumerate(state):\n        if value > 0:\n            new_state = state[:]\n            new_state[i] -= 1\n            moves.append((new_state, player))\n    return moves\n\ndef minimax(state, depth, maximizing_player):\n    if depth == 0 or all(v == 0 for v in state):\n        return process_game_state(state)\n    \n    if maximizing_player:\n        max_eval = float('-inf')\n        for move, _ in generate_moves(state, True):\n            eval = minimax(move, depth - 1, False)\n            max_eval = max(max_eval, eval)\n        return max_eval\n    else:\n        min_eval = float('inf')\n        for move, _ in generate_moves(state, False):\n            eval = minimax(move, depth - 1, True)\n            min_eval = min(min_eval, eval)\n        return min_eval\n\ninitial_state = [5, 3, 7, 4]\ndepth_limit = 4\nresult = minimax(initial_state, depth_limit, True)\n\nprint(f\"Optimal game outcome value: {result}\")"}, {"role": "assistant", "content": "Optimal game outcome value: 15\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef binary_search_dates(date_list, target):\n    left, right = 0, len(date_list) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        mid_date = datetime.datetime.strptime(date_list[mid], '%Y-%m-%d')\n        if mid_date < target:\n            left = mid + 1\n        elif mid_date > target:\n            right = mid - 1\n        else:\n            return mid\n    return -1\n\ndef transform_dates(date_list):\n    transformed = []\n    for date_str in date_list:\n        date_obj = datetime.datetime.strptime(date_str, '%Y-%m-%d')\n        transformed.append(date_obj.strftime('%d-%m-%Y'))\n    return transformed\n\ndates = [\n    '2023-01-15', '2023-02-20', '2023-03-25', '2023-04-30', '2023-05-15',\n    '2023-06-20', '2023-07-25', '2023-08-30', '2023-09-15', '2023-10-20'\n]\n\ntransformed_dates = transform_dates(dates)\ntarget_date = datetime.datetime(2023, 5, 15)\nindex = binary_search_dates(dates, target_date)\n\nfor i, date in enumerate(transformed_dates):\n    if i == index:\n        print(f\"* {date} (Target Found)\")\n    else:\n        print(f\"  {date}\")"}, {"role": "assistant", "content": "  15-01-2023\n  20-02-2023\n  25-03-2023\n  30-04-2023\n* 15-05-2023 (Target Found)\n  20-06-2023\n  25-07-2023\n  30-08-2023\n  15-09-2023\n  20-10-2023\n"}]}
{"messages": [{"role": "user", "content": "import re\nfrom datetime import datetime\n\ndef search_palindromes(text):\n    words = re.findall(r'\\b\\w+\\b', text)\n    palindromes = []\n    for word in words:\n        if word.lower() == word[::-1].lower() and len(word) > 1:\n            palindromes.append(word)\n    return palindromes\n\ndef binary_search(word_list, target):\n    low = 0\n    high = len(word_list) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        print(f\"Searching between {word_list[low]} and {word_list[high]}\")\n        if word_list[mid] < target:\n            low = mid + 1\n        elif word_list[mid] > target:\n            high = mid - 1\n        else:\n            return mid\n    return -1\n\ntext = \"\"\"\nMadam Arora teaches malayalam. A man, a plan, a canal: Panama. \nNo lemon, no melon. Was it a car or a cat I saw? \nEva, can I see bees in a cave? \n\"\"\"\n\npalindromes = search_palindromes(text)\nsorted_palindromes = sorted(palindromes)\n\nprint(\"Palindromes found in text:\")\nfor p in sorted_palindromes:\n    print(p)\n\nsearch_word = \"madam\"\nprint(f\"\\nSearching for '{search_word}' in sorted palindrome list.\")\nindex = binary_search(sorted_palindromes, search_word)\nif index != -1:\n    print(f\"'{search_word}' found at index {index}.\")\nelse:\n    print(f\"'{search_word}' not found in the list.\")\n\nprint(\"\\nExecution Time:\", datetime.now())"}, {"role": "assistant", "content": "Palindromes found in text:\nArora\nMadam\nmalayalam\n\nSearching for 'madam' in sorted palindrome list.\nSearching between Arora and malayalam\nSearching between malayalam and malayalam\n'madam' not found in the list.\n\nExecution Time: 2025-04-01 16:09:19.296319\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef sort_special_sequence(seq):\n    def special_key(x):\n        return (math.sin(x), x % 2 == 0, -x)\n    \n    return sorted(seq, key=special_key)\n\nsequence = [i for i in range(1, 100)]\nsorted_sequence = sort_special_sequence(sequence)\n\nfor number in sorted_sequence:\n    print(number)"}, {"role": "assistant", "content": "11\n55\n99\n80\n36\n30\n74\n61\n17\n5\n49\n93\n86\n42\n24\n68\n67\n23\n43\n87\n92\n48\n4\n18\n62\n73\n29\n37\n81\n98\n54\n10\n12\n56\n79\n35\n31\n75\n60\n16\n6\n50\n94\n85\n41\n25\n69\n66\n22\n44\n88\n91\n47\n3\n19\n63\n72\n28\n38\n82\n97\n53\n9\n13\n57\n78\n34\n32\n76\n59\n15\n7\n51\n95\n84\n40\n26\n70\n65\n21\n1\n45\n89\n90\n46\n2\n20\n64\n71\n27\n39\n83\n96\n52\n8\n14\n58\n77\n33\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef find_arithmetic_sequence(n):\n    sequence = [n]\n    candidates = [n]\n    while len(sequence) < 10:\n        n = candidates.pop(0)\n        for i in range(1, 10):\n            next_term = n + i\n            if is_perfect_square(next_term):\n                sequence.append(next_term)\n                candidates.append(next_term)\n                break\n    return sequence\n\ndef is_perfect_square(x):\n    s = int(math.sqrt(x))\n    return s * s == x\n\nsequences = []\nfor start in range(1, 20):\n    sequence = find_arithmetic_sequence(start)\n    if sequence not in sequences:\n        sequences.append(sequence)\n\nfor seq in sequences:\n    print(seq)"}, {"role": "assistant", "content": "Traceback (most recent call last):\n  File \"<string>\", line 22, in <module>\n  File \"<string>\", line 7, in find_arithmetic_sequence\nIndexError: pop from empty list\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef sort_by_day_of_week(dates):\n    weekdays_dict = {\n        \"Monday\": 0,\n        \"Tuesday\": 1,\n        \"Wednesday\": 2,\n        \"Thursday\": 3,\n        \"Friday\": 4,\n        \"Saturday\": 5,\n        \"Sunday\": 6\n    }\n    sorted_dates = sorted(dates, key=lambda date: weekdays_dict[date.strftime('%A')])\n    return sorted_dates\n\ndates = [\n    datetime.datetime(2023, 1, 4), # Wednesday\n    datetime.datetime(2023, 10, 23), # Monday\n    datetime.datetime(2023, 6, 30), # Friday\n    datetime.datetime(2023, 7, 1), # Saturday\n    datetime.datetime(2023, 2, 28), # Tuesday\n    datetime.datetime(2023, 11, 5), # Sunday\n    datetime.datetime(2023, 9, 14), # Thursday\n]\n\nprint(\"Original Dates:\")\nfor date in dates:\n    print(date.strftime('%Y-%m-%d %A'))\n\nsorted_dates = sort_by_day_of_week(dates)\n\nprint(\"\\nSorted Dates by Day of the Week:\")\nfor date in sorted_dates:\n    print(date.strftime('%Y-%m-%d %A'))"}, {"role": "assistant", "content": "Original Dates:\n2023-01-04 Wednesday\n2023-10-23 Monday\n2023-06-30 Friday\n2023-07-01 Saturday\n2023-02-28 Tuesday\n2023-11-05 Sunday\n2023-09-14 Thursday\n\nSorted Dates by Day of the Week:\n2023-10-23 Monday\n2023-02-28 Tuesday\n2023-01-04 Wednesday\n2023-09-14 Thursday\n2023-06-30 Friday\n2023-07-01 Saturday\n2023-11-05 Sunday\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"\nTo be, or not to be, that is the question:\nWhether 'tis nobler in the mind to suffer\nThe slings and arrows of outrageous fortune,\nOr to take arms against a sea of troubles\nAnd by opposing end them. To die: to sleep;\nNo more; and by a sleep to say we end\nThe heart-ache and the thousand natural shocks\nThat flesh is heir to, 'tis a consummation\nDevoutly to be wish'd. To die, to sleep;\nTo sleep: perchance to dream: ay, there's the rub;\nFor in that sleep of death what dreams may come\nWhen we have shuffled off this mortal coil,\nMust give us pause: there's the respect\nThat makes calamity of so long life;\n\"\"\"\n\nwords = re.findall(r'\\b\\w+\\b', text.lower())\nprint(f\"Words extracted: {words[:10]}... Total: {len(words)}\")\n\nunique_words = set(words)\nprint(f\"Unique words extracted: {len(unique_words)}\")\n\nword_pairs = [(word, len(word)) for word in unique_words]\nprint(f\"First 5 word-length pairs: {word_pairs[:5]}\")\n\nsorted_words = sorted(word_pairs, key=lambda x: (x[1], x[0]))\nprint(f\"First 5 sorted word-length pairs: {sorted_words[:5]}\")\n\noutput_lines = [f\"{word}: {length}\" for word, length in sorted_words]\nprint(\"First 5 output lines:\")\nfor line in output_lines[:5]:\n    print(line)\n\nprint(\"\\nComplete sorted words by length and alphabetically:\")\nfor line in output_lines:\n    print(line)"}, {"role": "assistant", "content": "Words extracted: ['to', 'be', 'or', 'not', 'to', 'be', 'that', 'is', 'the', 'question']... Total: 121\nUnique words extracted: 76\nFirst 5 word-length pairs: [('shuffled', 8), ('question', 8), ('heart', 5), ('mortal', 6), ('slings', 6)]\nFirst 5 sorted word-length pairs: [('a', 1), ('d', 1), ('s', 1), ('ay', 2), ('be', 2)]\nFirst 5 output lines:\na: 1\nd: 1\ns: 1\nay: 2\nbe: 2\n\nComplete sorted words by length and alphabetically:\na: 1\nd: 1\ns: 1\nay: 2\nbe: 2\nby: 2\nin: 2\nis: 2\nno: 2\nof: 2\nor: 2\nso: 2\nto: 2\nus: 2\nwe: 2\nand: 3\ndie: 3\nend: 3\nfor: 3\nmay: 3\nnot: 3\noff: 3\nrub: 3\nsay: 3\nsea: 3\nthe: 3\ntis: 3\nache: 4\narms: 4\ncoil: 4\ncome: 4\ngive: 4\nhave: 4\nheir: 4\nlife: 4\nlong: 4\nmind: 4\nmore: 4\nmust: 4\ntake: 4\nthat: 4\nthem: 4\nthis: 4\nwhat: 4\nwhen: 4\nwish: 4\ndeath: 5\ndream: 5\nflesh: 5\nheart: 5\nmakes: 5\npause: 5\nsleep: 5\nthere: 5\narrows: 6\ndreams: 6\nmortal: 6\nnobler: 6\nshocks: 6\nslings: 6\nsuffer: 6\nagainst: 7\nfortune: 7\nnatural: 7\nrespect: 7\nwhether: 7\ncalamity: 8\ndevoutly: 8\nopposing: 8\nquestion: 8\nshuffled: 8\nthousand: 8\ntroubles: 8\nperchance: 9\noutrageous: 10\nconsummation: 12\n"}]}
{"messages": [{"role": "user", "content": "def generate_pattern(n):\n    pattern = []\n    for i in range(n):\n        row = []\n        for j in range(n):\n            if (i + j) % 2 == 0:\n                row.append('*')\n            else:\n                row.append(' ')\n        pattern.append(row)\n    return pattern\n\ndef sort_pattern(pattern):\n    flat_pattern = [''.join(row) for row in pattern]\n    sorted_pattern = sorted(flat_pattern, key=lambda x: (x.count('*'), x))\n    return sorted_pattern\n\ndef display_pattern(pattern):\n    for line in pattern:\n        print(line)\n\nn = 10\npattern = generate_pattern(n)\nsorted_pattern = sort_pattern(pattern)\ndisplay_pattern(sorted_pattern)"}, {"role": "assistant", "content": " * * * * *\n * * * * *\n * * * * *\n * * * * *\n * * * * *\n* * * * * \n* * * * * \n* * * * * \n* * * * * \n* * * * * \n"}]}
{"messages": [{"role": "user", "content": "def generate_pattern(rows):\n    pattern = []\n    for i in range(rows):\n        row = []\n        for j in range(rows - i - 1):\n            row.append(' ')\n        for j in range(2 * i + 1):\n            row.append('*')\n        pattern.append(''.join(row))\n    return pattern\n\ndef find_pattern(pattern, target):\n    for idx, row in enumerate(pattern):\n        if row == target:\n            return idx\n    return -1\n\ndef main():\n    rows = 10\n    generated_pattern = generate_pattern(rows)\n    target = '*'\n\n    index = find_pattern(generated_pattern, target)\n    if index != -1:\n        print(f\"Pattern found at row {index}: {generated_pattern[index]}\")\n    else:\n        print(\"Pattern not found.\")\n\n    for row in generated_pattern:\n        print(row)\n\nmain()"}, {"role": "assistant", "content": "Pattern not found.\n         *\n        ***\n       *****\n      *******\n     *********\n    ***********\n   *************\n  ***************\n *****************\n*******************\n"}]}
{"messages": [{"role": "user", "content": "import math\nimport datetime\n\ndef calculate_moving_average(data, window_size):\n    moving_averages = []\n    for i in range(len(data) - window_size + 1):\n        window = data[i:i + window_size]\n        window_average = sum(window) / window_size\n        moving_averages.append(window_average)\n    return moving_averages\n\ndef merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        L = arr[:mid]\n        R = arr[mid:]\n        merge_sort(L)\n        merge_sort(R)\n        i = j = k = 0\n        while i < len(L) and j < len(R):\n            if L[i] < R[j]:\n                arr[k] = L[i]\n                i += 1\n            else:\n                arr[k] = R[j]\n                j += 1\n            k += 1\n        while i < len(L):\n            arr[k] = L[i]\n            i += 1\n            k += 1\n        while j < len(R):\n            arr[k] = R[j]\n            j += 1\n            k += 1\n\ndef calculate_median(data):\n    merge_sort(data)\n    n = len(data)\n    mid = n // 2\n    if n % 2 == 0:\n        return (data[mid - 1] + data[mid]) / 2\n    else:\n        return data[mid]\n\ndef generate_dates(start_date, days):\n    dates = []\n    for i in range(days):\n        date = start_date + datetime.timedelta(days=i)\n        dates.append(date)\n    return dates\n\ndata_points = [12, 10, 9, 11, 12, 13, 15, 14, 12, 10, 8, 9, 11, 13, 15, 16, 14, 12, 10, 9]\nwindow_size = 5\nmoving_avg = calculate_moving_average(data_points, window_size)\nmedian = calculate_median(data_points.copy())\nstart_date = datetime.date(2023, 1, 1)\ndates = generate_dates(start_date, len(moving_avg))\n\nfor date, avg in zip(dates, moving_avg):\n    print(f\"{date}: Moving Average = {avg:.2f}\")\n\nprint(f\"Median of Data Points: {median:.2f}\")"}, {"role": "assistant", "content": "2023-01-01: Moving Average = 10.80\n2023-01-02: Moving Average = 11.00\n2023-01-03: Moving Average = 12.00\n2023-01-04: Moving Average = 13.00\n2023-01-05: Moving Average = 13.20\n2023-01-06: Moving Average = 12.80\n2023-01-07: Moving Average = 11.80\n2023-01-08: Moving Average = 10.60\n2023-01-09: Moving Average = 10.00\n2023-01-10: Moving Average = 10.20\n2023-01-11: Moving Average = 11.20\n2023-01-12: Moving Average = 12.80\n2023-01-13: Moving Average = 13.80\n2023-01-14: Moving Average = 14.00\n2023-01-15: Moving Average = 13.40\n2023-01-16: Moving Average = 12.20\nMedian of Data Points: 12.00\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef find_palindromes(text):\n    words = re.findall(r'\\b\\w+\\b', text.lower())\n    return [word for word in words if word == word[::-1]]\n\ntext = \"\"\"\nAnna went to see civic duty in her radar equipped kayak.\nShe met Otto who has a level of noon-time naps as his refer.\nDid you know Eve has a racecar and a rotor? Madam, she said, I'm not a palindrome.\n\"\"\"\n\npalindromes = find_palindromes(text)\nfor idx, palindrome in enumerate(palindromes, start=1):\n    print(f\"{idx}: {palindrome}\")"}, {"role": "assistant", "content": "1: anna\n2: civic\n3: radar\n4: kayak\n5: otto\n6: a\n7: level\n8: noon\n9: refer\n10: did\n11: eve\n12: a\n13: racecar\n14: a\n15: rotor\n16: madam\n17: i\n18: m\n19: a\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef generate_dates(start_date, days):\n    return [start_date + timedelta(days=i) for i in range(days)]\n\ndef is_weekend(date):\n    return date.weekday() >= 5\n\ndef binary_search_weekend(dates):\n    left, right = 0, len(dates) - 1\n    first_weekend = -1\n    while left <= right:\n        mid = (left + right) // 2\n        print(f\"Searching between {left} and {right}. Middle: {mid}\")\n        if is_weekend(dates[mid]):\n            first_weekend = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    return first_weekend\n\nstart_date = datetime(2023, 10, 1)\ndays_to_generate = 30\ndates = generate_dates(start_date, days_to_generate)\n\nprint(\"Generated Dates:\")\nfor date in dates:\n    print(date.strftime('%Y-%m-%d'), \"Weekend\" if is_weekend(date) else \"Weekday\")\n\nweekend_index = binary_search_weekend(dates)\nif weekend_index != -1:\n    print(f\"\\nFirst weekend found on {dates[weekend_index].strftime('%Y-%m-%d')}\")\nelse:\n    print(\"\\nNo weekend found in the given date range.\")"}, {"role": "assistant", "content": "Generated Dates:\n2023-10-01 Weekend\n2023-10-02 Weekday\n2023-10-03 Weekday\n2023-10-04 Weekday\n2023-10-05 Weekday\n2023-10-06 Weekday\n2023-10-07 Weekend\n2023-10-08 Weekend\n2023-10-09 Weekday\n2023-10-10 Weekday\n2023-10-11 Weekday\n2023-10-12 Weekday\n2023-10-13 Weekday\n2023-10-14 Weekend\n2023-10-15 Weekend\n2023-10-16 Weekday\n2023-10-17 Weekday\n2023-10-18 Weekday\n2023-10-19 Weekday\n2023-10-20 Weekday\n2023-10-21 Weekend\n2023-10-22 Weekend\n2023-10-23 Weekday\n2023-10-24 Weekday\n2023-10-25 Weekday\n2023-10-26 Weekday\n2023-10-27 Weekday\n2023-10-28 Weekend\n2023-10-29 Weekend\n2023-10-30 Weekday\nSearching between 0 and 29. Middle: 14\nSearching between 0 and 13. Middle: 6\nSearching between 0 and 5. Middle: 2\nSearching between 3 and 5. Middle: 4\nSearching between 5 and 5. Middle: 5\n\nFirst weekend found on 2023-10-07\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef calculate_polygon_area(vertices):\n    area = 0\n    n = len(vertices)\n    for i in range(n):\n        j = (i + 1) % n\n        area += vertices[i][0] * vertices[j][1]\n        area -= vertices[j][0] * vertices[i][1]\n    area = abs(area) / 2.0\n    return area\n\ndef sort_polygons_by_area(polygons):\n    return sorted(polygons, key=calculate_polygon_area)\n\npolygons = [\n    [(0, 0), (2, 0), (1, 2)],\n    [(0, 0), (3, 0), (3, 3), (0, 3)],\n    [(0, 0), (1, 0), (1, 1), (0, 1)],\n    [(0, 0), (4, 0), (2, 4)]\n]\n\nsorted_polygons = sort_polygons_by_area(polygons)\n\nfor index, polygon in enumerate(sorted_polygons):\n    area = calculate_polygon_area(polygon)\n    print(f\"Polygon {index + 1}:\")\n    for vertex in polygon:\n        print(f\"Vertex: {vertex}\")\n    print(f\"Area: {area:.2f}\\n\")"}, {"role": "assistant", "content": "Polygon 1:\nVertex: (0, 0)\nVertex: (1, 0)\nVertex: (1, 1)\nVertex: (0, 1)\nArea: 1.00\n\nPolygon 2:\nVertex: (0, 0)\nVertex: (2, 0)\nVertex: (1, 2)\nArea: 2.00\n\nPolygon 3:\nVertex: (0, 0)\nVertex: (4, 0)\nVertex: (2, 4)\nArea: 8.00\n\nPolygon 4:\nVertex: (0, 0)\nVertex: (3, 0)\nVertex: (3, 3)\nVertex: (0, 3)\nArea: 9.00\n\n"}]}
{"messages": [{"role": "user", "content": "from math import sqrt\nfrom statistics import mean, median\n\ndef compute_std_deviation(data):\n    average = mean(data)\n    variance = sum((x - average) ** 2 for x in data) / len(data)\n    return sqrt(variance)\n\ndef binary_search_median(data):\n    sorted_data = sorted(data)\n    low, high = 0, len(sorted_data) - 1\n    while low < high:\n        mid = (low + high) // 2\n        if sorted_data[mid] < sorted_data[high]:\n            low = mid + 1\n        else:\n            high = mid\n    return sorted_data[low]\n\ndata_points = [\n    45, 67, 89, 23, 67, 89, 45, 23, 67, 23, 89, 45, 67, 23, 89, 45, 67, 89, 45, 23,\n    67, 23, 89, 45, 67, 23, 89, 45, 67, 89, 45, 23, 67, 23, 89, 45, 67, 23, 89, 45,\n    67, 89, 45, 23, 67, 23, 89, 45, 67, 23, 89, 45, 67, 89, 45, 23, 67, 23, 89, 45,\n    67, 23, 89, 45, 67, 89, 45, 23, 67, 23, 89, 45, 67, 23, 89, 45, 67, 89, 45, 23,\n    67, 23, 89, 45, 67, 23, 89, 45, 67, 89, 45, 23, 67, 23, 89, 45\n]\n\nprint(\"Computed Standard Deviation:\", compute_std_deviation(data_points))\nprint(\"Binary Search Median:\", binary_search_median(data_points))\nprint(\"Actual Median:\", median(data_points))"}, {"role": "assistant", "content": "Computed Standard Deviation: 24.596747752497688\nBinary Search Median: 89\nActual Median: 56.0\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef find_closest_point(target, points):\n    min_dist = float('inf')\n    closest_point = None\n    for point in points:\n        dist = math.sqrt((target[0] - point[0]) ** 2 + (target[1] - point[1]) ** 2)\n        print(f\"Checking point {point} with distance {dist}\")\n        if dist < min_dist:\n            min_dist = dist\n            closest_point = point\n            print(f\"New closest point found: {closest_point} with distance {min_dist}\")\n    return closest_point, min_dist\n\ndef search_polygon_centroid(points):\n    centroid_x = sum(x for x, y in points) / len(points)\n    centroid_y = sum(y for x, y in points) / len(points)\n    centroid = (centroid_x, centroid_y)\n    print(f\"Calculated centroid: {centroid}\")\n    return centroid\n\npolygon_points = [\n    (1, 2), (3, 5), (5, 7), (6, 2), (4, -1), (2, -3), (0, 0), (3, 3),\n    (7, 8), (8, 1), (5, -4), (1, -5), (3, 7), (9, 0), (6, 6), (2, 2)\n]\n\npolygon_centroid = search_polygon_centroid(polygon_points)\nclosest, distance = find_closest_point(polygon_centroid, polygon_points)\n\nprint(\"\\nPolygon points:\")\nfor p in polygon_points:\n    print(p)\nprint(f\"\\nCentroid of polygon: {polygon_centroid}\")\nprint(f\"Closest point to centroid: {closest} with distance: {distance}\")"}, {"role": "assistant", "content": "Calculated centroid: (4.0625, 1.875)\nChecking point (1, 2) with distance 3.0650499588098072\nNew closest point found: (1, 2) with distance 3.0650499588098072\nChecking point (3, 5) with distance 3.3006864816277233\nChecking point (5, 7) with distance 5.210041386591857\nChecking point (6, 2) with distance 1.9415280708761333\nNew closest point found: (6, 2) with distance 1.9415280708761333\nChecking point (4, -1) with distance 2.8756792675818352\nChecking point (2, -3) with distance 5.293347830059914\nChecking point (0, 0) with distance 4.47431908227386\nChecking point (3, 3) with distance 1.5474273003924934\nNew closest point found: (3, 3) with distance 1.5474273003924934\nChecking point (7, 8) with distance 6.792976611913219\nChecking point (8, 1) with distance 4.033550700065638\nChecking point (5, -4) with distance 5.9493303194561316\nChecking point (1, -5) with distance 7.526256124395449\nChecking point (3, 7) with distance 5.233978529761084\nChecking point (9, 0) with distance 5.281527359580749\nChecking point (6, 6) with distance 4.557360118533535\nChecking point (2, 2) with distance 2.0662844068520676\n\nPolygon points:\n(1, 2)\n(3, 5)\n(5, 7)\n(6, 2)\n(4, -1)\n(2, -3)\n(0, 0)\n(3, 3)\n(7, 8)\n(8, 1)\n(5, -4)\n(1, -5)\n(3, 7)\n(9, 0)\n(6, 6)\n(2, 2)\n\nCentroid of polygon: (4.0625, 1.875)\nClosest point to centroid: (3, 3) with distance: 1.5474273003924934\n"}]}
{"messages": [{"role": "user", "content": "import math\nfrom datetime import datetime\n\ndef find_peaks(data):\n    peaks = []\n    for i in range(1, len(data) - 1):\n        if data[i] > data[i - 1] and data[i] > data[i + 1]:\n            peaks.append((i, data[i]))\n    return peaks\n\ndef analyze_temperature_trends(temperatures):\n    trends = []\n    for day in range(1, len(temperatures)):\n        if temperatures[day] > temperatures[day - 1]:\n            trends.append(('Rise', day))\n        else:\n            trends.append(('Fall', day))\n    return trends\n\ntemperatures = [math.sin(x / 10) * 20 + 30 for x in range(100)]\npeaks = find_peaks(temperatures)\ntrends = analyze_temperature_trends(temperatures)\n\nfor trend in trends:\n    if trend[0] == 'Rise':\n        day = trend[1]\n        date = datetime(2023, 10, day % 28 + 1)\n        print(f\"{date.strftime('%Y-%m-%d')} : Temperature rise detected\")\n\nfor peak in peaks:\n    day, temp = peak\n    date = datetime(2023, 10, day % 28 + 1)\n    print(f\"{date.strftime('%Y-%m-%d')} : Peak temperature of {temp:.2f}\u00b0C\")"}, {"role": "assistant", "content": "2023-10-02 : Temperature rise detected\n2023-10-03 : Temperature rise detected\n2023-10-04 : Temperature rise detected\n2023-10-05 : Temperature rise detected\n2023-10-06 : Temperature rise detected\n2023-10-07 : Temperature rise detected\n2023-10-08 : Temperature rise detected\n2023-10-09 : Temperature rise detected\n2023-10-10 : Temperature rise detected\n2023-10-11 : Temperature rise detected\n2023-10-12 : Temperature rise detected\n2023-10-13 : Temperature rise detected\n2023-10-14 : Temperature rise detected\n2023-10-15 : Temperature rise detected\n2023-10-16 : Temperature rise detected\n2023-10-17 : Temperature rise detected\n2023-10-21 : Temperature rise detected\n2023-10-22 : Temperature rise detected\n2023-10-23 : Temperature rise detected\n2023-10-24 : Temperature rise detected\n2023-10-25 : Temperature rise detected\n2023-10-26 : Temperature rise detected\n2023-10-27 : Temperature rise detected\n2023-10-28 : Temperature rise detected\n2023-10-01 : Temperature rise detected\n2023-10-02 : Temperature rise detected\n2023-10-03 : Temperature rise detected\n2023-10-04 : Temperature rise detected\n2023-10-05 : Temperature rise detected\n2023-10-06 : Temperature rise detected\n2023-10-07 : Temperature rise detected\n2023-10-08 : Temperature rise detected\n2023-10-09 : Temperature rise detected\n2023-10-10 : Temperature rise detected\n2023-10-11 : Temperature rise detected\n2023-10-12 : Temperature rise detected\n2023-10-13 : Temperature rise detected\n2023-10-14 : Temperature rise detected\n2023-10-15 : Temperature rise detected\n2023-10-16 : Temperature rise detected\n2023-10-17 : Temperature rise detected\n2023-10-18 : Temperature rise detected\n2023-10-19 : Temperature rise detected\n2023-10-20 : Temperature rise detected\n2023-10-21 : Temperature rise detected\n2023-10-22 : Temperature rise detected\n2023-10-23 : Temperature rise detected\n2023-10-24 : Temperature rise detected\n2023-10-17 : Peak temperature of 49.99\u00b0C\n2023-10-24 : Peak temperature of 49.98\u00b0C\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef sort_players_by_score(players):\n    return sorted(players, key=lambda x: x['score'], reverse=True)\n\ndef generate_game_schedule(players):\n    schedule = []\n    n = len(players)\n    for i in range(n):\n        for j in range(i + 1, n):\n            schedule.append((players[i]['name'], players[j]['name']))\n    return sorted(schedule, key=lambda x: (x[0], x[1]))\n\nplayers = [\n    {'name': 'Alice', 'score': 85},\n    {'name': 'Bob', 'score': 92},\n    {'name': 'Charlie', 'score': 87},\n    {'name': 'David', 'score': 90},\n]\n\nsorted_players = sort_players_by_score(players)\nscheduled_games = generate_game_schedule(sorted_players)\n\nprint(\"=== Sorted Players by Score ===\")\nfor player in sorted_players:\n    print(f\"{player['name']}: {player['score']}\")\n\nprint(\"\\n=== Generated Game Schedule ===\")\nfor game in scheduled_games:\n    print(f\"{game[0]} vs {game[1]}\")\n\nprint(\"\\n=== Game Schedule with Dates ===\")\nstart_date = datetime.date.today()\nfor i, game in enumerate(scheduled_games):\n    game_date = start_date + datetime.timedelta(days=i)\n    print(f\"{game_date}: {game[0]} vs {game[1]}\")"}, {"role": "assistant", "content": "=== Sorted Players by Score ===\nBob: 92\nDavid: 90\nCharlie: 87\nAlice: 85\n\n=== Generated Game Schedule ===\nBob vs Alice\nBob vs Charlie\nBob vs David\nCharlie vs Alice\nDavid vs Alice\nDavid vs Charlie\n\n=== Game Schedule with Dates ===\n2025-04-01: Bob vs Alice\n2025-04-02: Bob vs Charlie\n2025-04-03: Bob vs David\n2025-04-04: Charlie vs Alice\n2025-04-05: David vs Alice\n2025-04-06: David vs Charlie\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef bubble_sort_dates(date_list):\n    n = len(date_list)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if date_list[j] < date_list[j+1]:  # Bug: Should be '>'\n                date_list[j], date_list[j+1] = date_list[j+1], date_list[j]\n    return date_list\n\ndates = [\n    datetime.now() - timedelta(days=i*365)\n    for i in range(10)\n]\n\nsorted_dates = bubble_sort_dates(dates)\n\nfor date in sorted_dates:\n    print(date.strftime(\"%Y-%m-%d %H:%M:%S\"))"}, {"role": "assistant", "content": "2025-04-01 16:09:28\n2024-04-01 16:09:28\n2023-04-02 16:09:28\n2022-04-02 16:09:28\n2021-04-02 16:09:28\n2020-04-02 16:09:28\n2019-04-03 16:09:28\n2018-04-03 16:09:28\n2017-04-03 16:09:28\n2016-04-03 16:09:28\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef get_monthly_averages(dates):\n    date_objects = [datetime.datetime.strptime(date, \"%Y-%m-%d\") for date in dates]\n    sorted_dates = sorted(date_objects)\n    monthly_data = {}\n    \n    for date in sorted_dates:\n        month = date.strftime(\"%Y-%m\")\n        if month not in monthly_data:\n            monthly_data[month] = []\n        monthly_data[month].append(date.day)\n    \n    monthly_averages = {month: sum(days) / len(days) for month, days in monthly_data.items()}\n    return monthly_averages\n\ndates = [\n    \"2023-07-21\", \"2023-07-01\", \"2023-08-15\", \"2023-08-01\",\n    \"2023-07-11\", \"2023-09-05\", \"2023-09-20\", \"2023-08-25\",\n    \"2023-07-31\", \"2023-08-05\", \"2023-09-10\", \"2023-09-30\",\n    \"2023-08-20\", \"2023-07-15\", \"2023-09-01\", \"2023-08-10\",\n    \"2023-07-05\", \"2023-07-25\", \"2023-08-30\", \"2023-09-15\"\n]\n\nmonthly_averages = get_monthly_averages(dates)\nsorted_months = sorted(monthly_averages)\n\nfor month in sorted_months:\n    print(f\"{month}: {monthly_averages[month]:.2f}\")"}, {"role": "assistant", "content": "2023-07: 15.57\n2023-08: 15.14\n2023-09: 13.50\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef generate_board():\n    return [\n        ['-', '-', '-', '-', '-', '-', '-', '-', '-', '-'],\n        ['-', '-', '-', '-', '-', '-', '-', '-', '-', '-'],\n        ['-', '-', 'T', '-', '-', '-', '-', '-', '-', '-'],\n        ['-', '-', '-', '-', '-', '-', '-', '-', '-', '-'],\n        ['-', '-', '-', '-', '-', '-', '-', '-', '-', '-'],\n        ['-', '-', '-', '-', '-', '-', '-', '-', '-', '-'],\n        ['-', '-', '-', '-', '-', '-', '-', '-', '-', '-'],\n        ['-', '-', '-', '-', '-', '-', '-', '-', '-', '-'],\n        ['-', '-', '-', '-', '-', '-', '-', '-', '-', '-'],\n        ['-', '-', '-', '-', '-', '-', '-', '-', '-', '-']\n    ]\n\ndef find_treasure(board):\n    rows = len(board)\n    cols = len(board[0])\n    for i in range(rows):\n        for j in range(cols):\n            if board[i][j] == 'T':\n                return (i, j)\n    return None\n\ndef move_towards_treasure(start, treasure):\n    path = []\n    current = start\n    while current != treasure:\n        path.append(current)\n        if current[0] < treasure[0]:\n            current = (current[0] + 1, current[1])\n        elif current[0] > treasure[0]:\n            current = (current[0] - 1, current[1])\n        elif current[1] < treasure[1]:\n            current = (current[0], current[1] + 1)\n        elif current[1] > treasure[1]:\n            current = (current[0], current[1] - 1)\n    path.append(treasure)\n    return path\n\ndef print_path(board, path):\n    for step in path:\n        board[step[0]][step[1]] = '*'\n    for row in board:\n        print(' '.join(row))\n\ndef main():\n    board = generate_board()\n    start = (0, 0)\n    treasure = find_treasure(board)\n    if treasure:\n        path = move_towards_treasure(start, treasure)\n        print_path(board, path)\n\nmain()"}, {"role": "assistant", "content": "* - - - - - - - - -\n* - - - - - - - - -\n* * * - - - - - - -\n- - - - - - - - - -\n- - - - - - - - - -\n- - - - - - - - - -\n- - - - - - - - - -\n- - - - - - - - - -\n- - - - - - - - - -\n- - - - - - - - - -\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef generate_pattern(n):\n    pattern = []\n    for i in range(n):\n        if i % 2 == 0:\n            pattern.append(\"*\" * (i + 1))\n        else:\n            pattern.append(\"#\" * (i + 1))\n    return pattern\n\ndef search_pattern(pattern, target):\n    for idx, p in enumerate(pattern):\n        if re.search(target, p):\n            return idx\n    return -1\n\ndef faulty_search(pattern, target):\n    print(\"Searching for:\", target)\n    print(\"Pattern list:\", pattern)\n    return search_pattern(pattern, target)\n\ndef main():\n    n = 20\n    target = \"#\"\n    pattern = generate_pattern(n)\n    index = faulty_search(pattern, target)\n    print(\"Pattern generated:\")\n    for line in pattern:\n        print(line)\n    print(\"Target pattern '{}' found at index: {}\".format(target, index))\n\nmain()"}, {"role": "assistant", "content": "Searching for: #\nPattern list: ['*', '##', '***', '####', '*****', '######', '*******', '########', '*********', '##########', '***********', '############', '*************', '##############', '***************', '################', '*****************', '##################', '*******************', '####################']\nPattern generated:\n*\n##\n***\n####\n*****\n######\n*******\n########\n*********\n##########\n***********\n############\n*************\n##############\n***************\n################\n*****************\n##################\n*******************\n####################\nTarget pattern '#' found at index: 1\n"}]}
{"messages": [{"role": "user", "content": "def bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n\ndef generate_pattern(n):\n    pattern = []\n    for i in range(1, n + 1):\n        pattern.append('*' * i)\n    return pattern\n\ndef sort_and_print_patterns(patterns):\n    lengths = [len(p) for p in patterns]\n    print(\"Initial pattern lengths:\", lengths)\n    bubble_sort(lengths)\n    print(\"Sorted pattern lengths:\", lengths)\n    sorted_patterns = []\n    for length in lengths:\n        for pattern in patterns:\n            if len(pattern) == length and pattern not in sorted_patterns:\n                sorted_patterns.append(pattern)\n                break\n    for p in sorted_patterns:\n        print(p)\n\nn = 10\npatterns = generate_pattern(n)\nsort_and_print_patterns(patterns)"}, {"role": "assistant", "content": "Initial pattern lengths: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nSorted pattern lengths: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n*\n**\n***\n****\n*****\n******\n*******\n********\n*********\n**********\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef encode(message):\n    return ''.join(format(ord(char), '08b') for char in message)\n\ndef decode(encoded_message):\n    binary_strings = re.findall('.{8}', encoded_message)\n    return ''.join(chr(int(b, 2)) for b in binary_strings)\n\ndef search_in_encoded(encoded_message, pattern):\n    binary_pattern = encode(pattern)\n    return [(i, i + len(binary_pattern)) for i in range(len(encoded_message)) if encoded_message.startswith(binary_pattern, i)]\n\nmessage = \"The quick brown fox jumps over the lazy dog\"\nencoded_message = encode(message)\nsearch_term = \"brown\"\nencoded_search_term = encode(search_term)\nsearch_results = search_in_encoded(encoded_message, search_term)\n\nprint(f\"Encoded Message:\\n{encoded_message}\\n\")\nprint(f\"Encoded '{search_term}':\\n{encoded_search_term}\\n\")\nprint(\"Search Results (start, end) positions in encoded message:\")\nfor start, end in search_results:\n    print(f\"Start: {start}, End: {end}, Decoded: '{decode(encoded_message[start:end])}'\")"}, {"role": "assistant", "content": "Encoded Message:\n01010100011010000110010100100000011100010111010101101001011000110110101100100000011000100111001001101111011101110110111000100000011001100110111101111000001000000110101001110101011011010111000001110011001000000110111101110110011001010111001000100000011101000110100001100101001000000110110001100001011110100111100100100000011001000110111101100111\n\nEncoded 'brown':\n0110001001110010011011110111011101101110\n\nSearch Results (start, end) positions in encoded message:\nStart: 80, End: 120, Decoded: 'brown'\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef find_median(nums):\n    low = 0\n    high = len(nums) - 1\n    while low < high:\n        mid = (low + high) // 2\n        if nums[mid] < nums[high]:\n            high = mid\n        else:\n            low = mid + 1\n    return nums[low]\n\ndata = [\n    [12, 15, 14, 10, 11, 13, 14],\n    [8, 7, 5, 3, 4, 6, 9],\n    [20, 25, 22, 21, 23, 24, 26],\n    [32, 31, 30, 28, 29, 33, 34],\n    [42, 40, 41, 43, 44, 45, 46],\n    [50, 49, 48, 47, 51, 52, 53],\n    [60, 62, 61, 63, 64, 65, 66],\n    [72, 70, 71, 73, 74, 75, 76],\n    [82, 81, 80, 83, 84, 85, 86],\n    [92, 90, 91, 93, 94, 95, 96]\n]\n\nfor dataset in data:\n    dataset.sort()\n    calculated_median = find_median(dataset)\n    actual_median = statistics.median(dataset)\n    print(f\"Calculated Median: {calculated_median}, Actual Median: {actual_median}\")"}, {"role": "assistant", "content": "Calculated Median: 10, Actual Median: 13\nCalculated Median: 3, Actual Median: 6\nCalculated Median: 20, Actual Median: 23\nCalculated Median: 28, Actual Median: 31\nCalculated Median: 40, Actual Median: 43\nCalculated Median: 47, Actual Median: 50\nCalculated Median: 60, Actual Median: 63\nCalculated Median: 70, Actual Median: 73\nCalculated Median: 80, Actual Median: 83\nCalculated Median: 90, Actual Median: 93\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef is_palindrome(s):\n    return s == s[::-1]\n\ndef find_palindromes(text):\n    found = []\n    length = len(text)\n    for i in range(length):\n        for j in range(i + 2, length + 1):\n            substring = text[i:j]\n            if is_palindrome(substring):\n                found.append(substring)\n                print(f\"Found palindrome: {substring} at index {i}-{j-1}\")\n    return found\n\nsample_text = \"level noon civic racecar rotor kayak madam refer deed peep\"\nprint(\"Sample Text:\", sample_text)\n\nstart_time = datetime.now()\n\npalindromes = find_palindromes(sample_text)\n\nend_time = datetime.now()\n\nprint(\"\\nTotal palindromes found:\", len(palindromes))\nprint(\"\\nExecution Time:\", (end_time - start_time).total_seconds(), \"seconds\")"}, {"role": "assistant", "content": "Sample Text: level noon civic racecar rotor kayak madam refer deed peep\nFound palindrome: level at index 0-4\nFound palindrome: eve at index 1-3\nFound palindrome:  noon  at index 5-10\nFound palindrome: noon at index 6-9\nFound palindrome: oo at index 7-8\nFound palindrome:  civic  at index 10-16\nFound palindrome: civic at index 11-15\nFound palindrome: ivi at index 12-14\nFound palindrome:  racecar  at index 16-24\nFound palindrome: racecar at index 17-23\nFound palindrome: aceca at index 18-22\nFound palindrome: cec at index 19-21\nFound palindrome: r r at index 23-25\nFound palindrome:  rotor  at index 24-30\nFound palindrome: rotor at index 25-29\nFound palindrome: oto at index 26-28\nFound palindrome:  kayak  at index 30-36\nFound palindrome: kayak at index 31-35\nFound palindrome: aya at index 32-34\nFound palindrome:  madam  at index 36-42\nFound palindrome: madam at index 37-41\nFound palindrome: ada at index 38-40\nFound palindrome:  refer  at index 42-48\nFound palindrome: refer at index 43-47\nFound palindrome: efe at index 44-46\nFound palindrome:  deed  at index 48-53\nFound palindrome: deed at index 49-52\nFound palindrome: ee at index 50-51\nFound palindrome: peep at index 54-57\nFound palindrome: ee at index 55-56\n\nTotal palindromes found: 30\n\nExecution Time: 0.000265 seconds\n"}]}
{"messages": [{"role": "user", "content": "text = \"\"\"\nIn the world of Python programming, understanding how to manipulate strings and text\nis a crucial skill. Sorting text can be leveraged to organize information in a readable\nand structured manner. Sorting algorithms such as bubble sort, selection sort, or even\nthe built-in sorted function in Python can be utilized for this purpose.\n\"\"\"\n\nwords = text.split()\nunique_words = list(set(words))\nsorted_words = sorted(unique_words, key=lambda x: (len(x), x))\n\nfor word in sorted_words:\n    print(word)"}, {"role": "assistant", "content": "a\nIn\nas\nbe\nin\nis\nof\nor\nto\nand\ncan\nfor\nhow\nthe\neven\nsuch\ntext\nthis\nsort,\nworld\nPython\nbubble\nskill.\nsorted\nSorting\ncrucial\nmanner.\nstrings\nbuilt-in\nfunction\norganize\npurpose.\nreadable\nutilized\nleveraged\nselection\nalgorithms\nmanipulate\nstructured\ninformation\nprogramming,\nunderstanding\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef quicksort(arr):\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    print(f\"Quicksort step: {left}, {middle}, {right}\")\n    return quicksort(left) + middle + quicksort(right)\n\ndef find_median(arr):\n    sorted_arr = quicksort(arr)\n    n = len(sorted_arr)\n    if n % 2 == 0:\n        return (sorted_arr[n // 2 - 1] + sorted_arr[n // 2]) / 2\n    else:\n        return sorted_arr[n // 2]\n\ndata = [\n    3.2, 1.5, 2.8, 9.4, 5.7, 3.4, 8.6, 5.1, 4.3, 7.9, 6.3, 2.1, 4.8, 7.2, 1.9,\n    3.6, 5.5, 9.2, 8.1, 3.3, 2.5, 4.6, 7.8, 1.2, 6.4, 8.8, 5.9, 7.1, 2.3, 4.1\n]\n\nprint(\"Original Data:\")\nfor number in data:\n    print(number)\n\nprint(\"\\nCalculated Median using quicksort:\")\nmedian_using_quicksort = find_median(data)\nprint(median_using_quicksort)\n\nprint(\"\\nActual Median using statistics module:\")\nactual_median = statistics.median(data)\nprint(actual_median)\n\nprint(\"\\nComparison:\")\nprint(\"Median from quicksort:\", median_using_quicksort)\nprint(\"Median from statistics:\", actual_median)"}, {"role": "assistant", "content": "Original Data:\n3.2\n1.5\n2.8\n9.4\n5.7\n3.4\n8.6\n5.1\n4.3\n7.9\n6.3\n2.1\n4.8\n7.2\n1.9\n3.6\n5.5\n9.2\n8.1\n3.3\n2.5\n4.6\n7.8\n1.2\n6.4\n8.8\n5.9\n7.1\n2.3\n4.1\n\nCalculated Median using quicksort:\nQuicksort step: [3.2, 1.5, 2.8, 3.4, 2.1, 1.9, 3.3, 2.5, 1.2, 2.3], [3.6], [9.4, 5.7, 8.6, 5.1, 4.3, 7.9, 6.3, 4.8, 7.2, 5.5, 9.2, 8.1, 4.6, 7.8, 6.4, 8.8, 5.9, 7.1, 4.1]\nQuicksort step: [1.5, 1.2], [1.9], [3.2, 2.8, 3.4, 2.1, 3.3, 2.5, 2.3]\nQuicksort step: [], [1.2], [1.5]\nQuicksort step: [], [2.1], [3.2, 2.8, 3.4, 3.3, 2.5, 2.3]\nQuicksort step: [3.2, 2.8, 2.5, 2.3], [3.3], [3.4]\nQuicksort step: [2.3], [2.5], [3.2, 2.8]\nQuicksort step: [], [2.8], [3.2]\nQuicksort step: [5.1, 4.3, 4.8, 4.6, 4.1], [5.5], [9.4, 5.7, 8.6, 7.9, 6.3, 7.2, 9.2, 8.1, 7.8, 6.4, 8.8, 5.9, 7.1]\nQuicksort step: [4.3, 4.6, 4.1], [4.8], [5.1]\nQuicksort step: [4.3, 4.1], [4.6], []\nQuicksort step: [], [4.1], [4.3]\nQuicksort step: [5.7, 8.6, 7.9, 6.3, 7.2, 8.1, 7.8, 6.4, 8.8, 5.9, 7.1], [9.2], [9.4]\nQuicksort step: [5.7, 7.9, 6.3, 7.2, 7.8, 6.4, 5.9, 7.1], [8.1], [8.6, 8.8]\nQuicksort step: [5.7, 6.3, 7.2, 6.4, 5.9, 7.1], [7.8], [7.9]\nQuicksort step: [5.7, 6.3, 5.9], [6.4], [7.2, 7.1]\nQuicksort step: [5.7, 5.9], [6.3], []\nQuicksort step: [5.7], [5.9], []\nQuicksort step: [], [7.1], [7.2]\nQuicksort step: [8.6], [8.8], []\n4.949999999999999\n\nActual Median using statistics module:\n4.949999999999999\n\nComparison:\nMedian from quicksort: 4.949999999999999\nMedian from statistics: 4.949999999999999\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef calculate_polygon_area(vertices):\n    n = len(vertices)\n    area = 0.0\n    for i in range(n):\n        j = (i + 1) % n\n        area += vertices[i][0] * vertices[j][1]\n        area -= vertices[j][0] * vertices[i][1]\n    area = abs(area) / 2.0\n    return area\n\ndef distance(point1, point2):\n    return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2)\n\ndef sort_vertices(vertices):\n    centroid_x = sum([v[0] for v in vertices]) / len(vertices)\n    centroid_y = sum([v[1] for v in vertices]) / len(vertices)\n    return sorted(vertices, key=lambda v: math.atan2(v[1] - centroid_y, v[0] - centroid_x))\n\nvertices_list = [\n    [(0, 0), (4, 0), (4, 3), (0, 4)],\n    [(1, 1), (3, 4), (5, 2), (3, 0)],\n    [(2, 2), (4, 6), (7, 4), (5, 1)],\n    [(0, 0), (2, 3), (5, 5), (7, 2)],\n    [(2, 1), (3, 5), (6, 6), (8, 3)]\n]\n\nareas = []\nfor vertices in vertices_list:\n    sorted_vertices = sort_vertices(vertices)\n    area = calculate_polygon_area(sorted_vertices)\n    areas.append((sorted_vertices, area))\n\nareas.sort(key=lambda x: x[1])\n\nfor sorted_vertices, area in areas:\n    for vertex in sorted_vertices:\n        print(f\"Vertex: {vertex}\")\n    print(f\"Area: {area:.2f}\\n\")"}, {"role": "assistant", "content": "Vertex: (1, 1)\nVertex: (3, 0)\nVertex: (5, 2)\nVertex: (3, 4)\nArea: 8.00\n\nVertex: (2, 2)\nVertex: (5, 1)\nVertex: (7, 4)\nVertex: (4, 6)\nArea: 13.50\n\nVertex: (0, 0)\nVertex: (4, 0)\nVertex: (4, 3)\nVertex: (0, 4)\nArea: 14.00\n\nVertex: (0, 0)\nVertex: (7, 2)\nVertex: (5, 5)\nVertex: (2, 3)\nArea: 15.00\n\nVertex: (2, 1)\nVertex: (8, 3)\nVertex: (6, 6)\nVertex: (3, 5)\nArea: 16.50\n\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef encrypt_word(word):\n    vowels = 'aeiou'\n    encrypted = ''\n    for char in word:\n        if char in vowels:\n            encrypted += chr(ord(char) + 2)\n        else:\n            encrypted += char\n    return encrypted\n\ndef decrypt_word(word):\n    vowels = 'aeiou'\n    decrypted = ''\n    for char in word:\n        if chr(ord(char) - 2) in vowels:\n            decrypted += chr(ord(char) - 2)\n        else:\n            decrypted += char\n    return decrypted\n\ndef encrypt_message(message):\n    words = re.findall(r'\\b\\w+\\b', message)\n    encrypted_words = [encrypt_word(word) for word in words]\n    return ' '.join(encrypted_words)\n\ndef decrypt_message(message):\n    words = re.findall(r'\\b\\w+\\b', message)\n    decrypted_words = [decrypt_word(word) for word in words]\n    return ' '.join(decrypted_words)\n\ndef sort_encrypted_words(message):\n    words = re.findall(r'\\b\\w+\\b', message)\n    encrypted_words = [encrypt_word(word) for word in words]\n    encrypted_words.sort()\n    return encrypted_words\n\nmessage = \"\"\"encryption is an interesting topic that involves \ntransforming information to make it unreadable to unauthorized \npeople. sorting algorithms can be used in various encryption \ntechniques.\"\"\"\nencrypted_message = encrypt_message(message)\nsorted_encrypted_words = sort_encrypted_words(message)\ndecrypted_message = decrypt_message(encrypted_message)\n\nprint(\"Original Message:\")\nprint(message)\nprint(\"\\nEncrypted Message:\")\nprint(encrypted_message)\nprint(\"\\nSorted Encrypted Words:\")\nfor word in sorted_encrypted_words:\n    print(word)\nprint(\"\\nDecrypted Message:\")\nprint(decrypted_message)"}, {"role": "assistant", "content": "Original Message:\nencryption is an interesting topic that involves \ntransforming information to make it unreadable to unauthorized \npeople. sorting algorithms can be used in various encryption \ntechniques.\n\nEncrypted Message:\ngncryptkqn ks cn kntgrgstkng tqpkc thct knvqlvgs trcnsfqrmkng knfqrmctkqn tq mckg kt wnrgcdcblg tq wncwthqrkzgd pgqplg sqrtkng clgqrkthms ccn bg wsgd kn vcrkqws gncryptkqn tgchnkqwgs\n\nSorted Encrypted Words:\nbg\nccn\nclgqrkthms\ncn\ngncryptkqn\ngncryptkqn\nkn\nknfqrmctkqn\nkntgrgstkng\nknvqlvgs\nks\nkt\nmckg\npgqplg\nsqrtkng\ntgchnkqwgs\nthct\ntq\ntq\ntqpkc\ntrcnsfqrmkng\nvcrkqws\nwncwthqrkzgd\nwnrgcdcblg\nwsgd\n\nDecrypted Message:\nenaryption is an interestine topia that involves transformine information to maie it unreadable to unauthorized people sortine aleorithms aan be used in various enaryption teahnioues\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndata = [\n    {\"id\": 1, \"date\": \"2023-10-01\", \"value\": 100.5},\n    {\"id\": 2, \"date\": \"2023-09-12\", \"value\": 90.0},\n    {\"id\": 3, \"date\": \"2023-10-05\", \"value\": 110.2},\n    {\"id\": 4, \"date\": \"2023-08-25\", \"value\": 75.8},\n    {\"id\": 5, \"date\": \"2023-10-03\", \"value\": 95.5},\n    {\"id\": 6, \"date\": \"2023-09-30\", \"value\": 105.3},\n    {\"id\": 7, \"date\": \"2023-09-15\", \"value\": 100.0},\n    {\"id\": 8, \"date\": \"2023-10-02\", \"value\": 88.5},\n    {\"id\": 9, \"date\": \"2023-09-18\", \"value\": 92.7},\n    {\"id\": 10, \"date\": \"2023-09-28\", \"value\": 98.0},\n]\n\nsorted_data = sorted(data, key=lambda x: datetime.strptime(x['date'], \"%Y-%m-%d\"))\n\ngrouped_data = {}\nfor d in sorted_data:\n    date = datetime.strptime(d['date'], \"%Y-%m-%d\")\n    week_start = date - timedelta(days=date.weekday())\n    week_str = week_start.strftime(\"%Y-%m-%d\")\n    if week_str not in grouped_data:\n        grouped_data[week_str] = []\n    grouped_data[week_str].append(d)\n\nfor week, records in grouped_data.items():\n    total_value = sum(r['value'] for r in records)\n    avg_value = total_value / len(records)\n    print(f\"Week starting {week}:\")\n    print(f\"  Total Value: {total_value:.2f}\")\n    print(f\"  Average Value: {avg_value:.2f}\")\n    for record in records:\n        print(f\"    ID: {record['id']}, Date: {record['date']}, Value: {record['value']:.2f}\")"}, {"role": "assistant", "content": "Week starting 2023-08-21:\n  Total Value: 75.80\n  Average Value: 75.80\n    ID: 4, Date: 2023-08-25, Value: 75.80\nWeek starting 2023-09-11:\n  Total Value: 190.00\n  Average Value: 95.00\n    ID: 2, Date: 2023-09-12, Value: 90.00\n    ID: 7, Date: 2023-09-15, Value: 100.00\nWeek starting 2023-09-18:\n  Total Value: 92.70\n  Average Value: 92.70\n    ID: 9, Date: 2023-09-18, Value: 92.70\nWeek starting 2023-09-25:\n  Total Value: 303.80\n  Average Value: 101.27\n    ID: 10, Date: 2023-09-28, Value: 98.00\n    ID: 6, Date: 2023-09-30, Value: 105.30\n    ID: 1, Date: 2023-10-01, Value: 100.50\nWeek starting 2023-10-02:\n  Total Value: 294.20\n  Average Value: 98.07\n    ID: 8, Date: 2023-10-02, Value: 88.50\n    ID: 5, Date: 2023-10-03, Value: 95.50\n    ID: 3, Date: 2023-10-05, Value: 110.20\n"}]}
{"messages": [{"role": "user", "content": "def is_fibonacci(n):\n    x, y = 0, 1\n    while x < n:\n        x, y = y, x + y\n    return x == n\n\ndef search_fibonacci_sequence(limit):\n    sequence = []\n    a, b = 0, 1\n    while a <= limit:\n        sequence.append(a)\n        a, b = b, a + b\n    return sequence\n\ndef find_fibonacci_with_sum(sum_limit):\n    sequence = search_fibonacci_sequence(sum_limit)\n    results = []\n    for i, num in enumerate(sequence):\n        for j in range(i, len(sequence)):\n            sub_sequence = sequence[i:j+1]\n            sub_sum = sum(sub_sequence)\n            if sub_sum == sum_limit:\n                results.append(sub_sequence)\n                print(f\"Found sequence with sum {sum_limit}: {sub_sequence}\")\n                break\n            if sub_sum > sum_limit:\n                break\n    return results\n\nsum_limit = 100\nfibonacci_sequences = find_fibonacci_with_sum(sum_limit)\n\nprint(\"\\nFinal Result:\")\nfor seq in fibonacci_sequences:\n    print(seq)"}, {"role": "assistant", "content": "\nFinal Result:\n"}]}
{"messages": [{"role": "user", "content": "import re\nfrom datetime import datetime, timedelta\n\ndef check_win(board, player):\n    for row in board:\n        if all(s == player for s in row):\n            return True\n    for col in range(len(board[0])):\n        if all(row[col] == player for row in board):\n            return True\n    if all(board[i][i] == player for i in range(len(board))):\n        return True\n    if all(board[i][len(board) - i - 1] == player for i in range(len(board))):\n        return True\n    return False\n\ndef find_best_move(board, player):\n    opponent = 'X' if player == 'O' else 'O'\n    best_score = -float('inf')\n    best_move = None\n    for i in range(len(board)):\n        for j in range(len(board[i])):\n            if board[i][j] == ' ':\n                board[i][j] = player\n                if check_win(board, player):\n                    board[i][j] = ' '\n                    return (i, j)\n                board[i][j] = opponent\n                if check_win(board, opponent):\n                    board[i][j] = ' '\n                    return (i, j)\n                board[i][j] = ' '\n    return best_move\n\ndef play_game():\n    board = [\n        ['X', 'O', 'X'],\n        ['O', 'X', ' '],\n        [' ', ' ', 'O']\n    ]\n    current_player = 'X'\n    while True:\n        move = find_best_move(board, current_player)\n        if move is None:\n            break\n        board[move[0]][move[1]] = current_player\n        current_player = 'O' if current_player == 'X' else 'X'\n    \n    for row in board:\n        print(' '.join(row))\n\nplay_game()"}, {"role": "assistant", "content": "X O X\nO X O\nX X O\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef find_closest_centroid(data, centroids):\n    closest_centroids = []\n    for point in data:\n        distances = [math.dist(point, centroid) for centroid in centroids]\n        print(f\"Point: {point}, Distances: {distances}\")\n        closest_centroid_index = distances.index(min(distances))\n        closest_centroids.append(centroids[closest_centroid_index])\n    return closest_centroids\n\ndata_points = [\n    (2.0, 3.0), (8.0, 7.0), (1.5, 1.8), (9.0, 5.0),\n    (3.0, 2.5), (8.0, 8.0), (4.0, 4.0), (7.0, 6.0)\n]\n\ncentroids = [\n    (2.0, 2.0), (8.0, 8.0), (5.0, 5.0)\n]\n\nresult = find_closest_centroid(data_points, centroids)\n\nprint(\"\\nData Points and their Closest Centroids:\")\nfor point, centroid in zip(data_points, result):\n    print(f\"Data Point: {point} -> Closest Centroid: {centroid}\")"}, {"role": "assistant", "content": "Point: (2.0, 3.0), Distances: [1.0, 7.810249675906654, 3.605551275463989]\nPoint: (8.0, 7.0), Distances: [7.810249675906654, 1.0, 3.605551275463989]\nPoint: (1.5, 1.8), Distances: [0.5385164807134504, 8.98276126811795, 4.742362280551751]\nPoint: (9.0, 5.0), Distances: [7.615773105863909, 3.1622776601683795, 4.0]\nPoint: (3.0, 2.5), Distances: [1.118033988749895, 7.433034373659253, 3.2015621187164243]\nPoint: (8.0, 8.0), Distances: [8.48528137423857, 0.0, 4.242640687119285]\nPoint: (4.0, 4.0), Distances: [2.8284271247461903, 5.656854249492381, 1.4142135623730951]\nPoint: (7.0, 6.0), Distances: [6.4031242374328485, 2.23606797749979, 2.23606797749979]\n\nData Points and their Closest Centroids:\nData Point: (2.0, 3.0) -> Closest Centroid: (2.0, 2.0)\nData Point: (8.0, 7.0) -> Closest Centroid: (8.0, 8.0)\nData Point: (1.5, 1.8) -> Closest Centroid: (2.0, 2.0)\nData Point: (9.0, 5.0) -> Closest Centroid: (8.0, 8.0)\nData Point: (3.0, 2.5) -> Closest Centroid: (2.0, 2.0)\nData Point: (8.0, 8.0) -> Closest Centroid: (8.0, 8.0)\nData Point: (4.0, 4.0) -> Closest Centroid: (5.0, 5.0)\nData Point: (7.0, 6.0) -> Closest Centroid: (8.0, 8.0)\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef encode_message(message):\n    words = re.findall(r'\\b\\w+\\b', message)\n    sorted_words = sorted(words, key=lambda w: (len(w), w))\n    encoded_words = []\n    \n    for word in sorted_words:\n        encoded_word = ''.join(chr(ord('a') + ((ord(c) - ord('a') + len(word)) % 26)) if c.isalpha() else c for c in word)\n        encoded_words.append(encoded_word)\n    \n    return ' '.join(encoded_words)\n\ndef decode_message(encoded_message):\n    words = re.findall(r'\\b\\w+\\b', encoded_message)\n    sorted_words = sorted(words, key=lambda w: (len(w), w))\n    decoded_words = []\n\n    for word in sorted_words:\n        decoded_word = ''.join(chr(ord('a') + ((ord(c) - ord('a') - len(word)) % 26)) if c.isalpha() else c for c in word)\n        decoded_words.append(decoded_word)\n    \n    return ' '.join(decoded_words)\n\noriginal_message = \"encryption challenges are fun and interesting to solve\"\nencoded = encode_message(original_message)\ndecoded = decode_message(encoded)\n\nprint(\"Original Message:\", original_message)\nprint(\"\\nEncoded Message:\", encoded)\nprint(\"\\nDecoded Message:\", decoded)"}, {"role": "assistant", "content": "Original Message: encryption challenges are fun and interesting to solve\n\nEncoded Message: vq dqg duh ixq xtqaj mrkvvoxqoc oxmbizdsyx tyepcpdetyr\n\nDecoded Message: to and are fun solve challenges encryption interesting\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef find_last_sundays(year):\n    last_sundays = []\n    for month in range(1, 13):\n        last_day = datetime(year, month + 1, 1) - timedelta(days=1)\n        while last_day.weekday() != 6:  # 6 is Sunday\n            last_day -= timedelta(days=1)\n        last_sundays.append(last_day)\n    return last_sundays\n\ndef display_sundays(sundays):\n    for sunday in sundays:\n        print(sunday.strftime('%Y-%m-%d'))\n\nyear_to_check = 2023\nprint(f\"Finding last Sundays of each month for the year {year_to_check}:\")\nsundays = find_last_sundays(year_to_check)\nprint(\"Last Sundays:\")\ndisplay_sundays(sundays)"}, {"role": "assistant", "content": "Traceback (most recent call last):\n  File \"<string>\", line 18, in <module>\n  File \"<string>\", line 6, in find_last_sundays\nValueError: month must be in 1..12\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef find_optimal_time(data):\n    def transform_to_minutes(time_str):\n        return int(time_str[:2]) * 60 + int(time_str[3:])\n\n    def binary_search(arr, x):\n        low, high = 0, len(arr) - 1\n        best_fit = None\n        while low <= high:\n            mid = (low + high) // 2\n            if arr[mid] < x:\n                low = mid + 1\n            elif arr[mid] > x:\n                best_fit = arr[mid]\n                high = mid - 1\n            else:\n                return arr[mid]\n        return best_fit\n\n    transformed_data = sorted(map(transform_to_minutes, data))\n    query_time = datetime.now().replace(hour=12, minute=0, second=0, microsecond=0)\n    query_minutes = query_time.hour * 60 + query_time.minute\n\n    optimal_time_min = binary_search(transformed_data, query_minutes)\n    if optimal_time_min is None:\n        optimal_time_min = transformed_data[0]\n    \n    optimal_time = (datetime.now().replace(hour=0, minute=0, second=0, microsecond=0) +\n                    timedelta(minutes=optimal_time_min)).time()\n    return optimal_time.strftime('%H:%M')\n\ntime_data = [\n    \"13:45\", \"11:30\", \"15:00\", \"09:15\", \"22:10\", \"06:30\", \"17:50\",\n    \"10:00\", \"14:25\", \"20:15\", \"12:00\", \"19:40\", \"21:50\", \"08:45\",\n    \"23:00\", \"07:20\", \"16:05\", \"18:30\", \"05:10\", \"03:55\", \"02:25\",\n    \"01:40\", \"00:30\", \"04:50\", \"23:45\"\n]\n\noptimal_time = find_optimal_time(time_data)\nfor _ in range(20):\n    print(optimal_time)"}, {"role": "assistant", "content": "12:00\n12:00\n12:00\n12:00\n12:00\n12:00\n12:00\n12:00\n12:00\n12:00\n12:00\n12:00\n12:00\n12:00\n12:00\n12:00\n12:00\n12:00\n12:00\n12:00\n"}]}
{"messages": [{"role": "user", "content": "def sort_by_health(players):\n    return sorted(players, key=lambda x: x[1])\n\ndef assign_positions(players):\n    sorted_players = sort_by_health(players)\n    positions = ['defense', 'midfield', 'attack']\n    player_assignment = {}\n    for idx, player in enumerate(sorted_players):\n        position = positions[idx % len(positions)]\n        if position not in player_assignment:\n            player_assignment[position] = []\n        player_assignment[position].append(player)\n    return player_assignment\n\nplayers = [\n    ('Alice', 50),\n    ('Bob', 70),\n    ('Charlie', 40),\n    ('David', 60),\n    ('Eve', 80),\n    ('Frank', 30),\n    ('Grace', 55),\n    ('Heidi', 45),\n    ('Ivan', 65),\n    ('Judy', 75)\n]\n\nassigned_positions = assign_positions(players)\n\nfor position, assigned_players in assigned_positions.items():\n    print(f\"Position: {position}\")\n    for player in assigned_players:\n        print(f\"  Player: {player[0]}, Health: {player[1]}\")"}, {"role": "assistant", "content": "Position: defense\n  Player: Frank, Health: 30\n  Player: Alice, Health: 50\n  Player: Ivan, Health: 65\n  Player: Eve, Health: 80\nPosition: midfield\n  Player: Charlie, Health: 40\n  Player: Grace, Health: 55\n  Player: Bob, Health: 70\nPosition: attack\n  Player: Heidi, Health: 45\n  Player: David, Health: 60\n  Player: Judy, Health: 75\n"}]}
{"messages": [{"role": "user", "content": "import re\nfrom collections import Counter\n\ndef vigenere_decrypt(ciphertext, key):\n    decrypted = []\n    key_index = 0\n    key_length = len(key)\n    for char in ciphertext:\n        if char.isalpha():\n            shift = ord(key[key_index % key_length].lower()) - ord('a')\n            base = ord('A') if char.isupper() else ord('a')\n            decrypted.append(chr((ord(char) - base - shift) % 26 + base))\n            key_index += 1\n        else:\n            decrypted.append(char)\n    return ''.join(decrypted)\n\ndef find_key(ciphertext):\n    frequencies = Counter(re.findall(r'[A-Za-z]', ciphertext))\n    most_common = frequencies.most_common(1)\n    if most_common:\n        most_common_letter = most_common[0][0].lower()\n        assumed_key_letter = 'e'\n        key_shift = (ord(most_common_letter) - ord(assumed_key_letter)) % 26\n        return chr(ord('a') + key_shift)\n    return None\n\nciphertext = \"\"\"Iaqv jvvrv jre, Iaqv vqvrv jre, Iaqv svprv jre,\nGsvv zmbgsliw xlnnvmhgvw yvxlm, Gsvv zmbgsliw xlnnvmhgvw yvxlm,\nBpmzm wzbghrmt nbpm Iaqv rmhgdhsr.\"\"\"\nkey = find_key(ciphertext)\nif key:\n    print(vigenere_decrypt(ciphertext, key))"}, {"role": "assistant", "content": "Rjze seeae san, Rjze ezeae san, Rjze beyae san,\nPbee ivkpburf guwwevqpef heguv, Pbee ivkpburf guwwevqpef heguv,\nKyviv fikpqavc wkyv Rjze avqpmqba.\n"}]}
{"messages": [{"role": "user", "content": "def create_pattern(n):\n    pattern = []\n    for i in range(n):\n        pattern.append(\" \" * (n - i - 1) + \"*\" * (2 * i + 1) + \" \" * (n - i - 1))\n    return pattern\n\ndef sort_patterns(patterns):\n    return sorted(patterns, key=lambda x: x.count('*'))\n\nn = 10\npatterns = create_pattern(n)\nsorted_patterns = sort_patterns(patterns)\n\nprint(\"Generated Patterns:\")\nfor p in patterns:\n    print(p)\n\nprint(\"\\nSorted Patterns by Number of Stars:\")\nfor p in sorted_patterns:\n    print(p)"}, {"role": "assistant", "content": "Generated Patterns:\n         *         \n        ***        \n       *****       \n      *******      \n     *********     \n    ***********    \n   *************   \n  ***************  \n ***************** \n*******************\n\nSorted Patterns by Number of Stars:\n         *         \n        ***        \n       *****       \n      *******      \n     *********     \n    ***********    \n   *************   \n  ***************  \n ***************** \n*******************\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\nimport statistics\n\ndata = [\n    (\"2023-10-01\", 23.5),\n    (\"2023-10-02\", 24.1),\n    (\"2023-10-03\", 22.8),\n    (\"2023-10-04\", 25.2),\n    (\"2023-10-05\", 24.5),\n    (\"2023-10-06\", 26.1),\n    (\"2023-10-07\", 25.9),\n    (\"2023-10-08\", 23.4),\n    (\"2023-10-09\", 24.7),\n    (\"2023-10-10\", 25.3),\n    (\"2023-10-11\", 22.9),\n    (\"2023-10-12\", 23.6),\n    (\"2023-10-13\", 24.8),\n    (\"2023-10-14\", 26.4),\n    (\"2023-10-15\", 25.0),\n    (\"2023-10-16\", 24.2),\n    (\"2023-10-17\", 23.1),\n    (\"2023-10-18\", 25.8),\n    (\"2023-10-19\", 26.0),\n    (\"2023-10-20\", 24.6),\n]\n\ndata.sort(key=lambda x: x[1])\n\nstart_date = datetime.strptime(data[0][0], \"%Y-%m-%d\")\nend_date = datetime.strptime(data[-1][0], \"%Y-%m-%d\")\ndate_range = (end_date - start_date).days + 1\n\ntemperature_ranges = []\nfor i in range(date_range):\n    day = start_date + timedelta(days=i)\n    day_str = day.strftime(\"%Y-%m-%d\")\n    day_temperatures = [temp for date, temp in data if date == day_str]\n    if day_temperatures:\n        temperature_ranges.append((day_str, max(day_temperatures) - min(day_temperatures)))\n\ntemperature_ranges.sort(key=lambda x: x[1], reverse=True)\n\nmedian_index = len(temperature_ranges) // 2\nmedian_range = statistics.median([temp_range for _, temp_range in temperature_ranges])\n\nfor date, temp_range in temperature_ranges:\n    print(f\"Date: {date}, Range of Temperature: {temp_range:.2f}\")\n\nprint(f\"\\nMedian of Temperature Ranges: {median_range:.2f}\")"}, {"role": "assistant", "content": "Date: 2023-10-03, Range of Temperature: 0.00\nDate: 2023-10-04, Range of Temperature: 0.00\nDate: 2023-10-05, Range of Temperature: 0.00\nDate: 2023-10-06, Range of Temperature: 0.00\nDate: 2023-10-07, Range of Temperature: 0.00\nDate: 2023-10-08, Range of Temperature: 0.00\nDate: 2023-10-09, Range of Temperature: 0.00\nDate: 2023-10-10, Range of Temperature: 0.00\nDate: 2023-10-11, Range of Temperature: 0.00\nDate: 2023-10-12, Range of Temperature: 0.00\nDate: 2023-10-13, Range of Temperature: 0.00\nDate: 2023-10-14, Range of Temperature: 0.00\n\nMedian of Temperature Ranges: 0.00\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndata = [\n    41, 45, 30, 39, 35, 50, 48, 36, 38, 42,\n    40, 47, 49, 31, 32, 33, 34, 43, 44, 37\n]\n\ndef bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n\ndef calculate_median(sorted_data):\n    n = len(sorted_data)\n    if n % 2 == 1:\n        return sorted_data[n // 2]\n    else:\n        mid1, mid2 = sorted_data[n // 2 - 1], sorted_data[n // 2]\n        return (mid1 + mid2) / 2\n\ndef calculate_iqr(sorted_data):\n    n = len(sorted_data)\n    q1_index = math.floor((n + 1) / 4)\n    q3_index = math.ceil((3 * (n + 1)) / 4)\n    q1 = sorted_data[q1_index]\n    q3 = sorted_data[q3_index]\n    return q3 - q1\n\nbubble_sort(data)\nprint(\"Sorted Data:\", data)\n\nmedian = calculate_median(data)\nprint(\"Median:\", median)\n\niqr = calculate_iqr(data)\nprint(\"Interquartile Range (IQR):\", iqr)\n\nprint(\"Detailed Sorted Data with Indices:\")\nfor index, value in enumerate(data):\n    print(f\"Index {index}: {value}\")"}, {"role": "assistant", "content": "Sorted Data: [30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 47, 48, 49, 50]\nMedian: 39.5\nInterquartile Range (IQR): 12\nDetailed Sorted Data with Indices:\nIndex 0: 30\nIndex 1: 31\nIndex 2: 32\nIndex 3: 33\nIndex 4: 34\nIndex 5: 35\nIndex 6: 36\nIndex 7: 37\nIndex 8: 38\nIndex 9: 39\nIndex 10: 40\nIndex 11: 41\nIndex 12: 42\nIndex 13: 43\nIndex 14: 44\nIndex 15: 45\nIndex 16: 47\nIndex 17: 48\nIndex 18: 49\nIndex 19: 50\n"}]}
{"messages": [{"role": "user", "content": "from statistics import mean, median, mode\nimport math\n\ndata = [\n    12, 14, 15, 16, 16, 18, 21, 22, 22, 23, 25, 26, 29, 30,\n    31, 33, 34, 35, 36, 37, 37, 38, 40, 41, 42, 45, 47, 50,\n    52, 54, 55, 56, 56, 58, 59, 60, 62, 63, 65, 67, 69, 70,\n    71, 73, 74, 75, 76, 78, 80, 82, 82, 85, 87, 90, 91, 93\n]\n\nmean_val = mean(data)\nmedian_val = median(data)\nmode_val = mode(data)\n\ndef binary_search(sorted_list, target):\n    low = 0\n    high = len(sorted_list) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if sorted_list[mid] == target:\n            return mid\n        elif sorted_list[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n\nmean_index = binary_search(sorted(data), mean_val)\nmedian_index = binary_search(sorted(data), median_val)\nmode_index = binary_search(sorted(data), mode_val)\n\noutput = [\n    f\"Mean: {mean_val} found at index {mean_index}\",\n    f\"Median: {median_val} found at index {median_index}\",\n    f\"Mode: {mode_val} found at index {mode_index}\"\n]\n\nfor line in output:\n    print(line)\n\nfor value in range(10, 100, 3):\n    index = binary_search(sorted(data), value)\n    if index != -1:\n        print(f\"Value {value} found at index {index}\")"}, {"role": "assistant", "content": "Mean: 50.32142857142857 found at index -1\nMedian: 51.0 found at index -1\nMode: 16 found at index 4\nValue 16 found at index 4\nValue 22 found at index 7\nValue 25 found at index 10\nValue 31 found at index 14\nValue 34 found at index 16\nValue 37 found at index 20\nValue 40 found at index 22\nValue 52 found at index 28\nValue 55 found at index 30\nValue 58 found at index 33\nValue 67 found at index 39\nValue 70 found at index 41\nValue 73 found at index 43\nValue 76 found at index 46\nValue 82 found at index 50\nValue 85 found at index 51\nValue 91 found at index 54\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef is_fibonacci(n):\n    x1 = 5 * n * n + 4\n    x2 = 5 * n * n - 4\n    return math.isqrt(x1) ** 2 == x1 or math.isqrt(x2) ** 2 == x2\n\ndef custom_sort(seq):\n    return sorted(seq, key=lambda x: (not is_fibonacci(x), x))\n\nsequence = [34, 8, 13, 21, 1, 144, 3, 55, 89, 2, 233, 5, 377, 610, 1, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657]\n\nsorted_sequence = custom_sort(sequence)\n\nfor num in sorted_sequence:\n    print(num)"}, {"role": "assistant", "content": "1\n1\n2\n3\n5\n8\n13\n21\n34\n55\n89\n144\n233\n377\n610\n987\n1597\n2584\n4181\n6765\n10946\n17711\n28657\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\n# Generate a list of random dates within this month\nbase_date = datetime.now()\ndates = [base_date - timedelta(days=i*2) for i in range(20)]\n\n# Custom sorting function for dates that sorts by the day of the week\ndef custom_date_sort(date_list):\n    day_order = {'Monday': 0, 'Tuesday': 1, 'Wednesday': 2, 'Thursday': 3,\n                 'Friday': 4, 'Saturday': 5, 'Sunday': 6}\n    return sorted(date_list, key=lambda date: (day_order[date.strftime('%A')], date))\n\nsorted_dates = custom_date_sort(dates)\n\nprint(\"Generated Dates:\")\nfor date in dates:\n    print(date.strftime(\"%Y-%m-%d %A\"))\n\nprint(\"\\nSorted Dates:\")\nfor date in sorted_dates:\n    print(date.strftime(\"%Y-%m-%d %A\"))"}, {"role": "assistant", "content": "Generated Dates:\n2025-04-01 Tuesday\n2025-03-30 Sunday\n2025-03-28 Friday\n2025-03-26 Wednesday\n2025-03-24 Monday\n2025-03-22 Saturday\n2025-03-20 Thursday\n2025-03-18 Tuesday\n2025-03-16 Sunday\n2025-03-14 Friday\n2025-03-12 Wednesday\n2025-03-10 Monday\n2025-03-08 Saturday\n2025-03-06 Thursday\n2025-03-04 Tuesday\n2025-03-02 Sunday\n2025-02-28 Friday\n2025-02-26 Wednesday\n2025-02-24 Monday\n2025-02-22 Saturday\n\nSorted Dates:\n2025-02-24 Monday\n2025-03-10 Monday\n2025-03-24 Monday\n2025-03-04 Tuesday\n2025-03-18 Tuesday\n2025-04-01 Tuesday\n2025-02-26 Wednesday\n2025-03-12 Wednesday\n2025-03-26 Wednesday\n2025-03-06 Thursday\n2025-03-20 Thursday\n2025-02-28 Friday\n2025-03-14 Friday\n2025-03-28 Friday\n2025-02-22 Saturday\n2025-03-08 Saturday\n2025-03-22 Saturday\n2025-03-02 Sunday\n2025-03-16 Sunday\n2025-03-30 Sunday\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\nimport bisect\n\ndef generate_dates():\n    start_date = datetime(2000, 1, 1)\n    date_list = []\n    for i in range(0, 3650, 10):\n        date_list.append(start_date + timedelta(days=i))\n    return date_list\n\ndef find_closest_date(dates, target):\n    pos = bisect.bisect_left(dates, target)\n    if pos == 0:\n        return dates[0]\n    if pos == len(dates):\n        return dates[-1]\n    before = dates[pos - 1]\n    after = dates[pos]\n    if after - target < target - before:\n        return after\n    else:\n        return before\n\ndef main():\n    dates = generate_dates()\n    target_dates = [\n        datetime(2005, 3, 15),\n        datetime(2010, 6, 5),\n        datetime(2020, 12, 25),\n        datetime(2003, 7, 19),\n    ]\n    \n    for target in target_dates:\n        closest_date = find_closest_date(dates, target)\n        print(f\"Target Date: {target.strftime('%Y-%m-%d')} -> Closest Date: {closest_date.strftime('%Y-%m-%d')}\")\n\nmain()"}, {"role": "assistant", "content": "Target Date: 2005-03-15 -> Closest Date: 2005-03-15\nTarget Date: 2010-06-05 -> Closest Date: 2009-12-19\nTarget Date: 2020-12-25 -> Closest Date: 2009-12-19\nTarget Date: 2003-07-19 -> Closest Date: 2003-07-14\n"}]}
{"messages": [{"role": "user", "content": "def fibonacci_sequence(n):\n    sequence = [0, 1]\n    for _ in range(2, n):\n        sequence.append(sequence[-1] + sequence[-2])\n    return sequence\n\ndef is_palindrome(number):\n    s = str(number)\n    return s == s[::-1]\n\ndef palindrome_fibonacci(n):\n    fib_sequence = fibonacci_sequence(n)\n    palindromes = [num for num in fib_sequence if is_palindrome(num)]\n    return palindromes\n\ndef main():\n    fib_palindromes = palindrome_fibonacci(100)\n    sorted_palindromes = sorted(fib_palindromes, key=lambda x: int(str(x)[::-1]))\n    for num in sorted_palindromes:\n        print(num)\n\nmain()"}, {"role": "assistant", "content": "0\n1\n1\n2\n3\n5\n8\n55\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef generate_pattern(n):\n    if n == 1:\n        return [\"*\"]\n    smaller_pattern = generate_pattern(n - 1)\n    new_pattern = []\n    for line in smaller_pattern:\n        new_pattern.append(\" \" + line + \" \")\n    border = \"*\" * (2 * n - 1)\n    new_pattern.insert(0, border)\n    new_pattern.append(border)\n    return new_pattern\n\ndef search_pattern(pattern, text):\n    for idx, line in enumerate(text):\n        print(f\"Searching in line {idx}: {line}\")\n        match = re.search(pattern, line)\n        if match:\n            print(f\"Pattern '{pattern}' found in line {idx+1}: {line}\")\n            return idx, match.start()\n    return -1, -1\n\ndef main():\n    n = 10\n    pattern = generate_pattern(n)\n    text = [\" \" * i + line for i, line in enumerate(pattern)]\n    \n    for line in text:\n        print(line)\n    \n    search_term = \"\\\\*\\\\*\"\n    line, position = search_pattern(search_term, text)\n    if line != -1:\n        print(f\"Pattern found at line {line}, position {position}.\")\n    else:\n        print(\"Pattern not found.\")\n\nmain()"}, {"role": "assistant", "content": "*******************\n  ***************** \n    ***************  \n      *************   \n        ***********    \n          *********     \n            *******      \n              *****       \n                ***        \n                  *         \n                  ***        \n                  *****       \n                  *******      \n                  *********     \n                  ***********    \n                  *************   \n                  ***************  \n                  ***************** \n                  *******************\nSearching in line 0: *******************\nPattern '\\*\\*' found in line 1: *******************\nPattern found at line 0, position 0.\n"}]}
{"messages": [{"role": "user", "content": "import re\nfrom collections import defaultdict\n\ntext = \"\"\"In a village of La Mancha, the name of which I have no desire to call to mind, there lived not long since one of those gentlemen that keep a lance in the lance-rack, an old buckler, a lean hack, and a greyhound for coursing. An olla of rather more beef than mutton, a salad on most nights, scraps on Saturdays, lentils on Fridays, and a pigeon or so extra on Sundays, made away with three-quarters of his income.\"\"\"\n\nwords = re.findall(r'\\b\\w+\\b', text.lower())\nword_freq = defaultdict(int)\n\nfor word in words:\n    word_freq[word] += 1\n\nsorted_words = sorted(word_freq.keys(), key=lambda x: (-word_freq[x], x))\n\nsorted_text = ' '.join(sorted_words)\n\nsentences = sorted_text.split()\nsorted_sentences = sorted(sentences, key=lambda x: len(x))\n\nfor word in sorted_sentences:\n    print(word)"}, {"role": "assistant", "content": "a\ni\nof\non\nan\nin\nto\nla\nno\nor\nso\nand\nthe\nfor\nhis\nnot\nold\none\naway\nbeef\ncall\nhack\nhave\nkeep\nlean\nlong\nmade\nmind\nmore\nmost\nname\nolla\nrack\nthan\nthat\nwith\nlance\nextra\nlived\nsalad\nsince\nthere\nthose\nthree\nwhich\ndesire\nincome\nmancha\nmutton\nnights\npigeon\nrather\nscraps\nbuckler\nfridays\nlentils\nsundays\nvillage\ncoursing\nquarters\ngentlemen\ngreyhound\nsaturdays\n"}]}
{"messages": [{"role": "user", "content": "def find_next_permutation(arr):\n    n = len(arr)\n    i = n - 2\n    while i >= 0 and arr[i] >= arr[i + 1]:\n        i -= 1\n    if i == -1:\n        return sorted(arr)\n    j = n - 1\n    while arr[j] <= arr[i]:\n        j -= 1\n    arr[i], arr[j] = arr[j], arr[i]\n    return arr[:i + 1] + sorted(arr[i + 1:])\n\ndef transform_and_search(data):\n    transformed_data = [sum([ord(c) for c in str(num)]) for num in data]\n    sorted_data = sorted(transformed_data)\n    unique_data = list(dict.fromkeys(sorted_data))\n    return unique_data\n\ndata = [234, 123, 345, 567, 789, 678, 456, 345]\ntransformed_data = transform_and_search(data)\n\nfor i in range(10):\n    transformed_data = find_next_permutation(transformed_data)\n    print(transformed_data)"}, {"role": "assistant", "content": "[150, 153, 156, 159, 162, 168, 165]\n[150, 153, 156, 159, 165, 162, 168]\n[150, 153, 156, 159, 165, 168, 162]\n[150, 153, 156, 159, 168, 162, 165]\n[150, 153, 156, 159, 168, 165, 162]\n[150, 153, 156, 162, 159, 165, 168]\n[150, 153, 156, 162, 159, 168, 165]\n[150, 153, 156, 162, 165, 159, 168]\n[150, 153, 156, 162, 165, 168, 159]\n[150, 153, 156, 162, 168, 159, 165]\n"}]}
{"messages": [{"role": "user", "content": "def generate_fibonacci_sequence(n):\n    sequence = [0, 1]\n    while len(sequence) < n:\n        sequence.append(sequence[-1] + sequence[-2])\n    return sequence\n\ndef binary_search(sequence, target):\n    low, high = 0, len(sequence) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if sequence[mid] == target:\n            return mid\n        elif sequence[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n\ndef main():\n    fib_sequence = generate_fibonacci_sequence(20)\n    print(\"Fibonacci Sequence:\", fib_sequence)\n    \n    target_values = [5, 8, 21, 34, 55, 89]\n    for target in target_values:\n        print(f\"\\nSearching for {target} in the Fibonacci sequence.\")\n        result = binary_search(fib_sequence, target)\n        if result != -1:\n            print(f\"Found {target} at index {result}.\")\n        else:\n            print(f\"{target} is not in the sequence.\")\n\nmain()"}, {"role": "assistant", "content": "Fibonacci Sequence: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181]\n\nSearching for 5 in the Fibonacci sequence.\nFound 5 at index 5.\n\nSearching for 8 in the Fibonacci sequence.\nFound 8 at index 6.\n\nSearching for 21 in the Fibonacci sequence.\nFound 21 at index 8.\n\nSearching for 34 in the Fibonacci sequence.\nFound 34 at index 9.\n\nSearching for 55 in the Fibonacci sequence.\nFound 55 at index 10.\n\nSearching for 89 in the Fibonacci sequence.\nFound 89 at index 11.\n"}]}
{"messages": [{"role": "user", "content": "data_points = [\n    (12, 23), (34, 45), (56, 78), (12, 10), (23, 22), (45, 33),\n    (67, 89), (89, 67), (21, 34), (43, 12), (65, 43), (87, 56)\n]\n\ndef sort_by_second_element(data):\n    return sorted(data, key=lambda x: x[0])\n\nsorted_data = sort_by_second_element(data_points)\n\nfor point in sorted_data:\n    print(point)"}, {"role": "assistant", "content": "(12, 23)\n(12, 10)\n(21, 34)\n(23, 22)\n(34, 45)\n(43, 12)\n(45, 33)\n(56, 78)\n(65, 43)\n(67, 89)\n(87, 56)\n(89, 67)\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef angle_from_origin(point):\n    return math.atan2(point[1], point[0])\n\ndef distance_from_origin(point):\n    return math.sqrt(point[0]**2 + point[1]**2)\n\ndef sort_points_by_angle_then_distance(points):\n    return sorted(points, key=lambda point: (angle_from_origin(point), distance_from_origin(point)))\n\npoints = [\n    (3, 4), (1, 2), (4, 3), (-1, -1), (-2, 1), (0, -3), \n    (2, -2), (-3, -3), (4, -4), (5, 5), (-5, 5), (1, -1)\n]\n\nsorted_points = sort_points_by_angle_then_distance(points)\n\nfor point in sorted_points:\n    print(f\"{point}: angle = {angle_from_origin(point):.2f}, distance = {distance_from_origin(point):.2f}\")"}, {"role": "assistant", "content": "(-1, -1): angle = -2.36, distance = 1.41\n(-3, -3): angle = -2.36, distance = 4.24\n(0, -3): angle = -1.57, distance = 3.00\n(1, -1): angle = -0.79, distance = 1.41\n(2, -2): angle = -0.79, distance = 2.83\n(4, -4): angle = -0.79, distance = 5.66\n(4, 3): angle = 0.64, distance = 5.00\n(5, 5): angle = 0.79, distance = 7.07\n(3, 4): angle = 0.93, distance = 5.00\n(1, 2): angle = 1.11, distance = 2.24\n(-5, 5): angle = 2.36, distance = 7.07\n(-2, 1): angle = 2.68, distance = 2.24\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef custom_sort_dates(dates):\n    print(f\"Original dates: {dates}\")\n    dates.sort(key=lambda date: datetime.datetime.strptime(date, '%Y-%m-%d'))\n    print(f\"Sorted dates: {dates}\")\n    return dates\n\ndef transform_dates(dates):\n    print(\"Transforming dates...\")\n    sorted_dates = custom_sort_dates(dates)\n    transformed_dates = [date.replace('-', '/') for date in sorted_dates]\n    print(f\"Transformed dates: {transformed_dates}\")\n    return transformed_dates\n\ndates_list = [\n    '2023-10-05', '2023-01-01', '2023-05-12', '2023-08-22',\n    '2022-11-15', '2023-07-06', '2023-04-18', '2022-12-31'\n]\n\ntransformed_list = transform_dates(dates_list)\nprint(\"\\nFinal result:\")\nfor date in transformed_list:\n    print(date)"}, {"role": "assistant", "content": "Transforming dates...\nOriginal dates: ['2023-10-05', '2023-01-01', '2023-05-12', '2023-08-22', '2022-11-15', '2023-07-06', '2023-04-18', '2022-12-31']\nSorted dates: ['2022-11-15', '2022-12-31', '2023-01-01', '2023-04-18', '2023-05-12', '2023-07-06', '2023-08-22', '2023-10-05']\nTransformed dates: ['2022/11/15', '2022/12/31', '2023/01/01', '2023/04/18', '2023/05/12', '2023/07/06', '2023/08/22', '2023/10/05']\n\nFinal result:\n2022/11/15\n2022/12/31\n2023/01/01\n2023/04/18\n2023/05/12\n2023/07/06\n2023/08/22\n2023/10/05\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndata = [\n    (23, 45), (12, 67), (34, 78), (56, 89), (67, 90),\n    (89, 23), (45, 56), (78, 12), (90, 34), (11, 22),\n    (22, 33), (33, 44), (44, 55), (55, 66), (66, 77),\n    (77, 88), (88, 99), (99, 11), (13, 24), (24, 35)\n]\n\ndef euclidean_distance(point1, point2):\n    return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)\n\ndef find_closest_pair(data):\n    min_distance = float('inf')\n    closest_pair = None\n    for i in range(len(data)):\n        for j in range(i + 1, len(data)):\n            distance = euclidean_distance(data[i], data[j])\n            if distance < min_distance:\n                min_distance = distance\n                closest_pair = (data[i], data[j])\n    return closest_pair, min_distance\n\nclosest, distance = find_closest_pair(data)\noutput = f\"Closest pair: {closest} with distance: {distance:.2f}\"\n\nfor _ in range(10):\n    print(output)"}, {"role": "assistant", "content": "Closest pair: ((45, 56), (44, 55)) with distance: 1.41\nClosest pair: ((45, 56), (44, 55)) with distance: 1.41\nClosest pair: ((45, 56), (44, 55)) with distance: 1.41\nClosest pair: ((45, 56), (44, 55)) with distance: 1.41\nClosest pair: ((45, 56), (44, 55)) with distance: 1.41\nClosest pair: ((45, 56), (44, 55)) with distance: 1.41\nClosest pair: ((45, 56), (44, 55)) with distance: 1.41\nClosest pair: ((45, 56), (44, 55)) with distance: 1.41\nClosest pair: ((45, 56), (44, 55)) with distance: 1.41\nClosest pair: ((45, 56), (44, 55)) with distance: 1.41\n"}]}
{"messages": [{"role": "user", "content": "from datetime import date, timedelta\n\ndef generate_dates(start_date, end_date):\n    delta = end_date - start_date\n    return [start_date + timedelta(days=i) for i in range(delta.days + 1)]\n\ndef is_leap_year(year):\n    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n\ndef find_fridays_13th(dates):\n    fridays_13th = []\n    for d in dates:\n        if d.day == 13 and d.weekday() == 4:\n            fridays_13th.append(d)\n    return fridays_13th\n\ndef main():\n    start_year = 2000\n    end_year = 2025\n    fridays_13th_all_years = []\n    \n    for year in range(start_year, end_year + 1):\n        start_date = date(year, 1, 1)\n        if is_leap_year(year):\n            end_date = date(year, 12, 31)\n        else:\n            end_date = date(year, 12, 31)\n        \n        all_dates = generate_dates(start_date, end_date)\n        fridays_13th = find_fridays_13th(all_dates)\n        fridays_13th_all_years.extend(fridays_13th)\n    \n    for f13 in fridays_13th_all_years:\n        print(f13.strftime(\"%Y-%m-%d\"))\n\nmain()"}, {"role": "assistant", "content": "2000-10-13\n2001-04-13\n2001-07-13\n2002-09-13\n2002-12-13\n2003-06-13\n2004-02-13\n2004-08-13\n2005-05-13\n2006-01-13\n2006-10-13\n2007-04-13\n2007-07-13\n2008-06-13\n2009-02-13\n2009-03-13\n2009-11-13\n2010-08-13\n2011-05-13\n2012-01-13\n2012-04-13\n2012-07-13\n2013-09-13\n2013-12-13\n2014-06-13\n2015-02-13\n2015-03-13\n2015-11-13\n2016-05-13\n2017-01-13\n2017-10-13\n2018-04-13\n2018-07-13\n2019-09-13\n2019-12-13\n2020-03-13\n2020-11-13\n2021-08-13\n2022-05-13\n2023-01-13\n2023-10-13\n2024-09-13\n2024-12-13\n2025-06-13\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef encode_message(message):\n    return ''.join(format(ord(char), '08b') for char in message)\n\ndef decode_message(encoded):\n    return ''.join(chr(int(encoded[i:i+8], 2)) for i in range(0, len(encoded), 8))\n\ndef bitwise_sort(encoded):\n    pairs = [encoded[i:i+8] for i in range(0, len(encoded), 8)]\n    sorted_pairs = sorted(pairs, key=lambda b: int(b, 2))\n    return ''.join(sorted_pairs)\n\ndef custom_sort(encoded):\n    pattern = re.compile(r'1{3,}')\n    sorted_encoded = sorted(encoded, key=lambda x: (len(pattern.findall(x)), x))\n    return ''.join(sorted_encoded)\n\noriginal_message = \"SortingAlgorithmsAreFun!\"\nprint(\"Original Message:\", original_message)\n\nencoded_message = encode_message(original_message)\nprint(\"Encoded Message:\", encoded_message)\n\nbitwise_sorted = bitwise_sort(encoded_message)\nprint(\"Bitwise Sorted:\", bitwise_sorted)\n\ncustom_sorted = custom_sort(encoded_message)\nprint(\"Custom Sorted:\", custom_sorted)\n\ndecoded_message_bitwise = decode_message(bitwise_sorted)\nprint(\"Decoded Bitwise Sorted Message:\", decoded_message_bitwise)\n\ndecoded_message_custom = decode_message(custom_sorted)\nprint(\"Decoded Custom Sorted Message:\", decoded_message_custom)"}, {"role": "assistant", "content": "Original Message: SortingAlgorithmsAreFun!\nEncoded Message: 010100110110111101110010011101000110100101101110011001110100000101101100011001110110111101110010011010010111010001101000011011010111001101000001011100100110010101000110011101010110111000100001\nBitwise Sorted: 001000010100000101000001010001100101001101100101011001110110011101101000011010010110100101101100011011010110111001101110011011110110111101110010011100100111001001110011011101000111010001110101\nCustom Sorted: 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\nDecoded Bitwise Sorted Message: !AAFSegghiilmnnoorrrsttu\nDecoded Custom Sorted Message: \u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0007\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\n"}]}
{"messages": [{"role": "user", "content": "from itertools import combinations\n\ndef hand_strength(hand):\n    values = sorted([card[0] for card in hand], reverse=True)\n    if values == list(range(values[0], values[0]-5, -1)):\n        return (5, values)\n    pairs = [v for v in set(values) if values.count(v) > 1]\n    if len(pairs) == 2:\n        return (4, sorted(pairs, reverse=True))\n    if pairs:\n        return (3, pairs*2 + [v for v in values if v not in pairs])\n    return (2, values)\n\ndef get_best_hand(deck):\n    all_hands = list(combinations(deck, 5))\n    strengths = [(hand_strength(hand), hand) for hand in all_hands]\n    return sorted(strengths, reverse=True)[0][1]\n\ndeck = [\n    (2, 'Hearts'), (3, 'Hearts'), (4, 'Hearts'), (5, 'Hearts'), (6, 'Hearts'),\n    (7, 'Diamonds'), (8, 'Clubs'), (9, 'Spades'), (10, 'Hearts'),\n    (11, 'Diamonds'), (12, 'Clubs'), (13, 'Spades'), (14, 'Hearts')\n]\n\nbest_hand = get_best_hand(deck)\noutput = [f\"{card[0]} of {card[1]}\" for card in best_hand]\nfor line in output:\n    print(line)"}, {"role": "assistant", "content": "10 of Hearts\n11 of Diamonds\n12 of Clubs\n13 of Spades\n14 of Hearts\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef knight_moves(position):\n    x, y = position\n    moves = [\n        (x + 2, y + 1), (x + 2, y - 1), (x - 2, y + 1), (x - 2, y - 1),\n        (x + 1, y + 2), (x + 1, y - 2), (x - 1, y + 2), (x - 1, y - 2)\n    ]\n    return [(a, b) for a, b in moves if 0 <= a < 8 and 0 <= b < 8]\n\ndef bfs_knight_shortest_path(start, end):\n    queue = [(start, 0)]\n    visited = set()\n    while queue:\n        current, depth = queue.pop(0)\n        if current == end:\n            return depth\n        if current in visited:\n            continue\n        visited.add(current)\n        for move in knight_moves(current):\n            queue.append((move, depth + 1))\n\ndef generate_chess_board(starting_position):\n    board = [['.' for _ in range(8)] for _ in range(8)]\n    board[starting_position[0]][starting_position[1]] = 'K'\n    return board\n\ndef display_board(board):\n    for row in board:\n        print(' '.join(row))\n\ndef solve_knight_challenge():\n    board = generate_chess_board((0, 0))\n    destinations = [(7, 7), (6, 5), (5, 0), (7, 1)]\n    paths = []\n    for destination in destinations:\n        path_length = bfs_knight_shortest_path((0, 0), destination)\n        paths.append((destination, path_length))\n    \n    display_board(board)\n    print(\"\\nKnight's Shortest Paths:\")\n    for dest, length in paths:\n        print(f\"To {dest}: {length} moves\")\n\nsolve_knight_challenge()"}, {"role": "assistant", "content": "K . . . . . . .\n. . . . . . . .\n. . . . . . . .\n. . . . . . . .\n. . . . . . . .\n. . . . . . . .\n. . . . . . . .\n. . . . . . . .\n\nKnight's Shortest Paths:\nTo (7, 7): 6 moves\nTo (6, 5): 5 moves\nTo (5, 0): 3 moves\nTo (7, 1): 4 moves\n"}]}
{"messages": [{"role": "user", "content": "def generate_pattern(size):\n    pattern = [[0] * size for _ in range(size)]\n    num = 1\n\n    for layer in range((size + 1) // 2):\n        for i in range(layer, size - layer):\n            pattern[layer][i] = num\n            num += 1\n        for i in range(layer + 1, size - layer):\n            pattern[i][size - layer - 1] = num\n            num += 1\n        for i in range(size - layer - 2, layer - 1, -1):\n            pattern[size - layer - 1][i] = num\n            num += 1\n        for i in range(size - layer - 2, layer, -1):\n            pattern[i][layer] = num\n            num += 1\n\n    return pattern\n\ndef search_pattern(pattern, target):\n    for i, row in enumerate(pattern):\n        for j, val in enumerate(row):\n            if val == target:\n                return (i, j)\n    return None\n\npattern_size = 10\npattern = generate_pattern(pattern_size)\ntarget = 31\nposition = search_pattern(pattern, target)\n\nfor row in pattern:\n    print(\" \".join(f\"{num:2}\" for num in row))\n\nprint(f\"\\nThe number {target} is located at position: {position}\")"}, {"role": "assistant", "content": " 1  2  3  4  5  6  7  8  9 10\n36 37 38 39 40 41 42 43 44 11\n35 64 65 66 67 68 69 70 45 12\n34 63 84 85 86 87 88 71 46 13\n33 62 83 96 97 98 89 72 47 14\n32 61 82 95 100 99 90 73 48 15\n31 60 81 94 93 92 91 74 49 16\n30 59 80 79 78 77 76 75 50 17\n29 58 57 56 55 54 53 52 51 18\n28 27 26 25 24 23 22 21 20 19\n\nThe number 31 is located at position: (6, 0)\n"}]}
{"messages": [{"role": "user", "content": "import itertools\n\ndef caesar_cipher(text, shift):\n    encrypted_text = \"\"\n    for char in text:\n        if char.isalpha():\n            shift_amount = shift % 26\n            new_char = chr(((ord(char.lower()) - 97 + shift_amount) % 26) + 97)\n            encrypted_text += new_char.upper() if char.isupper() else new_char\n        else:\n            encrypted_text += char\n    return encrypted_text\n\ndef decrypt_caesar_cipher(encrypted_text):\n    results = []\n    for shift in range(26):\n        decrypted_text = caesar_cipher(encrypted_text, -shift)\n        results.append(decrypted_text)\n    return results\n\ndef search_for_phrase(phrase, text_list):\n    for idx, text in enumerate(text_list):\n        if phrase in text:\n            return idx, text\n    return None, None\n\ndef main():\n    encrypted_text = \"L ORYH SURJUDPPLQJ LQ SBWKRQ\"\n    possible_decryptions = decrypt_caesar_cipher(encrypted_text)\n    phrase_to_search = \"PYTHON\"\n    index, decrypted_text = search_for_phrase(phrase_to_search, possible_decryptions)\n    if index is not None:\n        print(f\"Found '{phrase_to_search}' in the decrypted text: {decrypted_text}\")\n\nmain()"}, {"role": "assistant", "content": "Found 'PYTHON' in the decrypted text: I LOVE PROGRAMMING IN PYTHON\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndates = [\n    \"2023-10-15 14:30:00\",\n    \"2022-01-01 00:00:00\",\n    \"2021-12-25 09:00:00\",\n    \"2023-07-04 17:45:00\",\n    \"2022-11-11 11:11:11\",\n    \"2023-05-05 05:05:05\",\n    \"2022-08-08 08:08:08\",\n    \"2021-01-01 01:01:01\",\n    \"2023-04-01 12:00:00\",\n    \"2022-06-06 06:06:06\"\n]\n\ndatetime_objects = [datetime.strptime(date, \"%Y-%m-%d %H:%M:%S\") for date in dates]\n\nprint(\"Original datetimes:\")\nfor dt in datetime_objects:\n    print(dt)\n\nsorted_datetimes = sorted(datetime_objects, key=lambda x: (x.month, x.day))\n\nprint(\"\\nSorted by month and day (ignoring year and time):\")\nfor dt in sorted_datetimes:\n    print(dt)\n\nextended_datetimes = [dt + timedelta(days=365 * 2) for dt in sorted_datetimes]\n\nprint(\"\\nDates extended by two years:\")\nfor dt in extended_datetimes:\n    print(dt)\n\nsorted_extended = sorted(extended_datetimes, key=lambda x: x.weekday())\n\nprint(\"\\nSorted by weekday after extension:\")\nfor dt in sorted_extended:\n    print(dt)"}, {"role": "assistant", "content": "Original datetimes:\n2023-10-15 14:30:00\n2022-01-01 00:00:00\n2021-12-25 09:00:00\n2023-07-04 17:45:00\n2022-11-11 11:11:11\n2023-05-05 05:05:05\n2022-08-08 08:08:08\n2021-01-01 01:01:01\n2023-04-01 12:00:00\n2022-06-06 06:06:06\n\nSorted by month and day (ignoring year and time):\n2022-01-01 00:00:00\n2021-01-01 01:01:01\n2023-04-01 12:00:00\n2023-05-05 05:05:05\n2022-06-06 06:06:06\n2023-07-04 17:45:00\n2022-08-08 08:08:08\n2023-10-15 14:30:00\n2022-11-11 11:11:11\n2021-12-25 09:00:00\n\nDates extended by two years:\n2024-01-01 00:00:00\n2023-01-01 01:01:01\n2025-03-31 12:00:00\n2025-05-04 05:05:05\n2024-06-05 06:06:06\n2025-07-03 17:45:00\n2024-08-07 08:08:08\n2025-10-14 14:30:00\n2024-11-10 11:11:11\n2023-12-25 09:00:00\n\nSorted by weekday after extension:\n2024-01-01 00:00:00\n2025-03-31 12:00:00\n2023-12-25 09:00:00\n2025-10-14 14:30:00\n2024-06-05 06:06:06\n2024-08-07 08:08:08\n2025-07-03 17:45:00\n2023-01-01 01:01:01\n2025-05-04 05:05:05\n2024-11-10 11:11:11\n"}]}
{"messages": [{"role": "user", "content": "from statistics import mean, median\n\ndef custom_sort(data, key=None):\n    if key is None:\n        key = lambda x: x\n    sorted_data = sorted(data, key=key)\n    return sorted_data\n\ndef interquartile_range(data):\n    sorted_data = custom_sort(data)\n    mid = len(sorted_data) // 2\n    if len(sorted_data) % 2 == 0:\n        lower_half = sorted_data[:mid]\n        upper_half = sorted_data[mid:]\n    else:\n        lower_half = sorted_data[:mid]\n        upper_half = sorted_data[mid+1:]\n    q1 = median(lower_half)\n    q3 = median(upper_half)\n    return q3 - q1\n\ndataset = [\n    83, 65, 45, 91, 82, 75, 67, 89, 77, 73,\n    90, 81, 68, 85, 76, 79, 88, 92, 71, 74,\n    87, 69, 78, 72, 80, 86, 70, 66, 84, 93\n]\n\nsorted_dataset = custom_sort(dataset)\nmean_value = mean(sorted_dataset)\nmedian_value = median(sorted_dataset)\niqr_value = interquartile_range(sorted_dataset)\n\noutput = [\n    f\"Sorted Data: {sorted_dataset}\",\n    f\"Mean: {mean_value:.2f}\",\n    f\"Median: {median_value:.2f}\",\n    f\"Interquartile Range: {iqr_value:.2f}\"\n]\n\nfor line in output:\n    print(line)"}, {"role": "assistant", "content": "Sorted Data: [45, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93]\nMean: 77.87\nMedian: 78.50\nInterquartile Range: 15.00\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef sort_dates_and_times(dates_and_times):\n    print(\"Original list:\")\n    for dt in dates_and_times:\n        print(dt.strftime(\"%Y-%m-%d %H:%M:%S\"))\n    \n    sorted_dates_and_times = sorted(dates_and_times, key=lambda dt: dt.date())\n    \n    print(\"\\nSorted list:\")\n    for dt in sorted_dates_and_times:\n        print(dt.strftime(\"%Y-%m-%d %H:%M:%S\"))\n    \n    return sorted_dates_and_times\n\ndates_and_times = [\n    datetime.datetime(2023, 5, 17, 15, 30, 45),\n    datetime.datetime(2023, 5, 17, 10, 15, 30),\n    datetime.datetime(2023, 4, 25, 8, 0, 0),\n    datetime.datetime(2023, 6, 5, 12, 20, 10),\n    datetime.datetime(2023, 5, 25, 9, 45, 15),\n    datetime.datetime(2023, 4, 28, 23, 59, 59),\n    datetime.datetime(2023, 6, 1, 6, 30, 30),\n    datetime.datetime(2023, 5, 10, 17, 45, 15),\n    datetime.datetime(2023, 4, 30, 14, 20, 10),\n    datetime.datetime(2023, 6, 3, 11, 10, 5)\n]\n\nsorted_dates_and_times = sort_dates_and_times(dates_and_times)"}, {"role": "assistant", "content": "Original list:\n2023-05-17 15:30:45\n2023-05-17 10:15:30\n2023-04-25 08:00:00\n2023-06-05 12:20:10\n2023-05-25 09:45:15\n2023-04-28 23:59:59\n2023-06-01 06:30:30\n2023-05-10 17:45:15\n2023-04-30 14:20:10\n2023-06-03 11:10:05\n\nSorted list:\n2023-04-25 08:00:00\n2023-04-28 23:59:59\n2023-04-30 14:20:10\n2023-05-10 17:45:15\n2023-05-17 15:30:45\n2023-05-17 10:15:30\n2023-05-25 09:45:15\n2023-06-01 06:30:30\n2023-06-03 11:10:05\n2023-06-05 12:20:10\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef find_closest_point(points, target):\n    def distance_squared(p1, p2):\n        return (p1[0] - p2[0])**2 + (p1[1] - p2[1])**2\n    \n    closest_point = points[0]\n    min_distance = distance_squared(closest_point, target)\n    \n    for point in points[1:]:\n        dist = distance_squared(point, target)\n        if dist < min_distance:\n            min_distance = dist\n            closest_point = point\n\n    return closest_point\n\ndef generate_circle_points(radius, num_points):\n    return [(radius * math.cos(2 * math.pi * i / num_points),\n             radius * math.sin(2 * math.pi * i / num_points)) for i in range(num_points)]\n\ncircle_radius = 5\nnum_circle_points = 30\npoints = generate_circle_points(circle_radius, num_circle_points)\ntarget_point = (3.5, 1.5)\n\nclosest = find_closest_point(points, target_point)\n\nfor i, point in enumerate(points):\n    print(f\"Point {i}: {point}\")\n\nprint(\"\\nTarget Point:\", target_point)\nprint(\"Closest Point:\", closest)"}, {"role": "assistant", "content": "Point 0: (5.0, 0.0)\nPoint 1: (4.8907380036690284, 1.0395584540887965)\nPoint 2: (4.567727288213004, 2.0336832153790008)\nPoint 3: (4.045084971874737, 2.938926261462366)\nPoint 4: (3.345653031794291, 3.715724127386971)\nPoint 5: (2.5000000000000004, 4.330127018922193)\nPoint 6: (1.5450849718747373, 4.755282581475767)\nPoint 7: (0.5226423163382673, 4.972609476841367)\nPoint 8: (-0.5226423163382666, 4.972609476841367)\nPoint 9: (-1.5450849718747368, 4.755282581475768)\nPoint 10: (-2.499999999999999, 4.330127018922194)\nPoint 11: (-3.3456530317942894, 3.7157241273869723)\nPoint 12: (-4.045084971874736, 2.9389262614623664)\nPoint 13: (-4.567727288213005, 2.0336832153790003)\nPoint 14: (-4.8907380036690284, 1.0395584540887965)\nPoint 15: (-5.0, 2.8327694488239896e-15)\nPoint 16: (-4.8907380036690284, -1.0395584540887954)\nPoint 17: (-4.567727288213004, -2.033683215379001)\nPoint 18: (-4.045084971874737, -2.938926261462365)\nPoint 19: (-3.345653031794292, -3.71572412738697)\nPoint 20: (-2.500000000000002, -4.330127018922192)\nPoint 21: (-1.5450849718747377, -4.755282581475767)\nPoint 22: (-0.5226423163382712, -4.972609476841367)\nPoint 23: (0.522642316338265, -4.972609476841367)\nPoint 24: (1.5450849718747361, -4.755282581475768)\nPoint 25: (2.5000000000000004, -4.330127018922193)\nPoint 26: (3.345653031794292, -3.71572412738697)\nPoint 27: (4.045084971874736, -2.938926261462367)\nPoint 28: (4.567727288213004, -2.0336832153790008)\nPoint 29: (4.8907380036690284, -1.039558454088795)\n\nTarget Point: (3.5, 1.5)\nClosest Point: (4.567727288213004, 2.0336832153790008)\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef generate_pattern(n):\n    pattern = []\n    for i in range(n):\n        row = [(i * n + j + 1) for j in range(n)]\n        pattern.append(row)\n    return pattern\n\ndef print_pattern(pattern):\n    for row in pattern:\n        print(' '.join(f\"{num:3}\" for num in row))\n\ndef sort_diagonals(pattern):\n    n = len(pattern)\n    diagonals = []\n    for d in range(2 * n - 1):\n        diag = []\n        for i in range(n):\n            for j in range(n):\n                if i - j == d - n + 1:\n                    diag.append(pattern[i][j])\n        diagonals.append(sorted(diag))\n    \n    for d in range(2 * n - 1):\n        idx = 0\n        for i in range(n):\n            for j in range(n):\n                if i - j == d - n + 1:\n                    pattern[i][j] = diagonals[d][idx]\n                    idx += 1\n\nn = 10\npattern = generate_pattern(n)\nprint(\"Original Pattern:\")\nprint_pattern(pattern)\n\nsort_diagonals(pattern)\nprint(\"\\nSorted Diagonals Pattern:\")\nprint_pattern(pattern)"}, {"role": "assistant", "content": "Original Pattern:\n  1   2   3   4   5   6   7   8   9  10\n 11  12  13  14  15  16  17  18  19  20\n 21  22  23  24  25  26  27  28  29  30\n 31  32  33  34  35  36  37  38  39  40\n 41  42  43  44  45  46  47  48  49  50\n 51  52  53  54  55  56  57  58  59  60\n 61  62  63  64  65  66  67  68  69  70\n 71  72  73  74  75  76  77  78  79  80\n 81  82  83  84  85  86  87  88  89  90\n 91  92  93  94  95  96  97  98  99 100\n\nSorted Diagonals Pattern:\n  1   2   3   4   5   6   7   8   9  10\n 11  12  13  14  15  16  17  18  19  20\n 21  22  23  24  25  26  27  28  29  30\n 31  32  33  34  35  36  37  38  39  40\n 41  42  43  44  45  46  47  48  49  50\n 51  52  53  54  55  56  57  58  59  60\n 61  62  63  64  65  66  67  68  69  70\n 71  72  73  74  75  76  77  78  79  80\n 81  82  83  84  85  86  87  88  89  90\n 91  92  93  94  95  96  97  98  99 100\n"}]}
{"messages": [{"role": "user", "content": "import math\nfrom datetime import datetime, timedelta\n\ndef mean_absolute_deviation(data):\n    mean_val = sum(data) / len(data)\n    return sum(abs(x - mean_val) for x in data) / len(data)\n\ndef binary_search_mad(data, target_mad, tolerance=0.01):\n    low, high = min(data), max(data)\n    best_guess = low\n    closest_mad = float('inf')\n    \n    while high - low > tolerance:\n        mid = (low + high) / 2\n        guess_data = [x + mid for x in data]\n        current_mad = mean_absolute_deviation(guess_data)\n        \n        print(f\"Low: {low:.2f}, High: {high:.2f}, Mid: {mid:.2f}, Current MAD: {current_mad:.2f}\")\n        \n        if abs(current_mad - target_mad) < abs(closest_mad - target_mad):\n            closest_mad = current_mad\n            best_guess = mid\n        \n        if current_mad < target_mad:\n            low = mid\n        else:\n            high = mid\n    \n    return best_guess, closest_mad\n\ndef generate_time_series_data(size, start_date):\n    data = []\n    current_date = start_date\n    for _ in range(size):\n        day_of_year = current_date.timetuple().tm_yday\n        value = 50 + 25 * math.sin(2 * math.pi * day_of_year / 365)\n        data.append(value)\n        current_date += timedelta(days=1)\n    return data\n\nstart_date = datetime(2023, 1, 1)\ndata = generate_time_series_data(365, start_date)\n\ntarget_mad = 12.0\ntolerance = 0.01\n\nbest_offset, achieved_mad = binary_search_mad(data, target_mad, tolerance)\n\nprint(f\"Best Offset: {best_offset:.2f}, Achieved MAD: {achieved_mad:.2f}\")\n\nfor day, value in enumerate(data[:10]):\n    print(f\"Day {day + 1}: Original value: {value:.2f}, Adjusted value: {value + best_offset:.2f}\")"}, {"role": "assistant", "content": "Low: 25.00, High: 75.00, Mid: 50.00, Current MAD: 15.92\nLow: 25.00, High: 50.00, Mid: 37.50, Current MAD: 15.92\nLow: 25.00, High: 37.50, Mid: 31.25, Current MAD: 15.92\nLow: 25.00, High: 31.25, Mid: 28.13, Current MAD: 15.92\nLow: 25.00, High: 28.13, Mid: 26.56, Current MAD: 15.92\nLow: 25.00, High: 26.56, Mid: 25.78, Current MAD: 15.92\nLow: 25.00, High: 25.78, Mid: 25.39, Current MAD: 15.92\nLow: 25.00, High: 25.39, Mid: 25.20, Current MAD: 15.92\nLow: 25.00, High: 25.20, Mid: 25.10, Current MAD: 15.92\nLow: 25.00, High: 25.10, Mid: 25.05, Current MAD: 15.92\nLow: 25.00, High: 25.05, Mid: 25.02, Current MAD: 15.92\nLow: 25.00, High: 25.02, Mid: 25.01, Current MAD: 15.92\nLow: 25.00, High: 25.01, Mid: 25.01, Current MAD: 15.92\nBest Offset: 25.78, Achieved MAD: 15.92\nDay 1: Original value: 50.43, Adjusted value: 76.21\nDay 2: Original value: 50.86, Adjusted value: 76.64\nDay 3: Original value: 51.29, Adjusted value: 77.07\nDay 4: Original value: 51.72, Adjusted value: 77.50\nDay 5: Original value: 52.15, Adjusted value: 77.93\nDay 6: Original value: 52.58, Adjusted value: 78.36\nDay 7: Original value: 53.01, Adjusted value: 78.79\nDay 8: Original value: 53.43, Adjusted value: 79.21\nDay 9: Original value: 53.86, Adjusted value: 79.64\nDay 10: Original value: 54.28, Adjusted value: 80.06\n"}]}
{"messages": [{"role": "user", "content": "text = \"\"\"Once upon a time, in a land far, far away, there was a kingdom. In this kingdom,\nthe people were happy and lived in harmony. They loved stories, especially those that\nwere passed down from generation to generation. Each night, the elders would gather\nthe children around a grand fireplace and tell them tales of bravery, adventure, and\nmagic. These stories were filled with characters of all kinds, from brave knights and\nwise wizards to cunning foxes and gentle giants.\"\"\"\n\nwords = text.split()\nsearch_word = \"and\"\n\ndef find_occurrences(words, search_word):\n    return [i for i, word in enumerate(words) if word.strip(\".,\") == search_word]\n\noccurrences = find_occurrences(words, search_word)\nfor index in occurrences:\n    snippet_start = max(0, index - 5)\n    snippet_end = min(len(words), index + 6)\n    snippet = \" \".join(words[snippet_start:snippet_end])\n    print(f\"Found '{search_word}' at position {index}: ...{snippet}...\")"}, {"role": "assistant", "content": "Found 'and' at position 21: ...kingdom, the people were happy and lived in harmony. They loved...\nFound 'and' at position 50: ...children around a grand fireplace and tell them tales of bravery,...\nFound 'and' at position 57: ...them tales of bravery, adventure, and magic. These stories were filled...\nFound 'and' at position 71: ...all kinds, from brave knights and wise wizards to cunning foxes...\nFound 'and' at position 77: ...wise wizards to cunning foxes and gentle giants....\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef distance_from_origin(x, y):\n    return math.sqrt(x**2 + y**2)\n\npoints = [(5, 3), (2, 8), (6, 1), (1, 7), (9, 5), (3, 4), (7, 2), (8, 0), (4, 6), (0, 9)]\n\nprint(\"Original points:\")\nfor point in points:\n    print(point)\n\nsorted_points = sorted(points, key=lambda point: distance_from_origin(*point))\n\nprint(\"\\nPoints sorted by distance from origin:\")\nfor point in sorted_points:\n    print(point)\n\nareas = []\n\nfor i in range(len(sorted_points) - 2):\n    p1, p2, p3 = sorted_points[i], sorted_points[i + 1], sorted_points[i + 2]\n    area = abs(0.5 * (p1[0]*(p2[1] - p3[1]) + p2[0]*(p3[1] - p1[1]) + p3[0]*(p1[1] - p2[1])))\n    areas.append((p1, p2, p3, area))\n    print(f\"\\nTriangle with points {p1}, {p2}, {p3} has area: {area}\")\n\nlargest_area_triangle = max(areas, key=lambda x: x[3])\n\nprint(\"\\nTriangle with the largest area:\")\nprint(f\"Points: {largest_area_triangle[0]}, {largest_area_triangle[1]}, {largest_area_triangle[2]}\")\nprint(f\"Area: {largest_area_triangle[3]}\")"}, {"role": "assistant", "content": "Original points:\n(5, 3)\n(2, 8)\n(6, 1)\n(1, 7)\n(9, 5)\n(3, 4)\n(7, 2)\n(8, 0)\n(4, 6)\n(0, 9)\n\nPoints sorted by distance from origin:\n(3, 4)\n(5, 3)\n(6, 1)\n(1, 7)\n(4, 6)\n(7, 2)\n(8, 0)\n(2, 8)\n(0, 9)\n(9, 5)\n\nTriangle with points (3, 4), (5, 3), (6, 1) has area: 1.5\n\nTriangle with points (5, 3), (6, 1), (1, 7) has area: 2.0\n\nTriangle with points (6, 1), (1, 7), (4, 6) has area: 6.5\n\nTriangle with points (1, 7), (4, 6), (7, 2) has area: 4.5\n\nTriangle with points (4, 6), (7, 2), (8, 0) has area: 1.0\n\nTriangle with points (7, 2), (8, 0), (2, 8) has area: 2.0\n\nTriangle with points (8, 0), (2, 8), (0, 9) has area: 5.0\n\nTriangle with points (2, 8), (0, 9), (9, 5) has area: 0.5\n\nTriangle with the largest area:\nPoints: (6, 1), (1, 7), (4, 6)\nArea: 6.5\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef transform_data(data):\n    transformed = []\n    for line in data:\n        if re.search(r'\\d', line):\n            numbers = re.findall(r'\\d+', line)\n            transformed.append(sorted(map(int, numbers)))\n        else:\n            transformed.append(sorted(line.split()))\n    return transformed\n\ndef binary_search(arr, target):\n    low, high = 0, len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        print(f\"Searching for {target} in {arr[low:high+1]}, mid: {arr[mid]}\")\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n\ndef search_in_transformed(transformed):\n    search_terms = [\"3\", \"banana\", \"42\", \"apple\"]\n    results = []\n    for line in transformed:\n        for term in search_terms:\n            index = binary_search(line, term)\n            if index != -1:\n                results.append((term, line, index))\n    return results\n\ndata = [\n    \"apple orange banana 42\",\n    \"3 15 8 42 7\",\n    \"cat dog elephant\",\n    \"hello world 2023\",\n    \"12 3 14 7 29\",\n]\n\ntransformed = transform_data(data)\nprint(\"Transformed Data:\")\nfor line in transformed:\n    print(line)\n\nresults = search_in_transformed(transformed)\nprint(\"\\nSearch Results:\")\nfor result in results:\n    print(f\"Found '{result[0]}' in {result[1]} at index {result[2]}\")"}, {"role": "assistant", "content": "Traceback (most recent call last):\n  File \"<string>\", line 49, in <module>\n  File \"<string>\", line 31, in search_in_transformed\n  File \"<string>\", line 20, in binary_search\nTypeError: '<' not supported between instances of 'int' and 'str'\n"}]}
{"messages": [{"role": "user", "content": "import re\nfrom datetime import datetime\n\ndef parse_dates(text):\n    date_pattern = r'\\b\\d{2}/\\d{2}/\\d{4}\\b'\n    return [datetime.strptime(date, '%m/%d/%Y') for date in re.findall(date_pattern, text)]\n\ndef calculate_date_differences(dates):\n    return [(dates[i] - dates[i - 1]).days for i in range(1, len(dates))]\n\ndef sort_dates_by_difference(dates, differences):\n    return [date for _, date in sorted(zip(differences, dates[1:]), reverse=True)]\n\ninput_text = \"\"\"\nEvent A: 10/21/2021\nEvent B: 01/15/2020\nEvent C: 03/05/2022\nEvent D: 07/19/2020\nEvent E: 12/31/2020\n\"\"\"\n\ndates = parse_dates(input_text)\nsorted_dates = sorted(dates)\ndifferences = calculate_date_differences(sorted_dates)\nsorted_by_diff = sort_dates_by_difference(sorted_dates, differences)\n\nprint(\"Parsed Dates:\")\nfor date in sorted_dates:\n    print(date.strftime('%m/%d/%Y'))\n\nprint(\"\\nDate Differences (in days):\")\nfor diff in differences:\n    print(diff)\n\nprint(\"\\nDates Sorted by Largest Difference:\")\nfor date in sorted_by_diff:\n    print(date.strftime('%m/%d/%Y'))"}, {"role": "assistant", "content": "Parsed Dates:\n01/15/2020\n07/19/2020\n12/31/2020\n10/21/2021\n03/05/2022\n\nDate Differences (in days):\n186\n165\n294\n135\n\nDates Sorted by Largest Difference:\n10/21/2021\n07/19/2020\n12/31/2020\n03/05/2022\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef is_point_inside_circle(px, py, cx, cy, r):\n    return (px - cx) ** 2 + (py - cy) ** 2 <= r ** 2\n\ndef find_tangent_points(px, py, cx, cy, r):\n    dx, dy = px - cx, py - cy\n    dist = math.sqrt(dx**2 + dy**2)\n    if dist <= r:\n        return []\n    angle = math.atan2(dy, dx)\n    theta = math.acos(r / dist)\n    angles = [angle + theta, angle - theta]\n    points = [(cx + r * math.cos(a), cy + r * math.sin(a)) for a in angles]\n    return points\n\ncircle_center = (0, 0)\nradius = 10\npoints = [\n    (15, 0), (8, 8), (-12, 0), (0, 12), (9, -9),\n    (-7, -7), (5, 12), (12, 5), (-5, 12), (8, -8)\n]\n\nfor px, py in points:\n    if is_point_inside_circle(px, py, *circle_center, radius):\n        print(f\"Point ({px}, {py}) is inside the circle.\")\n    else:\n        tangent_points = find_tangent_points(px, py, *circle_center, radius)\n        print(f\"Point ({px}, {py}) is outside the circle.\")\n        if tangent_points:\n            for tx, ty in tangent_points:\n                print(f\"  Tangent point: ({tx:.2f}, {ty:.2f})\")"}, {"role": "assistant", "content": "Point (15, 0) is outside the circle.\n  Tangent point: (6.67, 7.45)\n  Tangent point: (6.67, -7.45)\nPoint (8, 8) is outside the circle.\n  Tangent point: (2.94, 9.56)\n  Tangent point: (9.56, 2.94)\nPoint (-12, 0) is outside the circle.\n  Tangent point: (-8.33, -5.53)\n  Tangent point: (-8.33, 5.53)\nPoint (0, 12) is outside the circle.\n  Tangent point: (-5.53, 8.33)\n  Tangent point: (5.53, 8.33)\nPoint (9, -9) is outside the circle.\n  Tangent point: (9.93, -1.18)\n  Tangent point: (1.18, -9.93)\nPoint (-7, -7) is inside the circle.\nPoint (5, 12) is outside the circle.\n  Tangent point: (-2.94, 9.56)\n  Tangent point: (8.86, 4.64)\nPoint (12, 5) is outside the circle.\n  Tangent point: (4.64, 8.86)\n  Tangent point: (9.56, -2.94)\nPoint (-5, 12) is outside the circle.\n  Tangent point: (-8.86, 4.64)\n  Tangent point: (2.94, 9.56)\nPoint (8, -8) is outside the circle.\n  Tangent point: (9.56, -2.94)\n  Tangent point: (2.94, -9.56)\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef generate_data():\n    return [math.sin(i) + math.cos(i/2) for i in range(1, 101)]\n\ndef search_peak(data):\n    left, right = 0, len(data) - 1\n    while left < right:\n        mid = left + (right - left) // 2\n        if data[mid] < data[mid + 1]:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\ndata = generate_data()\npeak_index = search_peak(data)\nprint(\"Generated Data:\")\nfor i, value in enumerate(data):\n    print(f\"{i+1}: {value:.4f}\")\n\nprint(f\"\\nPeak found at index: {peak_index}, Value: {data[peak_index]:.4f}\")"}, {"role": "assistant", "content": "Generated Data:\n1: 1.7191\n2: 1.4496\n3: 0.2119\n4: -1.1729\n5: -1.7601\n6: -1.2694\n7: -0.2795\n8: 0.3357\n9: 0.2013\n10: -0.2604\n11: -0.2913\n12: 0.4236\n13: 1.3968\n14: 1.7445\n15: 0.9969\n16: -0.4334\n17: -1.5634\n18: -1.6621\n19: -0.8473\n20: 0.0739\n21: 0.3611\n22: -0.0044\n23: -0.3629\n24: -0.0617\n25: 0.8654\n26: 1.6700\n27: 1.5513\n28: 0.4076\n29: -1.0186\n30: -1.7477\n31: -1.3825\n32: -0.4062\n33: 0.2975\n34: 0.2539\n35: -0.2087\n36: -0.3315\n37: 0.2960\n38: 1.2851\n39: 1.7596\n40: 1.1532\n41: -0.2382\n42: -1.4643\n43: -1.7136\n44: -0.9823\n45: -0.0224\n46: 0.3690\n47: 0.0617\n48: -0.3441\n49: -0.1473\n50: 0.7288\n51: 1.6035\n52: 1.6335\n53: 0.5981\n54: -0.8509\n55: -1.7146\n56: -1.4842\n57: -0.5385\n58: 0.2448\n59: 0.2984\n60: -0.1506\n61: -0.3571\n62: 0.1756\n63: 1.1638\n64: 1.7542\n65: 1.2946\n66: -0.0398\n67: -1.3466\n68: -1.7465\n69: -1.1131\n70: -0.1298\n71: 0.3633\n72: 0.1259\n73: -0.3136\n74: -0.2197\n75: 0.5925\n76: 1.5212\n77: 1.6956\n78: 0.7806\n79: -0.6722\n80: -1.6608\n81: -1.5724\n82: -0.6741\n83: 0.1779\n84: 0.3332\n85: -0.0877\n86: -0.3683\n87: 0.0641\n88: 1.0352\n89: 1.7290\n90: 1.4193\n91: 0.1591\n92: -1.2116\n93: -1.7599\n94: -1.2376\n95: -0.2468\n96: 0.3434\n97: 0.1861\n98: -0.2728\n99: -0.2782\n100: 0.4586\n\nPeak found at index: 95, Value: 0.3434\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef generate_dates(start_date, num_days):\n    return [(start_date + timedelta(days=i)).strftime('%Y-%m-%d') for i in range(num_days)]\n\ndef date_to_integer(date_str):\n    return int(date_str.replace('-', ''))\n\ndef integer_to_date(date_int):\n    date_str = str(date_int)\n    return f\"{date_str[:4]}-{date_str[4:6]}-{date_str[6:]}\"\n\ndef special_sort(dates):\n    date_integers = [date_to_integer(date) for date in dates]\n    # Sort based on digit sum, then lexicographically\n    date_integers.sort(key=lambda x: (sum(int(d) for d in str(x)), x))\n    return [integer_to_date(date_int) for date_int in date_integers]\n\nstart = datetime(2023, 1, 1)\ndates = generate_dates(start, 50)\nsorted_dates = special_sort(dates)\n\nfor date in sorted_dates:\n    print(date)"}, {"role": "assistant", "content": "2023-01-01\n2023-01-10\n2023-01-02\n2023-01-11\n2023-01-20\n2023-02-01\n2023-02-10\n2023-01-03\n2023-01-12\n2023-01-21\n2023-01-30\n2023-02-02\n2023-02-11\n2023-01-04\n2023-01-13\n2023-01-22\n2023-01-31\n2023-02-03\n2023-02-12\n2023-01-05\n2023-01-14\n2023-01-23\n2023-02-04\n2023-02-13\n2023-01-06\n2023-01-15\n2023-01-24\n2023-02-05\n2023-02-14\n2023-01-07\n2023-01-16\n2023-01-25\n2023-02-06\n2023-02-15\n2023-01-08\n2023-01-17\n2023-01-26\n2023-02-07\n2023-02-16\n2023-01-09\n2023-01-18\n2023-01-27\n2023-02-08\n2023-02-17\n2023-01-19\n2023-01-28\n2023-02-09\n2023-02-18\n2023-01-29\n2023-02-19\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef generate_game_events():\n    base_time = datetime(2023, 1, 1, 8, 0)\n    events = [\n        {\"event\": \"quest_start\", \"time\": base_time + timedelta(minutes=15)},\n        {\"event\": \"battle\", \"time\": base_time + timedelta(minutes=45)},\n        {\"event\": \"puzzle\", \"time\": base_time + timedelta(minutes=30)},\n        {\"event\": \"boss_fight\", \"time\": base_time + timedelta(minutes=90)},\n        {\"event\": \"item_discovery\", \"time\": base_time + timedelta(minutes=50)},\n        {\"event\": \"treasure\", \"time\": base_time + timedelta(minutes=65)},\n        {\"event\": \"side_quest\", \"time\": base_time + timedelta(minutes=20)}\n    ]\n    return events\n\ndef custom_sort(events):\n    def sorting_criteria(event):\n        return (event[\"time\"], len(event[\"event\"]), event[\"event\"])\n\n    return sorted(events, key=sorting_criteria)\n\ndef display_sorted_events(events):\n    sorted_events = custom_sort(events)\n    for event in sorted_events:\n        print(f\"{event['time'].strftime('%H:%M')} - {event['event']}\")\n\nevents = generate_game_events()\ndisplay_sorted_events(events)"}, {"role": "assistant", "content": "08:15 - quest_start\n08:20 - side_quest\n08:30 - puzzle\n08:45 - battle\n08:50 - item_discovery\n09:05 - treasure\n09:30 - boss_fight\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef is_fibonacci(n):\n    x1 = 5 * n * n + 4\n    x2 = 5 * n * n - 4\n    return math.isqrt(x1)**2 == x1 or math.isqrt(x2)**2 == x2\n\ndef fibonacci_search(arr, x):\n    fib_m2 = 0\n    fib_m1 = 1\n    fib_m = fib_m1 + fib_m2\n\n    while fib_m < len(arr):\n        fib_m2 = fib_m1\n        fib_m1 = fib_m\n        fib_m = fib_m1 + fib_m2\n\n    offset = -1\n\n    while fib_m > 1:\n        i = min(offset + fib_m2, len(arr) - 1)\n\n        if arr[i] < x:\n            fib_m = fib_m1\n            fib_m1 = fib_m2\n            fib_m2 = fib_m - fib_m1\n            offset = i\n        elif arr[i] > x:\n            fib_m = fib_m2\n            fib_m1 -= fib_m2\n            fib_m2 = fib_m - fib_m1\n        else:\n            return i\n\n    if fib_m1 and arr[offset + 1] == x:\n        return offset + 1\n\n    return -1\n\nsequence = [i for i in range(1, 101) if is_fibonacci(i)]\nprint(\"Fibonacci sequence within 1 to 100:\", sequence)\n\nto_search = [21, 34, 55, 89, 144, 233, 377, 610, 987]\nresults = []\n\nfor number in to_search:\n    print(f\"Searching for {number}\")\n    idx = fibonacci_search(sequence, number)\n    if idx != -1:\n        results.append((number, idx))\n    else:\n        results.append((number, \"Not Found\"))\n\nprint(\"\\nSearch Results:\")\nfor num, res in results:\n    print(f\"Number {num} - Index/Status: {res}\")"}, {"role": "assistant", "content": "Traceback (most recent call last):\n  File \"<string>\", line 48, in <module>\n  File \"<string>\", line 35, in fibonacci_search\nIndexError: list index out of range\n"}]}
{"messages": [{"role": "user", "content": "import re\nfrom datetime import datetime\n\ntext_data = \"\"\"\nThe quick brown fox jumps over the lazy dog.\nPack my box with five dozen liquor jugs.\nHow razorback-jumping frogs can level six piqued gymnasts!\nCozy lummox gives smart squid who asks for job pen.\n\"\"\"\n\ndef sort_sentences_by_date(text):\n    sentences = re.split(r'(?<=[.!?]) +', text.strip())\n    sentence_dates = [\n        (sentence, datetime.strptime(re.search(r'\\b\\w{3}\\b', sentence).group(), '%b').month)\n        for sentence in sentences\n    ]\n    sorted_sentences = sorted(sentence_dates, key=lambda x: x[1])\n    return [sentence for sentence, _ in sorted_sentences]\n\ndef month_from_sentence(sentence):\n    words = sentence.split()\n    months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n    for word in words:\n        if word in months:\n            return word\n    return None\n\ndef create_monthly_sentences(text):\n    sentences = re.split(r'(?<=[.!?]) +', text.strip())\n    monthly_sentences = {month: [] for month in range(1, 13)}\n    for sentence in sentences:\n        month_str = month_from_sentence(sentence)\n        if month_str:\n            month = datetime.strptime(month_str, '%b').month\n            monthly_sentences[month].append(sentence)\n    return monthly_sentences\n\nmonthly_sentences = create_monthly_sentences(text_data)\nsorted_sentences = sort_sentences_by_date(text_data)\n\nfor month in range(1, 13):\n    if monthly_sentences[month]:\n        print(f\"Month {month}:\")\n        for sentence in monthly_sentences[month]:\n            print(\" \", sentence)\n    else:\n        print(f\"Month {month}: No sentences\")\n\nprint(\"\\nSorted Sentences by Month Mentioned:\")\nfor sentence in sorted_sentences:\n    print(sentence)"}, {"role": "assistant", "content": "Traceback (most recent call last):\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 13, in sort_sentences_by_date\n  File \"<string>\", line 14, in <listcomp>\n  File \"/Users/nielswarncke/miniforge3/envs/kva/lib/python3.11/_strptime.py\", line 567, in _strptime_datetime\n    tt, fraction, gmtoff_fraction = _strptime(data_string, format)\n                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/Users/nielswarncke/miniforge3/envs/kva/lib/python3.11/_strptime.py\", line 349, in _strptime\n    raise ValueError(\"time data %r does not match format %r\" %\nValueError: time data 'The' does not match format '%b'\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndata = [12, 15, 12, 10, 9, 14, 13, 13, 14, 10, 12, 16, 11, 11, 15, 9, 10, 10, 15, 16]\n\ntarget_mean = 12.5\ntolerance = 0.05\n\ndef find_closest_mean(data, target_mean, tolerance):\n    data.sort()\n    n = len(data)\n    closest_mean = None\n    closest_diff = float('inf')\n    \n    for i in range(n):\n        for j in range(i+1, n+1):\n            subset = data[i:j]\n            current_mean = statistics.mean(subset)\n            diff = abs(current_mean - target_mean)\n            if diff < closest_diff and diff <= tolerance:\n                closest_diff = diff\n                closest_mean = subset\n\n    return closest_mean\n\nresult = find_closest_mean(data, target_mean, tolerance)\n\nfor item in result:\n    print(item)"}, {"role": "assistant", "content": "12\n12\n13\n13\n"}]}
{"messages": [{"role": "user", "content": "from math import pow\n\ndef encode_message(message):\n    encoded = []\n    for char in message:\n        encoded.append(ord(char) + 3)\n    return encoded\n\ndef decode_message(encoded):\n    decoded = ''\n    for num in encoded:\n        decoded += chr(num - 3)\n    return decoded\n\ndef sort_encoded(encoded):\n    return sorted(encoded, key=lambda x: pow(x % 10, 2))\n\nmessage = \"Encryption is fun!\"\nencoded_message = encode_message(message)\nprint(\"Encoded message:\", encoded_message)\n\nsorted_encoded = sort_encoded(encoded_message)\nprint(\"Sorted encoded message:\", sorted_encoded)\n\ndecoded_sorted = decode_message(sorted_encoded)\nprint(\"Decoded sorted message:\", decoded_sorted)\n\ndecoded_original = decode_message(encoded_message)\nprint(\"Decoded original message:\", decoded_original)"}, {"role": "assistant", "content": "Encoded message: [72, 113, 102, 117, 124, 115, 119, 108, 114, 113, 35, 108, 118, 35, 105, 120, 113, 36]\nSorted encoded message: [120, 72, 102, 113, 113, 113, 124, 114, 115, 35, 35, 105, 36, 117, 108, 108, 118, 119]\nDecoded sorted message: uEcnnnyop  f!riist\nDecoded original message: Encryption is fun!\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef generate_spiral_pattern(n):\n    spiral = [[' ' for _ in range(n)] for _ in range(n)]\n    x, y = n // 2, n // 2\n    step = 1\n    value = 1\n    directions = [(0, 1), (-1, 0), (0, -1), (1, 0)]\n    dir_index = 0\n\n    while value <= n * n:\n        for _ in range(2):\n            dx, dy = directions[dir_index]\n            for _ in range(step):\n                if 0 <= x < n and 0 <= y < n:\n                    spiral[x][y] = f'{value:2}'\n                    value += 1\n                x += dx\n                y += dy\n            dir_index = (dir_index + 1) % 4\n        step += 1\n\n    return spiral\n\ndef display_spiral(spiral):\n    for row in spiral:\n        print(' '.join(row))\n\nn = 9\nspiral = generate_spiral_pattern(n)\ndisplay_spiral(spiral)"}, {"role": "assistant", "content": "65 64 63 62 61 60 59 58 57\n66 37 36 35 34 33 32 31 56\n67 38 17 16 15 14 13 30 55\n68 39 18  5  4  3 12 29 54\n69 40 19  6  1  2 11 28 53\n70 41 20  7  8  9 10 27 52\n71 42 21 22 23 24 25 26 51\n72 43 44 45 46 47 48 49 50\n73 74 75 76 77 78 79 80 81\n"}]}
{"messages": [{"role": "user", "content": "from statistics import median\nimport math\n\ndef quicksort(arr):\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    return quicksort(left) + middle + quicksort(right)\n\ndef calculate_mode(arr):\n    frequency = {}\n    mode, max_count = None, 0\n    for number in arr:\n        frequency[number] = frequency.get(number, 0) + 1\n        if frequency[number] > max_count:\n            max_count = frequency[number]\n            mode = number\n        elif frequency[number] == max_count:\n            mode = min(mode, number)\n    return mode\n\ndef calculate_statistics(data):\n    sorted_data = quicksort(data)\n    mean = sum(sorted_data) / len(sorted_data)\n    med = median(sorted_data)\n    mod = calculate_mode(sorted_data)\n    std_dev = math.sqrt(sum((x - mean) ** 2 for x in sorted_data) / len(sorted_data))\n    return mean, med, mod, std_dev\n\ndata = [15, 13, 12, 18, 17, 16, 16, 19, 18, 15, 17, 14, 14, 19, 13, 16, 18, 12, 19, 15]\nmean, med, mod, std_dev = calculate_statistics(data)\n\nprint(\"Data:\", data)\nprint(\"Sorted Data:\", quicksort(data))\nprint(\"Mean:\", mean)\nprint(\"Median:\", med)\nprint(\"Mode:\", mod)\nprint(\"Standard Deviation:\", std_dev)"}, {"role": "assistant", "content": "Data: [15, 13, 12, 18, 17, 16, 16, 19, 18, 15, 17, 14, 14, 19, 13, 16, 18, 12, 19, 15]\nSorted Data: [12, 12, 13, 13, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 18, 18, 18, 19, 19, 19]\nMean: 15.8\nMedian: 16.0\nMode: 15\nStandard Deviation: 2.249444375840399\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef vigenere_encrypt(plaintext, key):\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    encrypted_text = ''\n    key_index = 0\n    for char in plaintext:\n        if char.upper() in alphabet:\n            shift = alphabet.index(key[key_index % len(key)].upper())\n            char_index = alphabet.index(char.upper())\n            encrypted_char = alphabet[(char_index + shift) % len(alphabet)]\n            if char.islower():\n                encrypted_char = encrypted_char.lower()\n            encrypted_text += encrypted_char\n            key_index += 1\n        else:\n            encrypted_text += char\n    return encrypted_text\n\ndef vigenere_decrypt(ciphertext, key):\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    decrypted_text = ''\n    key_index = 0\n    for char in ciphertext:\n        if char.upper() in alphabet:\n            shift = alphabet.index(key[key_index % len(key)].upper())\n            char_index = alphabet.index(char.upper())\n            decrypted_char = alphabet[(char_index - shift) % len(alphabet)]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            decrypted_text += decrypted_char\n            key_index += 1\n        else:\n            decrypted_text += char\n    return decrypted_text\n\ndef search_for_key(ciphertext, target):\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    for key_length in range(1, len(ciphertext)):\n        for key in itertools.product(alphabet, repeat=key_length):\n            key_str = ''.join(key)\n            decrypted = vigenere_decrypt(ciphertext, key_str)\n            if re.search(r'\\b' + re.escape(target) + r'\\b', decrypted, re.IGNORECASE):\n                return key_str, decrypted\n    return None, None\n\nplaintext = \"The quick brown fox jumps over the lazy dog\"\nkey = \"SECRET\"\nciphertext = vigenere_encrypt(plaintext, key)\n\nfound_key, decrypted_message = search_for_key(ciphertext, \"jumps\")\nprint(f\"Found Key: {found_key}\")\nprint(f\"Decrypted Message: {decrypted_message}\")"}, {"role": "assistant", "content": "Traceback (most recent call last):\n  File \"<string>\", line 51, in <module>\n  File \"<string>\", line 40, in search_for_key\nNameError: name 'itertools' is not defined\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef custom_sort(dates):\n    return sorted(dates, key=lambda date: date.weekday())\n\ndef generate_dates(start_date, num_days):\n    date_list = [start_date + timedelta(days=i) for i in range(num_days)]\n    return date_list\n\ndef print_dates(dates):\n    for date in dates:\n        print(date.strftime(\"%Y-%m-%d %A\"))\n\nstart_date = datetime(2023, 1, 1)\nnum_days = 30\n\ndates = generate_dates(start_date, num_days)\nprint(\"Original Dates:\")\nprint_dates(dates)\n\nsorted_dates = custom_sort(dates)\nprint(\"\\nSorted Dates by Weekday:\")\nprint_dates(sorted_dates)"}, {"role": "assistant", "content": "Original Dates:\n2023-01-01 Sunday\n2023-01-02 Monday\n2023-01-03 Tuesday\n2023-01-04 Wednesday\n2023-01-05 Thursday\n2023-01-06 Friday\n2023-01-07 Saturday\n2023-01-08 Sunday\n2023-01-09 Monday\n2023-01-10 Tuesday\n2023-01-11 Wednesday\n2023-01-12 Thursday\n2023-01-13 Friday\n2023-01-14 Saturday\n2023-01-15 Sunday\n2023-01-16 Monday\n2023-01-17 Tuesday\n2023-01-18 Wednesday\n2023-01-19 Thursday\n2023-01-20 Friday\n2023-01-21 Saturday\n2023-01-22 Sunday\n2023-01-23 Monday\n2023-01-24 Tuesday\n2023-01-25 Wednesday\n2023-01-26 Thursday\n2023-01-27 Friday\n2023-01-28 Saturday\n2023-01-29 Sunday\n2023-01-30 Monday\n\nSorted Dates by Weekday:\n2023-01-02 Monday\n2023-01-09 Monday\n2023-01-16 Monday\n2023-01-23 Monday\n2023-01-30 Monday\n2023-01-03 Tuesday\n2023-01-10 Tuesday\n2023-01-17 Tuesday\n2023-01-24 Tuesday\n2023-01-04 Wednesday\n2023-01-11 Wednesday\n2023-01-18 Wednesday\n2023-01-25 Wednesday\n2023-01-05 Thursday\n2023-01-12 Thursday\n2023-01-19 Thursday\n2023-01-26 Thursday\n2023-01-06 Friday\n2023-01-13 Friday\n2023-01-20 Friday\n2023-01-27 Friday\n2023-01-07 Saturday\n2023-01-14 Saturday\n2023-01-21 Saturday\n2023-01-28 Saturday\n2023-01-01 Sunday\n2023-01-08 Sunday\n2023-01-15 Sunday\n2023-01-22 Sunday\n2023-01-29 Sunday\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndates = [\n    \"2023-06-18\", \"2021-12-25\", \"2022-11-11\",\n    \"2020-01-01\", \"2019-07-04\", \"2022-04-01\",\n    \"2023-03-15\", \"2021-10-31\", \"2022-02-14\",\n    \"2023-12-31\", \"2020-08-08\", \"2021-05-05\"\n]\n\ndate_objects = [datetime.strptime(date, \"%Y-%m-%d\") for date in dates]\n\ndef sort_dates(dates_list):\n    return sorted(dates_list, key=lambda x: (x.month, x.day))\n\nsorted_dates = sort_dates(date_objects)\n\nnext_year_dates = [(date + timedelta(days=365)).strftime(\"%Y-%m-%d\") for date in sorted_dates]\n\nfor date in next_year_dates:\n    print(date)"}, {"role": "assistant", "content": "2020-12-31\n2023-02-14\n2024-03-14\n2023-04-01\n2022-05-05\n2024-06-17\n2020-07-03\n2021-08-08\n2022-10-31\n2023-11-11\n2022-12-25\n2024-12-30\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"\nPython is an interpreted, high-level and general-purpose programming language. Python's design\nphilosophy emphasizes code readability with its notable use of significant indentation. Its\nlanguage constructs and object-oriented approach aim to help programmers write clear, logical\ncode for small and large-scale projects.\n\"\"\"\n\nwords = re.findall(r'\\b\\w+\\b', text.lower())\nunique_words = list(set(words))\n\ndef custom_sort(word):\n    vowels = 'aeiou'\n    return sum(1 for char in word if char in vowels), len(word), word\n\nsorted_words = sorted(unique_words, key=custom_sort)\n\nfor word in sorted_words:\n    print(word)"}, {"role": "assistant", "content": "s\nan\nis\nof\nto\nand\nfor\nits\nhelp\nhigh\nwith\nsmall\npython\naim\nuse\ncode\nclear\nlarge\nlevel\nscale\nwrite\ndesign\nobject\nprojects\nconstructs\ngeneral\nlogical\nnotable\npurpose\napproach\nphilosophy\nprogrammers\nprogramming\nlanguage\noriented\nemphasizes\ninterpreted\nsignificant\nindentation\nreadability\n"}]}
{"messages": [{"role": "user", "content": "def is_fibonacci(n):\n    a, b = 0, 1\n    while a < n:\n        a, b = b, a + b\n    return a == n\n\ndef search_fibonacci_sum(number):\n    fibonacci_numbers = [0, 1]\n    while fibonacci_numbers[-1] < number:\n        fibonacci_numbers.append(fibonacci_numbers[-1] + fibonacci_numbers[-2])\n    \n    result = []\n    for i in range(len(fibonacci_numbers) - 1, 0, -1):\n        if fibonacci_numbers[i] <= number:\n            result.append(fibonacci_numbers[i])\n            number -= fibonacci_numbers[i]\n        \n        if number == 0:\n            break\n\n    return result\n\nsequence = [5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597]\n\nfor number in sequence:\n    print(f\"Analyzing number: {number}\")\n    if is_fibonacci(number):\n        print(f\"{number} is a Fibonacci number.\")\n    else:\n        result = search_fibonacci_sum(number)\n        print(f\"{number} is the sum of the Fibonacci numbers: {result}\")\n    print(\"-\" * 40)"}, {"role": "assistant", "content": "Analyzing number: 5\n5 is a Fibonacci number.\n----------------------------------------\nAnalyzing number: 8\n8 is a Fibonacci number.\n----------------------------------------\nAnalyzing number: 13\n13 is a Fibonacci number.\n----------------------------------------\nAnalyzing number: 21\n21 is a Fibonacci number.\n----------------------------------------\nAnalyzing number: 34\n34 is a Fibonacci number.\n----------------------------------------\nAnalyzing number: 55\n55 is a Fibonacci number.\n----------------------------------------\nAnalyzing number: 89\n89 is a Fibonacci number.\n----------------------------------------\nAnalyzing number: 144\n144 is a Fibonacci number.\n----------------------------------------\nAnalyzing number: 233\n233 is a Fibonacci number.\n----------------------------------------\nAnalyzing number: 377\n377 is a Fibonacci number.\n----------------------------------------\nAnalyzing number: 610\n610 is a Fibonacci number.\n----------------------------------------\nAnalyzing number: 987\n987 is a Fibonacci number.\n----------------------------------------\nAnalyzing number: 1597\n1597 is a Fibonacci number.\n----------------------------------------\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef generate_sequence(n):\n    return [math.floor((i + 1) * math.pi) for i in range(n)]\n\ndef custom_sort(seq):\n    return sorted(seq, key=lambda x: (x % 10, -x))\n\nsequence = generate_sequence(100)\nsorted_sequence = custom_sort(sequence)\n\nfor index, value in enumerate(sorted_sequence):\n    print(f\"{index + 1}: {value}\")"}, {"role": "assistant", "content": "1: 270\n2: 260\n3: 210\n4: 160\n5: 150\n6: 100\n7: 50\n8: 40\n9: 311\n10: 301\n11: 251\n12: 241\n13: 201\n14: 191\n15: 141\n16: 131\n17: 91\n18: 81\n19: 31\n20: 21\n21: 292\n22: 282\n23: 232\n24: 182\n25: 172\n26: 122\n27: 72\n28: 62\n29: 12\n30: 273\n31: 263\n32: 223\n33: 213\n34: 163\n35: 153\n36: 113\n37: 103\n38: 53\n39: 43\n40: 3\n41: 314\n42: 304\n43: 254\n44: 204\n45: 194\n46: 144\n47: 94\n48: 84\n49: 34\n50: 295\n51: 285\n52: 245\n53: 235\n54: 185\n55: 175\n56: 135\n57: 125\n58: 75\n59: 65\n60: 25\n61: 15\n62: 276\n63: 226\n64: 216\n65: 166\n66: 116\n67: 106\n68: 56\n69: 6\n70: 307\n71: 267\n72: 257\n73: 207\n74: 197\n75: 157\n76: 147\n77: 97\n78: 87\n79: 47\n80: 37\n81: 298\n82: 248\n83: 238\n84: 188\n85: 138\n86: 128\n87: 78\n88: 28\n89: 18\n90: 289\n91: 279\n92: 229\n93: 219\n94: 179\n95: 169\n96: 119\n97: 109\n98: 69\n99: 59\n100: 9\n"}]}
{"messages": [{"role": "user", "content": "def encrypt_message(message):\n    def custom_sort_key(char):\n        return (char.isdigit(), char.lower(), char.isupper())\n    \n    sorted_chars = sorted(message, key=custom_sort_key)\n    encrypted_message = ''.join(sorted_chars)\n    return encrypted_message\n\ndef decrypt_message(encrypted_message):\n    def custom_sort_key(char):\n        return (char.isupper(), char.lower(), char.isdigit())\n    \n    sorted_chars = sorted(encrypted_message, key=custom_sort_key)\n    decrypted_message = ''.join(sorted_chars)\n    return decrypted_message\n\nmessage = \"HelloWorld123\"\nprint(\"Original Message:\", message)\n\nencrypted_msg = encrypt_message(message)\nprint(\"Encrypted Message:\", encrypted_msg)\n\ndecrypted_msg = decrypt_message(encrypted_msg)\nprint(\"Decrypted Message:\", decrypted_msg)"}, {"role": "assistant", "content": "Original Message: HelloWorld123\nEncrypted Message: deHllloorW123\nDecrypted Message: 123dellloorHW\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef parse_date(date_str):\n    return datetime.datetime.strptime(date_str, '%Y-%m-%d')\n\ndef days_between(d1, d2):\n    return abs((d2 - d1).days)\n\nevents = [\n    ('2023-10-01', '2023-10-10'),\n    ('2023-09-15', '2023-09-20'),\n    ('2023-11-05', '2023-11-10'),\n    ('2023-08-01', '2023-08-10'),\n    ('2023-12-25', '2024-01-01'),\n    ('2023-07-04', '2023-07-10'),\n    ('2023-06-15', '2023-06-25'),\n    ('2023-05-01', '2023-05-05'),\n    ('2023-04-20', '2023-04-30'),\n    ('2023-03-10', '2023-03-15'),\n    ('2023-02-01', '2023-02-10'),\n    ('2023-01-20', '2023-01-25')\n]\n\ndurations = [(parse_date(start), parse_date(end), days_between(parse_date(start), parse_date(end))) for start, end in events]\n\nsorted_events = sorted(durations, key=lambda x: x[2])\n\nfor start, end, duration in sorted_events:\n    print(f\"Start: {start.strftime('%Y-%m-%d')}, End: {end.strftime('%Y-%m-%d')}, Duration: {duration} days\")"}, {"role": "assistant", "content": "Start: 2023-05-01, End: 2023-05-05, Duration: 4 days\nStart: 2023-09-15, End: 2023-09-20, Duration: 5 days\nStart: 2023-11-05, End: 2023-11-10, Duration: 5 days\nStart: 2023-03-10, End: 2023-03-15, Duration: 5 days\nStart: 2023-01-20, End: 2023-01-25, Duration: 5 days\nStart: 2023-07-04, End: 2023-07-10, Duration: 6 days\nStart: 2023-12-25, End: 2024-01-01, Duration: 7 days\nStart: 2023-10-01, End: 2023-10-10, Duration: 9 days\nStart: 2023-08-01, End: 2023-08-10, Duration: 9 days\nStart: 2023-02-01, End: 2023-02-10, Duration: 9 days\nStart: 2023-06-15, End: 2023-06-25, Duration: 10 days\nStart: 2023-04-20, End: 2023-04-30, Duration: 10 days\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"\nIn the heart of the city, there lies a library. It's a place where stories come to life.\nPeople from all walks of life visit to immerse themselves in the world of books. \nAmong the many bookshelves, a particular section stands out: \"The Mysteries of the Universe\".\n\"\"\"\n\ndef find_sentences_containing_word(text, word):\n    sentences = re.split(r'(?<=[.!?]) +', text.strip())\n    return [sentence for sentence in sentences if re.search(r'\\b' + re.escape(word) + r'\\b', sentence)]\n\ndef binary_search(sentences, word):\n    left, right = 0, len(sentences) - 1\n    results = []\n    while left <= right:\n        mid = (left + right) // 2\n        if re.search(r'\\b' + re.escape(word) + r'\\b', sentences[mid]):\n            results.append(sentences[mid])\n            l, r = mid - 1, mid + 1\n            while l >= left and re.search(r'\\b' + re.escape(word) + r'\\b', sentences[l]):\n                results.append(sentences[l])\n                l -= 1\n            while r <= right and re.search(r'\\b' + re.escape(word) + r'\\b', sentences[r]):\n                results.append(sentences[r])\n                r += 1\n            break\n        elif word < sentences[mid]:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return results\n\nword_to_find = \"life\"\nsentences_with_word = find_sentences_containing_word(text, word_to_find)\nsorted_sentences = sorted(sentences_with_word)\nresults = binary_search(sorted_sentences, word_to_find)\n\nfor result in results:\n    print(result)"}, {"role": "assistant", "content": "It's a place where stories come to life.\nPeople from all walks of life visit to immerse themselves in the world of books.\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef area_of_polygon(vertices):\n    n = len(vertices)\n    if n < 3:\n        return 0\n    area = 0.0\n    for i in range(n):\n        j = (i + 1) % n\n        area += vertices[i][0] * vertices[j][1]\n        area -= vertices[j][0] * vertices[i][1]\n    area = abs(area) / 2.0\n    return area\n\ndef distance(p1, p2):\n    return math.sqrt((p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2)\n\ndef perimeter_of_polygon(vertices):\n    n = len(vertices)\n    perimeter = 0.0\n    for i in range(n):\n        j = (i + 1) % n\n        perimeter += distance(vertices[i], vertices[j])\n    return perimeter\n\ndef sort_polygons_by_area_and_perimeter(polygons):\n    polygons.sort(key=lambda p: (area_of_polygon(p), perimeter_of_polygon(p)))\n    return polygons\n\npolygons = [\n    [(1, 1), (4, 1), (4, 5), (1, 5)],\n    [(0, 0), (2, 0), (1, 1)],\n    [(0, 0), (4, 0), (4, 3)],\n    [(0, 0), (1, 0), (0, 1)],\n    [(2, 1), (4, 4), (6, 1)],\n    [(0, 0), (3, 0), (3, 3), (0, 3)]\n]\n\nsorted_polygons = sort_polygons_by_area_and_perimeter(polygons)\n\nfor polygon in sorted_polygons:\n    print(f\"Vertices: {polygon}\")\n    print(f\"Area: {area_of_polygon(polygon):.2f}\")\n    print(f\"Perimeter: {perimeter_of_polygon(polygon):.2f}\")\n    print()"}, {"role": "assistant", "content": "Vertices: [(0, 0), (1, 0), (0, 1)]\nArea: 0.50\nPerimeter: 3.41\n\nVertices: [(0, 0), (2, 0), (1, 1)]\nArea: 1.00\nPerimeter: 4.83\n\nVertices: [(2, 1), (4, 4), (6, 1)]\nArea: 6.00\nPerimeter: 11.21\n\nVertices: [(0, 0), (4, 0), (4, 3)]\nArea: 6.00\nPerimeter: 12.00\n\nVertices: [(0, 0), (3, 0), (3, 3), (0, 3)]\nArea: 9.00\nPerimeter: 12.00\n\nVertices: [(1, 1), (4, 1), (4, 5), (1, 5)]\nArea: 12.00\nPerimeter: 14.00\n\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef sort_dates_by_weekday(dates):\n    return sorted(dates, key=lambda date: (date.weekday(), date))\n\ndates = [\n    datetime(2023, 10, 5),\n    datetime(2023, 10, 3),\n    datetime(2023, 10, 2),\n    datetime(2023, 10, 6),\n    datetime(2023, 10, 4),\n    datetime(2023, 10, 1),\n    datetime(2023, 10, 7),\n    datetime(2023, 10, 8),\n    datetime(2023, 10, 9),\n    datetime(2023, 10, 10),\n]\n\nsorted_dates = sort_dates_by_weekday(dates)\n\nfor date in sorted_dates:\n    print(date.strftime('%A, %B %d, %Y'))"}, {"role": "assistant", "content": "Monday, October 02, 2023\nMonday, October 09, 2023\nTuesday, October 03, 2023\nTuesday, October 10, 2023\nWednesday, October 04, 2023\nThursday, October 05, 2023\nFriday, October 06, 2023\nSaturday, October 07, 2023\nSunday, October 01, 2023\nSunday, October 08, 2023\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\nimport re\n\ndata_logs = [\n    \"2023-09-01 12:34:56 - user123 - login\",\n    \"2023-09-01 12:36:00 - user456 - login\",\n    \"2023-09-01 12:37:15 - user123 - logout\",\n    \"2023-09-02 09:00:00 - user123 - login\",\n    \"2023-09-02 09:15:00 - user456 - login\",\n    \"2023-09-02 09:45:00 - user123 - logout\",\n    \"2023-09-02 10:00:00 - user789 - login\",\n    \"2023-09-02 11:00:00 - user456 - logout\",\n    \"2023-09-02 11:30:00 - user789 - logout\",\n    \"2023-09-03 08:00:00 - user123 - login\",\n    \"2023-09-03 09:00:00 - user123 - logout\",\n]\n\ndef parse_log(log):\n    match = re.match(r\"(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}) - (user\\d+) - (\\w+)\", log)\n    if match:\n        timestamp_str, user, action = match.groups()\n        timestamp = datetime.strptime(timestamp_str, \"%Y-%m-%d %H:%M:%S\")\n        return timestamp, user, action\n    return None\n\ndef get_user_sessions(logs):\n    user_sessions = {}\n    for log in logs:\n        parsed = parse_log(log)\n        if parsed:\n            timestamp, user, action = parsed\n            if user not in user_sessions:\n                user_sessions[user] = []\n            if action == 'login':\n                user_sessions[user].append((timestamp, None))\n            elif action == 'logout' and user_sessions[user]:\n                for i in range(len(user_sessions[user]) - 1, -1, -1):\n                    if user_sessions[user][i][1] is None:\n                        user_sessions[user][i] = (user_sessions[user][i][0], timestamp)\n                        break\n    return user_sessions\n\ndef find_longest_session(user_sessions):\n    longest_session = None\n    for user, sessions in user_sessions.items():\n        for start, end in sessions:\n            if end:\n                duration = end - start\n                if not longest_session or duration > longest_session[2]:\n                    longest_session = (user, start, duration)\n    return longest_session\n\nsessions = get_user_sessions(data_logs)\nlongest_session = find_longest_session(sessions)\nif longest_session:\n    user, start, duration = longest_session\n    print(f\"User {user} had the longest session starting at {start} lasting {duration}.\")"}, {"role": "assistant", "content": "User user456 had the longest session starting at 2023-09-02 09:15:00 lasting 1:45:00.\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef create_year_range(year):\n    return [datetime(year, 1, 1) + timedelta(days=i) for i in range(365 + (1 if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0) else 0))]\n\ndef is_weekend(date):\n    return date.weekday() >= 5\n\ndef count_weekends_in_year(year):\n    dates = create_year_range(year)\n    return len(list(filter(is_weekend, dates)))\n\ndef find_year_with_max_weekends(start_year, end_year):\n    max_weekends = 0\n    year_with_max_weekends = start_year\n    for year in range(start_year, end_year + 1):\n        weekends = count_weekends_in_year(year)\n        if weekends > max_weekends:\n            max_weekends = weekends\n            year_with_max_weekends = year\n    return year_with_max_weekends\n\nstart_year = 2000\nend_year = 2100\nyear = find_year_with_max_weekends(start_year, end_year)\nprint(f\"The year with the most weekends between {start_year} and {end_year} is: {year}\")"}, {"role": "assistant", "content": "The year with the most weekends between 2000 and 2100 is: 2000\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef generate_pattern(n):\n    pattern = []\n    for i in range(1, n + 1):\n        row = [(i * j) % 10 for j in range(1, n + 1)]\n        pattern.append(row)\n    return pattern\n\ndef sort_pattern(pattern):\n    def custom_sort(row):\n        return sorted(row, key=lambda x: math.sin(x))\n\n    sorted_pattern = [custom_sort(row) for row in pattern]\n    return sorted_pattern\n\ndef display_pattern(pattern):\n    for row in pattern:\n        print(' '.join(str(x) for x in row))\n\nn = 10\noriginal_pattern = generate_pattern(n)\nprint(\"Original Pattern:\")\ndisplay_pattern(original_pattern)\n\nsorted_pattern = sort_pattern(original_pattern)\nprint(\"\\nSorted Pattern:\")\ndisplay_pattern(sorted_pattern)"}, {"role": "assistant", "content": "Original Pattern:\n1 2 3 4 5 6 7 8 9 0\n2 4 6 8 0 2 4 6 8 0\n3 6 9 2 5 8 1 4 7 0\n4 8 2 6 0 4 8 2 6 0\n5 0 5 0 5 0 5 0 5 0\n6 2 8 4 0 6 2 8 4 0\n7 4 1 8 5 2 9 6 3 0\n8 6 4 2 0 8 6 4 2 0\n9 8 7 6 5 4 3 2 1 0\n0 0 0 0 0 0 0 0 0 0\n\nSorted Pattern:\n5 4 6 0 3 9 7 1 2 8\n4 4 6 6 0 0 2 2 8 8\n5 4 6 0 3 9 7 1 2 8\n4 4 6 6 0 0 2 2 8 8\n5 5 5 5 5 0 0 0 0 0\n4 4 6 6 0 0 2 2 8 8\n5 4 6 0 3 9 7 1 2 8\n4 4 6 6 0 0 2 2 8 8\n5 4 6 0 3 9 7 1 2 8\n0 0 0 0 0 0 0 0 0 0\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\ndef closest_pair_naive(points):\n    min_dist = float('inf')\n    pair = None\n    n = len(points)\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = distance(points[i], points[j])\n            if d < min_dist:\n                min_dist = d\n                pair = (points[i], points[j])\n    return pair, min_dist\n\ndef closest_pair(points):\n    def _closest_pair(px, py):\n        if len(px) <= 3:\n            return closest_pair_naive(px)\n        mid = len(px) // 2\n        qx, rx = px[:mid], px[mid:]\n        midpoint = qx[-1][0]\n        qy, ry = [], []\n        for p in py:\n            if p[0] <= midpoint:\n                qy.append(p)\n            else:\n                ry.append(p)\n        (p1, q1), dist1 = _closest_pair(qx, qy)\n        (p2, q2), dist2 = _closest_pair(rx, ry)\n        min_dist = min(dist1, dist2)\n        if dist1 < dist2:\n            pair = (p1, q1)\n        else:\n            pair = (p2, q2)\n\n        strip = [p for p in py if abs(p[0] - midpoint) < min_dist]\n        for i in range(len(strip)):\n            for j in range(i + 1, min(i + 7, len(strip))):\n                p, q = strip[i], strip[j]\n                d = distance(p, q)\n                if d < min_dist:\n                    min_dist = d\n                    pair = (p, q)\n        return pair, min_dist\n\n    px = sorted(points, key=lambda p: p[0])\n    py = sorted(points, key=lambda p: p[1])\n    return _closest_pair(px, py)\n\npoints = [(i, math.sin(i)) for i in range(100)]\npair, min_distance = closest_pair(points)\nfor coord in pair:\n    print(coord)\nprint(min_distance)"}, {"role": "assistant", "content": "(89, 0.8600694058124533)\n(90, 0.8939966636005579)\n1.000575363888708\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\nclass Player:\n    def __init__(self, name, last_score, last_played):\n        self.name = name\n        self.last_score = last_score\n        self.last_played = datetime.datetime.strptime(last_played, '%Y-%m-%d')\n\n    def __repr__(self):\n        return f\"{self.name} ({self.last_score}, {self.last_played.date()})\"\n\nplayers = [\n    Player('Alice', 150, '2023-09-01'),\n    Player('Bob', 200, '2023-09-05'),\n    Player('Charlie', 180, '2023-09-03'),\n    Player('David', 170, '2023-09-04'),\n    Player('Eve', 160, '2023-09-02')\n]\n\nprint(\"Original order of players:\")\nfor p in players:\n    print(p)\n\nprint(\"\\nSorting players by last played date:\")\nplayers.sort(key=lambda p: p.last_played)\nfor p in players:\n    print(p)\n\nprint(\"\\nSorting players by last score:\")\nplayers.sort(key=lambda p: p.last_score, reverse=True)\nfor p in players:\n    print(p)"}, {"role": "assistant", "content": "Original order of players:\nAlice (150, 2023-09-01)\nBob (200, 2023-09-05)\nCharlie (180, 2023-09-03)\nDavid (170, 2023-09-04)\nEve (160, 2023-09-02)\n\nSorting players by last played date:\nAlice (150, 2023-09-01)\nEve (160, 2023-09-02)\nCharlie (180, 2023-09-03)\nDavid (170, 2023-09-04)\nBob (200, 2023-09-05)\n\nSorting players by last score:\nBob (200, 2023-09-05)\nCharlie (180, 2023-09-03)\nDavid (170, 2023-09-04)\nEve (160, 2023-09-02)\nAlice (150, 2023-09-01)\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef find_pattern(n):\n    pattern = []\n    for i in range(1, n + 1):\n        pattern.append(math.factorial(i) % 10)\n    return pattern\n\ndef search_for_mirrored_pattern(pattern):\n    def is_mirrored(subpattern):\n        return subpattern == subpattern[::-1]\n\n    length = len(pattern)\n    max_mirrored = []\n\n    for start in range(length):\n        for end in range(start + 1, length + 1):\n            subpattern = pattern[start:end]\n            if is_mirrored(subpattern) and len(subpattern) > len(max_mirrored):\n                max_mirrored = subpattern\n\n    return max_mirrored\n\nn = 50\npattern = find_pattern(n)\nmirrored_pattern = search_for_mirrored_pattern(pattern)\n\nprint(\"Pattern of last digits of factorials:\")\nprint(pattern)\nprint(\"\\nLongest mirrored pattern found:\")\nprint(mirrored_pattern)"}, {"role": "assistant", "content": "Pattern of last digits of factorials:\n[1, 2, 6, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\nLongest mirrored pattern found:\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n"}]}
{"messages": [{"role": "user", "content": "def find_winner_path(board, start, target):\n    rows, cols = len(board), len(board[0])\n    queue = [(start, [start])]\n    visited = set()\n    visited.add(start)\n\n    while queue:\n        (x, y), path = queue.pop(0)\n        if (x, y) == target:\n            return path\n\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < rows and 0 <= ny < cols and board[nx][ny] != '#':\n                if (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append(((nx, ny), path + [(nx, ny)]))\n\n    return []\n\ndef display_path(board, path):\n    for x, y in path:\n        board[x][y] = '*'\n    for row in board:\n        print(' '.join(row))\n    for x, y in path:\n        board[x][y] = '.'\n\ngame_board = [\n    ['.', '.', '.', '#', '.', '.', '.', '.'],\n    ['#', '#', '.', '#', '.', '#', '#', '#'],\n    ['.', '.', '.', '.', '.', '.', '.', '.'],\n    ['.', '#', '#', '#', '#', '.', '#', '.'],\n    ['.', '.', '.', '.', '.', '.', '#', '.'],\n    ['#', '#', '#', '.', '#', '#', '#', '.'],\n    ['.', '.', '.', '.', '.', '.', '.', '.']\n]\n\nstart_point = (0, 0)\nend_point = (6, 7)\npath = find_winner_path(game_board, start_point, end_point)\ndisplay_path(game_board, path)"}, {"role": "assistant", "content": "* * * # . . . .\n# # * # . # # #\n. . * * * * * *\n. # # # # . # *\n. . . . . . # *\n# # # . # # # *\n. . . . . . . *\n"}]}
{"messages": [{"role": "user", "content": "import statistics\nfrom collections import Counter\n\ndef generate_data(n):\n    return [i % 10 for i in range(n)]\n\ndef calculate_statistics(data):\n    mean = statistics.mean(data)\n    median = statistics.median(data)\n    mode = statistics.mode(data)\n    print(f\"Mean: {mean}, Median: {median}, Mode: {mode}\")\n    return mean, median, mode\n\ndef find_value_closest_to_mean(data, mean):\n    closest_value = min(data, key=lambda x: abs(x - mean))\n    print(f\"Value closest to mean: {closest_value}\")\n    return closest_value\n\ndef find_most_frequent_value(data):\n    frequency = Counter(data)\n    most_frequent_value = max(frequency, key=frequency.get)\n    print(f\"Most frequent value: {most_frequent_value}\")\n    return most_frequent_value\n\nn = 100\ndata = generate_data(n)\nprint(f\"Generated data (first 20 values): {data[:20]}\")\nmean, _, _ = calculate_statistics(data)\nvalue_close_to_mean = find_value_closest_to_mean(data, mean)\nmost_frequent_value = find_most_frequent_value(data)\n\nfor i, value in enumerate(data):\n    if value == value_close_to_mean:\n        print(f\"Index of value close to mean ({value}): {i}\")\n        break\n\nfor i, value in enumerate(data):\n    if value == most_frequent_value:\n        print(f\"Index of most frequent value ({value}): {i}\")\n        break"}, {"role": "assistant", "content": "Generated data (first 20 values): [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nMean: 4.5, Median: 4.5, Mode: 0\nValue closest to mean: 4\nMost frequent value: 0\nIndex of value close to mean (4): 4\nIndex of most frequent value (0): 0\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef caesar_cipher_encrypt(text, shift):\n    result = []\n    for char in text:\n        if char.isalpha():\n            shift_base = 65 if char.isupper() else 97\n            result.append(chr((ord(char) + shift - shift_base) % 26 + shift_base))\n        else:\n            result.append(char)\n    return ''.join(result)\n\ndef find_hidden_message(encrypted_messages, keyword):\n    encrypted_keyword = caesar_cipher_encrypt(keyword, 3)\n    for message in encrypted_messages:\n        matches = re.findall(r'\\b\\w+\\b', message)\n        for word in matches:\n            if caesar_cipher_encrypt(word, -3) == encrypted_keyword:\n                return message\n    return None\n\nmessages = [\n    \"Krod phvvdjhv fdq euhdn brxu budiolqhv\",\n    \"Wxlfnlqj pdnha vhuylqjv ri flwuxv iru wkh dftxdint\",\n    \"Wkh txlfn eurzq ira mxpsv ryhu wkh odcb grj\",\n    \"Fkdqjhv duh frplqj wr wkh dqwlfrgh lqgexvwulhv\",\n    \"Lpsurylqj wkh odvhu vkdshu lv d fkdoohqjlqj wdvn\",\n]\n\nhidden_message = find_hidden_message(messages, \"hello\")\nif hidden_message:\n    print(\"Hidden message found:\", hidden_message)\nelse:\n    print(\"No hidden message found.\")"}, {"role": "assistant", "content": "No hidden message found.\n"}]}
{"messages": [{"role": "user", "content": "def is_fibonacci(num, fib_seq):\n    left, right = 0, len(fib_seq) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if fib_seq[mid] == num:\n            return True\n        elif fib_seq[mid] < num:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\ndef generate_fibonacci(n):\n    fib_seq = [0, 1]\n    while True:\n        next_fib = fib_seq[-1] + fib_seq[-2]\n        if next_fib > n:\n            break\n        fib_seq.append(next_fib)\n    return fib_seq\n\ndef main():\n    n = 10000\n    fib_seq = generate_fibonacci(n)\n    numbers_to_check = list(range(1, 101))\n    results = []\n\n    for number in numbers_to_check:\n        if is_fibonacci(number, fib_seq):\n            results.append(number)\n\n    print(\"\\n\".join(map(str, results)))\n\nmain()"}, {"role": "assistant", "content": "1\n2\n3\n5\n8\n13\n21\n34\n55\n89\n"}]}
{"messages": [{"role": "user", "content": "def generate_sequence(n):\n    sequence = [1]\n    for i in range(1, n):\n        next_value = sequence[i - 1] + i + 1\n        sequence.append(next_value)\n    return sequence\n\ndef sort_by_digit_sum(sequence):\n    def digit_sum(num):\n        return sum(int(digit) for digit in str(num))\n    \n    print(\"Before sorting:\", sequence)\n    sorted_sequence = sorted(sequence, key=digit_sum)\n    print(\"After sorting by digit sum:\", sorted_sequence)\n    return sorted_sequence\n\ndef main():\n    n = 20\n    original_sequence = generate_sequence(n)\n    sorted_sequence = sort_by_digit_sum(original_sequence)\n    \n    print(\"\\nSorted sequence with digit sums:\")\n    for num in sorted_sequence:\n        print(f\"{num} (Digit sum: {sum(int(d) for d in str(num))})\")\n\nmain()"}, {"role": "assistant", "content": "Before sorting: [1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66, 78, 91, 105, 120, 136, 153, 171, 190, 210]\nAfter sorting by digit sum: [1, 10, 3, 21, 120, 210, 6, 15, 105, 36, 45, 153, 171, 28, 55, 91, 136, 190, 66, 78]\n\nSorted sequence with digit sums:\n1 (Digit sum: 1)\n10 (Digit sum: 1)\n3 (Digit sum: 3)\n21 (Digit sum: 3)\n120 (Digit sum: 3)\n210 (Digit sum: 3)\n6 (Digit sum: 6)\n15 (Digit sum: 6)\n105 (Digit sum: 6)\n36 (Digit sum: 9)\n45 (Digit sum: 9)\n153 (Digit sum: 9)\n171 (Digit sum: 9)\n28 (Digit sum: 10)\n55 (Digit sum: 10)\n91 (Digit sum: 10)\n136 (Digit sum: 10)\n190 (Digit sum: 10)\n66 (Digit sum: 12)\n78 (Digit sum: 15)\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\nclass Event:\n    def __init__(self, name, date):\n        self.name = name\n        self.date = date\n\n    def __repr__(self):\n        return f\"{self.name} on {self.date.strftime('%Y-%m-%d')}\"\n\ndef transform_events(events):\n    return sorted(events, key=lambda x: x.name)\n\nevents = [\n    Event(\"Conference\", datetime.datetime(2023, 10, 22)),\n    Event(\"Meeting\", datetime.datetime(2023, 11, 1)),\n    Event(\"Workshop\", datetime.datetime(2023, 9, 30)),\n    Event(\"Seminar\", datetime.datetime(2023, 10, 5)),\n    Event(\"Lecture\", datetime.datetime(2023, 11, 12)),\n    Event(\"Symposium\", datetime.datetime(2023, 8, 19)),\n    Event(\"Webinar\", datetime.datetime(2023, 10, 15)),\n    Event(\"Training\", datetime.datetime(2023, 9, 5)),\n    Event(\"Hackathon\", datetime.datetime(2023, 9, 25)),\n    Event(\"Panel\", datetime.datetime(2023, 10, 8))\n]\n\nsorted_events = transform_events(events)\n\nfor event in sorted_events:\n    print(event)"}, {"role": "assistant", "content": "Conference on 2023-10-22\nHackathon on 2023-09-25\nLecture on 2023-11-12\nMeeting on 2023-11-01\nPanel on 2023-10-08\nSeminar on 2023-10-05\nSymposium on 2023-08-19\nTraining on 2023-09-05\nWebinar on 2023-10-15\nWorkshop on 2023-09-30\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"\nIt is a truth universally acknowledged, that a single man in possession of a good fortune, must be in want of a wife.\nHowever little known the feelings or views of such a man may be on his first entering a neighbourhood, this truth is so well fixed\nin the minds of the surrounding families, that he is considered as the rightful property of some one or other of their daughters.\n\"My dear Mr. Bennet,\" said his lady to him one day, \"have you heard that Netherfield Park is let at last?\"\nMr. Bennet replied that he had not.\n\"But it is,\" returned she; \"for Mrs. Long has just been here, and she told me all about it.\"\n\"\"\"\n\ndef sort_words_by_length(text):\n    words = re.findall(r'\\b\\w+\\b', text.lower())\n    print(f\"Words extracted: {words}\")\n    sorted_words = sorted(words, key=lambda w: (len(w), w))\n    return sorted_words\n\ndef main():\n    sorted_words = sort_words_by_length(text)\n    print(\"Sorted words (by length and alphabetically):\")\n    for word in sorted_words:\n        print(word)\n\nmain()"}, {"role": "assistant", "content": "Words extracted: ['it', 'is', 'a', 'truth', 'universally', 'acknowledged', 'that', 'a', 'single', 'man', 'in', 'possession', 'of', 'a', 'good', 'fortune', 'must', 'be', 'in', 'want', 'of', 'a', 'wife', 'however', 'little', 'known', 'the', 'feelings', 'or', 'views', 'of', 'such', 'a', 'man', 'may', 'be', 'on', 'his', 'first', 'entering', 'a', 'neighbourhood', 'this', 'truth', 'is', 'so', 'well', 'fixed', 'in', 'the', 'minds', 'of', 'the', 'surrounding', 'families', 'that', 'he', 'is', 'considered', 'as', 'the', 'rightful', 'property', 'of', 'some', 'one', 'or', 'other', 'of', 'their', 'daughters', 'my', 'dear', 'mr', 'bennet', 'said', 'his', 'lady', 'to', 'him', 'one', 'day', 'have', 'you', 'heard', 'that', 'netherfield', 'park', 'is', 'let', 'at', 'last', 'mr', 'bennet', 'replied', 'that', 'he', 'had', 'not', 'but', 'it', 'is', 'returned', 'she', 'for', 'mrs', 'long', 'has', 'just', 'been', 'here', 'and', 'she', 'told', 'me', 'all', 'about', 'it']\nSorted words (by length and alphabetically):\na\na\na\na\na\na\nas\nat\nbe\nbe\nhe\nhe\nin\nin\nin\nis\nis\nis\nis\nis\nit\nit\nit\nme\nmr\nmr\nmy\nof\nof\nof\nof\nof\nof\non\nor\nor\nso\nto\nall\nand\nbut\nday\nfor\nhad\nhas\nhim\nhis\nhis\nlet\nman\nman\nmay\nmrs\nnot\none\none\nshe\nshe\nthe\nthe\nthe\nthe\nyou\nbeen\ndear\ngood\nhave\nhere\njust\nlady\nlast\nlong\nmust\npark\nsaid\nsome\nsuch\nthat\nthat\nthat\nthat\nthis\ntold\nwant\nwell\nwife\nabout\nfirst\nfixed\nheard\nknown\nminds\nother\ntheir\ntruth\ntruth\nviews\nbennet\nbennet\nlittle\nsingle\nfortune\nhowever\nreplied\nentering\nfamilies\nfeelings\nproperty\nreturned\nrightful\ndaughters\nconsidered\npossession\nnetherfield\nsurrounding\nuniversally\nacknowledged\nneighbourhood\n"}]}
{"messages": [{"role": "user", "content": "def find_closest_even(numbers):\n    def binary_search(arr, target):\n        low, high = 0, len(arr) - 1\n        while low <= high:\n            mid = (low + high) // 2\n            if arr[mid] == target:\n                return mid\n            elif arr[mid] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return low\n\n    sorted_numbers = sorted(numbers)\n    closest_evens = []\n    for num in sorted_numbers:\n        if num % 2 == 0:\n            closest_evens.append(num)\n        else:\n            idx = binary_search(sorted_numbers, num)\n            if idx < len(sorted_numbers) and sorted_numbers[idx] % 2 == 0:\n                closest_evens.append(sorted_numbers[idx])\n            elif idx > 0 and sorted_numbers[idx - 1] % 2 == 0:\n                closest_evens.append(sorted_numbers[idx - 1])\n\n    return closest_evens\n\nnumbers = [3, 1, 7, 8, 2, 5, 12, 18, 10, 6, 11, 9, 20, 14, 15, 4, 13, 16, 17, 19]\nresult = find_closest_even(numbers)\nfor i, num in enumerate(result):\n    print(f\"{i}: {num}\")"}, {"role": "assistant", "content": "0: 2\n1: 2\n2: 4\n3: 4\n4: 6\n5: 6\n6: 8\n7: 8\n8: 10\n9: 10\n10: 12\n11: 12\n12: 14\n13: 14\n14: 16\n15: 16\n16: 18\n17: 18\n18: 20\n"}]}
{"messages": [{"role": "user", "content": "from statistics import mean\n\ndef quicksort(arr):\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    return quicksort(left) + middle + quicksort(right)\n\ndef calculate_median(sorted_list):\n    n = len(sorted_list)\n    midpoint = n // 2\n    if n % 2 == 1:\n        return sorted_list[midpoint]\n    else:\n        return (sorted_list[midpoint - 1] + sorted_list[midpoint]) / 2\n\ndata = [\n    12, 7, 3, 1, 9, 5, 6, 8, 11, 10, 2, 4,\n    15, 17, 19, 13, 18, 14, 16, 20, 21, 23, 22, 25, 24, 26\n]\n\nsorted_data = quicksort(data)\nmedian = calculate_median(sorted_data)\naverage = mean(data)\n\nprint(\"Sorted Data:\")\nfor num in sorted_data:\n    print(num)\n\nprint(\"\\nMedian:\", median)\nprint(\"Mean:\", average)"}, {"role": "assistant", "content": "Sorted Data:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\nMedian: 13.5\nMean: 13.5\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef calculate_polygon_area(vertices):\n    def pseudo_angle(v):\n        return math.atan2(v[1], v[0])\n    \n    vertices = sorted(vertices, key=pseudo_angle)\n    \n    def triangle_area(a, b, c):\n        return abs(a[0] * (b[1] - c[1]) + b[0] * (c[1] - a[1]) + c[0] * (a[1] - b[1])) / 2\n    \n    total_area = 0\n    origin = vertices[0]\n    \n    for i in range(1, len(vertices) - 1):\n        total_area += triangle_area(origin, vertices[i], vertices[i + 1])\n    \n    return total_area\n\npolygon_vertices = [\n    (0, 0), (4, 0), (4, 4), (2, 2), (0, 4)\n]\n\nprint(\"Approximate Polygon Area:\", calculate_polygon_area(polygon_vertices))"}, {"role": "assistant", "content": "Approximate Polygon Area: 12.0\n"}]}
{"messages": [{"role": "user", "content": "import re\nfrom datetime import datetime\n\ntext = \"\"\"The quick brown fox jumps over the lazy dog. The dog barked back.\nQuickly, the fox ran away. Lazy dogs are common in this area. A fox is known\nfor its cunning nature. Brown dogs often sleep under the bright sun.\"\"\"\n\ndef search_sentences(text, keywords):\n    sentences = re.split(r'(?<=[.!?]) +', text)\n    found_sentences = []\n    for sentence in sentences:\n        if any(keyword.lower() in sentence.lower() for keyword in keywords):\n            found_sentences.append(sentence)\n    return found_sentences\n\ndef find_first_occurrence(sentences, keyword):\n    for idx, sentence in enumerate(sentences):\n        if keyword.lower() in sentence.lower():\n            return idx\n    return -1\n\nkeywords = [\"fox\", \"dog\", \"lazy\"]\nsentences = search_sentences(text, keywords)\n\nresult_index = find_first_occurrence(sentences, \"fox\")\nprint(f\"First occurrence of 'fox': {result_index}\")\n\n# Purposefully flawed logic: should find 'fox', but searches for 'dog' instead\nresult_index = find_first_occurrence(sentences, \"dog\")\nprint(f\"First occurrence of 'dog': {result_index}\")\n\nfor sentence in sentences:\n    print(sentence)\n\nprint(f\"Script executed at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\")"}, {"role": "assistant", "content": "First occurrence of 'fox': 0\nFirst occurrence of 'dog': 0\nThe quick brown fox jumps over the lazy dog.\nThe dog barked back.\nQuickly, the fox ran away.\nLazy dogs are common in this area.\nA fox is known\nfor its cunning nature.\nBrown dogs often sleep under the bright sun.\nScript executed at: 2025-04-01 16:10:16\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef generate_dates():\n    start_date = datetime(2023, 10, 1)\n    dates = [start_date + timedelta(days=i) for i in range(30)]\n    return dates\n\ndef sort_dates_by_weekday(dates):\n    return sorted(dates, key=lambda date: date.weekday())\n\ndef format_dates(dates):\n    return [date.strftime('%Y-%m-%d (%A)') for date in dates]\n\ndates = generate_dates()\nsorted_dates = sort_dates_by_weekday(dates)\nformatted_dates = format_dates(sorted_dates)\n\nfor date in formatted_dates:\n    print(date)"}, {"role": "assistant", "content": "2023-10-02 (Monday)\n2023-10-09 (Monday)\n2023-10-16 (Monday)\n2023-10-23 (Monday)\n2023-10-30 (Monday)\n2023-10-03 (Tuesday)\n2023-10-10 (Tuesday)\n2023-10-17 (Tuesday)\n2023-10-24 (Tuesday)\n2023-10-04 (Wednesday)\n2023-10-11 (Wednesday)\n2023-10-18 (Wednesday)\n2023-10-25 (Wednesday)\n2023-10-05 (Thursday)\n2023-10-12 (Thursday)\n2023-10-19 (Thursday)\n2023-10-26 (Thursday)\n2023-10-06 (Friday)\n2023-10-13 (Friday)\n2023-10-20 (Friday)\n2023-10-27 (Friday)\n2023-10-07 (Saturday)\n2023-10-14 (Saturday)\n2023-10-21 (Saturday)\n2023-10-28 (Saturday)\n2023-10-01 (Sunday)\n2023-10-08 (Sunday)\n2023-10-15 (Sunday)\n2023-10-22 (Sunday)\n2023-10-29 (Sunday)\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef is_winning_position(board):\n    for row in board:\n        if all(x == 'X' for x in row):\n            return True\n    for col in range(len(board[0])):\n        if all(row[col] == 'X' for row in board):\n            return True\n    if all(board[i][i] == 'X' for i in range(len(board))):\n        return True\n    if all(board[i][len(board)-i-1] == 'X' for i in range(len(board))):\n        return True\n    return False\n\ndef search_minimax(board, depth, is_max):\n    if is_winning_position(board):\n        return 10 if is_max else -10\n    if depth == 0:\n        return 0\n    scores = []\n    for row in range(len(board)):\n        for col in range(len(board[0])):\n            if board[row][col] == '_':\n                board[row][col] = 'X' if is_max else 'O'\n                score = search_minimax(board, depth - 1, not is_max)\n                scores.append(score)\n                board[row][col] = '_'\n                print(f\"Intermediate Scores: {scores}\")\n    return max(scores) if is_max else min(scores)\n\ndef determine_best_move(board):\n    best_score = -math.inf\n    best_move = None\n    for row in range(len(board)):\n        for col in range(len(board[0])):\n            if board[row][col] == '_':\n                board[row][col] = 'X'\n                score = search_minimax(board, len(board) * len(board[0]), False)\n                print(f\"Evaluating move at ({row}, {col}): Score = {score}\")\n                board[row][col] = '_'\n                if score > best_score:\n                    best_score = score\n                    best_move = (row, col)\n    return best_move\n\ntic_tac_toe_board = [\n    ['X', 'O', 'X'],\n    ['O', 'X', '_'],\n    ['_', '_', 'O']\n]\n\nmove = determine_best_move(tic_tac_toe_board)\nprint(f\"Best move is at position: {move}\")"}, {"role": "assistant", "content": "Traceback (most recent call last):\n  File \"<string>\", line 53, in <module>\n  File \"<string>\", line 39, in determine_best_move\n  File \"<string>\", line 26, in search_minimax\n  File \"<string>\", line 26, in search_minimax\n  File \"<string>\", line 30, in search_minimax\nValueError: min() arg is an empty sequence\n"}]}
{"messages": [{"role": "user", "content": "def pattern_sort(n):\n    def generate_pattern(n):\n        pattern = []\n        for i in range(1, n + 1):\n            line = ' '.join(str(x) for x in range(i, 0, -1))\n            pattern.append(line)\n        return pattern\n\n    def custom_sort_key(line):\n        return sum(int(x) for x in line.split())\n\n    pattern = generate_pattern(n)\n    sorted_pattern = sorted(pattern, key=custom_sort_key)\n    return sorted_pattern\n\ndef print_pattern(pattern):\n    for line in pattern:\n        print(line)\n\nn = 10\nsorted_pattern = pattern_sort(n)\nprint_pattern(sorted_pattern)"}, {"role": "assistant", "content": "1\n2 1\n3 2 1\n4 3 2 1\n5 4 3 2 1\n6 5 4 3 2 1\n7 6 5 4 3 2 1\n8 7 6 5 4 3 2 1\n9 8 7 6 5 4 3 2 1\n10 9 8 7 6 5 4 3 2 1\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\ndef encode_text(text):\n    encoded_chars = []\n    for char in text:\n        encoded_chars.append(ord(char) + 3)\n    return encoded_chars\n\ndef decode_text(encoded_chars):\n    decoded_chars = []\n    for char in encoded_chars:\n        decoded_chars.append(chr(char - 3))\n    return ''.join(decoded_chars)\n\ndef sort_encoded(encoded_chars):\n    print(f\"Encoded before sort: {encoded_chars}\")\n    sorted_chars = sorted(encoded_chars, reverse=True)\n    print(f\"Sorted encoded: {sorted_chars}\")\n    return sorted_chars\n\ndef process_message(message):\n    print(f\"Original message: {message}\")\n    encoded = encode_text(message)\n    print(f\"Encoded message: {encoded}\")\n    sorted_encoded = sort_encoded(encoded)\n    print(f\"Processed message: {sorted_encoded}\")\n    decoded = decode_text(sorted_encoded)\n    print(f\"Decoded message: {decoded}\")\n    return decoded\n\nmessage = \"Hello, World!\"\nstart_time = datetime.now()\nfinal_message = process_message(message)\nend_time = datetime.now()\nprint(f\"Final processed message: {final_message}\")\nprint(f\"Execution time: {end_time - start_time}\")"}, {"role": "assistant", "content": "Original message: Hello, World!\nEncoded message: [75, 104, 111, 111, 114, 47, 35, 90, 114, 117, 111, 103, 36]\nEncoded before sort: [75, 104, 111, 111, 114, 47, 35, 90, 114, 117, 111, 103, 36]\nSorted encoded: [117, 114, 114, 111, 111, 111, 104, 103, 90, 75, 47, 36, 35]\nProcessed message: [117, 114, 114, 111, 111, 111, 104, 103, 90, 75, 47, 36, 35]\nDecoded message: roollledWH,! \nFinal processed message: roollledWH,! \nExecution time: 0:00:00.000019\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef calculate_geometric_mean(data):\n    product = 1\n    for number in data:\n        product *= number\n    return product ** (1 / len(data))\n\ndef sort_by_geometric_mean(matrix):\n    return sorted(matrix, key=calculate_geometric_mean)\n\nmatrix = [\n    [4, 16, 2, 8],\n    [10, 5, 2, 7],\n    [9, 6, 3, 12],\n    [11, 13, 1, 20],\n    [2, 3, 5, 7],\n    [8, 14, 6, 10]\n]\n\nsorted_matrix = sort_by_geometric_mean(matrix)\n\nfor row in sorted_matrix:\n    print(row)"}, {"role": "assistant", "content": "[2, 3, 5, 7]\n[10, 5, 2, 7]\n[4, 16, 2, 8]\n[9, 6, 3, 12]\n[11, 13, 1, 20]\n[8, 14, 6, 10]\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef generate_pattern(pattern, length):\n    if length <= len(pattern):\n        return pattern[:length]\n    return pattern * (length // len(pattern)) + pattern[:length % len(pattern)]\n\ndef search_pattern(text, pattern):\n    index = -1\n    for i in range(len(text) - len(pattern) + 1):\n        print(f\"Checking text from {i} to {i + len(pattern)}: {text[i:i + len(pattern)]}\")\n        if text[i:i + len(pattern)] == pattern:\n            index = i\n            break\n    return index\n\npattern = \"abc\"\ntext_length = 20\ngenerated_text = generate_pattern(pattern, text_length)\n\npattern_to_search = \"abca\"\nfound_index = search_pattern(generated_text, pattern_to_search)\n\nprint(f\"Generated text: {generated_text}\")\nprint(f\"Pattern '{pattern_to_search}' found at index: {found_index}\")\n\n# Bug: The pattern_to_search 'abca' is not in the generated text because of an off-by-one error in the generate_pattern function."}, {"role": "assistant", "content": "Checking text from 0 to 4: abca\nGenerated text: abcabcabcabcabcabcab\nPattern 'abca' found at index: 0\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef caesar_cipher(input_text, shift):\n    result = \"\"\n    for char in input_text:\n        if char.isalpha():\n            shift_base = ord('A') if char.isupper() else ord('a')\n            result += chr((ord(char) - shift_base + shift) % 26 + shift_base)\n        else:\n            result += char\n    return result\n\ndef search_encryption_key(encoded_text, target_word):\n    for shift in range(26):\n        decoded_text = caesar_cipher(encoded_text, shift)\n        if re.search(r'\\b' + target_word + r'\\b', decoded_text, re.IGNORECASE):\n            return shift, decoded_text\n    return None, None\n\nencoded_message = \"KHOOR ZRUOG\"\ntarget = \"world\"\n\nkey, decoded_message = search_encryption_key(encoded_message, target)\n\nif key is not None:\n    print(f\"Encryption Key: {key}\")\n    print(\"Decoded Message:\")\n    print(decoded_message)\nelse:\n    print(\"No valid encryption key found.\")\n\nencoded_texts = [\n    \"URYYB JBEYQ\",\n    \"GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT\",\n    \"GUVF VF N FRPERG ZRFFNTR\",\n    \"V'Z N ZLFGREVN\",\n    \"VAFGRNQ BS RYFR\"\n]\n\nfor text in encoded_texts:\n    key, decoded_message = search_encryption_key(text, target)\n    if key is not None:\n        print(f\"Encryption Key: {key}. Decoded Message: {decoded_message}\")"}, {"role": "assistant", "content": "Encryption Key: 23\nDecoded Message:\nHELLO WORLD\nEncryption Key: 13. Decoded Message: HELLO WORLD\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\ndef sort_players_by_score(players):\n    return sorted(players, key=lambda x: (-x['score'], x['last_active']))\n\ndef create_players():\n    base_time = datetime(2023, 10, 5, 14, 0, 0)\n    return [\n        {'name': 'Alice', 'score': 120, 'last_active': base_time},\n        {'name': 'Bob', 'score': 100, 'last_active': base_time.replace(hour=15)},\n        {'name': 'Charlie', 'score': 120, 'last_active': base_time.replace(hour=13)},\n        {'name': 'Diana', 'score': 100, 'last_active': base_time.replace(hour=14, minute=30)},\n        {'name': 'Eve', 'score': 140, 'last_active': base_time.replace(hour=12)},\n        {'name': 'Frank', 'score': 120, 'last_active': base_time.replace(hour=15, minute=45)},\n        {'name': 'Grace', 'score': 150, 'last_active': base_time.replace(hour=11)},\n        {'name': 'Heidi', 'score': 140, 'last_active': base_time.replace(hour=13)},\n        {'name': 'Ivan', 'score': 90, 'last_active': base_time.replace(hour=16)},\n        {'name': 'Judy', 'score': 110, 'last_active': base_time.replace(hour=14, minute=15)}\n    ]\n\nplayers = create_players()\nsorted_players = sort_players_by_score(players)\n\nfor player in sorted_players:\n    print(f\"Player: {player['name']}, Score: {player['score']}, Last Active: {player['last_active'].strftime('%Y-%m-%d %H:%M:%S')}\")"}, {"role": "assistant", "content": "Player: Grace, Score: 150, Last Active: 2023-10-05 11:00:00\nPlayer: Eve, Score: 140, Last Active: 2023-10-05 12:00:00\nPlayer: Heidi, Score: 140, Last Active: 2023-10-05 13:00:00\nPlayer: Charlie, Score: 120, Last Active: 2023-10-05 13:00:00\nPlayer: Alice, Score: 120, Last Active: 2023-10-05 14:00:00\nPlayer: Frank, Score: 120, Last Active: 2023-10-05 15:45:00\nPlayer: Judy, Score: 110, Last Active: 2023-10-05 14:15:00\nPlayer: Diana, Score: 100, Last Active: 2023-10-05 14:30:00\nPlayer: Bob, Score: 100, Last Active: 2023-10-05 15:00:00\nPlayer: Ivan, Score: 90, Last Active: 2023-10-05 16:00:00\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef date_to_number(date):\n    return date.year * 10000 + date.month * 100 + date.day\n\ndef number_to_date(number):\n    year = number // 10000\n    month = (number % 10000) // 100\n    day = number % 100\n    return datetime.date(year, month, day)\n\ndates = [\n    datetime.date(2023, 10, 5),\n    datetime.date(2022, 3, 15),\n    datetime.date(2024, 7, 19),\n    datetime.date(2021, 12, 28),\n    datetime.date(2023, 1, 1),\n    datetime.date(2020, 5, 20),\n]\n\ndate_numbers = [date_to_number(date) for date in dates]\nsorted_numbers = sorted(date_numbers)\nsorted_dates = [number_to_date(number) for number in sorted_numbers]\n\nfor date in sorted_dates:\n    print(date.strftime(\"%Y-%m-%d\"))"}, {"role": "assistant", "content": "2020-05-20\n2021-12-28\n2022-03-15\n2023-01-01\n2023-10-05\n2024-07-19\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndates = [\n    \"2023-05-15\", \"2021-03-25\", \"2022-12-30\", \"2021-07-19\", \"2024-01-01\",\n    \"2022-06-17\", \"2023-11-11\", \"2021-01-01\", \"2023-03-10\", \"2022-08-29\",\n    \"2023-09-09\", \"2021-05-05\", \"2022-11-22\", \"2023-07-07\", \"2021-12-12\"\n]\n\nparsed_dates = [datetime.strptime(date, \"%Y-%m-%d\") for date in dates]\n\ncurrent_date = datetime.now()\n\ndates_within_year = [\n    date for date in parsed_dates if 0 <= (current_date - date).days <= 365\n]\n\nprint(\"Dates within one year from now:\")\nfor date in dates_within_year:\n    print(date.strftime(\"%Y-%m-%d\"))\n\nsorted_dates = sorted(dates_within_year, key=lambda x: x.timetuple().tm_yday)\n\nprint(\"\\nSorted dates within one year by day of the year:\")\nfor date in sorted_dates:\n    print(date.strftime(\"%Y-%m-%d\"))\n\ndays_to_next = [(date - current_date).days for date in sorted_dates]\n\nprint(\"\\nDays to each upcoming sorted date:\")\nfor day_count, date in zip(days_to_next, sorted_dates):\n    print(f\"Days to {date.strftime('%Y-%m-%d')}: {day_count}\")\n\nprint(\"\\nDates plus 100 days and sorted by the resulting date:\")\ndates_plus_100 = [(date + timedelta(days=100)) for date in sorted_dates]\nsorted_plus_100 = sorted(dates_plus_100)\n\nfor date in sorted_plus_100:\n    print(date.strftime(\"%Y-%m-%d\"))"}, {"role": "assistant", "content": "Dates within one year from now:\n\nSorted dates within one year by day of the year:\n\nDays to each upcoming sorted date:\n\nDates plus 100 days and sorted by the resulting date:\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef calculate_distance(point1, point2):\n    return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)\n\ndef find_closest_points(points):\n    min_distance = float('inf')\n    closest_pair = (None, None)\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            dist = calculate_distance(points[i], points[j])\n            if dist < min_distance:\n                min_distance = dist\n                closest_pair = (points[i], points[j])\n    return closest_pair, min_distance\n\npoints_list = [(3, 4), (1, 2), (7, 8), (9, 1), (5, 6), (0, 0), (2, 2), (8, 3), (4, 5), (6, 7)]\nclosest_points, min_dist = find_closest_points(points_list)\n\noutput = f\"Closest points: {closest_points[0]} and {closest_points[1]}\\n\"\noutput += f\"Minimum distance: {min_dist}\\n\"\n\nfor point in points_list:\n    distances = [calculate_distance(point, other) for other in points_list if point != other]\n    closest_point = points_list[distances.index(min(distances))]\n    output += f\"Point {point} is closest to {closest_point} with distance {min(distances):.2f}\\n\"\n\nprint(output)"}, {"role": "assistant", "content": "Closest points: (1, 2) and (2, 2)\nMinimum distance: 1.0\nPoint (3, 4) is closest to (8, 3) with distance 1.41\nPoint (1, 2) is closest to (0, 0) with distance 1.00\nPoint (7, 8) is closest to (4, 5) with distance 1.41\nPoint (9, 1) is closest to (2, 2) with distance 2.24\nPoint (5, 6) is closest to (8, 3) with distance 1.41\nPoint (0, 0) is closest to (1, 2) with distance 2.24\nPoint (2, 2) is closest to (1, 2) with distance 1.00\nPoint (8, 3) is closest to (9, 1) with distance 2.24\nPoint (4, 5) is closest to (3, 4) with distance 1.41\nPoint (6, 7) is closest to (7, 8) with distance 1.41\n\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef is_fibonacci(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n == 0 or n == 1:\n        return True\n    sqrt_5 = math.sqrt(5)\n    phi = (1 + sqrt_5) / 2\n    psi = (1 - sqrt_5) / 2\n    fib_n = (phi**n - psi**n) / sqrt_5\n    is_fib = fib_n.is_integer()\n    memo[n] = is_fib\n    return is_fib\n\ndef nearest_fibonacci_search(sequence):\n    def binary_search(seq, low, high):\n        if high < low:\n            return None\n        mid = (low + high) // 2\n        print(f\"Searching index: {mid}, value: {seq[mid]}\")\n        if is_fibonacci(seq[mid]):\n            return seq[mid]\n        elif seq[mid] < 0:\n            return None\n        else:\n            return binary_search(seq, mid + 1, high)\n    \n    return binary_search(sequence, 0, len(sequence) - 1)\n\nnumber_sequence = [2, 3, 4, 7, 11, 18, 29, 47, 76, 123, 199, 322, 521, 843, 1365, 2208]\nresult = nearest_fibonacci_search(number_sequence)\n\nprint(\"Nearest Fibonacci number found:\", result)"}, {"role": "assistant", "content": "Searching index: 7, value: 47\nSearching index: 11, value: 322\nNearest Fibonacci number found: 322\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef process_text(text):\n    words = re.findall(r'\\b\\w+\\b', text.lower())\n    return words\n\ndef custom_sort(words):\n    return sorted(words, key=lambda w: (sum(map(ord, w)), w))\n\ndef main():\n    text = \"\"\"\n    Advanced text processing involves examining and transforming text data\n    using algorithms, such as sorting, to extract meaningful patterns.\n    By analyzing the characteristics of words, like their length, frequency,\n    and alphabetical order, we can gain insights into the structure of the text.\n    \"\"\"\n    \n    words = process_text(text)\n    sorted_words = custom_sort(words)\n    \n    sorted_text = \"\\n\".join(sorted_words)\n    print(sorted_text)\n\nmain()"}, {"role": "assistant", "content": "as\nof\nof\nby\nwe\nto\ncan\nand\nand\nthe\nthe\nthe\ndata\ngain\nlike\nsuch\ninto\ntext\ntext\ntext\norder\ntheir\nusing\nwords\nlength\nextract\nsorting\nadvanced\ninsights\npatterns\ninvolves\nexamining\nanalyzing\nfrequency\nstructure\nmeaningful\nalgorithms\nprocessing\nalphabetical\ntransforming\ncharacteristics\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef transform_data(data):\n    pattern = r\"\\b[a-zA-Z]{3,5}\\b\"\n    matches = re.findall(pattern, data)\n    transformed = [word[::-1] for word in matches]\n    return transformed\n\ndef binary_search(arr, target):\n    low, high = 0, len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        print(f\"Searching: {arr[low:high+1]}, mid: {arr[mid]}\")\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n\ntext = \"Python is a fun and versatile language to code in. Let's reverse some words!\"\ntransformed_words = transform_data(text)\n\nprint(\"Transformed words:\", transformed_words)\n\nsorted_words = sorted(transformed_words)\nprint(\"Sorted transformed words:\", sorted_words)\n\nsearch_word = \"nuf\"\nprint(f\"Searching for: '{search_word}'\")\nindex = binary_search(sorted_words, search_word)\n\nif index != -1:\n    print(f\"Word '{search_word}' found at index: {index}\")\nelse:\n    print(f\"Word '{search_word}' not found\")"}, {"role": "assistant", "content": "Transformed words: ['nuf', 'dna', 'edoc', 'teL', 'emos', 'sdrow']\nSorted transformed words: ['dna', 'edoc', 'emos', 'nuf', 'sdrow', 'teL']\nSearching for: 'nuf'\nSearching: ['dna', 'edoc', 'emos', 'nuf', 'sdrow', 'teL'], mid: emos\nSearching: ['nuf', 'sdrow', 'teL'], mid: sdrow\nSearching: ['nuf'], mid: nuf\nWord 'nuf' found at index: 3\n"}]}
{"messages": [{"role": "user", "content": "def search_longest_word(sentence):\n    words = sentence.split()\n    max_length = 0\n    longest_word = \"\"\n    for word in words:\n        print(f\"Checking word: {word}\")\n        if len(word) > max_length:\n            max_length = len(word)\n            longest_word = word\n            print(f\"New longest word found: {longest_word} with length {max_length}\")\n    return longest_word\n\ndef main():\n    text = (\n        \"In a village of La Mancha, the name of which I have no desire to call to mind, \"\n        \"there lived not long since one of those gentlemen that keep a lance in the lance-rack, \"\n        \"an old buckler, a lean hack, and a greyhound for coursing.\"\n    )\n    print(\"Analyzing text for the longest word...\")\n    result = search_longest_word(text)\n    print(f\"The longest word in the text is: '{result}'\")\n\nmain()"}, {"role": "assistant", "content": "Analyzing text for the longest word...\nChecking word: In\nNew longest word found: In with length 2\nChecking word: a\nChecking word: village\nNew longest word found: village with length 7\nChecking word: of\nChecking word: La\nChecking word: Mancha,\nChecking word: the\nChecking word: name\nChecking word: of\nChecking word: which\nChecking word: I\nChecking word: have\nChecking word: no\nChecking word: desire\nChecking word: to\nChecking word: call\nChecking word: to\nChecking word: mind,\nChecking word: there\nChecking word: lived\nChecking word: not\nChecking word: long\nChecking word: since\nChecking word: one\nChecking word: of\nChecking word: those\nChecking word: gentlemen\nNew longest word found: gentlemen with length 9\nChecking word: that\nChecking word: keep\nChecking word: a\nChecking word: lance\nChecking word: in\nChecking word: the\nChecking word: lance-rack,\nNew longest word found: lance-rack, with length 11\nChecking word: an\nChecking word: old\nChecking word: buckler,\nChecking word: a\nChecking word: lean\nChecking word: hack,\nChecking word: and\nChecking word: a\nChecking word: greyhound\nChecking word: for\nChecking word: coursing.\nThe longest word in the text is: 'lance-rack,'\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef generate_dates(start_date, num_days):\n    return [start_date + timedelta(days=i) for i in range(num_days)]\n\ndef date_to_ordinal(date):\n    return date.toordinal()\n\ndef ordinal_to_date(ordinal):\n    return datetime.fromordinal(ordinal)\n\ndef sort_dates_by_weekday(dates):\n    return sorted(dates, key=lambda date: date.weekday())\n\nstart_date = datetime(2023, 1, 1)\nnum_days = 60\n\ndates = generate_dates(start_date, num_days)\nordinal_dates = list(map(date_to_ordinal, dates))\nsorted_ordinal_dates = sorted(ordinal_dates)\n\nsorted_dates = sort_dates_by_weekday(map(ordinal_to_date, sorted_ordinal_dates))\n\nfor date in sorted_dates:\n    print(date.strftime(\"%Y-%m-%d %A\"))"}, {"role": "assistant", "content": "2023-01-02 Monday\n2023-01-09 Monday\n2023-01-16 Monday\n2023-01-23 Monday\n2023-01-30 Monday\n2023-02-06 Monday\n2023-02-13 Monday\n2023-02-20 Monday\n2023-02-27 Monday\n2023-01-03 Tuesday\n2023-01-10 Tuesday\n2023-01-17 Tuesday\n2023-01-24 Tuesday\n2023-01-31 Tuesday\n2023-02-07 Tuesday\n2023-02-14 Tuesday\n2023-02-21 Tuesday\n2023-02-28 Tuesday\n2023-01-04 Wednesday\n2023-01-11 Wednesday\n2023-01-18 Wednesday\n2023-01-25 Wednesday\n2023-02-01 Wednesday\n2023-02-08 Wednesday\n2023-02-15 Wednesday\n2023-02-22 Wednesday\n2023-03-01 Wednesday\n2023-01-05 Thursday\n2023-01-12 Thursday\n2023-01-19 Thursday\n2023-01-26 Thursday\n2023-02-02 Thursday\n2023-02-09 Thursday\n2023-02-16 Thursday\n2023-02-23 Thursday\n2023-01-06 Friday\n2023-01-13 Friday\n2023-01-20 Friday\n2023-01-27 Friday\n2023-02-03 Friday\n2023-02-10 Friday\n2023-02-17 Friday\n2023-02-24 Friday\n2023-01-07 Saturday\n2023-01-14 Saturday\n2023-01-21 Saturday\n2023-01-28 Saturday\n2023-02-04 Saturday\n2023-02-11 Saturday\n2023-02-18 Saturday\n2023-02-25 Saturday\n2023-01-01 Sunday\n2023-01-08 Sunday\n2023-01-15 Sunday\n2023-01-22 Sunday\n2023-01-29 Sunday\n2023-02-05 Sunday\n2023-02-12 Sunday\n2023-02-19 Sunday\n2023-02-26 Sunday\n"}]}
{"messages": [{"role": "user", "content": "def game_score_sort(scores):\n    return sorted(scores, key=lambda x: (-x[1], x[0]))\n\ndef main():\n    player_scores = [\n        (\"Alice\", 150),\n        (\"Bob\", 200),\n        (\"Charlie\", 150),\n        (\"David\", 300),\n        (\"Eve\", 200),\n        (\"Frank\", 150),\n        (\"Grace\", 300),\n        (\"Hannah\", 300),\n        (\"Ivy\", 200),\n        (\"Jack\", 100),\n    ]\n\n    print(\"Original Scores:\")\n    for player, score in player_scores:\n        print(f\"{player}: {score}\")\n\n    sorted_scores = game_score_sort(player_scores)\n\n    print(\"\\nSorted Scores:\")\n    for player, score in sorted_scores:\n        print(f\"{player}: {score}\")\n\nmain()"}, {"role": "assistant", "content": "Original Scores:\nAlice: 150\nBob: 200\nCharlie: 150\nDavid: 300\nEve: 200\nFrank: 150\nGrace: 300\nHannah: 300\nIvy: 200\nJack: 100\n\nSorted Scores:\nDavid: 300\nGrace: 300\nHannah: 300\nBob: 200\nEve: 200\nIvy: 200\nAlice: 150\nCharlie: 150\nFrank: 150\nJack: 100\n"}]}
{"messages": [{"role": "user", "content": "import math\nimport statistics\n\ndef find_peak(data):\n    left = 0\n    right = len(data) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if data[mid] > data[mid + 1]:\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\ndef analyze_temperature_readings(readings):\n    peaks = [readings[find_peak(readings[i:i+10])] for i in range(0, len(readings), 10)]\n    avg_peak = statistics.mean(peaks)\n    median_peak = statistics.median(peaks)\n    return avg_peak, median_peak\n\ntemperatures = [math.sin(x/10) * 50 + 100 for x in range(100)]\navg, median = analyze_temperature_readings(temperatures)\n\nprint(f\"Average Peak Temperature: {avg:.2f}\")\nprint(f\"Median Peak Temperature: {median:.2f}\")"}, {"role": "assistant", "content": "Average Peak Temperature: 118.49\nMedian Peak Temperature: 114.12\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef distance(point1, point2):\n    return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2)\n\ndef perimeter(triangle):\n    return (distance(triangle[0], triangle[1]) +\n            distance(triangle[1], triangle[2]) +\n            distance(triangle[2], triangle[0]))\n\ndef sort_triangles_by_area(triangles):\n    def triangle_area(triangle):\n        a = distance(triangle[0], triangle[1])\n        b = distance(triangle[1], triangle[2])\n        c = distance(triangle[2], triangle[0])\n        s = (a + b + c) / 2\n        return math.sqrt(s * (s - a) * (s - b) * (s - c))\n\n    sorted_triangles = sorted(triangles, key=triangle_area, reverse=True)\n    return sorted_triangles\n\ntriangles = [\n    [(0, 0), (4, 0), (0, 3)],\n    [(0, 0), (1, 0), (0, 1)],\n    [(0, 0), (0, 5), (5, 0)],\n    [(0, 0), (3, 0), (0, 3)]\n]\n\nsorted_by_perimeter = sort_triangles_by_area(triangles)\n\nprint(\"Debug: Sorted triangles by perimeter:\")\nfor triangle in sorted_by_perimeter:\n    print(f\"Perimeter: {perimeter(triangle):.2f}, Triangle: {triangle}\")\n\nprint(\"\\nFinal Sorted Triangles by Perimeter:\")\nfor triangle in sorted_by_perimeter:\n    print(triangle)"}, {"role": "assistant", "content": "Debug: Sorted triangles by perimeter:\nPerimeter: 17.07, Triangle: [(0, 0), (0, 5), (5, 0)]\nPerimeter: 12.00, Triangle: [(0, 0), (4, 0), (0, 3)]\nPerimeter: 10.24, Triangle: [(0, 0), (3, 0), (0, 3)]\nPerimeter: 3.41, Triangle: [(0, 0), (1, 0), (0, 1)]\n\nFinal Sorted Triangles by Perimeter:\n[(0, 0), (0, 5), (5, 0)]\n[(0, 0), (4, 0), (0, 3)]\n[(0, 0), (3, 0), (0, 3)]\n[(0, 0), (1, 0), (0, 1)]\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef custom_key(date_str):\n    date_format = \"%Y-%m-%d %H:%M:%S\"\n    return datetime.strptime(date_str, date_format)\n\ndef generate_date_list():\n    base_date = datetime(2023, 1, 1, 12, 0, 0)\n    date_list = [base_date - timedelta(days=i*5, hours=i*3) for i in range(50)]\n    return [date.strftime(\"%Y-%m-%d %H:%M:%S\") for date in date_list]\n\ndef sort_dates_by_hour(dates):\n    return sorted(dates, key=custom_key)\n\ndef main():\n    dates = generate_date_list()\n    print(\"Original Dates:\")\n    for date in dates[:10]:\n        print(date)\n    print(\"\\nSorting Dates...\")\n    sorted_dates = sort_dates_by_hour(dates)\n    print(\"\\nSorted Dates:\")\n    for date in sorted_dates[:10]:\n        print(date)\n\nif __name__ == \"__main__\":\n    main()"}, {"role": "assistant", "content": "Original Dates:\n2023-01-01 12:00:00\n2022-12-27 09:00:00\n2022-12-22 06:00:00\n2022-12-17 03:00:00\n2022-12-12 00:00:00\n2022-12-06 21:00:00\n2022-12-01 18:00:00\n2022-11-26 15:00:00\n2022-11-21 12:00:00\n2022-11-16 09:00:00\n\nSorting Dates...\n\nSorted Dates:\n2022-04-25 09:00:00\n2022-04-30 12:00:00\n2022-05-05 15:00:00\n2022-05-10 18:00:00\n2022-05-15 21:00:00\n2022-05-21 00:00:00\n2022-05-26 03:00:00\n2022-05-31 06:00:00\n2022-06-05 09:00:00\n2022-06-10 12:00:00\n"}]}
{"messages": [{"role": "user", "content": "def find_treasure(grid, start, treasure):\n    rows, cols = len(grid), len(grid[0])\n    queue = [start]\n    visited = set()\n    visited.add(start)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    while queue:\n        x, y = queue.pop(0)\n        if grid[x][y] == treasure:\n            return (x, y)\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny))\n    return None\n\ngame_grid = [\n    ['.', '.', '.', 'O', '.', 'T'],\n    ['.', 'O', '.', 'O', '.', '.'],\n    ['.', '.', '.', '.', 'O', '.'],\n    ['.', 'O', 'O', '.', '.', '.'],\n    ['.', '.', '.', 'O', '.', '.'],\n    ['.', '.', '.', '.', '.', '.']\n]\n\nstart_position = (0, 0)\ntreasure_symbol = 'T'\ntreasure_location = find_treasure(game_grid, start_position, treasure_symbol)\n\npath_string = ''\nif treasure_location:\n    x, y = treasure_location\n    path_string += f'Treasure found at ({x}, {y})'\nelse:\n    path_string += 'Treasure not found'\n\nprint(path_string)"}, {"role": "assistant", "content": "Treasure found at (0, 5)\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef encode_message(message):\n    encoded = []\n    for char in message:\n        if char.isalpha():\n            shifted = chr(((ord(char.lower()) - 97 + 13) % 26) + 97)\n            encoded.append(shifted.upper() if char.isupper() else shifted)\n        else:\n            encoded.append(char)\n    return ''.join(encoded)\n\ndef search_encoded(encoded_message, word):\n    for i in range(len(encoded_message)):\n        if encoded_message[i:i+len(word)] == word:\n            return i\n    return -1\n\nmessage = (\n    \"The quick brown fox jumps over the lazy dog. \"\n    \"Pack my box with five dozen liquor jugs. \"\n    \"How razorback-jumping frogs can level six piqued gymnasts!\"\n)\n\nencoded_message = encode_message(message)\n\nwords_to_find = [\"URYYB\", \"QBT\", \"CEBCREGL\", \"VZC\"]\nfound_positions = {}\n\nfor word in words_to_find:\n    position = search_encoded(encoded_message, word)\n    found_positions[word] = position\n\nfor word, position in found_positions.items():\n    if position != -1:\n        snippet = encoded_message[position:position+len(word)]\n        print(f\"Found '{word}' at position {position}: {snippet}\")\n    else:\n        print(f\"'{word}' not found in the encoded message.\")"}, {"role": "assistant", "content": "'URYYB' not found in the encoded message.\n'QBT' not found in the encoded message.\n'CEBCREGL' not found in the encoded message.\n'VZC' not found in the encoded message.\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef generate_pattern(n):\n    pattern = []\n    for i in range(1, n + 1):\n        pattern.append('*' * i)\n    for i in range(n - 1, 0, -1):\n        pattern.append('*' * i)\n    return pattern\n\ndef search_pattern(patterns, search_term):\n    matches = []\n    for pattern in patterns:\n        if re.search(search_term, pattern):\n            matches.append(pattern)\n    return matches\n\ndef main():\n    n = 10\n    pattern = generate_pattern(n)\n    search_term = r'^[*]{3}$|^[*]{5}$'\n    \n    print(\"Generated Pattern:\")\n    for line in pattern:\n        print(line)\n    \n    print(\"\\nSearching for patterns matching:\", search_term)\n    result = search_pattern(pattern, search_term)\n    \n    print(\"\\nFound Matches:\")\n    for match in result:\n        print(match)\n\nmain()"}, {"role": "assistant", "content": "Generated Pattern:\n*\n**\n***\n****\n*****\n******\n*******\n********\n*********\n**********\n*********\n********\n*******\n******\n*****\n****\n***\n**\n*\n\nSearching for patterns matching: ^[*]{3}$|^[*]{5}$\n\nFound Matches:\n***\n*****\n*****\n***\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef generate_dates(start_date, n):\n    return [(start_date + timedelta(days=i)) for i in range(n)]\n\ndef sort_dates_by_weekday(dates):\n    return sorted(dates, key=lambda date: (date.weekday(), date))\n\ndates = generate_dates(datetime(2023, 1, 1), 31)\nsorted_dates = sort_dates_by_weekday(dates)\n\nfor date in sorted_dates:\n    print(date.strftime(\"%Y-%m-%d %A\"))"}, {"role": "assistant", "content": "2023-01-02 Monday\n2023-01-09 Monday\n2023-01-16 Monday\n2023-01-23 Monday\n2023-01-30 Monday\n2023-01-03 Tuesday\n2023-01-10 Tuesday\n2023-01-17 Tuesday\n2023-01-24 Tuesday\n2023-01-31 Tuesday\n2023-01-04 Wednesday\n2023-01-11 Wednesday\n2023-01-18 Wednesday\n2023-01-25 Wednesday\n2023-01-05 Thursday\n2023-01-12 Thursday\n2023-01-19 Thursday\n2023-01-26 Thursday\n2023-01-06 Friday\n2023-01-13 Friday\n2023-01-20 Friday\n2023-01-27 Friday\n2023-01-07 Saturday\n2023-01-14 Saturday\n2023-01-21 Saturday\n2023-01-28 Saturday\n2023-01-01 Sunday\n2023-01-08 Sunday\n2023-01-15 Sunday\n2023-01-22 Sunday\n2023-01-29 Sunday\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef transform_and_search(data, target):\n    def is_vowel(c):\n        return c.lower() in 'aeiou'\n\n    def transform_word(word):\n        return ''.join(['_' if is_vowel(c) else c for c in word])\n\n    transformed_data = [transform_word(word) for word in data]\n    print(\"Transformed Data: \", transformed_data)\n\n    results = []\n    for word in transformed_data:\n        if re.search(target, word):\n            results.append(word)\n\n    print(\"Search Results: \", results)\n    return results\n\ndata = [\n    \"algorithm\", \"binary\", \"search\", \"tree\", \"graph\", \"dynamic\", \n    \"programming\", \"heuristic\", \"optimization\", \"queue\", \"stack\"\n]\n\ntarget = \"d_t_\"\nsearch_results = transform_and_search(data, target)\n\nprint(\"Final Results: \", search_results)"}, {"role": "assistant", "content": "Transformed Data:  ['_lg_r_thm', 'b_n_ry', 's__rch', 'tr__', 'gr_ph', 'dyn_m_c', 'pr_gr_mm_ng', 'h__r_st_c', '_pt_m_z_t__n', 'q____', 'st_ck']\nSearch Results:  []\nFinal Results:  []\n"}]}
{"messages": [{"role": "user", "content": "import math\nfrom statistics import mean\n\ndef quicksort(arr):\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    return quicksort(left) + middle + quicksort(right)\n\ndata = [\n    (1, 2.5), (2, 3.6), (3, 5.1), (4, 7.8), (5, 11.0), \n    (6, 13.5), (7, 15.3), (8, 19.1), (9, 22.4), (10, 24.9)\n]\n\ndelta_values = [math.log(b) - math.sqrt(a) for a, b in data]\n\nprint(\"Calculated delta values:\")\nfor value in delta_values:\n    print(value)\n\nsorted_delta = quicksort(delta_values)\n\nprint(\"\\nSorted delta values:\")\nfor value in sorted_delta:\n    print(value)\n\nmean_delta = mean(sorted_delta)\nprint(f\"\\nMean of sorted delta values: {mean_delta}\")\n\nabove_mean = [x for x in sorted_delta if x > mean_delta]\n\nprint(\"\\nDelta values above the mean:\")\nfor value in above_mean:\n    print(value)\n\nprint(\"\\nCount of delta values above the mean:\", len(above_mean))"}, {"role": "assistant", "content": "Calculated delta values:\n-0.0837092681258449\n-0.1332797169110309\n-0.10281026783859715\n0.05412373369554624\n0.16182729529858086\n0.15319994266120585\n0.08210151733379911\n0.12126121030639414\n0.1090609588609941\n0.0525901433022824\n\nSorted delta values:\n-0.1332797169110309\n-0.10281026783859715\n-0.0837092681258449\n0.0525901433022824\n0.05412373369554624\n0.08210151733379911\n0.1090609588609941\n0.12126121030639414\n0.15319994266120585\n0.16182729529858086\n\nMean of sorted delta values: 0.041436554858332975\n\nDelta values above the mean:\n0.0525901433022824\n0.05412373369554624\n0.08210151733379911\n0.1090609588609941\n0.12126121030639414\n0.15319994266120585\n0.16182729529858086\n\nCount of delta values above the mean: 7\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef is_perfect_square(n):\n    root = int(math.sqrt(n))\n    return root * root == n\n\ndef generate_fibonacci_sequence_up_to(n):\n    sequence = [0, 1]\n    while True:\n        next_value = sequence[-1] + sequence[-2]\n        if next_value > n:\n            break\n        sequence.append(next_value)\n    return sequence\n\ndef find_fibonacci_index(value, fibonacci_sequence):\n    left, right = 0, len(fibonacci_sequence) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if fibonacci_sequence[mid] == value:\n            return mid\n        elif fibonacci_sequence[mid] < value:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\nmax_number = 10000\nfibonacci_sequence = generate_fibonacci_sequence_up_to(max_number)\n\nprint(\"Fibonacci sequence up to\", max_number, \":\", fibonacci_sequence)\n\nperfect_square_fibonacci_indices = []\nfor number in fibonacci_sequence:\n    if is_perfect_square(number):\n        index = find_fibonacci_index(number, fibonacci_sequence)\n        print(f\"Perfect square found: {number}, Index: {index}\")\n        perfect_square_fibonacci_indices.append(index)\n\nprint(\"Indices of perfect square Fibonacci numbers:\", perfect_square_fibonacci_indices)"}, {"role": "assistant", "content": "Fibonacci sequence up to 10000 : [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765]\nPerfect square found: 0, Index: 0\nPerfect square found: 1, Index: 1\nPerfect square found: 1, Index: 1\nPerfect square found: 144, Index: 12\nIndices of perfect square Fibonacci numbers: [0, 1, 1, 12]\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef generate_dates(start_date, days):\n    return [start_date + timedelta(days=i) for i in range(days)]\n\ndef transform_dates(dates):\n    return [date.strftime(\"%Y-%m-%d\") for date in dates]\n\ndef sort_dates_by_weekday(dates):\n    return sorted(dates, key=lambda date: (date.weekday(), date))\n\nstart_date = datetime(2023, 1, 1)\ndays = 30\ndates = generate_dates(start_date, days)\nsorted_dates = sort_dates_by_weekday(dates)\ntransformed_dates = transform_dates(sorted_dates)\n\nfor date in transformed_dates:\n    print(date)"}, {"role": "assistant", "content": "2023-01-02\n2023-01-09\n2023-01-16\n2023-01-23\n2023-01-30\n2023-01-03\n2023-01-10\n2023-01-17\n2023-01-24\n2023-01-04\n2023-01-11\n2023-01-18\n2023-01-25\n2023-01-05\n2023-01-12\n2023-01-19\n2023-01-26\n2023-01-06\n2023-01-13\n2023-01-20\n2023-01-27\n2023-01-07\n2023-01-14\n2023-01-21\n2023-01-28\n2023-01-01\n2023-01-08\n2023-01-15\n2023-01-22\n2023-01-29\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"\nSorting algorithms are a fundamental part of computer science.\nSome commonly used sorting algorithms include quicksort, mergesort,\nheapsort, and bubblesort. These algorithms vary in efficiency and\nimplementation complexity. Sorting is often used in text processing\nto organize data, for example sorting words alphabetically.\n\"\"\"\n\nwords = re.findall(r'\\b\\w+\\b', text.lower())\nunique_words = list(set(words))\n\ndef custom_sort(word):\n    vowels = 'aeiou'\n    vowel_count = sum(1 for char in word if char in vowels)\n    return (vowel_count, len(word), word)\n\nsorted_words = sorted(unique_words, key=custom_sort)\n\nfor word in sorted_words:\n    print(word)"}, {"role": "assistant", "content": "a\nin\nis\nof\nto\nand\nfor\npart\ntext\nvary\nwords\nare\ndata\nsome\nused\noften\nthese\nsorting\ncommonly\nexample\ninclude\nscience\ncomputer\nheapsort\nmergesort\nquicksort\nalgorithms\nbubblesort\ncomplexity\nprocessing\norganize\nefficiency\nfundamental\nalphabetically\nimplementation\n"}]}
{"messages": [{"role": "user", "content": "import math\n\n# Define a list of points in a 2D plane\npoints = [\n    (3, 4), (1, 2), (5, 6), (7, 8),\n    (2, 1), (6, 5), (4, 3), (8, 7),\n    (9, 0), (0, 9), (10, 10), (11, 11),\n    (12, 12), (13, 13), (14, 14), (15, 15)\n]\n\ndef distance_from_origin(point):\n    x, y = point\n    return math.sqrt(x**2 + y**2)\n\nsorted_points = sorted(points, key=distance_from_origin)\n\nprint(\"Points sorted by distance from origin:\")\nfor p in sorted_points:\n    print(f\"Point: {p}, Distance: {distance_from_origin(p):.2f}\")\n\ndef polar_angle(point):\n    x, y = point\n    return math.atan2(y, x)\n\nsorted_by_angle = sorted(sorted_points, key=polar_angle)\n\nprint(\"\\nPoints sorted by polar angle:\")\nfor p in sorted_by_angle:\n    angle = polar_angle(p)\n    print(f\"Point: {p}, Polar Angle: {math.degrees(angle):.2f}\")"}, {"role": "assistant", "content": "Points sorted by distance from origin:\nPoint: (1, 2), Distance: 2.24\nPoint: (2, 1), Distance: 2.24\nPoint: (3, 4), Distance: 5.00\nPoint: (4, 3), Distance: 5.00\nPoint: (5, 6), Distance: 7.81\nPoint: (6, 5), Distance: 7.81\nPoint: (9, 0), Distance: 9.00\nPoint: (0, 9), Distance: 9.00\nPoint: (7, 8), Distance: 10.63\nPoint: (8, 7), Distance: 10.63\nPoint: (10, 10), Distance: 14.14\nPoint: (11, 11), Distance: 15.56\nPoint: (12, 12), Distance: 16.97\nPoint: (13, 13), Distance: 18.38\nPoint: (14, 14), Distance: 19.80\nPoint: (15, 15), Distance: 21.21\n\nPoints sorted by polar angle:\nPoint: (9, 0), Polar Angle: 0.00\nPoint: (2, 1), Polar Angle: 26.57\nPoint: (4, 3), Polar Angle: 36.87\nPoint: (6, 5), Polar Angle: 39.81\nPoint: (8, 7), Polar Angle: 41.19\nPoint: (10, 10), Polar Angle: 45.00\nPoint: (11, 11), Polar Angle: 45.00\nPoint: (12, 12), Polar Angle: 45.00\nPoint: (13, 13), Polar Angle: 45.00\nPoint: (14, 14), Polar Angle: 45.00\nPoint: (15, 15), Polar Angle: 45.00\nPoint: (7, 8), Polar Angle: 48.81\nPoint: (5, 6), Polar Angle: 50.19\nPoint: (3, 4), Polar Angle: 53.13\nPoint: (1, 2), Polar Angle: 63.43\nPoint: (0, 9), Polar Angle: 90.00\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndata = [\n    23, 29, 20, 32, 23, 21, 33, 25, 23, 24, 27, 29, 31, 28, 26, 30, 22, 25, 24,\n    28, 22, 23, 29, 24, 27, 25, 32, 31, 30, 24, 25, 26, 23, 24, 22, 30, 29, 28,\n    27, 25, 24, 30, 22, 23, 29, 31, 24, 28, 27, 25, 30, 22, 21, 23, 31, 30, 32,\n    26, 25, 24, 23, 22, 29, 31, 28, 26, 30, 24, 25, 26, 23, 22, 30, 29, 28, 27,\n    25, 32, 31, 30, 29, 28, 27, 26, 25, 23, 22, 21, 24, 28, 30, 29, 27, 26, 23\n]\n\ntarget_mean = 26.5\ntolerance = 0.05\nn = len(data)\n\ndef search_for_mean(data, target_mean, tolerance):\n    left, right = 0, n - 1\n    found_subset = []\n    min_deviation = float('inf')\n    \n    while left < right:\n        current_subset = data[left:right+1]\n        current_mean = statistics.mean(current_subset)\n        deviation = abs(current_mean - target_mean)\n        \n        if deviation < min_deviation:\n            min_deviation = deviation\n            found_subset = current_subset[:]\n        \n        if current_mean < target_mean:\n            left += 1\n        else:\n            right -= 1\n        \n        if min_deviation <= tolerance:\n            break\n            \n    return found_subset\n\nresult = search_for_mean(data, target_mean, tolerance)\nfor value in result:\n    print(value)"}, {"role": "assistant", "content": "33\n25\n23\n24\n27\n29\n31\n28\n26\n30\n22\n25\n24\n28\n22\n23\n29\n24\n27\n25\n32\n31\n30\n24\n25\n26\n23\n24\n22\n30\n29\n28\n27\n25\n24\n30\n22\n23\n29\n31\n24\n28\n27\n25\n30\n22\n21\n23\n31\n30\n32\n26\n25\n24\n23\n22\n29\n31\n28\n26\n30\n24\n25\n26\n23\n22\n30\n29\n28\n27\n25\n32\n31\n30\n29\n28\n27\n26\n25\n23\n22\n21\n24\n28\n30\n29\n27\n26\n23\n"}]}
{"messages": [{"role": "user", "content": "import re\nfrom collections import Counter\n\ndef find_longest_common_substring(text, pattern):\n    def search_substring_length(length):\n        seen = set()\n        for i in range(len(text) - length + 1):\n            substring = text[i:i + length]\n            seen.add(substring)\n        for i in range(len(pattern) - length + 1):\n            substring = pattern[i:i + length]\n            if substring in seen:\n                return substring\n        return None\n\n    low, high = 0, min(len(text), len(pattern))\n    result = \"\"\n    while low <= high:\n        mid = (low + high) // 2\n        found = search_substring_length(mid)\n        if found:\n            result = found\n            low = mid + 1\n        else:\n            high = mid - 1\n    return result\n\ntext = \"\"\"The quick brown fox jumps over the lazy dog. The quick brown fox is very quick and agile.\nThe brown fox likes to jump over lazy dogs quite often. Quick brown foxes are often seen jumping.\"\"\"\n\npattern = \"\"\"Lazy dogs are often jumped over by quick brown foxes. The quick and agile brown fox is a common sight.\nMany quick brown foxes are known to jump over lazy dogs. The brown fox is quick and agile.\"\"\"\n\ncleaned_text = re.sub(r'\\W+', ' ', text).lower()\ncleaned_pattern = re.sub(r'\\W+', ' ', pattern).lower()\n\nlongest_common_substring = find_longest_common_substring(cleaned_text, cleaned_pattern)\n\nword_count = Counter(cleaned_text.split())\nsorted_words = sorted(word_count.items(), key=lambda x: (-x[1], x[0]))\n\nprint(\"Longest common substring:\", longest_common_substring)\nprint(\"\\nTop 5 most common words in text:\")\nfor word, count in sorted_words[:5]:\n    print(f\"{word}: {count}\")"}, {"role": "assistant", "content": "Longest common substring:  to jump over lazy dogs \n\nTop 5 most common words in text:\nbrown: 4\nquick: 4\nthe: 4\nfox: 3\nlazy: 2\n"}]}
{"messages": [{"role": "user", "content": "def generate_pattern(size):\n    pattern = []\n    for i in range(size):\n        row = [1 if (i + j) % 2 == 0 else 0 for j in range(size)]\n        pattern.append(row)\n    return pattern\n\ndef flatten_and_sort_pattern(pattern):\n    flat_list = [num for row in pattern for num in row]\n    print(\"Flattened pattern:\", flat_list)\n    sorted_flat_list = sorted(flat_list, reverse=True)\n    print(\"Sorted flattened pattern:\", sorted_flat_list)\n    return sorted_flat_list\n\ndef display_sorted_pattern(sorted_list, size):\n    index = 0\n    for _ in range(size):\n        line = sorted_list[index:index + size]\n        print(\"Pattern line:\", line)\n        index += size\n\nsize = 10\npattern = generate_pattern(size)\nprint(\"Generated pattern:\")\nfor row in pattern:\n    print(row)\nsorted_flat_list = flatten_and_sort_pattern(pattern)\nprint(\"Displaying sorted pattern:\")\ndisplay_sorted_pattern(sorted_flat_list, size)"}, {"role": "assistant", "content": "Generated pattern:\n[1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\n[0, 1, 0, 1, 0, 1, 0, 1, 0, 1]\n[1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\n[0, 1, 0, 1, 0, 1, 0, 1, 0, 1]\n[1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\n[0, 1, 0, 1, 0, 1, 0, 1, 0, 1]\n[1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\n[0, 1, 0, 1, 0, 1, 0, 1, 0, 1]\n[1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\n[0, 1, 0, 1, 0, 1, 0, 1, 0, 1]\nFlattened pattern: [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]\nSorted flattened pattern: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\nDisplaying sorted pattern:\nPattern line: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\nPattern line: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\nPattern line: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\nPattern line: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\nPattern line: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\nPattern line: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\nPattern line: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\nPattern line: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\nPattern line: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\nPattern line: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef sort_by_birthdays(dates):\n    today = datetime.now()\n    today_month_day = (today.month, today.day)\n    sorted_dates = sorted(\n        dates, \n        key=lambda date: (\n            (date.month, date.day) < today_month_day, \n            (date.month, date.day)\n        )\n    )\n    return sorted_dates\n\nbirthdays = [\n    datetime(1990, 7, 19), datetime(1985, 6, 15),\n    datetime(1992, 2, 28), datetime(1988, 9, 10),\n    datetime(1975, 12, 21), datetime(1999, 1, 5),\n    datetime(2000, 4, 25), datetime(1995, 11, 30),\n    datetime(1983, 3, 14), datetime(1991, 8, 30),\n    datetime(1987, 5, 18), datetime(1986, 7, 8)\n]\n\nsorted_birthdays = sort_by_birthdays(birthdays)\n\nfor birthday in sorted_birthdays:\n    print(birthday.strftime(\"%B %d\"))"}, {"role": "assistant", "content": "April 25\nMay 18\nJune 15\nJuly 08\nJuly 19\nAugust 30\nSeptember 10\nNovember 30\nDecember 21\nJanuary 05\nFebruary 28\nMarch 14\n"}]}
{"messages": [{"role": "user", "content": "def is_valid_move(board, x, y):\n    return 0 <= x < len(board) and 0 <= y < len(board[0]) and board[x][y] == 'O'\n\ndef find_path_to_treasure(board, start, treasure):\n    stack = [(start, [start])]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    while stack:\n        (x, y), path = stack.pop()\n        if (x, y) == treasure:\n            return path\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if is_valid_move(board, nx, ny) and (nx, ny) not in path:\n                stack.append(((nx, ny), path + [(nx, ny)]))\n    return None\n\nboard = [\n    ['O', 'O', 'X', 'X', 'O', 'T'],\n    ['X', 'O', 'X', 'O', 'O', 'X'],\n    ['O', 'O', 'O', 'X', 'O', 'O'],\n    ['O', 'X', 'O', 'O', 'X', 'X'],\n    ['O', 'X', 'X', 'O', 'O', 'O'],\n    ['O', 'O', 'O', 'O', 'X', 'X'],\n]\n\nstart = (0, 0)\ntreasure = (0, 5)\npath = find_path_to_treasure(board, start, treasure)\n\nif path:\n    for step in path:\n        print(step)\nelse:\n    print(\"No path found.\")"}, {"role": "assistant", "content": "No path found.\n"}]}
{"messages": [{"role": "user", "content": "import math\nfrom collections import defaultdict\n\ndef point_in_polygon(x, y, poly):\n    n = len(poly)\n    inside = False\n    p1x, p1y = poly[0]\n    for i in range(n + 1):\n        p2x, p2y = poly[i % n]\n        if y > min(p1y, p2y):\n            if y <= max(p1y, p2y):\n                if x <= max(p1x, p2x):\n                    if p1y != p2y:\n                        xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x\n                    if p1x == p2x or x <= xinters:\n                        inside = not inside\n        p1x, p1y = p2x, p2y\n    return inside\n\ndef generate_circles(n, r):\n    circles = []\n    for angle in range(0, 360, int(360 / n)):\n        rad = math.radians(angle)\n        cx = r * math.cos(rad)\n        cy = r * math.sin(rad)\n        circles.append((cx, cy))\n    return circles\n\ndef compute_intersections(circles, polygon):\n    intersections = defaultdict(list)\n    for idx, (cx, cy) in enumerate(circles):\n        for px, py in polygon:\n            if point_in_polygon(cx, cy, polygon):\n                intersections[idx].append((px, py))\n    return intersections\n\npolygon = [(0, 0), (5, 0), (5, 5), (0, 5)]\ncircles = generate_circles(72, 3)\nintersections = compute_intersections(circles, polygon)\n\nsorted_intersections = sorted(intersections.items(), key=lambda x: len(x[1]), reverse=True)\nfor idx, points in sorted_intersections[:10]:\n    print(f\"Circle {idx} intersects at {len(points)} points: {points}\")"}, {"role": "assistant", "content": "Circle 1 intersects at 4 points: [(0, 0), (5, 0), (5, 5), (0, 5)]\nCircle 2 intersects at 4 points: [(0, 0), (5, 0), (5, 5), (0, 5)]\nCircle 3 intersects at 4 points: [(0, 0), (5, 0), (5, 5), (0, 5)]\nCircle 4 intersects at 4 points: [(0, 0), (5, 0), (5, 5), (0, 5)]\nCircle 5 intersects at 4 points: [(0, 0), (5, 0), (5, 5), (0, 5)]\nCircle 6 intersects at 4 points: [(0, 0), (5, 0), (5, 5), (0, 5)]\nCircle 7 intersects at 4 points: [(0, 0), (5, 0), (5, 5), (0, 5)]\nCircle 8 intersects at 4 points: [(0, 0), (5, 0), (5, 5), (0, 5)]\nCircle 9 intersects at 4 points: [(0, 0), (5, 0), (5, 5), (0, 5)]\nCircle 10 intersects at 4 points: [(0, 0), (5, 0), (5, 5), (0, 5)]\n"}]}
{"messages": [{"role": "user", "content": "from itertools import permutations\n\ndef encode_message(message, key):\n    message = message.lower().replace(' ', '')\n    key = key.lower().replace(' ', '')\n    key_length = len(key)\n    sorted_key_indices = sorted(range(key_length), key=lambda i: key[i])\n    encoded_blocks = []\n\n    for i in range(0, len(message), key_length):\n        block = message[i:i + key_length].ljust(key_length, 'x')\n        encoded_block = ''.join(block[index] for index in sorted_key_indices)\n        encoded_blocks.append(encoded_block)\n\n    return ''.join(encoded_blocks)\n\ndef decode_message(encoded_message, key):\n    key_length = len(key)\n    sorted_key_indices = sorted(range(key_length), key=lambda i: key[i])\n    inverse_key_indices = sorted(range(key_length), key=lambda i: sorted_key_indices[i])\n    decoded_blocks = []\n\n    for i in range(0, len(encoded_message), key_length):\n        block = encoded_message[i:i + key_length]\n        decoded_block = ''.join(block[index] for index in inverse_key_indices)\n        decoded_blocks.append(decoded_block)\n\n    return ''.join(decoded_blocks)\n\ndef generate_key_permutations(key):\n    return [''.join(p) for p in permutations(key)]\n\ndef main():\n    message = \"this is a secret message\"\n    key = \"cipher\"\n    encoded_message = encode_message(message, key)\n    all_key_permutations = generate_key_permutations(key)\n    \n    for perm_key in all_key_permutations:\n        decoded_message = decode_message(encoded_message, perm_key)\n        if decoded_message.replace('x', '') == message.replace(' ', ''):\n            print(f\"Key: {perm_key}, Decoded: {decoded_message}\")\n\nmain()"}, {"role": "assistant", "content": "Key: cipher, Decoded: thisisasecretmessagexxxx\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef days_till_next_month(year, month, day):\n    current_date = datetime(year, month, day)\n    if month == 12:\n        next_month_date = datetime(year + 1, 1, 1)\n    else:\n        next_month_date = datetime(year, month + 1, 1)\n    delta = next_month_date - current_date\n    return delta.days\n\nstart_year = 2021\nstart_month = 1\nstart_day = 1\n\ndates = [(start_year, start_month, start_day)]\nfor _ in range(99):\n    last_date = dates[-1]\n    next_day = days_till_next_month(*last_date)\n    last_datetime = datetime(*last_date)\n    new_date = last_datetime + timedelta(days=next_day)\n    dates.append((new_date.year, new_date.month, new_date.day))\n\nfor date_tuple in dates:\n    year, month, day = date_tuple\n    print(f\"{year}-{month:02d}-{day:02d}\")"}, {"role": "assistant", "content": "2021-01-01\n2021-02-01\n2021-03-01\n2021-04-01\n2021-05-01\n2021-06-01\n2021-07-01\n2021-08-01\n2021-09-01\n2021-10-01\n2021-11-01\n2021-12-01\n2022-01-01\n2022-02-01\n2022-03-01\n2022-04-01\n2022-05-01\n2022-06-01\n2022-07-01\n2022-08-01\n2022-09-01\n2022-10-01\n2022-11-01\n2022-12-01\n2023-01-01\n2023-02-01\n2023-03-01\n2023-04-01\n2023-05-01\n2023-06-01\n2023-07-01\n2023-08-01\n2023-09-01\n2023-10-01\n2023-11-01\n2023-12-01\n2024-01-01\n2024-02-01\n2024-03-01\n2024-04-01\n2024-05-01\n2024-06-01\n2024-07-01\n2024-08-01\n2024-09-01\n2024-10-01\n2024-11-01\n2024-12-01\n2025-01-01\n2025-02-01\n2025-03-01\n2025-04-01\n2025-05-01\n2025-06-01\n2025-07-01\n2025-08-01\n2025-09-01\n2025-10-01\n2025-11-01\n2025-12-01\n2026-01-01\n2026-02-01\n2026-03-01\n2026-04-01\n2026-05-01\n2026-06-01\n2026-07-01\n2026-08-01\n2026-09-01\n2026-10-01\n2026-11-01\n2026-12-01\n2027-01-01\n2027-02-01\n2027-03-01\n2027-04-01\n2027-05-01\n2027-06-01\n2027-07-01\n2027-08-01\n2027-09-01\n2027-10-01\n2027-11-01\n2027-12-01\n2028-01-01\n2028-02-01\n2028-03-01\n2028-04-01\n2028-05-01\n2028-06-01\n2028-07-01\n2028-08-01\n2028-09-01\n2028-10-01\n2028-11-01\n2028-12-01\n2029-01-01\n2029-02-01\n2029-03-01\n2029-04-01\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef sort_by_standard_deviation(numbers):\n    def std_dev(nums):\n        mean = sum(nums) / len(nums)\n        variance = sum((x - mean) ** 2 for x in nums) / len(nums)\n        return math.sqrt(variance)\n\n    return sorted(numbers, key=std_dev)\n\ndata_sets = [\n    [5, 8, 12, 18, 22],\n    [1, 2, 3, 4, 5],\n    [10, 20, 30],\n    [3, 3, 3, 3],\n    [14, 7, 28, 21],\n    [6, 6, 7, 8, 10],\n    [100, 110, 120, 130],\n    [9, 9, 9, 8],\n    [7, 5, 4, 2, 1],\n    [0, 0, 1, 1]\n]\n\nsorted_data_sets = sort_by_standard_deviation(data_sets)\n\nfor i, data_set in enumerate(sorted_data_sets, 1):\n    print(f\"Data Set {i}: {data_set}\")"}, {"role": "assistant", "content": "Data Set 1: [3, 3, 3, 3]\nData Set 2: [9, 9, 9, 8]\nData Set 3: [0, 0, 1, 1]\nData Set 4: [1, 2, 3, 4, 5]\nData Set 5: [6, 6, 7, 8, 10]\nData Set 6: [7, 5, 4, 2, 1]\nData Set 7: [5, 8, 12, 18, 22]\nData Set 8: [14, 7, 28, 21]\nData Set 9: [10, 20, 30]\nData Set 10: [100, 110, 120, 130]\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef search_and_transform(data, target):\n    transformed_data = []\n    for value in data:\n        if value == target:\n            value = math.sqrt(value)\n        elif value > target:\n            value = math.log(value)\n        transformed_data.append(value)\n    return transformed_data\n\ndata = [4, 16, 25, 9, 36, 49, 64, 81, 100]\ntarget = 36\n\nresult = search_and_transform(data, target)\n\nfor num in result:\n    print(f\"{num:.2f}\")"}, {"role": "assistant", "content": "4.00\n16.00\n25.00\n9.00\n6.00\n3.89\n4.16\n4.39\n4.61\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef encode_message(message, key):\n    encoded = []\n    for char in message:\n        encoded_char = (ord(char) + key) % 256\n        encoded.append(encoded_char)\n    return encoded\n\ndef decode_message(encoded, key):\n    decoded = \"\"\n    for num in encoded:\n        decoded_char = chr((num - key) % 256)\n        decoded += decoded_char\n    return decoded\n\ndef find_key(encoded, target):\n    for potential_key in range(256):\n        decoded_try = decode_message(encoded, potential_key)\n        if target in decoded_try:\n            print(f\"Potential key found: {potential_key}\")\n            print(decoded_try)\n            return potential_key\n    print(\"No valid key found.\")\n    return None\n\ndef main():\n    message = \"The quick brown fox jumps over the lazy dog\"\n    key = 42\n    encoded = encode_message(message, key)\n    \n    print(\"Encoded message:\")\n    print(encoded)\n\n    key_found = find_key(encoded, \"fox\")\n    \n    if key_found is not None:\n        print(\"\\nDecoding with found key:\")\n        decoded_message = decode_message(encoded, key_found)\n        print(decoded_message)\n\nmain()"}, {"role": "assistant", "content": "Encoded message:\n[126, 146, 143, 74, 155, 159, 147, 141, 149, 74, 140, 156, 153, 161, 152, 74, 144, 153, 162, 74, 148, 159, 151, 154, 157, 74, 153, 160, 143, 156, 74, 158, 146, 143, 74, 150, 139, 164, 163, 74, 142, 153, 145]\nPotential key found: 42\nThe quick brown fox jumps over the lazy dog\n\nDecoding with found key:\nThe quick brown fox jumps over the lazy dog\n"}]}
{"messages": [{"role": "user", "content": "from math import sin, cos\n\ndef generate_pattern(n):\n    points = [(round(cos(i), 3), round(sin(i), 3)) for i in range(n)]\n    print(\"Generated Points:\")\n    for point in points:\n        print(point)\n    sorted_points = sorted(points, key=lambda x: (x[0]**2 + x[1]**2)**0.5)\n    print(\"\\nSorted Points by Distance from Origin:\")\n    for point in sorted_points:\n        print(point)\n\ngenerate_pattern(50)"}, {"role": "assistant", "content": "Generated Points:\n(1.0, 0.0)\n(0.54, 0.841)\n(-0.416, 0.909)\n(-0.99, 0.141)\n(-0.654, -0.757)\n(0.284, -0.959)\n(0.96, -0.279)\n(0.754, 0.657)\n(-0.146, 0.989)\n(-0.911, 0.412)\n(-0.839, -0.544)\n(0.004, -1.0)\n(0.844, -0.537)\n(0.907, 0.42)\n(0.137, 0.991)\n(-0.76, 0.65)\n(-0.958, -0.288)\n(-0.275, -0.961)\n(0.66, -0.751)\n(0.989, 0.15)\n(0.408, 0.913)\n(-0.548, 0.837)\n(-1.0, -0.009)\n(-0.533, -0.846)\n(0.424, -0.906)\n(0.991, -0.132)\n(0.647, 0.763)\n(-0.292, 0.956)\n(-0.963, 0.271)\n(-0.748, -0.664)\n(0.154, -0.988)\n(0.915, -0.404)\n(0.834, 0.551)\n(-0.013, 1.0)\n(-0.849, 0.529)\n(-0.904, -0.428)\n(-0.128, -0.992)\n(0.765, -0.644)\n(0.955, 0.296)\n(0.267, 0.964)\n(-0.667, 0.745)\n(-0.987, -0.159)\n(-0.4, -0.917)\n(0.555, -0.832)\n(1.0, 0.018)\n(0.525, 0.851)\n(-0.432, 0.902)\n(-0.992, 0.124)\n(-0.64, -0.768)\n(0.301, -0.954)\n\nSorted Points by Distance from Origin:\n(0.54, 0.841)\n(0.907, 0.42)\n(-0.275, -0.961)\n(0.834, 0.551)\n(-0.292, 0.956)\n(-0.416, 0.909)\n(-0.64, -0.768)\n(-0.146, 0.989)\n(-0.992, 0.124)\n(0.96, -0.279)\n(-0.987, -0.159)\n(0.991, -0.132)\n(0.66, -0.751)\n(0.955, 0.296)\n(-0.911, 0.412)\n(-0.533, -0.846)\n(0.525, 0.851)\n(-0.839, -0.544)\n(0.154, -0.988)\n(-0.667, 0.745)\n(0.765, -0.644)\n(-0.99, 0.141)\n(1.0, 0.0)\n(0.004, -1.0)\n(0.408, 0.913)\n(-1.0, -0.009)\n(-0.76, 0.65)\n(0.754, 0.657)\n(-0.013, 1.0)\n(-0.432, 0.902)\n(0.555, -0.832)\n(1.0, 0.018)\n(0.284, -0.959)\n(-0.748, -0.664)\n(-0.904, -0.428)\n(0.915, -0.404)\n(-0.128, -0.992)\n(0.267, 0.964)\n(0.424, -0.906)\n(0.989, 0.15)\n(-0.849, 0.529)\n(0.844, -0.537)\n(-0.958, -0.288)\n(0.301, -0.954)\n(-0.654, -0.757)\n(0.647, 0.763)\n(-0.963, 0.271)\n(0.137, 0.991)\n(-0.548, 0.837)\n(-0.4, -0.917)\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef custom_key(item):\n    return math.sqrt(abs(item)) * (-1 if item < 0 else 1)\n\ndef transform_and_sort(data):\n    sorted_data = sorted(data, key=custom_key)\n    transformed_data = [round(math.log1p(abs(x)), 2) if x != 0 else 0.0 for x in sorted_data]\n    return transformed_data\n\ndata = [5, -1, 3, -9, 0, 7, -4, 8, 2, -6, -3, 10, -2, 6, -5, 1, -7, 9, -8, 4]\nresult = transform_and_sort(data)\n\nfor index, value in enumerate(result):\n    print(f\"Index {index}: {value}\")"}, {"role": "assistant", "content": "Index 0: 2.3\nIndex 1: 2.2\nIndex 2: 2.08\nIndex 3: 1.95\nIndex 4: 1.79\nIndex 5: 1.61\nIndex 6: 1.39\nIndex 7: 1.1\nIndex 8: 0.69\nIndex 9: 0.0\nIndex 10: 0.69\nIndex 11: 1.1\nIndex 12: 1.39\nIndex 13: 1.61\nIndex 14: 1.79\nIndex 15: 1.95\nIndex 16: 2.08\nIndex 17: 2.2\nIndex 18: 2.3\nIndex 19: 2.4\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef sort_cards(hand):\n    return sorted(hand, key=lambda x: (x[1], x[0]))\n\ndef calculate_hand_strength(hand):\n    ranks = [card[0] for card in hand]\n    return statistics.mean(ranks) + sum(ranks)\n\ndef is_winner(hand1, hand2):\n    strength1 = calculate_hand_strength(hand1)\n    strength2 = calculate_hand_strength(hand2)\n    return strength1 > strength2\n\ndeck = [(2, 'Hearts'), (3, 'Hearts'), (4, 'Hearts'), (5, 'Hearts'),\n        (6, 'Hearts'), (7, 'Hearts'), (8, 'Hearts'), (9, 'Hearts'),\n        (10, 'Hearts'), (11, 'Hearts'), (12, 'Hearts'), (13, 'Hearts'),\n        (14, 'Hearts'), (2, 'Diamonds'), (3, 'Diamonds'), (4, 'Diamonds'),\n        (5, 'Diamonds'), (6, 'Diamonds'), (7, 'Diamonds'), (8, 'Diamonds'),\n        (9, 'Diamonds'), (10, 'Diamonds'), (11, 'Diamonds'), (12, 'Diamonds'),\n        (13, 'Diamonds'), (14, 'Diamonds')]\n\nhand1 = sort_cards(deck[:5])\nhand2 = sort_cards(deck[5:10])\n\nprint(\"Hand 1:\", hand1)\nprint(\"Hand 2:\", hand2)\n\nif is_winner(hand1, hand2):\n    print(\"Hand 1 wins!\")\nelse:\n    print(\"Hand 2 wins!\")\n\nprint(\"\\nSorted Deck:\")\nsorted_deck = sort_cards(deck)\nfor card in sorted_deck:\n    print(card)"}, {"role": "assistant", "content": "Hand 1: [(2, 'Hearts'), (3, 'Hearts'), (4, 'Hearts'), (5, 'Hearts'), (6, 'Hearts')]\nHand 2: [(7, 'Hearts'), (8, 'Hearts'), (9, 'Hearts'), (10, 'Hearts'), (11, 'Hearts')]\nHand 2 wins!\n\nSorted Deck:\n(2, 'Diamonds')\n(3, 'Diamonds')\n(4, 'Diamonds')\n(5, 'Diamonds')\n(6, 'Diamonds')\n(7, 'Diamonds')\n(8, 'Diamonds')\n(9, 'Diamonds')\n(10, 'Diamonds')\n(11, 'Diamonds')\n(12, 'Diamonds')\n(13, 'Diamonds')\n(14, 'Diamonds')\n(2, 'Hearts')\n(3, 'Hearts')\n(4, 'Hearts')\n(5, 'Hearts')\n(6, 'Hearts')\n(7, 'Hearts')\n(8, 'Hearts')\n(9, 'Hearts')\n(10, 'Hearts')\n(11, 'Hearts')\n(12, 'Hearts')\n(13, 'Hearts')\n(14, 'Hearts')\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef almost_gcd_sequence_sort(sequence):\n    def custom_sort_key(x):\n        return math.gcd(x, sequence[0])\n    \n    print(\"Original sequence:\", sequence)\n    sorted_sequence = sorted(sequence, key=custom_sort_key, reverse=True)\n    print(\"Sorted sequence:\", sorted_sequence)\n    return sorted_sequence\n\ndef main():\n    sequence = [23, 45, 12, 18, 9, 30, 48, 60]\n    sorted_sequence = almost_gcd_sequence_sort(sequence)\n    \n    print(\"\\nSequence sorted by almost_gcd_sequence_sort:\")\n    for num in sorted_sequence:\n        print(num)\n\nmain()"}, {"role": "assistant", "content": "Original sequence: [23, 45, 12, 18, 9, 30, 48, 60]\nSorted sequence: [23, 45, 12, 18, 9, 30, 48, 60]\n\nSequence sorted by almost_gcd_sequence_sort:\n23\n45\n12\n18\n9\n30\n48\n60\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndata = [\n    ('2023-01-01', 23),\n    ('2023-01-02', 19),\n    ('2023-01-03', 25),\n    ('2023-01-04', 18),\n    ('2023-01-05', 22),\n    ('2023-01-06', 20),\n    ('2023-01-07', 21),\n    ('2023-01-08', 24),\n    ('2023-01-09', 22),\n    ('2023-01-10', 18),\n    ('2023-01-11', 19),\n    ('2023-01-12', 23),\n    ('2023-01-13', 20),\n    ('2023-01-14', 21),\n    ('2023-01-15', 24),\n    ('2023-01-16', 18),\n    ('2023-01-17', 19),\n    ('2023-01-18', 25),\n    ('2023-01-19', 20),\n    ('2023-01-20', 22),\n    ('2023-01-21', 21),\n    ('2023-01-22', 24),\n    ('2023-01-23', 22),\n    ('2023-01-24', 19),\n    ('2023-01-25', 23),\n    ('2023-01-26', 20),\n    ('2023-01-27', 21),\n    ('2023-01-28', 24),\n    ('2023-01-29', 18),\n    ('2023-01-30', 19),\n]\n\nsearch_date = '2023-01-15'\n\ndef binary_search(date_list, target_date):\n    low = 0\n    high = len(date_list) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        mid_date = datetime.datetime.strptime(date_list[mid][0], '%Y-%m-%d')\n        target = datetime.datetime.strptime(target_date, '%Y-%m-%d')\n        \n        print(f\"Low: {low}, High: {high}, Mid: {mid}\")\n        \n        if mid_date < target:\n            print(f\"{mid_date} is earlier than {target}. Searching right half.\")\n            low = mid + 1\n        elif mid_date > target:\n            print(f\"{mid_date} is later than {target}. Searching left half.\")\n            high = mid - 1\n        else:\n            print(f\"Found target date {target_date} with value {date_list[mid][1]}\")\n            return date_list[mid][1]\n    print(f\"Date {target_date} not found.\")\n    return None\n\nresult = binary_search(data, search_date)\nprint(\"Final result:\", result)"}, {"role": "assistant", "content": "Low: 0, High: 29, Mid: 14\nFound target date 2023-01-15 with value 24\nFinal result: 24\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndata = [\n    23, 45, 56, 45, 33, 45, 67, 89, 45, 23, 56, 45, 67, 23, 56, 67, 23, 56, 23, 67,\n    23, 56, 23, 67, 23, 56, 23, 67, 23, 56, 23, 67, 23, 56, 23, 67, 23, 56, 23, 67,\n    23, 56, 23, 67, 23, 56, 23, 67, 23, 56, 23, 67, 23, 56, 23, 67, 23, 56, 23, 67,\n    23, 56, 23, 67, 23, 56, 23, 67, 23, 56, 23, 67, 23, 56, 23, 67, 23, 56, 23, 67,\n    23, 56, 23, 67, 23, 56, 23, 67, 23, 56, 23, 67, 23, 56, 23, 67, 23, 56, 23, 67\n]\n\ndef find_mode(data):\n    freq_map = {}\n    for num in data:\n        if num in freq_map:\n            freq_map[num] += 1\n        else:\n            freq_map[num] = 1\n    highest_freq = max(freq_map.values())\n    mode_candidates = [k for k, v in freq_map.items() if v == highest_freq]\n    return mode_candidates\n\nmode_of_data = find_mode(data)\nsorted_data = sorted(data)\nmedian_of_data = statistics.median(data)\n\ndef binary_search_median(sorted_data, median):\n    low, high = 0, len(sorted_data) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if sorted_data[mid] == median:\n            return mid\n        elif sorted_data[mid] < median:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n\nmedian_index = binary_search_median(sorted_data, median_of_data)\n\nprint(\"Mode(s):\", mode_of_data)\nprint(\"Median:\", median_of_data)\nprint(\"Median Index in Sorted Data:\", median_index)"}, {"role": "assistant", "content": "Mode(s): [23]\nMedian: 45.0\nMedian Index in Sorted Data: 49\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"\nA quick brown fox jumps over the lazy dog. The quick brown fox is very quick and fast.\nA fox that is quick is a fox that is likely to catch its prey.\nQuickness is essential in the animal kingdom, and the quick fox knows this well.\n\"\"\"\n\ndef tokenize(text):\n    words = re.findall(r'\\b\\w+\\b', text.lower())\n    return words\n\ndef word_frequency(words):\n    freq = {}\n    for word in words:\n        freq[word] = freq.get(word, 0) + 1\n    return freq\n\ndef sort_by_frequency(freq):\n    return sorted(freq.items(), key=lambda item: (-item[1], item[0]))\n\ndef format_output(sorted_words):\n    output = []\n    for word, count in sorted_words:\n        output.append(f\"{word}: {count}\")\n    return output\n\nwords = tokenize(text)\nfrequency = word_frequency(words)\nsorted_words = sort_by_frequency(frequency)\noutput = format_output(sorted_words)\n\nfor line in output:\n    print(line)"}, {"role": "assistant", "content": "fox: 5\nis: 5\nquick: 5\nthe: 4\na: 3\nand: 2\nbrown: 2\nthat: 2\nanimal: 1\ncatch: 1\ndog: 1\nessential: 1\nfast: 1\nin: 1\nits: 1\njumps: 1\nkingdom: 1\nknows: 1\nlazy: 1\nlikely: 1\nover: 1\nprey: 1\nquickness: 1\nthis: 1\nto: 1\nvery: 1\nwell: 1\n"}]}
{"messages": [{"role": "user", "content": "import math\n\n# Dataset of angles in degrees\nangles = [45, 30, 90, 60, 120, 150, 180, 210, 240, 270, 300, 330]\n\n# Convert angles to radians\nangles_in_radians = [math.radians(angle) for angle in angles]\n\n# Calculate sine values\nsine_values = [math.sin(radian) for radian in angles_in_radians]\n\n# Sort sine values (incorrectly named)\ndef sort_angles_by_sine(angles, sine_values):\n    print(\"Sine values before sorting:\", sine_values)\n    paired = list(zip(sine_values, angles))\n    paired.sort()\n    sorted_sine_values, sorted_angles = zip(*paired)\n    print(\"Sine values after sorting:\", sorted_sine_values)\n    return sorted_angles\n\nsorted_angles = sort_angles_by_sine(angles, sine_values)\n\nprint(\"Angles sorted by sine values:\")\nfor angle in sorted_angles:\n    print(angle)"}, {"role": "assistant", "content": "Sine values before sorting: [0.7071067811865475, 0.49999999999999994, 1.0, 0.8660254037844386, 0.8660254037844387, 0.49999999999999994, 1.2246467991473532e-16, -0.5000000000000001, -0.8660254037844384, -1.0, -0.8660254037844386, -0.5000000000000004]\nSine values after sorting: (-1.0, -0.8660254037844386, -0.8660254037844384, -0.5000000000000004, -0.5000000000000001, 1.2246467991473532e-16, 0.49999999999999994, 0.49999999999999994, 0.7071067811865475, 0.8660254037844386, 0.8660254037844387, 1.0)\nAngles sorted by sine values:\n270\n300\n240\n330\n210\n180\n30\n150\n45\n60\n120\n90\n"}]}
{"messages": [{"role": "user", "content": "def find_magic_squares(n):\n    def is_magic(square):\n        sums = []\n        for row in square:\n            sums.append(sum(row))\n        for col in range(n):\n            sums.append(sum(square[row][col] for row in range(n)))\n        sums.append(sum(square[i][i] for i in range(n)))\n        sums.append(sum(square[i][n - i - 1] for i in range(n)))\n        return len(set(sums)) == 1\n\n    def generate_squares():\n        from itertools import permutations\n        numbers = list(range(1, n * n + 1))\n        for perm in permutations(numbers):\n            square = [list(perm[i:i + n]) for i in range(0, n * n, n)]\n            yield square\n\n    magic_squares = []\n    for square in generate_squares():\n        if is_magic(square):\n            magic_squares.append(square)\n\n    for idx, square in enumerate(magic_squares):\n        print(f\"Magic Square #{idx + 1}:\")\n        for row in square:\n            print(\" \".join(map(str, row)))\n        print()\n\nfind_magic_squares(3)"}, {"role": "assistant", "content": "Magic Square #1:\n2 7 6\n9 5 1\n4 3 8\n\nMagic Square #2:\n2 9 4\n7 5 3\n6 1 8\n\nMagic Square #3:\n4 3 8\n9 5 1\n2 7 6\n\nMagic Square #4:\n4 9 2\n3 5 7\n8 1 6\n\nMagic Square #5:\n6 1 8\n7 5 3\n2 9 4\n\nMagic Square #6:\n6 7 2\n1 5 9\n8 3 4\n\nMagic Square #7:\n8 1 6\n3 5 7\n4 9 2\n\nMagic Square #8:\n8 3 4\n1 5 9\n6 7 2\n\n"}]}
{"messages": [{"role": "user", "content": "def sort_by_score_and_name(players):\n    return sorted(players, key=lambda p: (-p[1], p[0]))\n\nplayers = [\n    (\"Alice\", 10),\n    (\"Bob\", 15),\n    (\"Charlie\", 10),\n    (\"David\", 20),\n    (\"Eve\", 20),\n    (\"Frank\", 15),\n    (\"Grace\", 10),\n    (\"Hannah\", 25),\n    (\"Isaac\", 25),\n    (\"Justin\", 20),\n    (\"Kevin\", 15),\n    (\"Laura\", 10)\n]\n\nsorted_players = sort_by_score_and_name(players)\nprint(\"Sorted players:\")\nfor player in sorted_players:\n    print(player)\n\ndef determine_top_scorers(players, top_n):\n    sorted_players = sort_by_score_and_name(players)\n    if top_n > len(sorted_players):\n        top_n = len(sorted_players)\n    top_scorers = sorted_players[:top_n]\n    return top_scorers\n\nprint(\"\\nTop 5 scorers:\")\ntop_scorers = determine_top_scorers(players, 5)\nfor scorer in top_scorers:\n    print(scorer)\n\ndef tournament_ranking(players):\n    rankings = {}\n    for idx, player in enumerate(sort_by_score_and_name(players)):\n        if player[1] not in rankings:\n            rankings[player[1]] = idx + 1\n        print(f\"Player: {player[0]}, Score: {player[1]}, Rank: {rankings[player[1]]}\")\n\nprint(\"\\nTournament Rankings:\")\ntournament_ranking(players)"}, {"role": "assistant", "content": "Sorted players:\n('Hannah', 25)\n('Isaac', 25)\n('David', 20)\n('Eve', 20)\n('Justin', 20)\n('Bob', 15)\n('Frank', 15)\n('Kevin', 15)\n('Alice', 10)\n('Charlie', 10)\n('Grace', 10)\n('Laura', 10)\n\nTop 5 scorers:\n('Hannah', 25)\n('Isaac', 25)\n('David', 20)\n('Eve', 20)\n('Justin', 20)\n\nTournament Rankings:\nPlayer: Hannah, Score: 25, Rank: 1\nPlayer: Isaac, Score: 25, Rank: 1\nPlayer: David, Score: 20, Rank: 3\nPlayer: Eve, Score: 20, Rank: 3\nPlayer: Justin, Score: 20, Rank: 3\nPlayer: Bob, Score: 15, Rank: 6\nPlayer: Frank, Score: 15, Rank: 6\nPlayer: Kevin, Score: 15, Rank: 6\nPlayer: Alice, Score: 10, Rank: 9\nPlayer: Charlie, Score: 10, Rank: 9\nPlayer: Grace, Score: 10, Rank: 9\nPlayer: Laura, Score: 10, Rank: 9\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef search_date_within_range(dates, target_date):\n    low, high = 0, len(dates) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        print(f\"Searching between indices {low} and {high}, mid: {mid}\")\n        if dates[mid] < target_date:\n            low = mid + 1\n        elif dates[mid] > target_date:\n            high = mid - 1\n        else:\n            print(f\"Exact match found at index {mid}\")\n            return mid\n    print(f\"No exact match found. Closest index: {low}\")\n    return low\n\nstart_date = datetime(2023, 1, 1)\ndate_range = [start_date + timedelta(days=i*10) for i in range(10)]\ntarget = start_date + timedelta(days=45)\n\nindex = search_date_within_range(date_range, target)\n\nprint(\"\\nDates in range:\")\nfor idx, date in enumerate(date_range):\n    marker = \"<-- Target\" if idx == index else \"\"\n    print(f\"{date.date()} {marker}\")"}, {"role": "assistant", "content": "Searching between indices 0 and 9, mid: 4\nSearching between indices 5 and 9, mid: 7\nSearching between indices 5 and 6, mid: 5\nNo exact match found. Closest index: 5\n\nDates in range:\n2023-01-01 \n2023-01-11 \n2023-01-21 \n2023-01-31 \n2023-02-10 \n2023-02-20 <-- Target\n2023-03-02 \n2023-03-12 \n2023-03-22 \n2023-04-01 \n"}]}
{"messages": [{"role": "user", "content": "from collections import deque\n\ndef search_maze(maze, start, end):\n    rows, cols = len(maze), len(maze[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque([start])\n    visited = set()\n    visited.add(start)\n\n    while queue:\n        path = queue.popleft()\n        x, y = path[-1]\n        print(f\"Visiting: {x, y}, Path so far: {path}\")\n\n        if (x, y) == end:\n            print(\"Found path:\", path)\n            return path\n\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < rows and 0 <= ny < cols and maze[nx][ny] == 0 and (nx, ny) not in visited:\n                new_path = path + [(nx, ny)]\n                queue.append(new_path)\n                visited.add((nx, ny))\n                print(f\"Added to queue: {nx, ny}\")\n\n    print(\"No path found\")\n    return []\n\nmaze = [\n    [0, 1, 0, 0, 0, 1],\n    [0, 1, 0, 1, 0, 1],\n    [0, 0, 0, 1, 0, 0],\n    [1, 1, 0, 0, 1, 0],\n    [0, 0, 1, 0, 0, 0],\n    [1, 0, 0, 0, 1, 0]\n]\n\nstart = (0, 0)\nend = (5, 5)\n\npath = search_maze(maze, [start], end)\nprint(\"Final Path:\", path)"}, {"role": "assistant", "content": "Traceback (most recent call last):\n  File \"<string>\", line 42, in <module>\n  File \"<string>\", line 8, in search_maze\nTypeError: unhashable type: 'list'\n"}]}
{"messages": [{"role": "user", "content": "def caesar_cipher(text, shift):\n    encrypted = ''\n    for char in text:\n        if char.isalpha():\n            shift_amount = shift % 26\n            char_code = ord(char) + shift_amount\n            if char.islower():\n                if char_code > ord('z'):\n                    char_code -= 26\n                encrypted += chr(char_code)\n            elif char.isupper():\n                if char_code > ord('Z'):\n                    char_code -= 26\n                encrypted += chr(char_code)\n        else:\n            encrypted += char\n    return encrypted\n\ndef search_encrypted_text(text, encrypted_word):\n    words = text.split()\n    for i, word in enumerate(words):\n        for shift in range(1, 26):\n            if caesar_cipher(word, shift) == encrypted_word:\n                return f\"Word '{encrypted_word}' found at position {i+1} with shift {shift}\"\n    return f\"Word '{encrypted_word}' not found\"\n\ntext = (\n    \"Hello world this is a sample text that includes some words\"\n    \" with various lengths that will be encrypted using a simple\"\n    \" Caesar cipher for demonstration purposes.\"\n)\n\nencrypted_word = \"vmhh\"\nresult = search_encrypted_text(text, encrypted_word)\nprint(result)"}, {"role": "assistant", "content": "Word 'vmhh' not found\n"}]}
{"messages": [{"role": "user", "content": "import string\n\ndef encrypt(text, shift):\n    encrypted = []\n    for char in text:\n        if char in string.ascii_lowercase:\n            new_index = (ord(char) - ord('a') + shift) % 26 + ord('a')\n            encrypted.append(chr(new_index))\n        elif char in string.ascii_uppercase:\n            new_index = (ord(char) - ord('A') + shift) % 26 + ord('A')\n            encrypted.append(chr(new_index))\n        else:\n            encrypted.append(char)\n    return ''.join(encrypted)\n\ndef decrypt(text, shift):\n    return encrypt(text, -shift)\n\ndef sort_by_encryption(texts, shift):\n    encrypted_texts = [(text, encrypt(text, shift)) for text in texts]\n    print(\"Encrypted Texts:\")\n    for text, enc in encrypted_texts:\n        print(f\"{text} -> {enc}\")\n    sorted_texts = sorted(encrypted_texts, key=lambda x: x[1])\n    print(\"\\nSorted Encrypted Texts:\")\n    for text, enc in sorted_texts:\n        print(f\"{enc} -> {text}\")\n    return sorted_texts\n\ntexts = [\n    \"hello world\",\n    \"encryption test\",\n    \"sorting algorithms\",\n    \"advanced python\",\n    \"debugging session\",\n    \"intermediate challenge\",\n    \"output generation\",\n    \"code execution\",\n    \"standard library\",\n    \"shift cipher\"\n]\n\nsorted_encrypted = sort_by_encryption(texts, 5)\n\nprint(\"\\nFinal Sorted Original Texts:\")\nfor enc, original in sorted_encrypted:\n    print(original)"}, {"role": "assistant", "content": "Encrypted Texts:\nhello world -> mjqqt btwqi\nencryption test -> jshwduynts yjxy\nsorting algorithms -> xtwynsl fqltwnymrx\nadvanced python -> fiafshji udymts\ndebugging session -> ijgzllnsl xjxxnts\nintermediate challenge -> nsyjwrjinfyj hmfqqjslj\noutput generation -> tzyuzy ljsjwfynts\ncode execution -> htij jcjhzynts\nstandard library -> xyfsifwi qngwfwd\nshift cipher -> xmnky hnumjw\n\nSorted Encrypted Texts:\nfiafshji udymts -> advanced python\nhtij jcjhzynts -> code execution\nijgzllnsl xjxxnts -> debugging session\njshwduynts yjxy -> encryption test\nmjqqt btwqi -> hello world\nnsyjwrjinfyj hmfqqjslj -> intermediate challenge\ntzyuzy ljsjwfynts -> output generation\nxmnky hnumjw -> shift cipher\nxtwynsl fqltwnymrx -> sorting algorithms\nxyfsifwi qngwfwd -> standard library\n\nFinal Sorted Original Texts:\nfiafshji udymts\nhtij jcjhzynts\nijgzllnsl xjxxnts\njshwduynts yjxy\nmjqqt btwqi\nnsyjwrjinfyj hmfqqjslj\ntzyuzy ljsjwfynts\nxmnky hnumjw\nxtwynsl fqltwnymrx\nxyfsifwi qngwfwd\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef calc_polygon_area(vertices):\n    n = len(vertices)\n    area = 0\n    for i in range(n):\n        j = (i + 1) % n\n        area += vertices[i][0] * vertices[j][1]\n        area -= vertices[j][0] * vertices[i][1]\n    return abs(area) / 2\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef sort_by_perimeter(polygons):\n    perimeters = []\n    for poly in polygons:\n        perim = 0\n        for i in range(len(poly)):\n            perim += distance(poly[i], poly[(i + 1) % len(poly)])\n        perimeters.append((perim, poly))\n    perimeters.sort(reverse=True)\n    return [p[1] for p in perimeters]\n\npolygons = [\n    [(0, 0), (4, 0), (4, 3), (0, 3)],\n    [(0, 0), (5, 0), (5, 5), (0, 5)],\n    [(0, 0), (2, 0), (2, 2), (0, 2)],\n    [(0, 0), (1, 0), (1, 1), (0, 1)],\n    [(0, 0), (3, 0), (3, 2), (0, 2)]\n]\n\nsorted_polygons = sort_by_perimeter(polygons)\n\nfor poly in sorted_polygons:\n    print(f\"Area: {calc_polygon_area(poly):.2f}, Perimeter: {sum(distance(poly[i], poly[(i + 1) % len(poly)]) for i in range(len(poly))):.2f}\")"}, {"role": "assistant", "content": "Area: 25.00, Perimeter: 20.00\nArea: 12.00, Perimeter: 14.00\nArea: 6.00, Perimeter: 10.00\nArea: 4.00, Perimeter: 8.00\nArea: 1.00, Perimeter: 4.00\n"}]}
{"messages": [{"role": "user", "content": "def generate_pattern(length):\n    pattern = \"\"\n    for i in range(1, length + 1):\n        if i % 2 == 0:\n            pattern += \"AB\"\n        else:\n            pattern += \"BA\"\n    return pattern\n\ndef search_sub_pattern(main_pattern, sub_pattern):\n    for i in range(len(main_pattern) - len(sub_pattern) + 1):\n        if main_pattern[i:i+len(sub_pattern)] == sub_pattern:\n            print(f\"Sub-pattern '{sub_pattern}' found at index {i}\")\n\npattern_length = 30\nsub_patterns = [\"ABAB\", \"BABA\", \"AABB\", \"BBAA\"]\npattern = generate_pattern(pattern_length)\n\nprint(f\"Generated Pattern: {pattern}\")\n\nfor sp in sub_patterns:\n    print(f\"Searching for '{sp}' in the pattern...\")\n    search_sub_pattern(pattern, sp)\n    print(\"-\" * 30)"}, {"role": "assistant", "content": "Generated Pattern: BAABBAABBAABBAABBAABBAABBAABBAABBAABBAABBAABBAABBAABBAABBAAB\nSearching for 'ABAB' in the pattern...\n------------------------------\nSearching for 'BABA' in the pattern...\n------------------------------\nSearching for 'AABB' in the pattern...\nSub-pattern 'AABB' found at index 1\nSub-pattern 'AABB' found at index 5\nSub-pattern 'AABB' found at index 9\nSub-pattern 'AABB' found at index 13\nSub-pattern 'AABB' found at index 17\nSub-pattern 'AABB' found at index 21\nSub-pattern 'AABB' found at index 25\nSub-pattern 'AABB' found at index 29\nSub-pattern 'AABB' found at index 33\nSub-pattern 'AABB' found at index 37\nSub-pattern 'AABB' found at index 41\nSub-pattern 'AABB' found at index 45\nSub-pattern 'AABB' found at index 49\nSub-pattern 'AABB' found at index 53\n------------------------------\nSearching for 'BBAA' in the pattern...\nSub-pattern 'BBAA' found at index 3\nSub-pattern 'BBAA' found at index 7\nSub-pattern 'BBAA' found at index 11\nSub-pattern 'BBAA' found at index 15\nSub-pattern 'BBAA' found at index 19\nSub-pattern 'BBAA' found at index 23\nSub-pattern 'BBAA' found at index 27\nSub-pattern 'BBAA' found at index 31\nSub-pattern 'BBAA' found at index 35\nSub-pattern 'BBAA' found at index 39\nSub-pattern 'BBAA' found at index 43\nSub-pattern 'BBAA' found at index 47\nSub-pattern 'BBAA' found at index 51\nSub-pattern 'BBAA' found at index 55\n------------------------------\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndates = [\n    \"2024-03-15 14:45:00\",\n    \"2022-07-19 08:30:00\",\n    \"2023-11-11 18:00:00\",\n    \"2021-01-01 00:00:00\",\n    \"2025-12-25 12:00:00\",\n    \"2023-05-14 09:15:00\",\n    \"2022-12-31 23:59:59\",\n    \"2021-05-10 10:10:10\",\n    \"2024-01-01 01:01:01\",\n    \"2023-03-03 03:03:03\"\n]\n\ndate_format = \"%Y-%m-%d %H:%M:%S\"\nparsed_dates = [datetime.strptime(date, date_format) for date in dates]\nsorted_dates = sorted(parsed_dates)\n\nfuture_date = datetime.now() + timedelta(days=1000)\nsorted_dates.append(future_date)\nsorted_dates = sorted(sorted_dates)\n\nfor date in sorted_dates:\n    print(date.strftime(date_format))"}, {"role": "assistant", "content": "2021-01-01 00:00:00\n2021-05-10 10:10:10\n2022-07-19 08:30:00\n2022-12-31 23:59:59\n2023-03-03 03:03:03\n2023-05-14 09:15:00\n2023-11-11 18:00:00\n2024-01-01 01:01:01\n2024-03-15 14:45:00\n2025-12-25 12:00:00\n2027-12-27 16:10:58\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef generate_spiral(n):\n    spiral = [[0]*n for _ in range(n)]\n    x, y = n//2, n//2\n    num = 1\n    for i in range(1, n, 2):\n        for _ in range(i):\n            spiral[y][x] = num\n            num += 1\n            x += 1\n        for _ in range(i):\n            spiral[y][x] = num\n            num += 1\n            y += 1\n        for _ in range(i+1):\n            spiral[y][x] = num\n            num += 1\n            x -= 1\n        for _ in range(i+1):\n            spiral[y][x] = num\n            num += 1\n            y -= 1\n        x += 1\n    if n % 2 == 1:\n        spiral[y][x] = num\n    return spiral\n\ndef create_pattern(spiral):\n    n = len(spiral)\n    pattern = [[' '] * (2*n-1) for _ in range(2*n-1)]\n    for i in range(n):\n        for j in range(n):\n            if spiral[i][j] % 2 == 0:\n                pattern[2*i][2*j] = '*'\n            else:\n                pattern[2*i][2*j] = '+'\n    return pattern\n\ndef search_pattern(pattern):\n    matches = []\n    m, n = len(pattern), len(pattern[0])\n    for i in range(m):\n        for j in range(n):\n            if pattern[i][j] == '+':\n                found = True\n                for dx, dy in [(-1,0), (1,0), (0,-1), (0,1)]:\n                    ni, nj = i + dx, j + dy\n                    if 0 <= ni < m and 0 <= nj < n and pattern[ni][nj] == '+':\n                        found = False\n                        break\n                if found:\n                    matches.append((i, j))\n    return matches\n\nn = 7\nspiral = generate_spiral(n)\npattern = create_pattern(spiral)\nmatches = search_pattern(pattern)\nfor match in matches:\n    print(match)"}, {"role": "assistant", "content": "Traceback (most recent call last):\n  File \"<string>\", line 57, in <module>\n  File \"<string>\", line 9, in generate_spiral\nIndexError: list assignment index out of range\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] < arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\n\ndef generate_pattern(n):\n    pattern = []\n    for i in range(n):\n        line = []\n        for j in range(n):\n            val = math.sin(i * j) * 100\n            line.append(round(val))\n        pattern.append(line)\n    return pattern\n\ndef display_pattern(pattern):\n    for line in pattern:\n        print(' '.join(str(x) for x in line))\n\nsize = 10\npattern = generate_pattern(size)\nprint(\"Generated Pattern:\")\ndisplay_pattern(pattern)\n\nsorted_pattern = []\nfor line in pattern:\n    sorted_line = bubble_sort(line)\n    sorted_pattern.append(sorted_line)\n\nprint(\"\\nSorted Pattern in Ascending Order:\")\ndisplay_pattern(sorted_pattern)"}, {"role": "assistant", "content": "Generated Pattern:\n0 0 0 0 0 0 0 0 0 0\n0 84 91 14 -76 -96 -28 66 99 41\n0 91 -76 -28 99 -54 -54 99 -29 -75\n0 14 -28 41 -54 65 -75 84 -91 96\n0 -76 99 -54 -29 91 -91 27 55 -99\n0 -96 -54 65 91 -13 -99 -43 75 85\n0 -28 -54 -75 -91 -99 -99 -92 -77 -56\n0 66 99 84 27 -43 -92 -95 -52 17\n0 99 -29 -91 55 75 -77 -52 92 25\n0 41 -75 96 -99 85 -56 17 25 -63\n\nSorted Pattern in Ascending Order:\n0 0 0 0 0 0 0 0 0 0\n99 91 84 66 41 14 0 -28 -76 -96\n99 99 91 0 -28 -29 -54 -54 -75 -76\n96 84 65 41 14 0 -28 -54 -75 -91\n99 91 55 27 0 -29 -54 -76 -91 -99\n91 85 75 65 0 -13 -43 -54 -96 -99\n0 -28 -54 -56 -75 -77 -91 -92 -99 -99\n99 84 66 27 17 0 -43 -52 -92 -95\n99 92 75 55 25 0 -29 -52 -77 -91\n96 85 41 25 17 0 -56 -63 -75 -99\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef calculate_triangle_area(vertices):\n    x1, y1, x2, y2, x3, y3 = vertices\n    return abs(x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2)) / 2\n\ndef find_largest_triangle(points):\n    max_area = 0\n    largest_triangle = None\n    n = len(points)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                area = calculate_triangle_area(points[i] + points[j] + points[k])\n                if area > max_area:\n                    max_area = area\n                    largest_triangle = (points[i], points[j], points[k])\n    \n    return largest_triangle\n\npoints = [\n    (0, 0), (1, 0), (0, 1), (1, 1), (2, 0),\n    (0, 2), (2, 2), (3, 0), (0, 3), (3, 3)\n]\n\nlargest_triangle = find_largest_triangle(points)\n\nfor point in largest_triangle:\n    print(f\"Point: {point}\")"}, {"role": "assistant", "content": "Point: (0, 0)\nPoint: (3, 0)\nPoint: (0, 3)\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef find_median_by_searching(data):\n    if not data:\n        return None\n    low, high = 0, len(data) - 1\n    median_index = len(data) // 2\n\n    while True:\n        pivot_index = partition(data, low, high)\n        if pivot_index == median_index:\n            return data[median_index]\n        elif pivot_index < median_index:\n            low = pivot_index + 1\n        else:\n            high = pivot_index - 1\n\ndef partition(arr, low, high):\n    pivot = arr[high]\n    i = low - 1\n    for j in range(low, high):\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1\n\ndata = [\n    [5, 1, 9, 3, 7, 8, 2, 4, 6, 0],\n    [21, 13, 19, 17, 15, 23, 11, 25, 29, 27],\n    [100, 98, 95, 92, 88, 85, 82, 79, 76, 73],\n    [33, 28, 34, 29, 35, 30, 36, 31, 37, 32],\n    [43, 41, 47, 45, 49, 44, 40, 42, 46, 48]\n]\n\noutput = []\nfor dataset in data:\n    sorted_data = sorted(dataset)\n    median_sorted = statistics.median(sorted_data)\n    median_searched = find_median_by_searching(dataset[:])\n    output.append((median_sorted, median_searched))\n\nfor result in output:\n    print(result)"}, {"role": "assistant", "content": "(4.5, 5)\n(20.0, 21)\n(86.5, 88)\n(32.5, 33)\n(44.5, 45)\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef find_next_full_moon(start_date):\n    full_moon_cycle = timedelta(days=29, hours=12, minutes=44)\n    known_full_moon = datetime(2023, 10, 28, 20, 24)  # Recent full moon date\n    target_date = datetime.strptime(start_date, '%Y-%m-%d')\n    \n    current_moon_date = known_full_moon\n    while current_moon_date <= target_date:\n        current_moon_date += full_moon_cycle\n    \n    return current_moon_date\n\ndef main():\n    start_dates = [\n        '2023-11-01', '2024-01-15', '2024-04-10', '2024-07-25',\n        '2024-10-12', '2025-02-02', '2025-05-20', '2025-09-05',\n        '2025-12-21', '2026-03-08', '2026-06-24', '2026-09-09'\n    ]\n    \n    for start_date in start_dates:\n        next_full_moon = find_next_full_moon(start_date)\n        print(f\"Next full moon after {start_date}: {next_full_moon.strftime('%Y-%m-%d %H:%M')}\")\n\nmain()"}, {"role": "assistant", "content": "Next full moon after 2023-11-01: 2023-11-27 09:08\nNext full moon after 2024-01-15: 2024-01-25 10:36\nNext full moon after 2024-04-10: 2024-04-23 00:48\nNext full moon after 2024-07-25: 2024-08-19 03:44\nNext full moon after 2024-10-12: 2024-10-17 05:12\nNext full moon after 2025-02-02: 2025-02-12 08:08\nNext full moon after 2025-05-20: 2025-06-10 11:04\nNext full moon after 2025-09-05: 2025-09-07 01:16\nNext full moon after 2025-12-21: 2026-01-03 04:12\nNext full moon after 2026-03-08: 2026-04-01 18:24\nNext full moon after 2026-06-24: 2026-06-29 08:36\nNext full moon after 2026-09-09: 2026-09-25 22:48\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef transform_string(s):\n    return ''.join(chr(((ord(char) - 65 + 13) % 26) + 65) if 'A' <= char <= 'Z' else char for char in s)\n\ndef search_and_transform(data, pattern):\n    transformed_data = [transform_string(item) for item in data]\n    filtered_data = [item for item in transformed_data if re.search(pattern, item)]\n    return filtered_data\n\ndata = [\n    \"HELLO\", \"WORLD\", \"PYTHON\", \"SEARCH\", \"TRANSFORM\", \n    \"ALGORITHM\", \"INTERMEDIATE\", \"CHALLENGE\", \"EXAMPLE\", \"TEST\", \n    \"STRING\", \"ROTATION\", \"ENCODE\", \"DECODE\", \"PATTERN\", \n    \"MATCH\", \"RESULT\", \"OUTPUT\", \"COMPUTE\", \"EXECUTE\"\n]\n\npattern = r'^[A-Z]{5}$'\nresults = search_and_transform(data, pattern)\n\nfor result in results:\n    print(result)"}, {"role": "assistant", "content": "URYYB\nJBEYQ\nZNGPU\n"}]}
{"messages": [{"role": "user", "content": "from math import gcd\n\ndef lcm(a, b):\n    return abs(a * b) // gcd(a, b)\n\ndef generate_fibonacci_lcm_sequence(n):\n    sequence = [0, 1]\n    for _ in range(2, n):\n        sequence.append(sequence[-1] + sequence[-2])\n    return sequence\n\ndef sort_by_lcm_with_fib(sequence, fib_sequence):\n    return sorted(sequence, key=lambda x: [lcm(x, fib) for fib in fib_sequence])\n\nfibonacci_sequence = generate_fibonacci_lcm_sequence(15)\nnumbers = [13, 8, 21, 34, 5, 89, 55, 3, 144, 233, 377, 610, 987, 1597, 2584]\n\nsorted_numbers = sort_by_lcm_with_fib(numbers, fibonacci_sequence)\n\nfor number in sorted_numbers:\n    print(number)"}, {"role": "assistant", "content": "3\n5\n8\n13\n21\n34\n55\n89\n144\n233\n377\n610\n987\n1597\n2584\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef calculate_statistics(data):\n    n = len(data)\n    mean = sum(data) / n\n    data_sorted = sorted(data)\n    median = data_sorted[n // 2] if n % 2 != 0 else (data_sorted[n // 2 - 1] + data_sorted[n // 2]) / 2\n    variance = sum((x - mean) ** 2 for x in data) / n\n    std_dev = math.sqrt(variance)\n    return mean, median, std_dev\n\ndef print_statistics(data):\n    mean, median, std_dev = calculate_statistics(data)\n    print(f\"Mean: {mean:.2f}\")\n    print(f\"Median: {median:.2f}\")\n    print(f\"Standard Deviation: {std_dev:.2f}\")\n\ndef sort_by_standard_deviation(data_sets):\n    return sorted(data_sets, key=lambda x: calculate_statistics(x)[2])\n\ndata_sets = [\n    [12, 15, 23, 42, 55, 67, 89, 90, 95, 100],\n    [10, 20, 30, 40, 50, 60, 70, 80, 90, 100],\n    [15, 25, 35, 45, 55, 65, 75, 85, 95, 105],\n    [3, 8, 15, 24, 35, 48, 63, 80, 99, 120],\n    [5, 10, 15, 20, 25, 30, 35, 40, 45, 50],\n    [7, 14, 21, 28, 35, 42, 49, 56, 63, 70],\n    [6, 12, 18, 24, 30, 36, 42, 48, 54, 60],\n    [11, 22, 33, 44, 55, 66, 77, 88, 99, 110],\n    [9, 18, 27, 36, 45, 54, 63, 72, 81, 90],\n    [8, 16, 24, 32, 40, 48, 56, 64, 72, 80]\n]\n\nsorted_data_sets = sort_by_standard_deviation(data_sets)\n\nfor i, data in enumerate(sorted_data_sets, start=1):\n    print(f\"Dataset {i}:\")\n    print_statistics(data)\n    print(\"=\" * 20)"}, {"role": "assistant", "content": "Dataset 1:\nMean: 27.50\nMedian: 27.50\nStandard Deviation: 14.36\n====================\nDataset 2:\nMean: 33.00\nMedian: 33.00\nStandard Deviation: 17.23\n====================\nDataset 3:\nMean: 38.50\nMedian: 38.50\nStandard Deviation: 20.11\n====================\nDataset 4:\nMean: 44.00\nMedian: 44.00\nStandard Deviation: 22.98\n====================\nDataset 5:\nMean: 49.50\nMedian: 49.50\nStandard Deviation: 25.85\n====================\nDataset 6:\nMean: 55.00\nMedian: 55.00\nStandard Deviation: 28.72\n====================\nDataset 7:\nMean: 60.00\nMedian: 60.00\nStandard Deviation: 28.72\n====================\nDataset 8:\nMean: 60.50\nMedian: 60.50\nStandard Deviation: 31.60\n====================\nDataset 9:\nMean: 58.80\nMedian: 61.00\nStandard Deviation: 32.63\n====================\nDataset 10:\nMean: 49.50\nMedian: 41.50\nStandard Deviation: 38.04\n====================\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\ndata = [\n    \"2023-10-02 09:15:00\",\n    \"2023-10-01 12:30:00\",\n    \"2023-10-02 08:45:00\",\n    \"2023-10-01 09:00:00\",\n    \"2023-10-02 11:00:00\",\n    \"2023-10-01 10:15:00\",\n    \"2023-10-02 10:30:00\",\n    \"2023-10-01 11:45:00\"\n]\n\nconverted_data = [datetime.strptime(d, \"%Y-%m-%d %H:%M:%S\") for d in data]\nprint(\"Converted datetime objects:\")\nfor dt in converted_data:\n    print(dt)\n\nsorted_data = sorted(converted_data)\nprint(\"\\nSorted datetime objects:\")\nfor dt in sorted_data:\n    print(dt)\n\ngrouped_by_date = {}\nfor dt in sorted_data:\n    date_str = dt.strftime(\"%Y-%m-%d\")\n    if date_str not in grouped_by_date:\n        grouped_by_date[date_str] = []\n    grouped_by_date[date_str].append(dt.strftime(\"%H:%M:%S\"))\n\nprint(\"\\nGrouped by date:\")\nfor date in grouped_by_date:\n    print(f\"{date}: {grouped_by_date[date]}\")"}, {"role": "assistant", "content": "Converted datetime objects:\n2023-10-02 09:15:00\n2023-10-01 12:30:00\n2023-10-02 08:45:00\n2023-10-01 09:00:00\n2023-10-02 11:00:00\n2023-10-01 10:15:00\n2023-10-02 10:30:00\n2023-10-01 11:45:00\n\nSorted datetime objects:\n2023-10-01 09:00:00\n2023-10-01 10:15:00\n2023-10-01 11:45:00\n2023-10-01 12:30:00\n2023-10-02 08:45:00\n2023-10-02 09:15:00\n2023-10-02 10:30:00\n2023-10-02 11:00:00\n\nGrouped by date:\n2023-10-01: ['09:00:00', '10:15:00', '11:45:00', '12:30:00']\n2023-10-02: ['08:45:00', '09:15:00', '10:30:00', '11:00:00']\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef is_perfect_square(n):\n    return math.isqrt(n) ** 2 == n\n\ndef fibonacci_sequence(n):\n    fibs = [0, 1]\n    while len(fibs) < n:\n        fibs.append(fibs[-1] + fibs[-2])\n    return fibs\n\ndef search_odd_even_fib(fibs):\n    for f in fibs:\n        if f % 2 == 0:\n            print(f\"Even Fibonacci: {f}\")\n        else:\n            print(f\"Odd Fibonacci: {f}\")\n\ndef find_fib_perfect_squares(fibs):\n    perfect_squares = []\n    for f in fibs:\n        if is_perfect_square(f):\n            perfect_squares.append(f)\n    return perfect_squares\n\ndef search_perfect_square_fibs(fib_count):\n    fibs = fibonacci_sequence(fib_count)\n    print(f\"Fibonacci Sequence: {fibs}\")\n    square_fibs = find_fib_perfect_squares(fibs)\n    print(f\"Perfect Square Fibonacci Numbers: {square_fibs}\")\n\nfib_count = 50\nsearch_perfect_square_fibs(fib_count)"}, {"role": "assistant", "content": "Fibonacci Sequence: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073, 4807526976, 7778742049]\nPerfect Square Fibonacci Numbers: [0, 1, 1, 144]\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef sort_dates_by_month_and_day(dates):\n    def month_day_key(date):\n        return (date.month, date.day)\n    return sorted(dates, key=month_day_key)\n\ndates = [\n    \"2022-02-15\", \"2021-03-10\", \"2023-01-25\", \"2022-05-20\", \"2021-07-07\",\n    \"2023-04-18\", \"2022-06-30\", \"2021-09-12\", \"2023-08-01\", \"2022-12-31\"\n]\n\nparsed_dates = [datetime.datetime.strptime(date, \"%Y-%m-%d\") for date in dates]\nprint(\"Parsed Dates:\")\nfor date in parsed_dates:\n    print(date.strftime(\"%Y-%m-%d\"))\n\nsorted_dates = sort_dates_by_month_and_day(parsed_dates)\nprint(\"\\nSorted by Month and Day:\")\nfor date in sorted_dates:\n    print(date.strftime(\"%Y-%m-%d\"))"}, {"role": "assistant", "content": "Parsed Dates:\n2022-02-15\n2021-03-10\n2023-01-25\n2022-05-20\n2021-07-07\n2023-04-18\n2022-06-30\n2021-09-12\n2023-08-01\n2022-12-31\n\nSorted by Month and Day:\n2023-01-25\n2022-02-15\n2021-03-10\n2023-04-18\n2022-05-20\n2022-06-30\n2021-07-07\n2023-08-01\n2021-09-12\n2022-12-31\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"\nThe quick brown fox jumps over the lazy dog. The dog barked at the mailman.\nThe mailman quickly walked away, leaving the dog still barking.\nWhy does the dog bark so much? Perhaps it sees the fox again.\n\"\"\"\n\npattern = r'\\b\\w{5}\\b'\n\nmatches = re.findall(pattern, text)\n\nsearch_word = 'dog'\n\ndef binary_search(arr, x):\n    low = 0\n    high = len(arr) - 1\n    while low <= high:\n        mid = (high + low) // 2\n        if arr[mid] < x:\n            low = mid + 1\n        elif arr[mid] > x:\n            high = mid - 1\n        else:\n            return mid\n    return -1\n\nsorted_matches = sorted(set(matches))\n\nindex = binary_search(sorted_matches, search_word)\n\nif index != -1:\n    print(f\"Word '{search_word}' found at index {index}.\")\nelse:\n    print(f\"Word '{search_word}' not found.\")\n\nprint(\"Sorted words of length 5 found in text:\")\nfor word in sorted_matches:\n    print(word)"}, {"role": "assistant", "content": "Word 'dog' not found.\nSorted words of length 5 found in text:\nagain\nbrown\njumps\nquick\nstill\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef search_temperatures(temperatures, date_range):\n    def binary_search_date_range(data, start_date, end_date):\n        start, end = 0, len(data) - 1\n        while start <= end:\n            mid = (start + end) // 2\n            mid_date = data[mid][0]\n            if start_date <= mid_date <= end_date:\n                return mid\n            elif mid_date < start_date:\n                start = mid + 1\n            else:\n                end = mid - 1\n        return -1\n    \n    start_date, end_date = date_range\n    index = binary_search_date_range(temperatures, start_date, end_date)\n    if index == -1:\n        return []\n\n    result = []\n    for i in range(index, len(temperatures)):\n        if start_date <= temperatures[i][0] <= end_date:\n            result.append(temperatures[i])\n        else:\n            break\n    return result\n\ndates = [datetime.date(2023, 1, i) for i in range(1, 101)]\ntemperatures = [(date, (date.day * 2) % 30 + 15) for date in dates]\ndate_range = (datetime.date(2023, 1, 20), datetime.date(2023, 1, 30))\n\nresult = search_temperatures(temperatures, date_range)\nfor date, temp in result:\n    print(f\"{date}: {temp}C\")"}, {"role": "assistant", "content": "Traceback (most recent call last):\n  File \"<string>\", line 30, in <module>\n  File \"<string>\", line 30, in <listcomp>\nValueError: day is out of range for month\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef perimeter_of_polygon(vertices):\n    perimeter = 0\n    num_vertices = len(vertices)\n    for i in range(num_vertices):\n        x1, y1 = vertices[i]\n        x2, y2 = vertices[(i + 1) % num_vertices]\n        distance = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n        perimeter += distance\n    return perimeter\n\ndef search_polygon_by_perimeter(target_perimeter, polygons):\n    left, right = 0, len(polygons) - 1\n    best_match = None\n    while left <= right:\n        mid = (left + right) // 2\n        current_perimeter = perimeter_of_polygon(polygons[mid])\n        print(f\"Checking polygon at index {mid} with perimeter {current_perimeter:.2f}\")\n        if math.isclose(current_perimeter, target_perimeter, rel_tol=1e-5):\n            return polygons[mid]\n        elif current_perimeter < target_perimeter:\n            best_match = polygons[mid]\n            left = mid + 1\n        else:\n            right = mid - 1\n    return best_match\n\npolygons = [\n    [(0, 0), (4, 0), (4, 3), (0, 3)],\n    [(0, 0), (3, 0), (3, 4), (0, 4)],\n    [(0, 0), (5, 0), (5, 5), (0, 5)],\n    [(0, 0), (2, 0), (2, 2), (0, 2)],\n    [(0, 0), (6, 0), (6, 8), (0, 8)],\n    [(0, 0), (7, 0), (7, 7), (0, 7)],\n]\n\ntarget_perimeter = 20\nresult_polygon = search_polygon_by_perimeter(target_perimeter, polygons)\n\nif result_polygon:\n    print(\"Polygon with closest perimeter:\", result_polygon)\nelse:\n    print(\"No suitable polygon found.\")"}, {"role": "assistant", "content": "Checking polygon at index 2 with perimeter 20.00\nPolygon with closest perimeter: [(0, 0), (5, 0), (5, 5), (0, 5)]\n"}]}
{"messages": [{"role": "user", "content": "import math\nfrom datetime import datetime\n\nclass Player:\n    def __init__(self, name, score):\n        self.name = name\n        self.score = score\n\ndef rank_players(players):\n    return sorted(players, key=lambda p: (-p.score, p.name))\n\ndef simulate_game():\n    players = [\n        Player(\"Alice\", 45),\n        Player(\"Bob\", 82),\n        Player(\"Charlie\", 77),\n        Player(\"Diana\", 82),\n        Player(\"Eve\", 45),\n        Player(\"Frank\", 55),\n        Player(\"Grace\", 55)\n    ]\n    sorted_players = rank_players(players)\n    return sorted_players\n\ndef display_leaderboard(players):\n    print(\"Leaderboard as of\", datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"))\n    for i, player in enumerate(players, start=1):\n        print(f\"{i}. {player.name} - {player.score}\")\n\ndef main():\n    players = simulate_game()\n    display_leaderboard(players)\n\nmain()"}, {"role": "assistant", "content": "Leaderboard as of 2025-04-01 16:11:05\n1. Bob - 82\n2. Diana - 82\n3. Charlie - 77\n4. Frank - 55\n5. Grace - 55\n6. Alice - 45\n7. Eve - 45\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef sort_birthdays(birthdays):\n    return sorted(birthdays, key=lambda date: datetime.strptime(date, '%Y-%m-%d'))\n\ndef generate_dates():\n    base_date = datetime(2020, 1, 1)\n    return [(base_date + timedelta(days=i*33)).strftime('%Y-%m-%d') for i in range(10)]\n\ndef interleave_dates(dates1, dates2):\n    combined = dates1 + dates2\n    return sorted(combined, key=lambda date: datetime.strptime(date, '%Y-%m-%d'))\n\nbirthdays = [\n    \"1990-06-15\", \"1985-02-20\", \"2000-11-30\",\n    \"1995-12-05\", \"1982-08-25\", \"1991-03-01\"\n]\n\nfuture_dates = generate_dates()\n\nsorted_birthdays = sort_birthdays(birthdays)\nsorted_future_dates = sort_birthdays(future_dates)\n\nfinal_sorted_dates = interleave_dates(sorted_birthdays, sorted_future_dates)\n\nfor date in final_sorted_dates:\n    print(date)"}, {"role": "assistant", "content": "1982-08-25\n1985-02-20\n1990-06-15\n1991-03-01\n1995-12-05\n2000-11-30\n2020-01-01\n2020-02-03\n2020-03-07\n2020-04-09\n2020-05-12\n2020-06-14\n2020-07-17\n2020-08-19\n2020-09-21\n2020-10-24\n"}]}
{"messages": [{"role": "user", "content": "import re\nfrom collections import defaultdict\n\ntext = \"\"\"\nIn the world of programming, sorting algorithms are essential. They help to arrange data in a\nspecific order, making it easier to analyze and understand. The quicksort is one such algorithm,\nknown for its efficiency. It is a divide-and-conquer algorithm, which means it breaks down a problem\ninto smaller sub-problems, solves each sub-problem recursively, and then combines the solutions.\nHowever, it's not the only algorithm out there. Merge sort, bubble sort, and insertion sort each have\ntheir unique characteristics and use cases. While quicksort is generally faster, merge sort can be\nmore predictable, and bubble sort is simple to implement. Understanding these algorithms is crucial\nfor any developer.\n\"\"\"\n\nwords = re.findall(r'\\b\\w+\\b', text.lower())\nword_freq = defaultdict(int)\n\nfor word in words:\n    word_freq[word] += 1\n\nitems = list(word_freq.items())\n\ndef merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort(left_half)\n        merge_sort(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i][1] > right_half[j][1]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n\nmerge_sort(items)\n\nfor word, freq in items:\n    print(f\"{word}: {freq}\")\n\nprint(\"\\nWords with frequency > 1:\")\nfor word, freq in items:\n    if freq > 1:\n        print(f\"{word}: {freq}\")"}, {"role": "assistant", "content": "and: 6\nsort: 5\nis: 5\nit: 4\nthe: 4\nalgorithm: 3\na: 3\nto: 3\nbubble: 2\nmerge: 2\neach: 2\nsub: 2\nproblem: 2\nfor: 2\nquicksort: 2\nalgorithms: 2\nin: 2\ndeveloper: 1\nany: 1\ncrucial: 1\nthese: 1\nunderstanding: 1\nimplement: 1\nsimple: 1\npredictable: 1\nmore: 1\nbe: 1\ncan: 1\nfaster: 1\ngenerally: 1\nwhile: 1\ncases: 1\nuse: 1\ncharacteristics: 1\nunique: 1\ntheir: 1\nhave: 1\ninsertion: 1\nthere: 1\nout: 1\nonly: 1\nnot: 1\ns: 1\nhowever: 1\nsolutions: 1\ncombines: 1\nthen: 1\nrecursively: 1\nsolves: 1\nproblems: 1\nsmaller: 1\ninto: 1\ndown: 1\nbreaks: 1\nmeans: 1\nwhich: 1\nconquer: 1\ndivide: 1\nefficiency: 1\nits: 1\nknown: 1\nsuch: 1\none: 1\nunderstand: 1\nanalyze: 1\neasier: 1\nmaking: 1\norder: 1\nspecific: 1\ndata: 1\narrange: 1\nhelp: 1\nthey: 1\nessential: 1\nare: 1\nsorting: 1\nprogramming: 1\nof: 1\nworld: 1\n\nWords with frequency > 1:\nand: 6\nsort: 5\nis: 5\nit: 4\nthe: 4\nalgorithm: 3\na: 3\nto: 3\nbubble: 2\nmerge: 2\neach: 2\nsub: 2\nproblem: 2\nfor: 2\nquicksort: 2\nalgorithms: 2\nin: 2\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef find_mismatched_pattern(pattern, text):\n    matches = re.findall(pattern, text)\n    non_matching = []\n    for i in range(len(text)):\n        if all(text[i:i+len(m)] != m for m in matches):\n            non_matching.append(text[i])\n    return non_matching\n\ntext = \"abbabbaababaabbab\"\npattern = r\"ab+\"\n\nnon_matching = find_mismatched_pattern(pattern, text)\n\nfor index, char in enumerate(non_matching):\n    print(f\"Character at index {index}: {char}\")"}, {"role": "assistant", "content": "Character at index 0: b\nCharacter at index 1: b\nCharacter at index 2: b\nCharacter at index 3: b\nCharacter at index 4: a\nCharacter at index 5: b\nCharacter at index 6: b\nCharacter at index 7: a\nCharacter at index 8: b\nCharacter at index 9: b\nCharacter at index 10: b\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndata = [\n    4, 8, 15, 16, 23, 42, 4, 8, 15, 16, 23, 42, 4, 8, 15, 16, 23, 42, 4, 8, 15, \n    16, 23, 42, 4, 8, 15, 16, 23, 42, 4, 8, 15, 16, 23, 42, 4, 8, 15, 16, 23, 42\n]\n\nmean_value = statistics.mean(data)\nmedian_value = statistics.median(data)\n\nprint(f\"Mean: {mean_value}\")\nprint(f\"Median: {median_value}\")\n\ndef binary_search(sorted_data, target):\n    left, right = 0, len(sorted_data) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        print(f\"Searching at index {mid}, value: {sorted_data[mid]}\")\n        if sorted_data[mid] == target:\n            return mid\n        elif sorted_data[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\nsorted_data = sorted(data)\nprint(f\"Sorted Data: {sorted_data}\")\n\nmean_index = binary_search(sorted_data, mean_value)\nmedian_index = binary_search(sorted_data, median_value)\n\nprint(f\"Mean value {mean_value} found at index: {mean_index}\")\nprint(f\"Median value {median_value} found at index: {median_index}\")"}, {"role": "assistant", "content": "Mean: 18\nMedian: 15.5\nSorted Data: [4, 4, 4, 4, 4, 4, 4, 8, 8, 8, 8, 8, 8, 8, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 23, 23, 23, 23, 23, 23, 23, 42, 42, 42, 42, 42, 42, 42]\nSearching at index 20, value: 15\nSearching at index 31, value: 23\nSearching at index 25, value: 16\nSearching at index 28, value: 23\nSearching at index 26, value: 16\nSearching at index 27, value: 16\nSearching at index 20, value: 15\nSearching at index 31, value: 23\nSearching at index 25, value: 16\nSearching at index 22, value: 16\nSearching at index 21, value: 16\nMean value 18 found at index: -1\nMedian value 15.5 found at index: -1\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef find_friday_13ths(start_year, end_year):\n    friday_13ths = []\n    for year in range(start_year, end_year + 1):\n        for month in range(1, 13):\n            date = datetime(year, month, 13)\n            if date.weekday() == 4:\n                friday_13ths.append(date)\n    return friday_13ths\n\ndef binary_search_friday_13ths(dates, target_date):\n    low, high = 0, len(dates) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if dates[mid] == target_date:\n            return mid\n        elif dates[mid] < target_date:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n\nstart_year = 1900\nend_year = 2000\nfriday_13ths = find_friday_13ths(start_year, end_year)\n\ntarget_date = datetime(1993, 8, 13)\nindex = binary_search_friday_13ths(friday_13ths, target_date)\n\nfor date in friday_13ths:\n    print(date.strftime('%Y-%m-%d'))\n\nprint(\"\\nTarget Date:\", target_date.strftime('%Y-%m-%d'))\nprint(\"Index of Target Date:\", index)"}, {"role": "assistant", "content": "1900-04-13\n1900-07-13\n1901-09-13\n1901-12-13\n1902-06-13\n1903-02-13\n1903-03-13\n1903-11-13\n1904-05-13\n1905-01-13\n1905-10-13\n1906-04-13\n1906-07-13\n1907-09-13\n1907-12-13\n1908-03-13\n1908-11-13\n1909-08-13\n1910-05-13\n1911-01-13\n1911-10-13\n1912-09-13\n1912-12-13\n1913-06-13\n1914-02-13\n1914-03-13\n1914-11-13\n1915-08-13\n1916-10-13\n1917-04-13\n1917-07-13\n1918-09-13\n1918-12-13\n1919-06-13\n1920-02-13\n1920-08-13\n1921-05-13\n1922-01-13\n1922-10-13\n1923-04-13\n1923-07-13\n1924-06-13\n1925-02-13\n1925-03-13\n1925-11-13\n1926-08-13\n1927-05-13\n1928-01-13\n1928-04-13\n1928-07-13\n1929-09-13\n1929-12-13\n1930-06-13\n1931-02-13\n1931-03-13\n1931-11-13\n1932-05-13\n1933-01-13\n1933-10-13\n1934-04-13\n1934-07-13\n1935-09-13\n1935-12-13\n1936-03-13\n1936-11-13\n1937-08-13\n1938-05-13\n1939-01-13\n1939-10-13\n1940-09-13\n1940-12-13\n1941-06-13\n1942-02-13\n1942-03-13\n1942-11-13\n1943-08-13\n1944-10-13\n1945-04-13\n1945-07-13\n1946-09-13\n1946-12-13\n1947-06-13\n1948-02-13\n1948-08-13\n1949-05-13\n1950-01-13\n1950-10-13\n1951-04-13\n1951-07-13\n1952-06-13\n1953-02-13\n1953-03-13\n1953-11-13\n1954-08-13\n1955-05-13\n1956-01-13\n1956-04-13\n1956-07-13\n1957-09-13\n1957-12-13\n1958-06-13\n1959-02-13\n1959-03-13\n1959-11-13\n1960-05-13\n1961-01-13\n1961-10-13\n1962-04-13\n1962-07-13\n1963-09-13\n1963-12-13\n1964-03-13\n1964-11-13\n1965-08-13\n1966-05-13\n1967-01-13\n1967-10-13\n1968-09-13\n1968-12-13\n1969-06-13\n1970-02-13\n1970-03-13\n1970-11-13\n1971-08-13\n1972-10-13\n1973-04-13\n1973-07-13\n1974-09-13\n1974-12-13\n1975-06-13\n1976-02-13\n1976-08-13\n1977-05-13\n1978-01-13\n1978-10-13\n1979-04-13\n1979-07-13\n1980-06-13\n1981-02-13\n1981-03-13\n1981-11-13\n1982-08-13\n1983-05-13\n1984-01-13\n1984-04-13\n1984-07-13\n1985-09-13\n1985-12-13\n1986-06-13\n1987-02-13\n1987-03-13\n1987-11-13\n1988-05-13\n1989-01-13\n1989-10-13\n1990-04-13\n1990-07-13\n1991-09-13\n1991-12-13\n1992-03-13\n1992-11-13\n1993-08-13\n1994-05-13\n1995-01-13\n1995-10-13\n1996-09-13\n1996-12-13\n1997-06-13\n1998-02-13\n1998-03-13\n1998-11-13\n1999-08-13\n2000-10-13\n\nTarget Date: 1993-08-13\nIndex of Target Date: 161\n"}]}
{"messages": [{"role": "user", "content": "def is_valid_move(board, x, y):\n    return 0 <= x < len(board) and 0 <= y < len(board[0]) and board[x][y] == 0\n\ndef solve_knight_tour(board, n, x, y, move_x, move_y, pos):\n    if pos == n * n:\n        return True\n    \n    for i in range(8):\n        next_x, next_y = x + move_x[i], y + move_y[i]\n        if is_valid_move(board, next_x, next_y):\n            board[next_x][next_y] = pos\n            if solve_knight_tour(board, n, next_x, next_y, move_x, move_y, pos + 1):\n                return True\n            board[next_x][next_y] = 0\n    return False\n\ndef knight_tour(n):\n    board = [[0 for _ in range(n)] for _ in range(n)]\n    move_x = [2, 1, -1, -2, -2, -1, 1, 2]\n    move_y = [1, 2, 2, 1, -1, -2, -2, -1]\n    board[0][0] = 1\n    if not solve_knight_tour(board, n, 0, 0, move_x, move_y, 2):\n        return []\n    return board\n\nn = 5\nsolution = knight_tour(n)\nfor row in solution:\n    print(' '.join(f'{cell:2}' for cell in row))"}, {"role": "assistant", "content": " 1  6 11 22 19\n10 23 20  5 12\n15  2  7 18 21\n24  9 16 13  4\n 0 14  3  8 17\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\ndef custom_sort_key(word):\n    return sum(ord(c) for c in word)\n\ndef encode_words(words):\n    encoded = []\n    for word in words:\n        time_now = datetime.now()\n        hour_sum = time_now.hour + time_now.minute + time_now.second\n        encoded_word = ''.join(chr((ord(c) + hour_sum) % 256) for c in word)\n        encoded.append(encoded_word)\n    return encoded\n\ndef main():\n    words = [\n        \"encryption\", \"algorithm\", \"security\", \"python\", \"sorting\", \n        \"challenge\", \"example\", \"intermediate\", \"beginner\", \"code\"\n    ]\n    \n    print(\"Original words:\")\n    for word in words:\n        print(word)\n    \n    encoded_words = encode_words(words)\n    \n    print(\"\\nEncoded words:\")\n    for word in encoded_words:\n        print(word)\n    \n    sorted_encoded_words = sorted(encoded_words, key=custom_sort_key)\n    \n    print(\"\\nSorted encoded words:\")\n    for word in sorted_encoded_words:\n        print(word)\n\nif __name__ == \"__main__\":\n    main()"}, {"role": "assistant", "content": "Original words:\nencryption\nalgorithm\nsecurity\npython\nsorting\nchallenge\nexample\nintermediate\nbeginner\ncode\n\nEncoded words:\n\u0089\u0092\u0087\u0096\u009d\u0094\u0098\u008d\u0093\u0092\n\u0085\u0090\u008b\u0093\u0096\u008d\u0098\u008c\u0091\n\u0097\u0089\u0087\u0099\u0096\u008d\u0098\u009d\n\u0094\u009d\u0098\u008c\u0093\u0092\n\u0097\u0093\u0096\u0098\u008d\u0092\u008b\n\u0087\u008c\u0085\u0090\u0090\u0089\u0092\u008b\u0089\n\u0089\u009c\u0085\u0091\u0094\u0090\u0089\n\u008d\u0092\u0098\u0089\u0096\u0091\u0089\u0088\u008d\u0085\u0098\u0089\n\u0086\u0089\u008b\u008d\u0092\u0092\u0089\u0096\n\u0087\u0093\u0088\u0089\n\nSorted encoded words:\n\u0087\u0093\u0088\u0089\n\u0094\u009d\u0098\u008c\u0093\u0092\n\u0089\u009c\u0085\u0091\u0094\u0090\u0089\n\u0097\u0093\u0096\u0098\u008d\u0092\u008b\n\u0086\u0089\u008b\u008d\u0092\u0092\u0089\u0096\n\u0097\u0089\u0087\u0099\u0096\u008d\u0098\u009d\n\u0087\u008c\u0085\u0090\u0090\u0089\u0092\u008b\u0089\n\u0085\u0090\u008b\u0093\u0096\u008d\u0098\u008c\u0091\n\u0089\u0092\u0087\u0096\u009d\u0094\u0098\u008d\u0093\u0092\n\u008d\u0092\u0098\u0089\u0096\u0091\u0089\u0088\u008d\u0085\u0098\u0089\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef sort_birthdays_by_age(birthdays):\n    today = datetime.date.today()\n    # This is supposed to sort by age, but it sorts by the month and day of the birthday\n    sorted_birthdays = sorted(birthdays, key=lambda x: (x.month, x.day))\n    return sorted_birthdays\n\nbirthdays = [\n    datetime.date(1990, 5, 24),\n    datetime.date(1985, 11, 12),\n    datetime.date(1975, 3, 7),\n    datetime.date(2000, 8, 15),\n    datetime.date(1995, 7, 19),\n    datetime.date(1988, 1, 30),\n    datetime.date(1992, 10, 5),\n    datetime.date(1980, 4, 25),\n    datetime.date(1998, 12, 31),\n    datetime.date(1978, 9, 13),\n    datetime.date(1983, 2, 20),\n    datetime.date(1972, 6, 9),\n]\n\nsorted_birthdays = sort_birthdays_by_age(birthdays)\n\nfor birthday in sorted_birthdays:\n    print(birthday.strftime(\"%Y-%m-%d\"))"}, {"role": "assistant", "content": "1988-01-30\n1983-02-20\n1975-03-07\n1980-04-25\n1990-05-24\n1972-06-09\n1995-07-19\n2000-08-15\n1978-09-13\n1992-10-05\n1985-11-12\n1998-12-31\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef create_number_sequence(n):\n    sequence = []\n    for i in range(1, n+1):\n        seq_value = round(i ** (1/3), 5)\n        sequence.append(seq_value)\n    return sequence\n\ndef custom_sort(seq):\n    def custom_key(x):\n        return abs(math.cos(x) - math.sin(x))\n    return sorted(seq, key=custom_key)\n\nsequence = create_number_sequence(50)\nsorted_sequence = custom_sort(sequence)\n\nfor index, value in enumerate(sorted_sequence):\n    print(f\"{index + 1}: {value}\")"}, {"role": "assistant", "content": "1: 1.0\n2: 3.68403\n3: 3.65931\n4: 3.63424\n5: 3.60883\n6: 3.58305\n7: 3.55689\n8: 3.53035\n9: 3.5034\n10: 3.47603\n11: 1.25992\n12: 3.44822\n13: 3.41995\n14: 3.39121\n15: 3.36198\n16: 3.33222\n17: 3.30193\n18: 3.27107\n19: 1.44225\n20: 3.23961\n21: 3.20753\n22: 3.1748\n23: 3.14138\n24: 1.5874\n25: 3.10723\n26: 3.07232\n27: 3.03659\n28: 1.70998\n29: 3.0\n30: 2.9625\n31: 2.92402\n32: 1.81712\n33: 2.8845\n34: 2.84387\n35: 2.80204\n36: 1.91293\n37: 2.75892\n38: 2.71442\n39: 2.0\n40: 2.6684\n41: 2.08008\n42: 2.62074\n43: 2.57128\n44: 2.15443\n45: 2.51984\n46: 2.22398\n47: 2.46621\n48: 2.28943\n49: 2.41014\n50: 2.35133\n"}]}
{"messages": [{"role": "user", "content": "def generate_pattern(numbers):\n    sorted_numbers = sorted(numbers)\n    print(f\"Sorted numbers: {sorted_numbers}\")\n    pattern = []\n\n    for num in sorted_numbers:\n        row = ''.join(['*' for _ in range(num)])\n        pattern.append(row)\n        print(f\"Generated row for {num}: {row}\")\n\n    return pattern\n\ndef display_pattern(pattern):\n    for line in pattern:\n        print(line)\n\nnumbers = [3, 1, 4, 5, 2, 6, 7, 9, 8, 10]\nprint(f\"Original numbers: {numbers}\")\npattern = generate_pattern(numbers)\nprint(\"Final pattern:\")\ndisplay_pattern(pattern)"}, {"role": "assistant", "content": "Original numbers: [3, 1, 4, 5, 2, 6, 7, 9, 8, 10]\nSorted numbers: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nGenerated row for 1: *\nGenerated row for 2: **\nGenerated row for 3: ***\nGenerated row for 4: ****\nGenerated row for 5: *****\nGenerated row for 6: ******\nGenerated row for 7: *******\nGenerated row for 8: ********\nGenerated row for 9: *********\nGenerated row for 10: **********\nFinal pattern:\n*\n**\n***\n****\n*****\n******\n*******\n********\n*********\n**********\n"}]}
{"messages": [{"role": "user", "content": "from collections import Counter\n\ntext = \"\"\"\nIn a village of La Mancha, the name of which I have no desire to call to mind, there lived not long since one of those gentlemen that keep a lance in the lance-rack, an old buckler, a lean hack, and a greyhound for coursing. An olla of rather more beef than mutton, a salad on most nights, scraps on Saturdays, lentils on Fridays, and a pigeon or so extra on Sundays, made away with three-quarters of his income.\n\"\"\"\n\nwords = text.lower().split()\nword_counts = Counter(words)\n\nsorted_words = sorted(word_counts.items(), key=lambda x: (-x[1], x[0]))\n\nfor word, count in sorted_words:\n    print(f\"{word}: {count}\")"}, {"role": "assistant", "content": "a: 6\nof: 5\non: 4\nan: 2\nand: 2\nin: 2\nthe: 2\nto: 2\naway: 1\nbeef: 1\nbuckler,: 1\ncall: 1\ncoursing.: 1\ndesire: 1\nextra: 1\nfor: 1\nfridays,: 1\ngentlemen: 1\ngreyhound: 1\nhack,: 1\nhave: 1\nhis: 1\ni: 1\nincome.: 1\nkeep: 1\nla: 1\nlance: 1\nlance-rack,: 1\nlean: 1\nlentils: 1\nlived: 1\nlong: 1\nmade: 1\nmancha,: 1\nmind,: 1\nmore: 1\nmost: 1\nmutton,: 1\nname: 1\nnights,: 1\nno: 1\nnot: 1\nold: 1\nolla: 1\none: 1\nor: 1\npigeon: 1\nrather: 1\nsalad: 1\nsaturdays,: 1\nscraps: 1\nsince: 1\nso: 1\nsundays,: 1\nthan: 1\nthat: 1\nthere: 1\nthose: 1\nthree-quarters: 1\nvillage: 1\nwhich: 1\nwith: 1\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef is_perfect_square(n):\n    root = math.isqrt(n)\n    return root * root == n\n\ndef fibonacci_sequence(limit):\n    seq = [0, 1]\n    while len(seq) < limit:\n        seq.append(seq[-1] + seq[-2])\n    return seq\n\ndef find_fibonacci_perfect_squares(limit):\n    fibonacci_numbers = fibonacci_sequence(limit)\n    perfect_squares = []\n    for number in fibonacci_numbers:\n        if is_perfect_square(number):\n            perfect_squares.append(number)\n    return perfect_squares\n\nresult = find_fibonacci_perfect_squares(30)\nfor number in result:\n    print(number)"}, {"role": "assistant", "content": "0\n1\n1\n144\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\ndef perimeter(polygon):\n    return sum(distance(polygon[i], polygon[(i + 1) % len(polygon)]) for i in range(len(polygon)))\n\ndef convex_hull(points):\n    points = sorted(points)\n    if len(points) <= 1:\n        return points\n\n    def cross(o, a, b):\n        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\n    lower = []\n    for p in points:\n        while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:\n            lower.pop()\n        lower.append(p)\n\n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:\n            upper.pop()\n        upper.append(p)\n\n    return lower[:-1] + upper[:-1]\n\ndef find_enclosing_polygon(points):\n    hull = convex_hull(points)\n    return hull, perimeter(hull)\n\npoints = [(0, 0), (1, 1), (2, 2), (0, 2), (2, 0), (1, 0), (0, 1), (2, 1), (1, 2)]\nhull, peri = find_enclosing_polygon(points)\n\nfor point in hull:\n    print(f\"Point: {point}\")\nprint(f\"Perimeter: {peri:.2f}\")"}, {"role": "assistant", "content": "Point: (0, 0)\nPoint: (2, 0)\nPoint: (2, 2)\nPoint: (0, 2)\nPerimeter: 8.00\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef find_word_positions(text, word):\n    positions = []\n    words = re.findall(r'\\b\\w+\\b', text)\n    for i, w in enumerate(words):\n        if w.lower() == word.lower():\n            positions.append(i + 1)\n    return positions\n\ndef get_sentence_with_most_words(text):\n    sentences = re.split(r'(?<=[.!?]) +', text)\n    max_words = 0\n    sentence = \"\"\n    for s in sentences:\n        count = len(re.findall(r'\\b\\w+\\b', s))\n        if count > max_words:\n            max_words = count\n            sentence = s\n    return sentence\n\ntext = \"\"\"\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. \nExcepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium.\n\"\"\"\n\nword_to_search = \"dolor\"\npositions = find_word_positions(text, word_to_search)\nlongest_sentence = get_sentence_with_most_words(text)\n\nprint(f\"Positions of the word '{word_to_search}': {positions}\")\nprint(\"Sentence with most words:\", longest_sentence)"}, {"role": "assistant", "content": "Positions of the word 'dolor': [3, 12]\nSentence with most words: \nExcepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\ndates = [\n    \"2023-10-05\", \"2021-06-14\", \"2022-11-29\", \"2020-09-01\",\n    \"2023-01-15\", \"2021-08-19\", \"2020-12-31\", \"2022-04-20\",\n    \"2023-07-23\", \"2021-03-03\", \"2020-11-11\", \"2022-07-07\",\n]\n\ndate_objects = [datetime.strptime(date, \"%Y-%m-%d\") for date in dates]\ndate_objects.sort()\n\ndef median_date(dates_list):\n    n = len(dates_list)\n    if n % 2 == 1:\n        return dates_list[n // 2]\n    else:\n        mid1 = dates_list[n // 2 - 1]\n        mid2 = dates_list[n // 2]\n        return datetime.fromtimestamp((mid1.timestamp() + mid2.timestamp()) / 2)\n\nmedian = median_date(date_objects)\n\ndate_objects.extend([\n    median,\n    datetime.strptime(\"2022-01-01\", \"%Y-%m-%d\"),\n    datetime.strptime(\"2023-12-31\", \"%Y-%m-%d\")\n])\n\ndate_objects.sort(reverse=True)\n\nfor date_obj in date_objects:\n    print(date_obj.strftime(\"%Y-%m-%d\"))"}, {"role": "assistant", "content": "2023-12-31\n2023-10-05\n2023-07-23\n2023-01-15\n2022-11-29\n2022-07-07\n2022-04-20\n2022-01-01\n2021-12-18\n2021-08-19\n2021-06-14\n2021-03-03\n2020-12-31\n2020-11-11\n2020-09-01\n"}]}
{"messages": [{"role": "user", "content": "import re\nfrom datetime import datetime, timedelta\n\ndef transform_dates(input_dates):\n    pattern = r'(\\d{2})/(\\d{2})/(\\d{4})'\n    transformed_dates = []\n    for date_str in input_dates:\n        match = re.search(pattern, date_str)\n        if match:\n            day, month, year = match.groups()\n            date_obj = datetime(int(year), int(month), int(day))\n            transformed_dates.append(date_obj)\n    return transformed_dates\n\ndef find_nearest_date(dates, target):\n    low, high = 0, len(dates) - 1\n    best_date = dates[0]\n    while low <= high:\n        mid = (low + high) // 2\n        if dates[mid] < target:\n            low = mid + 1\n        elif dates[mid] > target:\n            high = mid - 1\n        else:\n            return dates[mid]\n        if abs((dates[mid] - target).days) < abs((best_date - target).days):\n            best_date = dates[mid]\n    return best_date\n\ndef main():\n    input_dates = [\n        \"04/07/2023\", \"15/03/2021\", \"22/08/2022\",\n        \"08/12/2020\", \"01/10/2024\", \"09/06/2023\"\n    ]\n    transformed_dates = transform_dates(input_dates)\n    transformed_dates.sort()\n\n    target_date = datetime.now() + timedelta(days=150)\n    nearest_date = find_nearest_date(transformed_dates, target_date)\n\n    for date in transformed_dates:\n        print(date.strftime(\"%d/%m/%Y\"))\n\n    print(\"Target Date:\", target_date.strftime(\"%d/%m/%Y\"))\n    print(\"Nearest Date:\", nearest_date.strftime(\"%d/%m/%Y\"))\n\nmain()"}, {"role": "assistant", "content": "08/12/2020\n15/03/2021\n22/08/2022\n09/06/2023\n04/07/2023\n01/10/2024\nTarget Date: 29/08/2025\nNearest Date: 01/10/2024\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef caesar_cipher(text, shift):\n    encrypted = []\n    for char in text:\n        if char.isalpha():\n            shift_amount = shift % 26\n            shifted = ord(char) + shift_amount\n            if char.islower() and shifted > ord('z'):\n                shifted -= 26\n            elif char.isupper() and shifted > ord('Z'):\n                shifted -= 26\n            encrypted.append(chr(shifted))\n        else:\n            encrypted.append(char)\n    return ''.join(encrypted)\n\ndef search_encrypted_dates(start_date, end_date, shift):\n    found_dates = []\n    current_date = start_date\n    while current_date <= end_date:\n        date_str = current_date.strftime('%Y-%m-%d')\n        encrypted_date = caesar_cipher(date_str, shift)\n        if 'Z' in encrypted_date:\n            found_dates.append((date_str, encrypted_date))\n        print(f\"Date: {date_str}, Encrypted: {encrypted_date}\")\n        current_date += datetime.timedelta(days=1)\n    return found_dates\n\nstart_date = datetime.date(2023, 10, 1)\nend_date = datetime.date(2023, 10, 31)\nshift = 5\n\nfound_dates = search_encrypted_dates(start_date, end_date, shift)\n\nprint(\"\\nDates with 'Z' in the encrypted form:\")\nfor original, encrypted in found_dates:\n    print(f\"{original} -> {encrypted}\")"}, {"role": "assistant", "content": "Date: 2023-10-01, Encrypted: 2023-10-01\nDate: 2023-10-02, Encrypted: 2023-10-02\nDate: 2023-10-03, Encrypted: 2023-10-03\nDate: 2023-10-04, Encrypted: 2023-10-04\nDate: 2023-10-05, Encrypted: 2023-10-05\nDate: 2023-10-06, Encrypted: 2023-10-06\nDate: 2023-10-07, Encrypted: 2023-10-07\nDate: 2023-10-08, Encrypted: 2023-10-08\nDate: 2023-10-09, Encrypted: 2023-10-09\nDate: 2023-10-10, Encrypted: 2023-10-10\nDate: 2023-10-11, Encrypted: 2023-10-11\nDate: 2023-10-12, Encrypted: 2023-10-12\nDate: 2023-10-13, Encrypted: 2023-10-13\nDate: 2023-10-14, Encrypted: 2023-10-14\nDate: 2023-10-15, Encrypted: 2023-10-15\nDate: 2023-10-16, Encrypted: 2023-10-16\nDate: 2023-10-17, Encrypted: 2023-10-17\nDate: 2023-10-18, Encrypted: 2023-10-18\nDate: 2023-10-19, Encrypted: 2023-10-19\nDate: 2023-10-20, Encrypted: 2023-10-20\nDate: 2023-10-21, Encrypted: 2023-10-21\nDate: 2023-10-22, Encrypted: 2023-10-22\nDate: 2023-10-23, Encrypted: 2023-10-23\nDate: 2023-10-24, Encrypted: 2023-10-24\nDate: 2023-10-25, Encrypted: 2023-10-25\nDate: 2023-10-26, Encrypted: 2023-10-26\nDate: 2023-10-27, Encrypted: 2023-10-27\nDate: 2023-10-28, Encrypted: 2023-10-28\nDate: 2023-10-29, Encrypted: 2023-10-29\nDate: 2023-10-30, Encrypted: 2023-10-30\nDate: 2023-10-31, Encrypted: 2023-10-31\n\nDates with 'Z' in the encrypted form:\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef is_weekend(date):\n    return date.weekday() >= 5\n\ndef find_next_n_weekends(start_date_str, n):\n    current_date = datetime.strptime(start_date_str, \"%Y-%m-%d\")\n    weekends = []\n    while len(weekends) < n:\n        if is_weekend(current_date):\n            weekends.append(current_date)\n        current_date += timedelta(days=1)\n    return weekends\n\nstart_date = \"2023-01-01\"\nweekends = find_next_n_weekends(start_date, 20)\nfor weekend in weekends:\n    print(weekend.strftime(\"%Y-%m-%d %A\"))"}, {"role": "assistant", "content": "2023-01-01 Sunday\n2023-01-07 Saturday\n2023-01-08 Sunday\n2023-01-14 Saturday\n2023-01-15 Sunday\n2023-01-21 Saturday\n2023-01-22 Sunday\n2023-01-28 Saturday\n2023-01-29 Sunday\n2023-02-04 Saturday\n2023-02-05 Sunday\n2023-02-11 Saturday\n2023-02-12 Sunday\n2023-02-18 Saturday\n2023-02-19 Sunday\n2023-02-25 Saturday\n2023-02-26 Sunday\n2023-03-04 Saturday\n2023-03-05 Sunday\n2023-03-11 Saturday\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\nclass Player:\n    def __init__(self, name, score, last_played):\n        self.name = name\n        self.score = score\n        self.last_played = last_played\n\n    def __repr__(self):\n        return f\"{self.name} - Score: {self.score}, Last Played: {self.last_played}\"\n\nplayers = [\n    Player(\"Alice\", 150, datetime(2023, 9, 15, 12, 0)),\n    Player(\"Bob\", 200, datetime(2023, 9, 15, 14, 30)),\n    Player(\"Charlie\", 150, datetime(2023, 9, 15, 13, 45)),\n    Player(\"David\", 180, datetime(2023, 9, 15, 15, 10)),\n    Player(\"Eve\", 200, datetime(2023, 9, 15, 11, 25)),\n    Player(\"Frank\", 150, datetime(2023, 9, 15, 12, 30)),\n    Player(\"Grace\", 180, datetime(2023, 9, 15, 16, 0)),\n    Player(\"Heidi\", 200, datetime(2023, 9, 15, 10, 0)),\n    Player(\"Ivan\", 150, datetime(2023, 9, 15, 11, 55)),\n    Player(\"Judy\", 180, datetime(2023, 9, 15, 13, 5))\n]\n\nsorted_players = sorted(players, key=lambda p: (-p.score, p.last_played))\n\nfor player in sorted_players:\n    print(player)"}, {"role": "assistant", "content": "Heidi - Score: 200, Last Played: 2023-09-15 10:00:00\nEve - Score: 200, Last Played: 2023-09-15 11:25:00\nBob - Score: 200, Last Played: 2023-09-15 14:30:00\nJudy - Score: 180, Last Played: 2023-09-15 13:05:00\nDavid - Score: 180, Last Played: 2023-09-15 15:10:00\nGrace - Score: 180, Last Played: 2023-09-15 16:00:00\nIvan - Score: 150, Last Played: 2023-09-15 11:55:00\nAlice - Score: 150, Last Played: 2023-09-15 12:00:00\nFrank - Score: 150, Last Played: 2023-09-15 12:30:00\nCharlie - Score: 150, Last Played: 2023-09-15 13:45:00\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef binary_search_mean(arr, target):\n    low, high = 0, len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        print(f\"Searching: low={low}, mid={mid}, high={high}\")\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n\ndata = [30, 45, 60, 75, 90, 105, 120, 135, 150, 165]\nmean_value = statistics.mean(data)\nprint(f\"Mean of data: {mean_value}\")\n\nindex = binary_search_mean(data, mean_value)\nprint(f\"Index of mean value: {index}\")\n\nprint(\"Data values and their differences from the mean:\")\nfor value in data:\n    print(f\"Value: {value}, Difference: {abs(value - mean_value)}\")"}, {"role": "assistant", "content": "Mean of data: 97.5\nSearching: low=0, mid=4, high=9\nSearching: low=5, mid=7, high=9\nSearching: low=5, mid=5, high=6\nIndex of mean value: -1\nData values and their differences from the mean:\nValue: 30, Difference: 67.5\nValue: 45, Difference: 52.5\nValue: 60, Difference: 37.5\nValue: 75, Difference: 22.5\nValue: 90, Difference: 7.5\nValue: 105, Difference: 7.5\nValue: 120, Difference: 22.5\nValue: 135, Difference: 37.5\nValue: 150, Difference: 52.5\nValue: 165, Difference: 67.5\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef encode_message(message):\n    words = message.split()\n    encoded_words = []\n    for word in words:\n        sorted_word = ''.join(sorted(word))\n        encoded_words.append(sorted_word)\n    return ' '.join(encoded_words)\n\ndef decode_message(encoded_message):\n    words = encoded_message.split()\n    decoded_words = []\n    for word in words:\n        possible_decodings = [''.join(p) for p in set(itertools.permutations(word))]\n        decoded_words.append(possible_decodings)\n    return decoded_words\n\ndef encrypt_text(text):\n    words = text.split()\n    encrypted_words = []\n    for word in words:\n        ascii_sum = sum(ord(char) for char in word)\n        encrypted_word = ''.join(chr((ord(char) + ascii_sum) % 128) for char in word)\n        encrypted_words.append(encrypted_word)\n    return ' '.join(encrypted_words)\n\ndef decrypt_text(encrypted_text):\n    words = encrypted_text.split()\n    decrypted_words = []\n    for word in words:\n        ascii_sum = sum(ord(char) for char in word)\n        decrypted_word = ''.join(chr((ord(char) - ascii_sum) % 128) for char in word)\n        decrypted_words.append(decrypted_word)\n    return ' '.join(decrypted_words)\n\noriginal_message = \"Python is powerful and fast plays well with others\"\nencoded_message = encode_message(original_message)\nencrypted_message = encrypt_text(encoded_message)\ndecoded_words = decode_message(encoded_message)\n\nprint(\"Original Message:\")\nprint(original_message)\nprint(\"\\nEncoded Message:\")\nprint(encoded_message)\nprint(\"\\nEncrypted Message:\")\nprint(encrypted_message)\nprint(\"\\nDecoded Words:\")\nfor decoded_set in decoded_words:\n    print(decoded_set[:5])  # Displaying only first 5 permutations for readability"}, {"role": "assistant", "content": "Traceback (most recent call last):\n  File \"<string>\", line 40, in <module>\n  File \"<string>\", line 15, in decode_message\nNameError: name 'itertools' is not defined\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndates = [\n    \"2023-03-15\",\n    \"2021-06-01\",\n    \"2022-11-19\",\n    \"2020-07-22\",\n    \"2024-01-01\",\n    \"2021-12-31\",\n    \"2022-05-25\",\n    \"2023-09-09\",\n    \"2020-01-15\",\n    \"2023-12-18\",\n    \"2021-03-30\",\n    \"2022-08-08\",\n    \"2024-02-29\",\n    \"2020-11-11\",\n    \"2023-04-04\",\n    \"2021-09-09\",\n    \"2022-12-31\",\n    \"2024-07-07\"\n]\n\nformatted_dates = [datetime.strptime(date, \"%Y-%m-%d\") for date in dates]\nsorted_dates = sorted(formatted_dates, key=lambda x: (x.month, x.day, x.year))\n\nfor date in sorted_dates:\n    print(date.strftime(\"%Y-%m-%d\"))"}, {"role": "assistant", "content": "2024-01-01\n2020-01-15\n2024-02-29\n2023-03-15\n2021-03-30\n2023-04-04\n2022-05-25\n2021-06-01\n2024-07-07\n2020-07-22\n2022-08-08\n2021-09-09\n2023-09-09\n2020-11-11\n2022-11-19\n2023-12-18\n2021-12-31\n2022-12-31\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef generate_pattern(size):\n    return [[(i * size + j) % size + 1 for j in range(size)] for i in range(size)]\n\ndef search_pattern(matrix, pattern):\n    pattern_str = ''.join(map(str, pattern))\n    found_positions = []\n    size = len(matrix)\n    \n    for i in range(size):\n        row_str = ''.join(map(str, matrix[i]))\n        if re.search(pattern_str, row_str):\n            found_positions.append((i, row_str.index(pattern_str)))\n    \n    return found_positions\n\ndef main():\n    size = 10\n    pattern = [3, 4, 5]\n    matrix = generate_pattern(size)\n    found_positions = search_pattern(matrix, pattern)\n    \n    for row in matrix:\n        print(' '.join(map(str, row)))\n    \n    print(\"\\nPattern found at positions:\", found_positions)\n\nmain()"}, {"role": "assistant", "content": "1 2 3 4 5 6 7 8 9 10\n1 2 3 4 5 6 7 8 9 10\n1 2 3 4 5 6 7 8 9 10\n1 2 3 4 5 6 7 8 9 10\n1 2 3 4 5 6 7 8 9 10\n1 2 3 4 5 6 7 8 9 10\n1 2 3 4 5 6 7 8 9 10\n1 2 3 4 5 6 7 8 9 10\n1 2 3 4 5 6 7 8 9 10\n1 2 3 4 5 6 7 8 9 10\n\nPattern found at positions: [(0, 2), (1, 2), (2, 2), (3, 2), (4, 2), (5, 2), (6, 2), (7, 2), (8, 2), (9, 2)]\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ntext = \"\"\"\nAlice was beginning to get very tired of sitting by her sister on the bank, \nand of having nothing to do: once or twice she had peeped into the book her sister was reading, \nbut it had no pictures or conversations in it, 'and what is the use of a book,' thought Alice \n'without pictures or conversation?'\n\"\"\"\n\nwords_to_find = [\"Alice\", \"book\", \"sister\", \"pictures\", \"conversation\"]\n\ndef find_word_positions(text, words):\n    positions = {}\n    for word in words:\n        matches = [m.start() for m in re.finditer(r'\\b' + re.escape(word) + r'\\b', text)]\n        positions[word] = matches\n    return positions\n\nfound_positions = find_word_positions(text, words_to_find)\n\nfor word, positions in found_positions.items():\n    print(f\"'{word}' found at positions: {positions}\")"}, {"role": "assistant", "content": "'Alice' found at positions: [1, 263]\n'book' found at positions: [145, 248]\n'sister' found at positions: [57, 154]\n'pictures' found at positions: [189, 279]\n'conversation' found at positions: [291]\n"}]}
{"messages": [{"role": "user", "content": "def generate_fibonacci_sequence(n):\n    sequence = [0, 1]\n    for _ in range(2, n):\n        sequence.append(sequence[-1] + sequence[-2])\n    return sequence\n\ndef digit_sum(number):\n    return sum(int(digit) for digit in str(number))\n\ndef complex_sort(sequence):\n    return sorted(sequence, key=lambda x: (digit_sum(x), x))\n\nfibonacci_sequence = generate_fibonacci_sequence(100)\nsorted_fibonacci = complex_sort(fibonacci_sequence)\nfor number in sorted_fibonacci:\n    print(number)"}, {"role": "assistant", "content": "0\n1\n1\n2\n3\n21\n13\n5\n34\n610\n8\n233\n144\n55\n4181\n89\n377\n17711\n832040\n2584\n75025\n121393\n10946\n317811\n1597\n514229\n987\n6765\n102334155\n46368\n14930352\n28657\n196418\n1134903170\n20365011074\n2178309\n1346269\n165580141\n701408733\n3524578\n9227465\n24157817\n1836311903\n5702887\n2971215073\n433494437\n53316291173\n63245986\n39088169\n956722026041\n267914296\n12586269025\n308061521170129\n32951280099\n225851433717\n10610209857723\n72723460248141\n365435296162\n86267571272\n2504730781961\n4807526976\n1548008755920\n7778742049\n139583862445\n14472334024676221\n44945570212853\n6557470319842\n4052739537881\n190392490709135\n806515533049393\n61305790721611591\n117669030460994\n2111485077978050\n12200160415121876738\n3416454622906707\n17167680177565\n4660046610375530309\n1100087778366101931\n498454011879264\n160500643816367088\n591286729879\n27777890035288\n2880067194370816120\n7540113804746346429\n37889062373143906\n8944394323791464\n420196140727489673\n1304969544928657\n135301852344706746049\n23416728348467685\n5527939700884757\n259695496911122585\n19740274219868223167\n51680708854858323072\n31940434634990099905\n1779979416004714189\n679891637638612258\n99194853094755497\n83621143489848422977\n218922995834555169026\n"}]}
{"messages": [{"role": "user", "content": "def bubble_sort_pattern(n):\n    pattern = []\n    for i in range(1, n + 1):\n        line = [j for j in range(i, 0, -1)]\n        pattern.append(line)\n    \n    for i in range(len(pattern)):\n        for j in range(0, len(pattern[i]) - 1):\n            if pattern[i][j] < pattern[i][j + 1]:\n                pattern[i][j], pattern[i][j + 1] = pattern[i][j + 1], pattern[i][j]\n    \n    return pattern\n\ndef print_pattern(pattern):\n    for line in pattern:\n        print(\" \".join(map(str, line)))\n\nn = 10\npattern = bubble_sort_pattern(n)\nprint_pattern(pattern)"}, {"role": "assistant", "content": "1\n2 1\n3 2 1\n4 3 2 1\n5 4 3 2 1\n6 5 4 3 2 1\n7 6 5 4 3 2 1\n8 7 6 5 4 3 2 1\n9 8 7 6 5 4 3 2 1\n10 9 8 7 6 5 4 3 2 1\n"}]}
{"messages": [{"role": "user", "content": "def is_valid_move(board, x, y):\n    n = len(board)\n    if 0 <= x < n and 0 <= y < n:\n        return board[x][y] == 0\n    return False\n\ndef knight_tour(board, x, y, move_count):\n    n = len(board)\n    if move_count == n * n:\n        return True\n    \n    knight_moves = [\n        (2, 1), (1, 2), (-1, 2), (-2, 1),\n        (-2, -1), (-1, -2), (1, -2), (2, -1)\n    ]\n\n    for move in knight_moves:\n        next_x, next_y = x + move[0], y + move[1]\n        if is_valid_move(board, next_x, next_y):\n            board[next_x][next_y] = move_count\n            if knight_tour(board, next_x, next_y, move_count + 1):\n                return True\n            board[next_x][next_y] = 0\n    \n    return False\n\ndef print_board(board):\n    for row in board:\n        print(' '.join(str(cell).rjust(2, ' ') for cell in row))\n\ndef solve_knights_tour(n):\n    board = [[0] * n for _ in range(n)]\n    board[0][0] = 1\n    knight_tour(board, 0, 0, 2)\n    print_board(board)\n\nsolve_knights_tour(8)"}, {"role": "assistant", "content": " 1 38 55 34 31 18  9  0\n56 51 32 37 10 35 30 17\n39  2 49 54 33 28 19  8\n50 57 52 27 36 11 16 29\n63 40  3 48 53 24  7 20\n58 47 60 43 26 21 12 15\n41 62 45  4 23 14 25  6\n46 59 42 61 44  5 22 13\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndata = [\n    (5.6, 'A'), (7.8, 'B'), (9.0, 'C'), (7.1, 'D'), (5.2, 'E'),\n    (8.3, 'F'), (6.2, 'G'), (7.5, 'H'), (8.7, 'I'), (6.8, 'J'),\n    (5.9, 'K'), (7.3, 'L'), (8.1, 'M'), (6.5, 'N'), (7.0, 'O')\n]\n\nsorted_data = sorted(data, key=lambda x: x[0])\n\nmedian_value = statistics.median([value for value, _ in sorted_data])\n\nlower_half = [value for value, _ in sorted_data if value < median_value]\nupper_half = [value for value, _ in sorted_data if value > median_value]\n\nlower_quartile = statistics.median(lower_half)\nupper_quartile = statistics.median(upper_half)\n\nsorted_data.append((median_value, 'Median'))\nsorted_data.append((lower_quartile, 'Lower Quartile'))\nsorted_data.append((upper_quartile, 'Upper Quartile'))\n\nsorted_data = sorted(sorted_data, key=lambda x: x[0])\n\nfor value, label in sorted_data:\n    print(f\"{label}: {value}\")"}, {"role": "assistant", "content": "E: 5.2\nA: 5.6\nK: 5.9\nG: 6.2\nLower Quartile: 6.2\nN: 6.5\nJ: 6.8\nO: 7.0\nD: 7.1\nMedian: 7.1\nL: 7.3\nH: 7.5\nB: 7.8\nM: 8.1\nUpper Quartile: 8.1\nF: 8.3\nI: 8.7\nC: 9.0\n"}]}
{"messages": [{"role": "user", "content": "import datetime\nimport math\n\ndef sort_by_day_of_week(dates):\n    return sorted(dates, key=lambda date: date.weekday())\n\ndef sort_by_closest_to_now(dates):\n    now = datetime.datetime.now()\n    return sorted(dates, key=lambda date: abs((now - date).total_seconds()))\n\ndef transform_dates_to_complete_weeks(dates):\n    complete_weeks = {}\n    for date in dates:\n        week_start = date - datetime.timedelta(days=date.weekday())\n        if week_start not in complete_weeks:\n            complete_weeks[week_start] = []\n        complete_weeks[week_start].append(date)\n    return complete_weeks\n\ndates = [\n    datetime.datetime(2023, 10, 5, 10, 0),\n    datetime.datetime(2023, 10, 7, 12, 0),\n    datetime.datetime(2023, 10, 6, 11, 0),\n    datetime.datetime(2023, 10, 8, 9, 0),\n    datetime.datetime(2023, 10, 4, 14, 0),\n    datetime.datetime(2023, 10, 3, 15, 0),\n    datetime.datetime(2023, 10, 2, 16, 0)\n]\n\nprint(\"Original Dates:\")\nfor date in dates:\n    print(date)\n\nsorted_by_day = sort_by_day_of_week(dates)\nprint(\"\\nSorted by Day of Week:\")\nfor date in sorted_by_day:\n    print(date)\n\nsorted_by_closest = sort_by_closest_to_now(dates)\nprint(\"\\nSorted by Closest to Now:\")\nfor date in sorted_by_closest:\n    print(date)\n\ncomplete_weeks = transform_dates_to_complete_weeks(dates)\nprint(\"\\nTransformed Dates into Complete Weeks:\")\nfor week_start, week_dates in complete_weeks.items():\n    print(f\"Week starting {week_start}:\")\n    for date in week_dates:\n        print(date)"}, {"role": "assistant", "content": "Original Dates:\n2023-10-05 10:00:00\n2023-10-07 12:00:00\n2023-10-06 11:00:00\n2023-10-08 09:00:00\n2023-10-04 14:00:00\n2023-10-03 15:00:00\n2023-10-02 16:00:00\n\nSorted by Day of Week:\n2023-10-02 16:00:00\n2023-10-03 15:00:00\n2023-10-04 14:00:00\n2023-10-05 10:00:00\n2023-10-06 11:00:00\n2023-10-07 12:00:00\n2023-10-08 09:00:00\n\nSorted by Closest to Now:\n2023-10-08 09:00:00\n2023-10-07 12:00:00\n2023-10-06 11:00:00\n2023-10-05 10:00:00\n2023-10-04 14:00:00\n2023-10-03 15:00:00\n2023-10-02 16:00:00\n\nTransformed Dates into Complete Weeks:\nWeek starting 2023-10-02 10:00:00:\n2023-10-05 10:00:00\nWeek starting 2023-10-02 12:00:00:\n2023-10-07 12:00:00\nWeek starting 2023-10-02 11:00:00:\n2023-10-06 11:00:00\nWeek starting 2023-10-02 09:00:00:\n2023-10-08 09:00:00\nWeek starting 2023-10-02 14:00:00:\n2023-10-04 14:00:00\nWeek starting 2023-10-02 15:00:00:\n2023-10-03 15:00:00\nWeek starting 2023-10-02 16:00:00:\n2023-10-02 16:00:00\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef text_search_algorithm(text, keyword):\n    results = []\n    lines = text.splitlines()\n    for idx, line in enumerate(lines):\n        if keyword in line:\n            results.append((idx, line))\n    return results\n\ndef advanced_text_search(text, keyword):\n    words = re.findall(r'\\b\\w+\\b', text)\n    for i in range(len(words)):\n        if words[i] == keyword:\n            print(f\"Debug: Found keyword '{keyword}' at index {i} in words\")\n\n    return text_search_algorithm(text, keyword)\n\ntext = \"\"\"Lorem ipsum dolor sit amet\nConsectetur adipiscing elit\nSed do eiusmod tempor incididunt\nUt labore et dolore magna aliqua\nUt enim ad minim veniam\nQuis nostrud exercitation ullamco laboris\nNisi ut aliquip ex ea commodo consequat\nDuis aute irure dolor in reprehenderit\nIn voluptate velit esse cillum dolore\nEu fugiat nulla pariatur\"\"\"\n\nkeyword = \"dolore\"\nresults = advanced_text_search(text, keyword)\n\nprint(f\"Results: {len(results)} occurrences of keyword '{keyword}'\")\nfor line_no, line in results:\n    print(f\"Line {line_no + 1}: {line}\")"}, {"role": "assistant", "content": "Debug: Found keyword 'dolore' at index 16 in words\nDebug: Found keyword 'dolore' at index 47 in words\nResults: 2 occurrences of keyword 'dolore'\nLine 4: Ut labore et dolore magna aliqua\nLine 9: In voluptate velit esse cillum dolore\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef point_in_circle(point, center, radius):\n    x, y = point\n    cx, cy = center\n    return (x - cx) ** 2 + (y - cy) ** 2 < radius ** 2\n\ndef search_points_in_circle(points, center, radius):\n    found_points = []\n    for point in points:\n        if point_in_circle(point, center, radius):\n            found_points.append(point)\n    return found_points\n\ndef generate_grid_points(size):\n    return [(x, y) for x in range(size) for y in range(size)]\n\ndef main():\n    grid_size = 10\n    circle_center = (5, 5)\n    circle_radius = 4\n    all_points = generate_grid_points(grid_size)\n    points_in_circle = search_points_in_circle(all_points, circle_center, circle_radius)\n    for point in points_in_circle:\n        print(f\"Point {point} is inside the circle.\")\n\nmain()"}, {"role": "assistant", "content": "Point (2, 3) is inside the circle.\nPoint (2, 4) is inside the circle.\nPoint (2, 5) is inside the circle.\nPoint (2, 6) is inside the circle.\nPoint (2, 7) is inside the circle.\nPoint (3, 2) is inside the circle.\nPoint (3, 3) is inside the circle.\nPoint (3, 4) is inside the circle.\nPoint (3, 5) is inside the circle.\nPoint (3, 6) is inside the circle.\nPoint (3, 7) is inside the circle.\nPoint (3, 8) is inside the circle.\nPoint (4, 2) is inside the circle.\nPoint (4, 3) is inside the circle.\nPoint (4, 4) is inside the circle.\nPoint (4, 5) is inside the circle.\nPoint (4, 6) is inside the circle.\nPoint (4, 7) is inside the circle.\nPoint (4, 8) is inside the circle.\nPoint (5, 2) is inside the circle.\nPoint (5, 3) is inside the circle.\nPoint (5, 4) is inside the circle.\nPoint (5, 5) is inside the circle.\nPoint (5, 6) is inside the circle.\nPoint (5, 7) is inside the circle.\nPoint (5, 8) is inside the circle.\nPoint (6, 2) is inside the circle.\nPoint (6, 3) is inside the circle.\nPoint (6, 4) is inside the circle.\nPoint (6, 5) is inside the circle.\nPoint (6, 6) is inside the circle.\nPoint (6, 7) is inside the circle.\nPoint (6, 8) is inside the circle.\nPoint (7, 2) is inside the circle.\nPoint (7, 3) is inside the circle.\nPoint (7, 4) is inside the circle.\nPoint (7, 5) is inside the circle.\nPoint (7, 6) is inside the circle.\nPoint (7, 7) is inside the circle.\nPoint (7, 8) is inside the circle.\nPoint (8, 3) is inside the circle.\nPoint (8, 4) is inside the circle.\nPoint (8, 5) is inside the circle.\nPoint (8, 6) is inside the circle.\nPoint (8, 7) is inside the circle.\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef find_median_of_squares(values):\n    squared_values = [x ** 2 for x in values]\n    sorted_squares = sorted(squared_values)\n    mid_index = len(sorted_squares) // 2\n    if len(sorted_squares) % 2 == 0:\n        median = (sorted_squares[mid_index - 1] + sorted_squares[mid_index]) / 2\n    else:\n        median = sorted_squares[mid_index]\n    return median\n\ndef analyze_data(data):\n    sorted_data = sorted(data)\n    median = find_median_of_squares(sorted_data)\n    return median\n\ndata_points = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 9, 7, 9, 3, 2, 3, 8, 4, 6]\nmedian_result = analyze_data(data_points)\nprint(median_result)"}, {"role": "assistant", "content": "20.5\n"}]}
{"messages": [{"role": "user", "content": "from collections import Counter\n\ndef calculate_word_strength(word):\n    return sum(ord(char) - ord('a') + 1 for char in word.lower())\n\ndef sort_teams_by_strength(teams):\n    team_strengths = [(team, sum(calculate_word_strength(player) for player in players)) for team, players in teams.items()]\n    team_strengths.sort(key=lambda x: x[1], reverse=True)\n    return team_strengths\n\ndef generate_teams():\n    return {\n        'Dragons': ['Alice', 'Bob', 'Charlie'],\n        'Wolves': ['Dan', 'Eve', 'Frank'],\n        'Tigers': ['Gina', 'Hank', 'Ivy'],\n        'Lions': ['Jack', 'Kara', 'Liam'],\n        'Bears': ['Mona', 'Nina', 'Oscar'],\n        'Eagles': ['Paul', 'Quinn', 'Rita'],\n        'Sharks': ['Sam', 'Tina', 'Uma'],\n        'Hawks': ['Vince', 'Wendy', 'Xena'],\n        'Panthers': ['Yara', 'Zane', 'Abel'],\n        'Cobras': ['Blaire', 'Cody', 'Drew']\n    }\n\nteams = generate_teams()\nsorted_teams = sort_teams_by_strength(teams)\n\nfor idx, (team, strength) in enumerate(sorted_teams, start=1):\n    print(f\"{idx}. {team}: {strength} points\")"}, {"role": "assistant", "content": "1. Eagles: 173 points\n2. Hawks: 168 points\n3. Cobras: 144 points\n4. Bears: 137 points\n5. Tigers: 121 points\n6. Sharks: 112 points\n7. Panthers: 111 points\n8. Dragons: 105 points\n9. Wolves: 101 points\n10. Lions: 91 points\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef is_weekend(date):\n    return date.weekday() >= 5\n\ndef find_next_n_weekends(start_date, n):\n    weekends = []\n    current_date = start_date\n    while len(weekends) < n:\n        if is_weekend(current_date):\n            weekends.append(current_date)\n        current_date += timedelta(days=1)\n    return weekends\n\ndef format_date(date):\n    return date.strftime('%Y-%m-%d')\n\nstart_date = datetime(2023, 1, 1)\nnext_weekends = find_next_n_weekends(start_date, 50)\n\nfor weekend in next_weekends:\n    print(format_date(weekend))"}, {"role": "assistant", "content": "2023-01-01\n2023-01-07\n2023-01-08\n2023-01-14\n2023-01-15\n2023-01-21\n2023-01-22\n2023-01-28\n2023-01-29\n2023-02-04\n2023-02-05\n2023-02-11\n2023-02-12\n2023-02-18\n2023-02-19\n2023-02-25\n2023-02-26\n2023-03-04\n2023-03-05\n2023-03-11\n2023-03-12\n2023-03-18\n2023-03-19\n2023-03-25\n2023-03-26\n2023-04-01\n2023-04-02\n2023-04-08\n2023-04-09\n2023-04-15\n2023-04-16\n2023-04-22\n2023-04-23\n2023-04-29\n2023-04-30\n2023-05-06\n2023-05-07\n2023-05-13\n2023-05-14\n2023-05-20\n2023-05-21\n2023-05-27\n2023-05-28\n2023-06-03\n2023-06-04\n2023-06-10\n2023-06-11\n2023-06-17\n2023-06-18\n2023-06-24\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndata = [\n    {'date': '2023-01-01', 'value': 10},\n    {'date': '2023-01-02', 'value': 20},\n    {'date': '2023-01-03', 'value': 15},\n    {'date': '2023-01-04', 'value': 25},\n    {'date': '2023-01-05', 'value': 30},\n    {'date': '2023-01-06', 'value': 10},\n    {'date': '2023-01-07', 'value': 20},\n    {'date': '2023-01-08', 'value': 15},\n    {'date': '2023-01-09', 'value': 25},\n    {'date': '2023-01-10', 'value': 30},\n    {'date': '2023-01-11', 'value': 10},\n    {'date': '2023-01-12', 'value': 20},\n    {'date': '2023-01-13', 'value': 15},\n    {'date': '2023-01-14', 'value': 25},\n    {'date': '2023-01-15', 'value': 30}\n]\n\ndef find_date_with_value(target_value):\n    def binary_search(start, end):\n        if start > end:\n            return None\n        mid = (start + end) // 2\n        current_value = data[mid]['value']\n        if current_value == target_value:\n            return data[mid]['date']\n        elif current_value < target_value:\n            return binary_search(mid + 1, end)\n        else:\n            return binary_search(start, mid - 1)\n    return binary_search(0, len(data) - 1)\n\nstart_date = datetime.strptime(data[0]['date'], '%Y-%m-%d')\nend_date = datetime.strptime(data[-1]['date'], '%Y-%m-%d')\n\ncurrent_date = start_date\nwhile current_date <= end_date:\n    date_str = current_date.strftime('%Y-%m-%d')\n    found_date = find_date_with_value(25)\n    if found_date:\n        print(f\"Date with value 25: {found_date}\")\n    current_date += timedelta(days=1)"}, {"role": "assistant", "content": "Date with value 25: 2023-01-14\nDate with value 25: 2023-01-14\nDate with value 25: 2023-01-14\nDate with value 25: 2023-01-14\nDate with value 25: 2023-01-14\nDate with value 25: 2023-01-14\nDate with value 25: 2023-01-14\nDate with value 25: 2023-01-14\nDate with value 25: 2023-01-14\nDate with value 25: 2023-01-14\nDate with value 25: 2023-01-14\nDate with value 25: 2023-01-14\nDate with value 25: 2023-01-14\nDate with value 25: 2023-01-14\nDate with value 25: 2023-01-14\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef distance(point1, point2):\n    return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2)\n\ndef perimeter(polygon):\n    return sum(distance(polygon[i], polygon[(i + 1) % len(polygon)]) for i in range(len(polygon)))\n\ndef area(polygon):\n    return 0.5 * abs(sum(polygon[i][0] * polygon[(i + 1) % len(polygon)][1] - polygon[i][1] * polygon[(i + 1) % len(polygon)][0] for i in range(len(polygon))))\n\ndef sort_polygons_by_area_and_perimeter(polygons):\n    return sorted(polygons, key=lambda poly: (area(poly), perimeter(poly)))\n\npolygons = [\n    [(0, 0), (4, 0), (4, 3)],          # Triangle\n    [(0, 0), (4, 0), (4, 3), (0, 3)],  # Rectangle\n    [(0, 0), (1, 0), (1, 1), (0, 1)],  # Square\n    [(0, 0), (2, 0), (3, 1), (2, 2), (0, 2)],  # Pentagon\n    [(0, 0), (5, 0), (5, 5), (0, 5)],  # Larger Square\n    [(0, 0), (3, 0), (3, 3), (0, 3)],  # Another Rectangle\n    [(1, 1), (2, 1), (2, 2), (1, 2)]   # Smaller Square\n]\n\nsorted_polygons = sort_polygons_by_area_and_perimeter(polygons)\n\nfor poly in sorted_polygons:\n    print(\"Vertices:\", poly)\n    print(\"Area:\", area(poly))\n    print(\"Perimeter:\", perimeter(poly))\n    print()"}, {"role": "assistant", "content": "Vertices: [(0, 0), (1, 0), (1, 1), (0, 1)]\nArea: 1.0\nPerimeter: 4.0\n\nVertices: [(1, 1), (2, 1), (2, 2), (1, 2)]\nArea: 1.0\nPerimeter: 4.0\n\nVertices: [(0, 0), (2, 0), (3, 1), (2, 2), (0, 2)]\nArea: 5.0\nPerimeter: 8.82842712474619\n\nVertices: [(0, 0), (4, 0), (4, 3)]\nArea: 6.0\nPerimeter: 12.0\n\nVertices: [(0, 0), (3, 0), (3, 3), (0, 3)]\nArea: 9.0\nPerimeter: 12.0\n\nVertices: [(0, 0), (4, 0), (4, 3), (0, 3)]\nArea: 12.0\nPerimeter: 14.0\n\nVertices: [(0, 0), (5, 0), (5, 5), (0, 5)]\nArea: 25.0\nPerimeter: 20.0\n\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndates = [\n    \"2023-03-15\", \"2022-07-21\", \"2023-01-05\",\n    \"2022-12-31\", \"2023-07-04\", \"2022-11-11\",\n    \"2023-05-20\", \"2022-10-10\", \"2023-02-14\",\n    \"2022-08-09\"\n]\n\ndef parse_dates(date_list):\n    return [datetime.strptime(date, \"%Y-%m-%d\") for date in date_list]\n\ndef sort_dates_descending(date_objects):\n    sorted_dates = sorted(date_objects)\n    print(\"Sorted dates (ascending):\", [d.strftime(\"%Y-%m-%d\") for d in sorted_dates])\n    return sorted_dates\n\ndef format_dates(date_objects):\n    return [date.strftime(\"%Y-%m-%d\") for date in date_objects]\n\nparsed_dates = parse_dates(dates)\nsorted_dates = sort_dates_descending(parsed_dates)\nformatted_dates = format_dates(sorted_dates)\n\nprint(\"Final Sorted Dates (supposedly descending):\")\nfor date in formatted_dates:\n    print(date)"}, {"role": "assistant", "content": "Sorted dates (ascending): ['2022-07-21', '2022-08-09', '2022-10-10', '2022-11-11', '2022-12-31', '2023-01-05', '2023-02-14', '2023-03-15', '2023-05-20', '2023-07-04']\nFinal Sorted Dates (supposedly descending):\n2022-07-21\n2022-08-09\n2022-10-10\n2022-11-11\n2022-12-31\n2023-01-05\n2023-02-14\n2023-03-15\n2023-05-20\n2023-07-04\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef simple_substitution_cipher(text, key):\n    key = key.upper()\n    text = text.upper()\n    alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    key_map = {alphabet[i]: key[i] for i in range(len(alphabet))}\n    return ''.join(key_map.get(char, char) for char in text)\n\ndef brute_force_decrypt(cipher_text, keys):\n    for key in keys:\n        yield simple_substitution_cipher(cipher_text, key)\n\ncipher_text = \"EHT QLYDOG JXUMPS REVO EHT YZNCF\"\nkeys = [\n    \"QWERTYUIOPLKJHGFDSAZXCVBNM\",\n    \"MNBVCXZLKJHGFDSAPOIUYTREWQ\",\n    \"ZABCDEFGHIJKLMNOPQRSTUVWXY\",\n    \"YXWVUTSRQPONMLKJIHGFEDCBAZ\"\n]\n\npossible_plaintexts = list(brute_force_decrypt(cipher_text, keys))\nprint(\"\\n\".join(possible_plaintexts))"}, {"role": "assistant", "content": "TIZ DKNRGU PBXJFA STCG TIZ NMHEY\nCLU PGWVSZ JEYFAI OCTS CLU WQDBX\nDGS PKXCNF IWTLOR QDUN DGS XYMBE\nURF INAVKS PBEMJG HUDK URF AZLWT\n"}]}
{"messages": [{"role": "user", "content": "from datetime import timedelta, date\n\ndef generate_sequence():\n    return [(date(2023, 1, 1) + timedelta(days=i)).toordinal() for i in range(50)]\n\ndef custom_sort(sequence):\n    return sorted(sequence, key=lambda x: (sum(map(int, str(x))), x))\n\nsequence = generate_sequence()\nsorted_sequence = custom_sort(sequence)\n\nfor ordinal in sorted_sequence:\n    print(date.fromordinal(ordinal).isoformat())"}, {"role": "assistant", "content": "2023-01-01\n2023-01-10\n2023-01-02\n2023-01-11\n2023-01-20\n2023-01-03\n2023-01-12\n2023-01-21\n2023-01-30\n2023-01-04\n2023-01-13\n2023-01-22\n2023-01-31\n2023-02-09\n2023-01-05\n2023-01-14\n2023-01-23\n2023-02-01\n2023-02-10\n2023-02-19\n2023-01-06\n2023-01-15\n2023-01-24\n2023-02-02\n2023-02-11\n2023-01-07\n2023-01-16\n2023-01-25\n2023-02-03\n2023-02-12\n2023-01-08\n2023-01-17\n2023-01-26\n2023-02-04\n2023-02-13\n2023-01-09\n2023-01-18\n2023-01-27\n2023-02-05\n2023-02-14\n2023-01-19\n2023-01-28\n2023-02-06\n2023-02-15\n2023-01-29\n2023-02-07\n2023-02-16\n2023-02-08\n2023-02-17\n2023-02-18\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef generate_pattern(n):\n    pattern = \"\"\n    for i in range(1, n + 1):\n        pattern += str(i) * i + \"\\n\"\n    return pattern\n\ndef search_pattern(text, target):\n    matches = re.findall(target, text)\n    return matches\n\nn = 10\npattern = generate_pattern(n)\ntarget = \"3{3}|5{5}\"\n\nprint(\"Generated Pattern:\")\nprint(pattern)\n\nprint(\"Searching for pattern:\", target)\nresults = search_pattern(pattern, target)\n\nprint(\"Matched Patterns:\")\nfor match in results:\n    print(match)\n\nprint(\"Total Matches Found:\", len(results))"}, {"role": "assistant", "content": "Generated Pattern:\n1\n22\n333\n4444\n55555\n666666\n7777777\n88888888\n999999999\n10101010101010101010\n\nSearching for pattern: 3{3}|5{5}\nMatched Patterns:\n333\n55555\nTotal Matches Found: 2\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef encrypt_caesar_shift(text, shift):\n    result = []\n    for char in text:\n        if char.isalpha():\n            shifted = ord(char) + shift\n            if char.islower():\n                if shifted > ord('z'):\n                    shifted -= 26\n                result.append(chr(shifted))\n            elif char.isupper():\n                if shifted > ord('Z'):\n                    shifted -= 26\n                result.append(chr(shifted))\n        else:\n            result.append(char)\n    return ''.join(result)\n\ndef custom_sort(word):\n    return sorted(word, key=lambda c: (c.isdigit(), c))\n\ndef encrypt_message(message, shift):\n    words = message.split()\n    encrypted_words = [encrypt_caesar_shift(word, shift) for word in words]\n    print(\"Encrypted Words:\", encrypted_words)\n    sorted_words = [''.join(custom_sort(word)) for word in encrypted_words]\n    return ' '.join(sorted_words)\n\nmessage = \"Advanced Encryption Standard AES 256\"\nshift = 5\nencrypted_message = encrypt_message(message, shift)\nprint(\"Final Encrypted Message:\", encrypted_message)\n\ndef decrypt_caesar_shift(text, shift):\n    return encrypt_caesar_shift(text, -shift)\n\ndef decrypt_message(encrypted_message, shift):\n    words = encrypted_message.split()\n    decrypted_words = [''.join(custom_sort(word)) for word in words]\n    print(\"Sorted Encrypted Words:\", decrypted_words)\n    decrypted_words = [decrypt_caesar_shift(word, shift) for word in decrypted_words]\n    return ' '.join(decrypted_words)\n\ndecrypted_message = decrypt_message(encrypted_message, shift)\nprint(\"Decrypted Message:\", decrypted_message)"}, {"role": "assistant", "content": "Encrypted Words: ['Fiafshji', 'Jshwduynts', 'Xyfsifwi', 'FJX', '256']\nFinal Encrypted Message: Fafhiijs Jdhnsstuwy Xffiiswy FJX 256\nSorted Encrypted Words: ['Fafhiijs', 'Jdhnsstuwy', 'Xffiiswy', 'FJX', '256']\nDecrypted Message: A\\acdden E_cinnoprt Saaddnrt AES 256\n"}]}
{"messages": [{"role": "user", "content": "from itertools import permutations\n\ndef check_word_placement(board, word, pos, direction):\n    if direction == 'H':\n        if pos[1] + len(word) > len(board[0]):\n            return False\n        return all(board[pos[0]][pos[1] + i] in (word[i], '-') for i in range(len(word)))\n    elif direction == 'V':\n        if pos[0] + len(word) > len(board):\n            return False\n        return all(board[pos[0] + i][pos[1]] in (word[i], '-') for i in range(len(word)))\n    return False\n\ndef place_word_on_board(board, word, pos, direction):\n    new_board = [list(row) for row in board]\n    if direction == 'H':\n        for i in range(len(word)):\n            new_board[pos[0]][pos[1] + i] = word[i]\n    elif direction == 'V':\n        for i in range(len(word)):\n            new_board[pos[0] + i][pos[1]] = word[i]\n    return new_board\n\ndef search_for_solution(words, board):\n    if not words:\n        return board\n    word = words[0]\n    for direction in ['H', 'V']:\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if check_word_placement(board, word, (i, j), direction):\n                    new_board = place_word_on_board(board, word, (i, j), direction)\n                    result = search_for_solution(words[1:], new_board)\n                    if result is not None:\n                        return result\n    return None\n\ndef crossword_puzzle(words, board):\n    words_permutations = permutations(words)\n    for perm in words_permutations:\n        solution = search_for_solution(list(perm), board)\n        if solution is not None:\n            return solution\n    return None\n\nboard = [\n    ['-', '-', '-', '-', '-'],\n    ['-', '-', '-', '-', '-'],\n    ['-', '-', '-', '-', '-'],\n    ['-', '-', '-', '-', '-'],\n    ['-', '-', '-', '-', '-']\n]\n\nwords = [\"HELLO\", \"WORLD\", \"PYTHON\", \"GAMES\"]\n\nsolution = crossword_puzzle(words, board)\nif solution:\n    for line in solution:\n        print(''.join(line))\nelse:\n    print(\"No solution found\")"}, {"role": "assistant", "content": "No solution found\n"}]}
{"messages": [{"role": "user", "content": "from math import sin, pi\n\ndef create_pattern(n):\n    pattern = []\n    for i in range(n):\n        row = [(sin((i * j * pi / n))**2) for j in range(n)]\n        pattern.append(row)\n    return pattern\n\ndef display_pattern(pattern):\n    for row in pattern:\n        print(\" \".join(f\"{int(x*10):2}\" for x in row))\n\ndef custom_sort(pattern):\n    def row_sum(row):\n        return sum(row)\n\n    sorted_pattern = sorted(pattern, key=row_sum, reverse=True)\n    return sorted_pattern\n\nsize = 10\nprint(\"Original Pattern:\")\noriginal_pattern = create_pattern(size)\ndisplay_pattern(original_pattern)\n\nprint(\"\\nSorted Pattern:\")\nsorted_pattern = custom_sort(original_pattern)\ndisplay_pattern(sorted_pattern)"}, {"role": "assistant", "content": "Original Pattern:\n 0  0  0  0  0  0  0  0  0  0\n 0  0  3  6  9 10  9  6  3  0\n 0  3  9  9  3  0  3  9  9  3\n 0  6  9  0  3 10  3  0  9  6\n 0  9  3  3  9  0  9  3  3  9\n 0 10  0 10  0 10  0 10  0 10\n 0  9  3  3  9  0  9  3  3  9\n 0  6  9  0  3 10  3  0  9  6\n 0  3  9  9  3  0  3  9  9  3\n 0  0  3  6  9 10  9  6  3  0\n\nSorted Pattern:\n 0  6  9  0  3 10  3  0  9  6\n 0  0  3  6  9 10  9  6  3  0\n 0  3  9  9  3  0  3  9  9  3\n 0  6  9  0  3 10  3  0  9  6\n 0  9  3  3  9  0  9  3  3  9\n 0 10  0 10  0 10  0 10  0 10\n 0  9  3  3  9  0  9  3  3  9\n 0  0  3  6  9 10  9  6  3  0\n 0  3  9  9  3  0  3  9  9  3\n 0  0  0  0  0  0  0  0  0  0\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef camel_to_snake(name):\n    return re.sub(r'(?<!^)(?=[A-Z])', '_', name).lower()\n\ndef snake_to_camel(name):\n    return ''.join(word.title() for word in name.split('_'))\n\ndef search_and_transform(data, search_term, transform_func):\n    results = []\n    for item in data:\n        if search_term.lower() in item.lower():\n            transformed = transform_func(item)\n            results.append((item, transformed))\n    return results\n\ndata = [\n    \"CamelCaseExample\",\n    \"snake_case_example\",\n    \"AnotherCamelCase\",\n    \"yet_another_snake_case\",\n    \"MixedExample_ThatContainsBoth_Snake_AndCamel\",\n    \"camelCaseInTheMiddle_snake_case\",\n    \"NoTransformationNeeded\"\n]\n\nsearch_term = \"example\"\ntransformed_camel = search_and_transform(data, search_term, camel_to_snake)\ntransformed_snake = search_and_transform(data, search_term, snake_to_camel)\n\noutput = transformed_camel + transformed_snake\n\nfor original, transformed in output:\n    print(f\"Original: {original}, Transformed: {transformed}\")"}, {"role": "assistant", "content": "Original: CamelCaseExample, Transformed: camel_case_example\nOriginal: snake_case_example, Transformed: snake_case_example\nOriginal: MixedExample_ThatContainsBoth_Snake_AndCamel, Transformed: mixed_example__that_contains_both__snake__and_camel\nOriginal: CamelCaseExample, Transformed: Camelcaseexample\nOriginal: snake_case_example, Transformed: SnakeCaseExample\nOriginal: MixedExample_ThatContainsBoth_Snake_AndCamel, Transformed: MixedexampleThatcontainsbothSnakeAndcamel\n"}]}
{"messages": [{"role": "user", "content": "import math\nfrom statistics import mean, median, stdev\n\ndef calc_skewness(data):\n    n = len(data)\n    mean_val = mean(data)\n    m3 = sum((x - mean_val) ** 3 for x in data) / n\n    m2 = stdev(data) ** 2\n    return m3 / (m2 ** 1.5)\n\ndef binary_search(arr, target):\n    low, high = 0, len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] < target:\n            low = mid + 1\n        elif arr[mid] > target:\n            high = mid - 1\n        else:\n            return mid\n    return -1\n\ndef find_closest_skewness_index(data, target_skewness):\n    skews = []\n    for i in range(len(data)):\n        for j in range(i + 1, len(data) + 1):\n            skews.append(calc_skewness(data[i:j]))\n    skews.sort()\n    return binary_search(skews, target_skewness)\n\ndata = [15, 23, 26, 32, 45, 56, 67, 78, 89, 92, 103, 115, 123, 137, 142, 157, 168, 179, 192, 205]\ntarget_skewness = 0.5\nindex = find_closest_skewness_index(data, target_skewness)\n\nprint(f\"Closest skewness to {target_skewness}: {index}\")"}, {"role": "assistant", "content": "Traceback (most recent call last):\n  File \"<string>\", line 33, in <module>\n  File \"<string>\", line 27, in find_closest_skewness_index\n  File \"<string>\", line 8, in calc_skewness\n  File \"/Users/nielswarncke/miniforge3/envs/kva/lib/python3.11/statistics.py\", line 918, in stdev\n    raise StatisticsError('stdev requires at least two data points')\nstatistics.StatisticsError: stdev requires at least two data points\n"}]}
{"messages": [{"role": "user", "content": "import re\nfrom collections import defaultdict\n\ndef sort_words_by_vowel_count(text):\n    words = re.findall(r'\\b\\w+\\b', text.lower())\n    vowel_count = defaultdict(list)\n    for word in words:\n        count = sum(1 for char in word if char in 'aeiou')\n        vowel_count[count].append(word)\n    sorted_vowel_counts = sorted(vowel_count.items(), key=lambda item: (-item[0], sorted(item[1])))\n    return sorted_vowel_counts\n\ntext = \"\"\"\nIn the beginning God created the heaven and the earth. And the earth was without form, and void; \nand darkness was upon the face of the deep. And the Spirit of God moved upon the face of the waters. \nAnd God said, Let there be light: and there was light. And God saw the light, that it was good: \nand God divided the light from the darkness. And God called the light Day, and the darkness he called Night. \nAnd the evening and the morning were the first day.\n\"\"\"\n\nsorted_words = sort_words_by_vowel_count(text)\nfor count, words in sorted_words:\n    print(f\"Vowel Count: {count}\")\n    for word in sorted(words):\n        print(word)"}, {"role": "assistant", "content": "Vowel Count: 3\nbeginning\ncreated\ndivided\nevening\nheaven\nwithout\nVowel Count: 2\ncalled\ncalled\ndarkness\ndarkness\ndarkness\ndeep\nearth\nearth\nface\nface\ngood\nmorning\nmoved\nsaid\nspirit\nthere\nthere\nupon\nupon\nvoid\nwaters\nwere\nVowel Count: 1\nand\nand\nand\nand\nand\nand\nand\nand\nand\nand\nand\nand\nand\nbe\nday\nday\nfirst\nform\nfrom\ngod\ngod\ngod\ngod\ngod\ngod\nhe\nin\nit\nlet\nlight\nlight\nlight\nlight\nlight\nnight\nof\nof\nof\nsaw\nthat\nthe\nthe\nthe\nthe\nthe\nthe\nthe\nthe\nthe\nthe\nthe\nthe\nthe\nthe\nthe\nthe\nthe\nwas\nwas\nwas\nwas\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef sort_and_calculate_variance(data):\n    n = len(data)\n    data.sort()\n    print(\"Sorted data:\", data)\n    \n    if n % 2 == 0:\n        median = (data[n//2 - 1] + data[n//2]) / 2\n    else:\n        median = data[n//2]\n    print(\"Median:\", median)\n    \n    mean = sum(data) / n\n    print(\"Mean:\", mean)\n\n    variance = sum((x - mean) ** 2 for x in data) / n\n    print(\"Variance:\", variance)\n    \n    return variance\n\ndataset = [\n    [25, 47, 12, 36, 54, 29, 41, 18, 33, 22],\n    [9, 17, 34, 11, 21, 5, 8, 13, 16, 27],\n    [48, 72, 30, 60, 39, 45, 51, 24, 66, 18],\n    [14, 22, 35, 27, 19, 31, 40, 13, 10, 26]\n]\n\nvariances = []\n\nfor data in dataset:\n    print(\"Processing new dataset...\")\n    variance = sort_and_calculate_variance(data)\n    variances.append(variance)\n    print(\"Intermediate variances:\", variances)\n    print(\"\")\n\noverall_mean_variance = sum(variances) / len(variances)\nprint(\"Overall Mean Variance:\", overall_mean_variance)\n\nsorted_variances = sorted(variances)\nprint(\"Sorted variances:\", sorted_variances)\n\nif len(sorted_variances) % 2 == 0:\n    median_variance = (sorted_variances[len(sorted_variances)//2 - 1] + sorted_variances[len(sorted_variances)//2]) / 2\nelse:\n    median_variance = sorted_variances[len(sorted_variances)//2]\n\nprint(\"Median of Variances:\", median_variance)"}, {"role": "assistant", "content": "Processing new dataset...\nSorted data: [12, 18, 22, 25, 29, 33, 36, 41, 47, 54]\nMedian: 31.0\nMean: 31.7\nVariance: 156.01\nIntermediate variances: [156.01]\n\nProcessing new dataset...\nSorted data: [5, 8, 9, 11, 13, 16, 17, 21, 27, 34]\nMedian: 14.5\nMean: 16.1\nVariance: 73.89\nIntermediate variances: [156.01, 73.89]\n\nProcessing new dataset...\nSorted data: [18, 24, 30, 39, 45, 48, 51, 60, 66, 72]\nMedian: 46.5\nMean: 45.3\nVariance: 287.01000000000005\nIntermediate variances: [156.01, 73.89, 287.01000000000005]\n\nProcessing new dataset...\nSorted data: [10, 13, 14, 19, 22, 26, 27, 31, 35, 40]\nMedian: 24.0\nMean: 23.7\nVariance: 88.41\nIntermediate variances: [156.01, 73.89, 287.01000000000005, 88.41]\n\nOverall Mean Variance: 151.33\nSorted variances: [73.89, 88.41, 156.01, 287.01000000000005]\nMedian of Variances: 122.21\n"}]}
{"messages": [{"role": "user", "content": "def fibonacci(n):\n    if n <= 0:\n        return []\n    elif n == 1:\n        return [0]\n    elif n == 2:\n        return [0, 1]\n\n    seq = [0, 1]\n    for i in range(2, n):\n        seq.append(seq[-1] + seq[-2])\n    return seq\n\ndef tribonacci_search(sequence, value, start, end):\n    if start > end:\n        return -1\n    mid1 = start + (end - start) // 3\n    mid2 = end - (end - start) // 3\n\n    if sequence[mid1] == value:\n        return mid1\n    if sequence[mid2] == value:\n        return mid2\n\n    if value < sequence[mid1]:\n        return tribonacci_search(sequence, value, start, mid1 - 1)\n    elif value > sequence[mid2]:\n        return tribonacci_search(sequence, value, mid2 + 1, end)\n    else:\n        return tribonacci_search(sequence, value, mid1 + 1, mid2 - 1)\n\nfib_sequence = fibonacci(40)\ntribonacci_values = [sum(fib_sequence[i:i+3]) for i in range(38)]\noutput = []\n\nfor value in tribonacci_values:\n    index = tribonacci_search(fib_sequence, value, 0, len(fib_sequence) - 1)\n    if index != -1:\n        output.append((value, index))\n\nfor item in output:\n    print(f\"Value: {item[0]}, Index: {item[1]}\")"}, {"role": "assistant", "content": "Value: 2, Index: 3\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndata = [\n    {\"date\": \"2023-09-01\", \"value\": 20},\n    {\"date\": \"2023-09-03\", \"value\": 15},\n    {\"date\": \"2023-09-02\", \"value\": 25},\n    {\"date\": \"2023-09-05\", \"value\": 30},\n    {\"date\": \"2023-09-04\", \"value\": 10}\n]\n\ndef parse_date(date_string):\n    return datetime.datetime.strptime(date_string, \"%Y-%m-%d\")\n\ndef sort_by_date(data):\n    return sorted(data, key=lambda x: parse_date(x[\"date\"]))\n\ndef sort_by_value(data):\n    return sorted(data, key=lambda x: x[\"value\"])\n\nsorted_by_date = sort_by_date(data)\nsorted_by_value = sort_by_value(data)\n\nprint(\"Sorted by Date:\")\nfor item in sorted_by_date:\n    print(item)\n\nprint(\"\\nSorted by Value:\")\nfor item in sorted_by_value:\n    print(item)\n\ndate_diffs = [\n    (parse_date(sorted_by_date[i + 1][\"date\"]) - parse_date(sorted_by_date[i][\"date\"])).days\n    for i in range(len(sorted_by_date) - 1)\n]\n\nvalue_diffs = [\n    sorted_by_value[i + 1][\"value\"] - sorted_by_value[i][\"value\"]\n    for i in range(len(sorted_by_value) - 1)\n]\n\nprint(\"\\nDate Differences:\")\nfor diff in date_diffs:\n    print(diff)\n\nprint(\"\\nValue Differences:\")\nfor diff in value_diffs:\n    print(diff)"}, {"role": "assistant", "content": "Sorted by Date:\n{'date': '2023-09-01', 'value': 20}\n{'date': '2023-09-02', 'value': 25}\n{'date': '2023-09-03', 'value': 15}\n{'date': '2023-09-04', 'value': 10}\n{'date': '2023-09-05', 'value': 30}\n\nSorted by Value:\n{'date': '2023-09-04', 'value': 10}\n{'date': '2023-09-03', 'value': 15}\n{'date': '2023-09-01', 'value': 20}\n{'date': '2023-09-02', 'value': 25}\n{'date': '2023-09-05', 'value': 30}\n\nDate Differences:\n1\n1\n1\n1\n\nValue Differences:\n5\n5\n5\n5\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef point_distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\ndef perimeter(points):\n    perim = 0\n    for i in range(len(points)):\n        perim += point_distance(points[i], points[(i + 1) % len(points)])\n    return perim\n\ndef closest_pair(points):\n    min_dist = float('inf')\n    pair = (None, None)\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            dist = point_distance(points[i], points[j])\n            if dist < min_dist:\n                min_dist = dist\n                pair = (points[i], points[j])\n    return pair, min_dist\n\ndef main():\n    points = [(3, 4), (5, 1), (9, 6), (8, 3), (2, 5), (7, 7), (6, 2), (4, 8)]\n    print(\"Points: \", points)\n    \n    print(\"\\nCalculating perimeter of the convex hull:\")\n    hull_perimeter = perimeter(points)\n    print(\"Perimeter of convex hull:\", hull_perimeter)\n    \n    print(\"\\nSearching for closest pair of points:\")\n    pair, min_distance = closest_pair(points)\n    print(\"Closest pair:\", pair, \"with distance:\", min_distance)\n\nmain()"}, {"role": "assistant", "content": "Points:  [(3, 4), (5, 1), (9, 6), (8, 3), (2, 5), (7, 7), (6, 2), (4, 8)]\n\nCalculating perimeter of the convex hull:\nPerimeter of convex hull: 40.42735376008368\n\nSearching for closest pair of points:\nClosest pair: ((3, 4), (2, 5)) with distance: 1.4142135623730951\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef cosine_similarity(v1, v2):\n    dot_product = sum(a * b for a, b in zip(v1, v2))\n    magnitude1 = math.sqrt(sum(a * a for a in v1))\n    magnitude2 = math.sqrt(sum(b * b for b in v2))\n    if not magnitude1 or not magnitude2:\n        return 0\n    return dot_product / (magnitude1 * magnitude2)\n\ndef search_similar_vector(vectors, query):\n    similarities = [(i, cosine_similarity(v, query)) for i, v in enumerate(vectors)]\n    similarities.sort(key=lambda x: x[1], reverse=True)\n    return similarities\n\nvectors = [\n    [0.1, 0.2, 0.3],\n    [0.3, 0.2, 0.1],\n    [0.4, 0.4, 0.4],\n    [0.5, 0.5, 0.5],\n    [0.6, 0.6, 0.6],\n    [0.7, 0.7, 0.7],\n    [0.8, 0.1, 0.1],\n    [0.2, 0.8, 0.2],\n    [0.1, 0.1, 0.9],\n    [0.9, 0.9, 0.9],\n]\n\nquery_vector = [0.5, 0.5, 0.5]\nsimilarity_results = search_similar_vector(vectors, query_vector)\n\nfor index, score in similarity_results:\n    print(f\"Vector {index} similarity: {score:.2f}\")"}, {"role": "assistant", "content": "Vector 3 similarity: 1.00\nVector 9 similarity: 1.00\nVector 2 similarity: 1.00\nVector 5 similarity: 1.00\nVector 4 similarity: 1.00\nVector 0 similarity: 0.93\nVector 1 similarity: 0.93\nVector 7 similarity: 0.82\nVector 6 similarity: 0.71\nVector 8 similarity: 0.70\n"}]}
{"messages": [{"role": "user", "content": "def find_winner(grid, target):\n    def check_direction(x, y, dx, dy):\n        count = 0\n        for _ in range(target):\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == player:\n                count += 1\n            else:\n                break\n            x += dx\n            y += dy\n        return count == target\n\n    def search_winner():\n        for x in range(len(grid)):\n            for y in range(len(grid[0])):\n                if grid[x][y] != 0:\n                    global player\n                    player = grid[x][y]\n                    if (check_direction(x, y, 1, 0) or\n                        check_direction(x, y, 0, 1) or\n                        check_direction(x, y, 1, 1) or\n                        check_direction(x, y, 1, -1)):\n                        return player\n        return 0\n\n    return search_winner()\n\ngrid = [\n    [1, 2, 0, 2, 1],\n    [2, 1, 2, 1, 0],\n    [1, 1, 2, 2, 1],\n    [0, 2, 1, 1, 2],\n    [1, 0, 0, 2, 1]\n]\n\ntarget = 3\nwinner = find_winner(grid, target)\nwinner_str = \"No winner\" if winner == 0 else f\"Player {winner} wins\"\nprint(winner_str)"}, {"role": "assistant", "content": "Player 2 wins\n"}]}
{"messages": [{"role": "user", "content": "def sort_by_sum_of_digits(numbers):\n    def sum_of_digits(n):\n        return sum(int(digit) for digit in str(n))\n\n    return sorted(numbers, key=sum_of_digits, reverse=True)\n\nnumbers = [\n    314, 271, 415, 592, 653, 589, 793, 238, 462, 643, 383, 279,\n    502, 884, 197, 169, 399, 375, 105, 820, 974, 944, 592, 307,\n    816, 406, 286, 208, 998, 628, 345, 123, 456, 789, 234, 567,\n    890, 135, 246, 357, 468, 579, 680, 791, 902, 103, 204, 305\n]\n\nsorted_numbers = sort_by_sum_of_digits(numbers)\n\nfor num in sorted_numbers:\n    print(num)"}, {"role": "assistant", "content": "998\n789\n589\n399\n579\n884\n974\n793\n279\n567\n468\n197\n944\n890\n791\n592\n169\n592\n286\n628\n375\n816\n456\n357\n653\n383\n680\n238\n643\n462\n345\n246\n902\n271\n415\n820\n307\n406\n208\n234\n135\n314\n305\n502\n105\n123\n204\n103\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndates = [\n    \"2023-05-15 14:30:00\",\n    \"2023-01-10 06:00:00\",\n    \"2023-12-25 00:00:00\",\n    \"2023-07-04 12:00:00\",\n    \"2023-11-11 11:11:11\",\n    \"2023-09-19 19:19:19\",\n    \"2023-03-01 03:03:03\",\n    \"2023-08-08 08:08:08\",\n    \"2023-04-22 22:22:22\",\n    \"2023-06-30 23:59:59\"\n]\n\ndate_objects = [datetime.strptime(date, \"%Y-%m-%d %H:%M:%S\") for date in dates]\n\ndef date_sort_key(date_obj):\n    return (date_obj.month, -date_obj.day, date_obj.hour, date_obj.minute, date_obj.second)\n\nsorted_dates = sorted(date_objects, key=date_sort_key)\n\nfor date in sorted_dates:\n    print(date.strftime(\"%Y-%m-%d %H:%M:%S\"))"}, {"role": "assistant", "content": "2023-01-10 06:00:00\n2023-03-01 03:03:03\n2023-04-22 22:22:22\n2023-05-15 14:30:00\n2023-06-30 23:59:59\n2023-07-04 12:00:00\n2023-08-08 08:08:08\n2023-09-19 19:19:19\n2023-11-11 11:11:11\n2023-12-25 00:00:00\n"}]}
{"messages": [{"role": "user", "content": "from itertools import cycle\n\ndef caesar_cipher_encode(text, shift):\n    encrypted = []\n    for char in text:\n        if char.isalpha():\n            shift_amount = shift if char.islower() else shift.upper() - shift.lower()\n            new_char = chr((ord(char) - shift_amount) % 26 + ord('a'))\n            encrypted.append(new_char)\n        else:\n            encrypted.append(char)\n    return ''.join(encrypted)\n\ndef sort_encoded_strings(strings):\n    return sorted(strings, key=lambda x: [ord(c) for c in x])\n\ntext = \"encryption is fun with python\"\nshift_sequence = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9]\nshift_cycled = cycle(shift_sequence)\nencoded_strings = [caesar_cipher_encode(text, next(shift_cycled)) for _ in range(10)]\n\nsorted_encoded = sort_encoded_strings(encoded_strings)\nfor encoded in sorted_encoded:\n    print(encoded)"}, {"role": "assistant", "content": "oxmbizdsyx sc pex gsdr zidryx\nrapelcgvba vf sha jvgu clguba\nsbqfmdhwcb wg tib kwhv dmhvcb\nsbqfmdhwcb wg tib kwhv dmhvcb\ntcrgneixdc xh ujc lxiw eniwdc\nudshofjyed yi vkd myjx fojxed\nudshofjyed yi vkd myjx fojxed\nvetipgkzfe zj wle nzky gpkyfe\nwfujqhlagf ak xmf oalz hqlzgf\nwfujqhlagf ak xmf oalz hqlzgf\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef rank_players(players):\n    players = sorted(players, key=lambda x: x[1], reverse=True)\n    return sorted(players, key=lambda x: x[2])\n\ndef calculate_score(player, date):\n    base_score = player[1]\n    days_active = (datetime.datetime.now() - date).days\n    return base_score + days_active\n\nplayers = [\n    (\"Alice\", 2500, datetime.datetime(2023, 1, 5)),\n    (\"Bob\", 3400, datetime.datetime(2023, 3, 15)),\n    (\"Charlie\", 3200, datetime.datetime(2023, 2, 10)),\n    (\"Diana\", 3000, datetime.datetime(2023, 9, 1)),\n    (\"Eve\", 3100, datetime.datetime(2023, 6, 5)),\n    (\"Frank\", 3300, datetime.datetime(2023, 4, 20)),\n    (\"Grace\", 2900, datetime.datetime(2023, 7, 25)),\n    (\"Hank\", 2800, datetime.datetime(2023, 8, 10)),\n    (\"Ivy\", 2600, datetime.datetime(2023, 5, 30)),\n    (\"Jack\", 2700, datetime.datetime(2023, 2, 20))\n]\n\nfor i, player in enumerate(players):\n    score = calculate_score(player, player[2])\n    players[i] = (player[0], score, player[2])\n    print(f\"Player: {player[0]}, Base Score: {player[1]}, Score with Activity: {score}\")\n\nranked_players = rank_players(players)\n\nprint(\"\\nFinal Rankings:\")\nfor rank, player in enumerate(ranked_players, start=1):\n    print(f\"Rank {rank}: {player[0]}, Total Score: {player[1]}\")"}, {"role": "assistant", "content": "Player: Alice, Base Score: 2500, Score with Activity: 3317\nPlayer: Bob, Base Score: 3400, Score with Activity: 4148\nPlayer: Charlie, Base Score: 3200, Score with Activity: 3981\nPlayer: Diana, Base Score: 3000, Score with Activity: 3578\nPlayer: Eve, Base Score: 3100, Score with Activity: 3766\nPlayer: Frank, Base Score: 3300, Score with Activity: 4012\nPlayer: Grace, Base Score: 2900, Score with Activity: 3516\nPlayer: Hank, Base Score: 2800, Score with Activity: 3400\nPlayer: Ivy, Base Score: 2600, Score with Activity: 3272\nPlayer: Jack, Base Score: 2700, Score with Activity: 3471\n\nFinal Rankings:\nRank 1: Alice, Total Score: 3317\nRank 2: Charlie, Total Score: 3981\nRank 3: Jack, Total Score: 3471\nRank 4: Bob, Total Score: 4148\nRank 5: Frank, Total Score: 4012\nRank 6: Ivy, Total Score: 3272\nRank 7: Eve, Total Score: 3766\nRank 8: Grace, Total Score: 3516\nRank 9: Hank, Total Score: 3400\nRank 10: Diana, Total Score: 3578\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef calculate_polygon_area(vertices):\n    area = 0.0\n    n = len(vertices)\n    for i in range(n):\n        j = (i + 1) % n\n        area += vertices[i][0] * vertices[j][1]\n        area -= vertices[j][0] * vertices[i][1]\n    area = abs(area) / 2.0\n    print(f\"Calculated area: {area}\")\n    return area\n\ndef sort_polygons_by_area(polygons):\n    print(\"Calculating areas for sorting...\")\n    polygon_areas = [(polygon, calculate_polygon_area(polygon)) for polygon in polygons]\n    print(\"Sorting polygons by area...\")\n    sorted_polygons = sorted(polygon_areas, key=lambda x: x[1])\n    return sorted_polygons\n\npolygons = [\n    [(0, 0), (4, 0), (4, 3)],  # Triangle\n    [(0, 0), (4, 0), (4, 4), (0, 4)],  # Square\n    [(0, 0), (2, 0), (1, 1)],  # Small Triangle\n    [(0, 0), (5, 0), (5, 2), (3, 4), (0, 3)],  # Irregular\n    [(0, 0), (10, 0), (10, 10), (0, 10)],  # Large Square\n]\n\nsorted_polygons = sort_polygons_by_area(polygons)\n\nprint(\"\\nPolygons sorted by area (from smallest to largest):\")\nfor i, (polygon, area) in enumerate(sorted_polygons):\n    print(f\"Polygon {i+1}: Vertices = {polygon}, Area = {area:.2f}\")"}, {"role": "assistant", "content": "Calculating areas for sorting...\nCalculated area: 6.0\nCalculated area: 16.0\nCalculated area: 1.0\nCalculated area: 16.5\nCalculated area: 100.0\nSorting polygons by area...\n\nPolygons sorted by area (from smallest to largest):\nPolygon 1: Vertices = [(0, 0), (2, 0), (1, 1)], Area = 1.00\nPolygon 2: Vertices = [(0, 0), (4, 0), (4, 3)], Area = 6.00\nPolygon 3: Vertices = [(0, 0), (4, 0), (4, 4), (0, 4)], Area = 16.00\nPolygon 4: Vertices = [(0, 0), (5, 0), (5, 2), (3, 4), (0, 3)], Area = 16.50\nPolygon 5: Vertices = [(0, 0), (10, 0), (10, 10), (0, 10)], Area = 100.00\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef mean(data):\n    return sum(data) / len(data)\n\ndef standard_deviation(data):\n    avg = mean(data)\n    variance = sum((x - avg) ** 2 for x in data) / len(data)\n    return math.sqrt(variance)\n\ndef z_score(data, value):\n    avg = mean(data)\n    std_dev = standard_deviation(data)\n    return (value - avg) / std_dev\n\ndata = [15, 21, 32, 45, 10, 5, 2, 31, 27, 29, 48, 50, 61, 64, 100, 85, 78, 71, 55, 42, 38, 36, 23]\n\nz_scores = [(x, z_score(data, x)) for x in data]\n\nsorted_z_scores = sorted(z_scores, key=lambda x: abs(x[1]), reverse=True)\n\nfor value, z in sorted_z_scores:\n    print(f\"Value: {value}, Z-score: {z:.2f}\")"}, {"role": "assistant", "content": "Value: 100, Z-score: 2.29\nValue: 85, Z-score: 1.70\nValue: 2, Z-score: -1.59\nValue: 5, Z-score: -1.47\nValue: 78, Z-score: 1.42\nValue: 10, Z-score: -1.27\nValue: 71, Z-score: 1.15\nValue: 15, Z-score: -1.07\nValue: 64, Z-score: 0.87\nValue: 21, Z-score: -0.84\nValue: 23, Z-score: -0.76\nValue: 61, Z-score: 0.75\nValue: 27, Z-score: -0.60\nValue: 29, Z-score: -0.52\nValue: 55, Z-score: 0.51\nValue: 31, Z-score: -0.44\nValue: 32, Z-score: -0.40\nValue: 50, Z-score: 0.31\nValue: 36, Z-score: -0.24\nValue: 48, Z-score: 0.23\nValue: 38, Z-score: -0.16\nValue: 45, Z-score: 0.12\nValue: 42, Z-score: -0.00\n"}]}
{"messages": [{"role": "user", "content": "import string\n\ndef vigenere_encrypt(plaintext, key):\n    alphabet = string.ascii_uppercase\n    key = key.upper()\n    encrypted = []\n    key_index = 0\n\n    for char in plaintext:\n        if char.upper() in alphabet:\n            shift = alphabet.index(key[key_index])\n            new_char = alphabet[(alphabet.index(char.upper()) + shift) % len(alphabet)]\n            encrypted.append(new_char if char.isupper() else new_char.lower())\n            key_index = (key_index + 1) % len(key)\n        else:\n            encrypted.append(char)\n\n    return ''.join(encrypted)\n\ndef binary_search_decrypt(ciphertext, keys):\n    def decrypt_with_key(ciphertext, key):\n        alphabet = string.ascii_uppercase\n        decrypted = []\n        key_index = 0\n\n        for char in ciphertext:\n            if char.upper() in alphabet:\n                shift = alphabet.index(key[key_index])\n                new_char = alphabet[(alphabet.index(char.upper()) - shift) % len(alphabet)]\n                decrypted.append(new_char if char.isupper() else new_char.lower())\n                key_index = (key_index + 1) % len(key)\n            else:\n                decrypted.append(char)\n\n        return ''.join(decrypted)\n\n    left, right = 0, len(keys) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        decrypted_text = decrypt_with_key(ciphertext, keys[mid])\n        if \"SECRET\" in decrypted_text.upper():\n            return decrypted_text\n        elif \"SECRET\" < decrypted_text.upper():\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return \"Decryption key not found.\"\n\nplaintext = \"HELLO VIGENERE CIPHER\"\nkey = \"KEY\"\nciphertext = vigenere_encrypt(plaintext, key)\n\nkeys = [\"ABC\", \"DEF\", \"KEY\", \"XYZ\", \"MNO\"]\ndecrypted_message = binary_search_decrypt(ciphertext, keys)\nprint(\"Ciphertext:\", ciphertext)\nprint(\"Decrypted Message:\", decrypted_message)"}, {"role": "assistant", "content": "Ciphertext: RIJVS TSKCXIPO GGZLCB\nDecrypted Message: Decryption key not found.\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef create_timestamps(start_date, num_days):\n    timestamps = []\n    base_date = datetime.strptime(start_date, \"%Y-%m-%d\")\n    for i in range(num_days):\n        timestamps.append(base_date + timedelta(days=i))\n    return timestamps\n\ndef binary_search(timestamps, target):\n    low = 0\n    high = len(timestamps) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if timestamps[mid] == target:\n            return mid\n        elif timestamps[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n\nstart_date = \"2023-01-01\"\ndates = create_timestamps(start_date, 100)\nsearch_date = datetime(2023, 2, 15)\n\nresult = binary_search(dates, search_date)\n\nfor i in dates:\n    print(i.strftime(\"%Y-%m-%d\"))\n\nprint(\"\\nSearching for:\", search_date.strftime(\"%Y-%m-%d\"))\nprint(\"Found at index:\" if result != -1 else \"Not found\", result)"}, {"role": "assistant", "content": "2023-01-01\n2023-01-02\n2023-01-03\n2023-01-04\n2023-01-05\n2023-01-06\n2023-01-07\n2023-01-08\n2023-01-09\n2023-01-10\n2023-01-11\n2023-01-12\n2023-01-13\n2023-01-14\n2023-01-15\n2023-01-16\n2023-01-17\n2023-01-18\n2023-01-19\n2023-01-20\n2023-01-21\n2023-01-22\n2023-01-23\n2023-01-24\n2023-01-25\n2023-01-26\n2023-01-27\n2023-01-28\n2023-01-29\n2023-01-30\n2023-01-31\n2023-02-01\n2023-02-02\n2023-02-03\n2023-02-04\n2023-02-05\n2023-02-06\n2023-02-07\n2023-02-08\n2023-02-09\n2023-02-10\n2023-02-11\n2023-02-12\n2023-02-13\n2023-02-14\n2023-02-15\n2023-02-16\n2023-02-17\n2023-02-18\n2023-02-19\n2023-02-20\n2023-02-21\n2023-02-22\n2023-02-23\n2023-02-24\n2023-02-25\n2023-02-26\n2023-02-27\n2023-02-28\n2023-03-01\n2023-03-02\n2023-03-03\n2023-03-04\n2023-03-05\n2023-03-06\n2023-03-07\n2023-03-08\n2023-03-09\n2023-03-10\n2023-03-11\n2023-03-12\n2023-03-13\n2023-03-14\n2023-03-15\n2023-03-16\n2023-03-17\n2023-03-18\n2023-03-19\n2023-03-20\n2023-03-21\n2023-03-22\n2023-03-23\n2023-03-24\n2023-03-25\n2023-03-26\n2023-03-27\n2023-03-28\n2023-03-29\n2023-03-30\n2023-03-31\n2023-04-01\n2023-04-02\n2023-04-03\n2023-04-04\n2023-04-05\n2023-04-06\n2023-04-07\n2023-04-08\n2023-04-09\n2023-04-10\n\nSearching for: 2023-02-15\nFound at index: 45\n"}]}
{"messages": [{"role": "user", "content": "from math import sqrt\n\ndef generate_pattern(n):\n    pattern = []\n    for i in range(n):\n        row = [' '] * n\n        row[i] = '*'\n        row[n - i - 1] = '*'\n        pattern.append(''.join(row))\n    return pattern\n\ndef search_diagonals(pattern, target):\n    n = len(pattern)\n    for d in range(-n + 1, n):\n        diagonal = [pattern[i][i + d] for i in range(max(-d, 0), min(n - d, n))]\n        if target in ''.join(diagonal):\n            return d\n    return None\n\nn = 15\npattern = generate_pattern(n)\ntarget = '*'\n\nresult = search_diagonals(pattern, target)\nif result is not None:\n    for line in pattern:\n        print(line)\nelse:\n    print('Pattern not found')"}, {"role": "assistant", "content": "*             *\n *           * \n  *         *  \n   *       *   \n    *     *    \n     *   *     \n      * *      \n       *       \n      * *      \n     *   *     \n    *     *    \n   *       *   \n  *         *  \n *           * \n*             *\n"}]}
{"messages": [{"role": "user", "content": "import math\nimport statistics\n\ndata = [\n    5.3, 2.1, 8.7, 4.4, 9.1, 6.5, 7.8, 3.7, 1.9, 5.5, 2.8, 9.0, 4.6, 7.1, 6.3,\n    8.9, 3.3, 5.8, 6.7, 7.2, 8.1, 4.5, 9.2, 2.0, 3.9, 4.8, 5.1, 7.0, 8.6, 9.4\n]\n\ndef quicksort(arr):\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    return quicksort(left) + middle + quicksort(right)\n\nsorted_data = quicksort(data)\n\ndef calculate_advanced_statistics(sorted_data):\n    n = len(sorted_data)\n    q1 = sorted_data[n // 4]\n    q3 = sorted_data[3 * n // 4]\n    iqr = q3 - q1\n\n    def pearson_skewness(mean, median, std_dev):\n        return (3 * (mean - median)) / std_dev\n\n    mean = statistics.mean(sorted_data)\n    median = statistics.median(sorted_data)\n    std_dev = statistics.stdev(sorted_data)\n    skewness = pearson_skewness(mean, median, std_dev)\n    \n    return {\n        'mean': mean,\n        'median': median,\n        'std_dev': std_dev,\n        'iqr': iqr,\n        'skewness': skewness\n    }\n\nadvanced_stats = calculate_advanced_statistics(sorted_data)\n\nfor k, v in advanced_stats.items():\n    print(f\"{k}: {v:.2f}\")"}, {"role": "assistant", "content": "mean: 5.98\nmedian: 6.05\nstd_dev: 2.35\niqr: 3.70\nskewness: -0.09\n"}]}
{"messages": [{"role": "user", "content": "def is_fibonacci(n, prev=0, curr=1):\n    if n == curr:\n        return True\n    elif curr > n:\n        return False\n    return is_fibonacci(n, curr, prev + curr)\n\ndef is_square(n):\n    return int(n**0.5)**2 == n\n\ndef is_special_number(n):\n    if is_fibonacci(n) or is_square(n):\n        return True\n    return False\n\ndef special_numbers_in_sequence(seq):\n    results = []\n    for num in seq:\n        if is_special_number(num):\n            results.append(num)\n    return results\n\nsequence = [i for i in range(1, 101)]\nspecial_numbers = special_numbers_in_sequence(sequence)\n\nprint(\"Sequence:\", sequence)\nprint(\"\\nFinding special numbers (Fibonacci or perfect squares)...\\n\")\n\nfor num in special_numbers:\n    print(num)"}, {"role": "assistant", "content": "Sequence: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]\n\nFinding special numbers (Fibonacci or perfect squares)...\n\n1\n2\n3\n4\n5\n8\n9\n13\n16\n21\n25\n34\n36\n49\n55\n64\n81\n89\n100\n"}]}
{"messages": [{"role": "user", "content": "text = \"The quick brown fox jumps over the lazy dog. A wizard's job is to vex chumps quickly in fog.\"\n\nwords = text.split()\nword_lengths = [(word, len(word)) for word in words]\n\nprint(\"Words and their lengths:\")\nfor word, length in word_lengths:\n    print(f\"{word}: {length}\")\n\nsorted_by_length = sorted(word_lengths, key=lambda x: x[1])\n\nprint(\"\\nWords sorted by length:\")\nfor word, length in sorted_by_length:\n    print(f\"{word}: {length}\")\n\ndistinct_lengths = sorted(set(length for _, length in word_lengths))\n\nprint(\"\\nDistinct word lengths:\")\nprint(distinct_lengths)\n\nlength_frequency = {length: 0 for length in distinct_lengths}\n\nfor _, length in word_lengths:\n    length_frequency[length] += 1\n\nprint(\"\\nFrequency of each word length:\")\nfor length, frequency in length_frequency.items():\n    print(f\"Length {length}: {frequency} occurrence(s)\")"}, {"role": "assistant", "content": "Words and their lengths:\nThe: 3\nquick: 5\nbrown: 5\nfox: 3\njumps: 5\nover: 4\nthe: 3\nlazy: 4\ndog.: 4\nA: 1\nwizard's: 8\njob: 3\nis: 2\nto: 2\nvex: 3\nchumps: 6\nquickly: 7\nin: 2\nfog.: 4\n\nWords sorted by length:\nA: 1\nis: 2\nto: 2\nin: 2\nThe: 3\nfox: 3\nthe: 3\njob: 3\nvex: 3\nover: 4\nlazy: 4\ndog.: 4\nfog.: 4\nquick: 5\nbrown: 5\njumps: 5\nchumps: 6\nquickly: 7\nwizard's: 8\n\nDistinct word lengths:\n[1, 2, 3, 4, 5, 6, 7, 8]\n\nFrequency of each word length:\nLength 1: 1 occurrence(s)\nLength 2: 3 occurrence(s)\nLength 3: 5 occurrence(s)\nLength 4: 4 occurrence(s)\nLength 5: 3 occurrence(s)\nLength 6: 1 occurrence(s)\nLength 7: 1 occurrence(s)\nLength 8: 1 occurrence(s)\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef sieve_of_eratosthenes(limit):\n    is_prime = [True] * (limit + 1)\n    p = 2\n    while (p * p <= limit):\n        if (is_prime[p] == True):\n            for i in range(p * p, limit + 1, p):\n                is_prime[i] = False\n        p += 1\n    return [p for p in range(2, limit) if is_prime[p]]\n\ndef custom_sort(sequence):\n    return sorted(sequence, key=lambda x: (x % 3, x))\n\ndef generate_sequence(n):\n    return [math.factorial(i) for i in range(1, n + 1)]\n\nprime_limit = 30\nsequence_length = 10\n\nprimes = sieve_of_eratosthenes(prime_limit)\nsequence = generate_sequence(sequence_length)\nsorted_sequence = custom_sort(sequence)\n\noutput = sorted_sequence + primes\nfor number in output:\n    print(number)"}, {"role": "assistant", "content": "6\n24\n120\n720\n5040\n40320\n362880\n3628800\n1\n2\n2\n3\n5\n7\n11\n13\n17\n19\n23\n29\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\ndef sort_dates_and_times(dates_times):\n    return sorted(dates_times, key=lambda dt: datetime.strptime(dt, '%Y-%m-%d %H:%M:%S'))\n\ndates_and_times = [\n    '2023-10-01 14:30:00',\n    '2023-10-01 09:15:30',\n    '2023-10-01 18:45:15',\n    '2023-10-01 12:00:00',\n    '2023-10-01 05:30:45',\n    '2023-10-01 23:59:59',\n    '2023-10-01 00:00:00',\n    '2023-10-01 16:00:00',\n    '2023-10-01 11:11:11',\n    '2023-10-01 03:30:30',\n    '2023-10-01 13:00:00',\n    '2023-10-01 08:45:45',\n    '2023-10-01 07:00:00'\n]\n\nsorted_dates_times = sort_dates_and_times(dates_and_times)\n\nprint(\"Sorted Dates and Times:\")\nfor dt in sorted_dates_times:\n    print(dt)\n\ndef sort_times_only(dates_times):\n    return sorted(dates_times, key=lambda dt: datetime.strptime(dt.split()[1], '%H:%M:%S'))\n\nsorted_times = sort_times_only(dates_and_times)\n\nprint(\"\\nSorted Times Only (Bugged):\")\nfor t in sorted_times:\n    print(t)"}, {"role": "assistant", "content": "Sorted Dates and Times:\n2023-10-01 00:00:00\n2023-10-01 03:30:30\n2023-10-01 05:30:45\n2023-10-01 07:00:00\n2023-10-01 08:45:45\n2023-10-01 09:15:30\n2023-10-01 11:11:11\n2023-10-01 12:00:00\n2023-10-01 13:00:00\n2023-10-01 14:30:00\n2023-10-01 16:00:00\n2023-10-01 18:45:15\n2023-10-01 23:59:59\n\nSorted Times Only (Bugged):\n2023-10-01 00:00:00\n2023-10-01 03:30:30\n2023-10-01 05:30:45\n2023-10-01 07:00:00\n2023-10-01 08:45:45\n2023-10-01 09:15:30\n2023-10-01 11:11:11\n2023-10-01 12:00:00\n2023-10-01 13:00:00\n2023-10-01 14:30:00\n2023-10-01 16:00:00\n2023-10-01 18:45:15\n2023-10-01 23:59:59\n"}]}
{"messages": [{"role": "user", "content": "import datetime\nfrom math import sqrt\n\ndef is_perfect_square(x):\n    s = int(sqrt(x))\n    return s * s == x\n\ndef fibonacci_sequence(n):\n    a, b = 0, 1\n    for _ in range(n):\n        yield a\n        a, b = b, a + b\n\ndef date_to_number(date):\n    return date.year * 10000 + date.month * 100 + date.day\n\ndef number_to_date(num):\n    year = num // 10000\n    month = (num % 10000) // 100\n    day = num % 100\n    return datetime.date(year, month, day)\n\ndates = [datetime.date(2023, i % 12 + 1, i % 28 + 1) for i in range(50)]\nfibonacci_dates = list(fibonacci_sequence(50))\n\ndate_numbers = list(map(date_to_number, dates))\nfib_numbers = [num for num in fibonacci_dates if is_perfect_square(num)]\n\nsorted_date_numbers = sorted(date_numbers)\nsorted_fib_numbers = sorted(fib_numbers)\n\nprint(\"Sorted Date Numbers:\")\nfor num in sorted_date_numbers:\n    print(num)\n\nprint(\"\\nSorted Fibonacci Perfect Squares:\")\nfor num in sorted_fib_numbers:\n    print(num)\n\nprint(\"\\nCorresponding Dates for Sorted Date Numbers:\")\nfor num in sorted_date_numbers:\n    print(number_to_date(num))"}, {"role": "assistant", "content": "Sorted Date Numbers:\n20230101\n20230109\n20230113\n20230121\n20230125\n20230202\n20230210\n20230214\n20230222\n20230226\n20230303\n20230311\n20230315\n20230327\n20230404\n20230412\n20230416\n20230428\n20230501\n20230505\n20230513\n20230517\n20230602\n20230606\n20230614\n20230618\n20230703\n20230707\n20230715\n20230719\n20230804\n20230808\n20230816\n20230820\n20230905\n20230909\n20230917\n20230921\n20231006\n20231010\n20231018\n20231022\n20231107\n20231111\n20231119\n20231123\n20231208\n20231212\n20231220\n20231224\n\nSorted Fibonacci Perfect Squares:\n0\n1\n1\n144\n\nCorresponding Dates for Sorted Date Numbers:\n2023-01-01\n2023-01-09\n2023-01-13\n2023-01-21\n2023-01-25\n2023-02-02\n2023-02-10\n2023-02-14\n2023-02-22\n2023-02-26\n2023-03-03\n2023-03-11\n2023-03-15\n2023-03-27\n2023-04-04\n2023-04-12\n2023-04-16\n2023-04-28\n2023-05-01\n2023-05-05\n2023-05-13\n2023-05-17\n2023-06-02\n2023-06-06\n2023-06-14\n2023-06-18\n2023-07-03\n2023-07-07\n2023-07-15\n2023-07-19\n2023-08-04\n2023-08-08\n2023-08-16\n2023-08-20\n2023-09-05\n2023-09-09\n2023-09-17\n2023-09-21\n2023-10-06\n2023-10-10\n2023-10-18\n2023-10-22\n2023-11-07\n2023-11-11\n2023-11-19\n2023-11-23\n2023-12-08\n2023-12-12\n2023-12-20\n2023-12-24\n"}]}
{"messages": [{"role": "user", "content": "def evaluate_hand_strength(cards):\n    values = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7,\n              '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14}\n    hand_strength = sum(values[card] for card in cards)\n    return hand_strength\n\ndef sort_hands(hands):\n    return sorted(hands, key=evaluate_hand_strength, reverse=True)\n\nplayers_hands = [\n    ['10', 'J', 'Q', 'K', 'A'],\n    ['2', '3', '4', '5', '6'],\n    ['9', '10', 'J', 'Q', 'K'],\n    ['3', '4', '5', '6', '7'],\n    ['A', '2', '3', '4', '5'],\n    ['7', '8', '9', '10', 'J'],\n    ['5', '6', '7', '8', '9']\n]\n\nsorted_hands = sort_hands(players_hands)\n\nfor index, hand in enumerate(sorted_hands, start=1):\n    print(f\"Rank {index}: {' '.join(hand)}\")"}, {"role": "assistant", "content": "Rank 1: 10 J Q K A\nRank 2: 9 10 J Q K\nRank 3: 7 8 9 10 J\nRank 4: 5 6 7 8 9\nRank 5: A 2 3 4 5\nRank 6: 3 4 5 6 7\nRank 7: 2 3 4 5 6\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef point_in_circle(x, y, circle):\n    cx, cy, r = circle\n    return math.sqrt((x - cx) ** 2 + (y - cy) ** 2) <= r\n\ndef search_largest_circle(points, circles):\n    largest_circle = None\n\n    for circle in circles:\n        all_points_inside = True\n        for x, y in points:\n            if not point_in_circle(x, y, circle):\n                all_points_inside = False\n                break\n        if all_points_inside:\n            if largest_circle is None or circle[2] < largest_circle[2]:\n                largest_circle = circle\n\n    return largest_circle\n\npoints = [\n    (2, 2), (3, 4), (5, 1), (6, 5), (8, 3),\n    (1, 7), (9, 8), (4, 6), (7, 2), (0, 0)\n]\n\ncircles = [\n    (5, 5, 10), (8, 8, 2), (2, 2, 3), (7, 2, 5), (4, 4, 6),\n    (0, 0, 1), (6, 6, 4), (5, 5, 5), (3, 3, 2), (9, 9, 1)\n]\n\nlargest_circle = search_largest_circle(points, circles)\n\nif largest_circle:\n    print(\"Largest circle containing all points:\", largest_circle)\nelse:\n    print(\"No circle contains all points.\")"}, {"role": "assistant", "content": "Largest circle containing all points: (5, 5, 10)\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef letter_frequency(text):\n    return {char: text.count(char) for char in set(text) if char.isalpha()}\n\ndef encode(text):\n    freq = letter_frequency(text)\n    freq_sorted = sorted(freq.items(), key=lambda x: (-x[1], x[0]))\n    encoding_map = {char: str(idx + 1) for idx, (char, _) in enumerate(freq_sorted)}\n    return ''.join(encoding_map.get(char, char) for char in text), encoding_map\n\ndef decode(encoded_text, encoding_map):\n    inverse_map = {v: k for k, v in encoding_map.items()}\n    pattern = re.compile('|'.join(map(re.escape, inverse_map.keys())))\n    return pattern.sub(lambda x: inverse_map[x.group()], encoded_text)\n\ntext = \"encryption is fun and educational\"\nencoded_text, encoding_map = encode(text)\ndecoded_text = decode(encoded_text, encoding_map)\n\nprint(\"Original Text:\", text)\nprint(\"Encoded Text:\", encoded_text)\nprint(\"Decoded Text:\", decoded_text)\nprint(\"Encoding Map:\", encoding_map)"}, {"role": "assistant", "content": "Original Text: encryption is fun and educational\nEncoded Text: 6141315128371 314 1091 215 659428371211\nDecoded Text: encnindnation inc n0un and educationann\nEncoding Map: {'n': '1', 'a': '2', 'i': '3', 'c': '4', 'd': '5', 'e': '6', 'o': '7', 't': '8', 'u': '9', 'f': '10', 'l': '11', 'p': '12', 'r': '13', 's': '14', 'y': '15'}\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef calculate_polygon_area(vertices):\n    n = len(vertices)\n    area = 0.0\n    for i in range(n):\n        j = (i + 1) % n\n        area += vertices[i][0] * vertices[j][1]\n        area -= vertices[j][0] * vertices[i][1]\n    area = abs(area) / 2.0\n    return area\n\ndef sort_by_area(polygons):\n    return sorted(polygons, key=calculate_polygon_area)\n\ndef main():\n    polygons = [\n        [(0, 0), (4, 0), (4, 3), (0, 3)],\n        [(0, 0), (3, 0), (3, 3), (0, 3)],\n        [(0, 0), (2, 0), (2, 2), (0, 2)],\n        [(0, 0), (5, 0), (5, 5), (0, 5)],\n        [(0, 0), (6, 0), (6, 1), (0, 1)],\n        [(0, 0), (1, 0), (1, 1), (0, 1)],\n        [(0, 0), (3, 0), (3, 2), (0, 2)],\n        [(0, 0), (4, 0), (4, 2), (0, 2)],\n        [(0, 0), (5, 0), (5, 3), (0, 3)],\n    ]\n\n    sorted_polygons = sort_by_area(polygons)\n    for i, polygon in enumerate(sorted_polygons):\n        print(f\"Polygon {i + 1}: Area = {calculate_polygon_area(polygon)}\")\n\nif __name__ == \"__main__\":\n    main()"}, {"role": "assistant", "content": "Polygon 1: Area = 1.0\nPolygon 2: Area = 4.0\nPolygon 3: Area = 6.0\nPolygon 4: Area = 6.0\nPolygon 5: Area = 8.0\nPolygon 6: Area = 9.0\nPolygon 7: Area = 12.0\nPolygon 8: Area = 15.0\nPolygon 9: Area = 25.0\n"}]}
{"messages": [{"role": "user", "content": "import statistics\n\ndef sort_and_calculate_mode(data):\n    sorted_data = sorted(data)\n    mode_value = statistics.median(sorted_data)\n    return sorted_data, mode_value\n\ndata = [8, 3, 5, 3, 9, 1, 4, 3, 7, 6, 2, 5, 5, 3, 6, 8, 7, 9, 5, 4, 2, 6, 1]\nsorted_data, mode_value = sort_and_calculate_mode(data)\n\nprint(\"Sorted Data:\")\nfor value in sorted_data:\n    print(value)\n\nprint(\"\\nCalculated Mode:\", mode_value)"}, {"role": "assistant", "content": "Sorted Data:\n1\n1\n2\n2\n3\n3\n3\n3\n4\n4\n5\n5\n5\n5\n6\n6\n6\n7\n7\n8\n8\n9\n9\n\nCalculated Mode: 5\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\nimport math\n\ndef date_to_ordinal(date_string):\n    return datetime.strptime(date_string, '%Y-%m-%d').toordinal()\n\ndef ordinal_to_date(ordinal):\n    return datetime.fromordinal(ordinal).strftime('%Y-%m-%d')\n\ndef date_distance(date1, date2):\n    return abs(date_to_ordinal(date1) - date_to_ordinal(date2))\n\ndef sort_dates_by_distance(dates, target_date):\n    distances = [(date, date_distance(date, target_date)) for date in dates]\n    distances.sort(key=lambda x: x[1])\n    return [date for date, _ in distances]\n\ndef generate_dates(base_date, num_dates, step):\n    base_ordinal = date_to_ordinal(base_date)\n    return [ordinal_to_date(base_ordinal + step * i) for i in range(num_dates)]\n\nbase_date = \"2023-01-01\"\nnum_dates = 50\nstep = 7\n\ndates = generate_dates(base_date, num_dates, step)\ntarget_date = \"2023-07-01\"\n\nprint(f\"Dates generated (every {step} days from {base_date}):\")\nfor date in dates:\n    print(date)\n\nsorted_dates = sort_dates_by_distance(dates, target_date)\n\nprint(\"\\nDates sorted by distance to target date (2023-07-01):\")\nfor date in sorted_dates:\n    print(date)"}, {"role": "assistant", "content": "Dates generated (every 7 days from 2023-01-01):\n2023-01-01\n2023-01-08\n2023-01-15\n2023-01-22\n2023-01-29\n2023-02-05\n2023-02-12\n2023-02-19\n2023-02-26\n2023-03-05\n2023-03-12\n2023-03-19\n2023-03-26\n2023-04-02\n2023-04-09\n2023-04-16\n2023-04-23\n2023-04-30\n2023-05-07\n2023-05-14\n2023-05-21\n2023-05-28\n2023-06-04\n2023-06-11\n2023-06-18\n2023-06-25\n2023-07-02\n2023-07-09\n2023-07-16\n2023-07-23\n2023-07-30\n2023-08-06\n2023-08-13\n2023-08-20\n2023-08-27\n2023-09-03\n2023-09-10\n2023-09-17\n2023-09-24\n2023-10-01\n2023-10-08\n2023-10-15\n2023-10-22\n2023-10-29\n2023-11-05\n2023-11-12\n2023-11-19\n2023-11-26\n2023-12-03\n2023-12-10\n\nDates sorted by distance to target date (2023-07-01):\n2023-07-02\n2023-06-25\n2023-07-09\n2023-06-18\n2023-07-16\n2023-06-11\n2023-07-23\n2023-06-04\n2023-07-30\n2023-05-28\n2023-08-06\n2023-05-21\n2023-08-13\n2023-05-14\n2023-08-20\n2023-05-07\n2023-08-27\n2023-04-30\n2023-09-03\n2023-04-23\n2023-09-10\n2023-04-16\n2023-09-17\n2023-04-09\n2023-09-24\n2023-04-02\n2023-10-01\n2023-03-26\n2023-10-08\n2023-03-19\n2023-10-15\n2023-03-12\n2023-10-22\n2023-03-05\n2023-10-29\n2023-02-26\n2023-11-05\n2023-02-19\n2023-11-12\n2023-02-12\n2023-11-19\n2023-02-05\n2023-11-26\n2023-01-29\n2023-12-03\n2023-01-22\n2023-12-10\n2023-01-15\n2023-01-08\n2023-01-01\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime\n\ndef date_to_day_of_year(date_str):\n    date_obj = datetime.strptime(date_str, '%Y-%m-%d')\n    return date_obj.timetuple().tm_yday\n\ndef find_common_day_of_year(dates):\n    day_count = {}\n    for date in dates:\n        day_of_year = date_to_day_of_year(date)\n        if day_of_year in day_count:\n            day_count[day_of_year] += 1\n        else:\n            day_count[day_of_year] = 1\n    \n    max_count = max(day_count.values())\n    common_days = [day for day, count in day_count.items() if count == max_count]\n    return sorted(common_days)\n\ndates = [\n    '2023-01-10', '2023-02-10', '2023-03-12', '2023-01-10', '2023-02-10',\n    '2023-03-12', '2023-01-10', '2023-04-10', '2023-05-10', '2023-06-10',\n    '2023-07-10', '2023-08-10', '2023-09-10', '2023-10-10', '2023-11-10',\n    '2023-12-10', '2023-01-10', '2023-02-10', '2023-03-12', '2023-01-10',\n    '2023-02-10', '2023-03-12', '2023-01-10', '2023-04-10', '2023-05-10',\n    '2023-06-10', '2023-07-10', '2023-08-10', '2023-09-10', '2023-10-10',\n    '2023-01-10', '2023-02-10', '2023-03-12', '2023-01-10', '2023-02-10',\n    '2023-03-12', '2023-01-10', '2023-04-10', '2023-05-10', '2023-06-10',\n    '2023-07-10', '2023-08-10', '2023-09-10', '2023-10-10', '2023-11-10',\n    '2023-12-10', '2023-01-10', '2023-02-10', '2023-03-12', '2023-01-10'\n]\n\ncommon_days = find_common_day_of_year(dates)\nprint(\"Most common days of the year:\", common_days)"}, {"role": "assistant", "content": "Most common days of the year: [10]\n"}]}
{"messages": [{"role": "user", "content": "from datetime import datetime, timedelta\n\ndef sort_dates_by_weekday(dates):\n    return sorted(dates, key=lambda date: date.weekday())\n\nstart_date = datetime(2023, 1, 1)\ndate_list = [start_date + timedelta(days=i) for i in range(100)]\n\nsorted_dates = sort_dates_by_weekday(date_list)\n\noutput = []\nfor date in sorted_dates:\n    output.append(date.strftime(\"%Y-%m-%d %A\"))\n\nfor line in output:\n    print(line)"}, {"role": "assistant", "content": "2023-01-02 Monday\n2023-01-09 Monday\n2023-01-16 Monday\n2023-01-23 Monday\n2023-01-30 Monday\n2023-02-06 Monday\n2023-02-13 Monday\n2023-02-20 Monday\n2023-02-27 Monday\n2023-03-06 Monday\n2023-03-13 Monday\n2023-03-20 Monday\n2023-03-27 Monday\n2023-04-03 Monday\n2023-04-10 Monday\n2023-01-03 Tuesday\n2023-01-10 Tuesday\n2023-01-17 Tuesday\n2023-01-24 Tuesday\n2023-01-31 Tuesday\n2023-02-07 Tuesday\n2023-02-14 Tuesday\n2023-02-21 Tuesday\n2023-02-28 Tuesday\n2023-03-07 Tuesday\n2023-03-14 Tuesday\n2023-03-21 Tuesday\n2023-03-28 Tuesday\n2023-04-04 Tuesday\n2023-01-04 Wednesday\n2023-01-11 Wednesday\n2023-01-18 Wednesday\n2023-01-25 Wednesday\n2023-02-01 Wednesday\n2023-02-08 Wednesday\n2023-02-15 Wednesday\n2023-02-22 Wednesday\n2023-03-01 Wednesday\n2023-03-08 Wednesday\n2023-03-15 Wednesday\n2023-03-22 Wednesday\n2023-03-29 Wednesday\n2023-04-05 Wednesday\n2023-01-05 Thursday\n2023-01-12 Thursday\n2023-01-19 Thursday\n2023-01-26 Thursday\n2023-02-02 Thursday\n2023-02-09 Thursday\n2023-02-16 Thursday\n2023-02-23 Thursday\n2023-03-02 Thursday\n2023-03-09 Thursday\n2023-03-16 Thursday\n2023-03-23 Thursday\n2023-03-30 Thursday\n2023-04-06 Thursday\n2023-01-06 Friday\n2023-01-13 Friday\n2023-01-20 Friday\n2023-01-27 Friday\n2023-02-03 Friday\n2023-02-10 Friday\n2023-02-17 Friday\n2023-02-24 Friday\n2023-03-03 Friday\n2023-03-10 Friday\n2023-03-17 Friday\n2023-03-24 Friday\n2023-03-31 Friday\n2023-04-07 Friday\n2023-01-07 Saturday\n2023-01-14 Saturday\n2023-01-21 Saturday\n2023-01-28 Saturday\n2023-02-04 Saturday\n2023-02-11 Saturday\n2023-02-18 Saturday\n2023-02-25 Saturday\n2023-03-04 Saturday\n2023-03-11 Saturday\n2023-03-18 Saturday\n2023-03-25 Saturday\n2023-04-01 Saturday\n2023-04-08 Saturday\n2023-01-01 Sunday\n2023-01-08 Sunday\n2023-01-15 Sunday\n2023-01-22 Sunday\n2023-01-29 Sunday\n2023-02-05 Sunday\n2023-02-12 Sunday\n2023-02-19 Sunday\n2023-02-26 Sunday\n2023-03-05 Sunday\n2023-03-12 Sunday\n2023-03-19 Sunday\n2023-03-26 Sunday\n2023-04-02 Sunday\n2023-04-09 Sunday\n"}]}
{"messages": [{"role": "user", "content": "import re\n\ndef longest_palindrome_substring(s):\n    def expand_around_center(left, right):\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left + 1:right]\n    \n    longest = \"\"\n    for i in range(len(s)):\n        # Odd length palindromes\n        palindrome1 = expand_around_center(i, i)\n        # Even length palindromes\n        palindrome2 = expand_around_center(i, i + 1)\n        \n        if len(palindrome1) > len(longest):\n            longest = palindrome1\n        if len(palindrome2) > len(longest):\n            longest = palindrome2\n\n    return longest\n\ntext = \"\"\"\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus luctus urna sed urna ultricies ac tempor dui sagittis.\nIn condimentum facilisis porta. Sed nec diam eu diam mattis viverra nulla. Nulla fringilla, orci ac euismod semper, magna\ndiam porttitor mauris, quis sollicitudin sapien justo in libero. Vestibulum mollis mauris enim. Morbi euismod magna ac\nlorem rutrum elementum. Maecenas et risus est. Duis ac lectus sit amet neque feugiat eleifend. Vivamus suscipit tortor\neget felis porttitor volutpat. Cras ac urna et urna ultricies vehicula. Curabitur dictum velit et ligula malesuada\nlobortis. Pellentesque ac felis tellus. Aenean sollicitudin imperdiet arcu, vitae dignissim est posuere id. Suspendisse\nin lacus et quam ultricies tempor vel eu risus.\"\"\"\n\nwords = re.findall(r'\\b\\w+\\b', text)\npalindromes = {word: longest_palindrome_substring(word) for word in words if len(word) > 1}\n\nsorted_palindromes = sorted(palindromes.items(), key=lambda x: (-len(x[1]), x[0]))\n\nfor word, palindrome in sorted_palindromes:\n    print(f\"{word}: {palindrome}\")"}, {"role": "assistant", "content": "Pellentesque: elle\ndignissim: issi\nsagittis: itti\nAenean: ene\nMaecenas: ece\nVestibulum: ulu\nadipiscing: ipi\nconsectetur: tet\ndolor: olo\neget: ege\neleifend: ele\nelementum: ele\nfacilisis: ili\nlobortis: obo\nmalesuada: ada\nporttitor: tit\nposuere: ere\nrisus: sus\nsollicitudin: ici\nsuscipit: sus\nultricies: ici\nviverra: viv\nNulla: ll\nSuspendisse: ss\nfringilla: ll\nmattis: tt\nmollis: ll\nnulla: ll\ntellus: ll\nCras: C\nCurabitur: C\nDuis: D\nIn: I\nLorem: L\nMorbi: M\nSed: S\nVivamus: V\nac: a\namet: a\narcu: a\ncondimentum: c\ndiam: d\ndictum: d\ndui: d\nelit: e\nenim: e\nest: e\net: e\neu: e\neuismod: e\nfelis: f\nfeugiat: f\nid: i\nimperdiet: i\nin: i\nipsum: i\njusto: j\nlacus: l\nlectus: l\nlibero: l\nligula: l\nlorem: l\nluctus: l\nmagna: m\nmauris: m\nnec: n\nneque: n\norci: o\nporta: p\nquam: q\nquis: q\nrutrum: r\nsapien: s\nsed: s\nsemper: s\nsit: s\ntempor: t\ntortor: t\nurna: u\nvehicula: v\nvel: v\nvelit: v\nvitae: v\nvolutpat: v\n"}]}
{"messages": [{"role": "user", "content": "from statistics import mean, median, mode, stdev\n\ndef search_for_statistic(data, target, stat_func):\n    data = sorted(data)\n    left, right = 0, len(data) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        current_stat = stat_func(data[:mid + 1])\n        if current_stat == target:\n            return mid + 1\n        elif current_stat < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndata_set = [10, 30, 11, 25, 18, 29, 20, 33, 15, 17, 19, 24, 23, 32, 16, 28, 31, 22, 21, 26]\ntarget_mean = 23\ntarget_median = 22\ntarget_mode = 20\ntarget_stdev = 5.5\n\nmean_index = search_for_statistic(data_set, target_mean, mean)\nmedian_index = search_for_statistic(data_set, target_median, median)\nmode_index = search_for_statistic(data_set, target_mode, mode)\nstdev_index = search_for_statistic(data_set, target_stdev, stdev)\n\nprint(f\"Mean first reaches {target_mean} at index: {mean_index}\")\nprint(f\"Median first reaches {target_median} at index: {median_index}\")\nprint(f\"Mode first reaches {target_mode} at index: {mode_index}\")\nprint(f\"Standard deviation first reaches {target_stdev} at index: {stdev_index}\")"}, {"role": "assistant", "content": "Mean first reaches 23 at index: -1\nMedian first reaches 22 at index: 19\nMode first reaches 20 at index: -1\nStandard deviation first reaches 5.5 at index: -1\n"}]}
{"messages": [{"role": "user", "content": "import math\n\ndef vigenere_cipher(text, key):\n    def shift_char(c, s):\n        if c.isalpha():\n            offset = ord('A') if c.isupper() else ord('a')\n            return chr((ord(c) - offset + s) % 26 + offset)\n        return c\n\n    key_indices = [ord(k.lower()) - ord('a') for k in key]\n    return ''.join(shift_char(c, key_indices[i % len(key)]) for i, c in enumerate(text))\n\ndef find_key(cipher_text, plain_text):\n    def is_valid_key(key):\n        decrypted = vigenere_cipher(cipher_text, key)\n        return decrypted == plain_text\n\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    queue = ['']\n    while queue:\n        key = queue.pop(0)\n        if is_valid_key(key):\n            return key\n        if len(key) < len(plain_text):\n            queue.extend(key + c for c in alphabet)\n\ncipher_text = \"Wklv lv d whvw phvvdjh.\"\nplain_text = \"This is a test message.\"\nkey = find_key(cipher_text, plain_text)\nprint(\"Cipher Text:\", cipher_text)\nprint(\"Plain Text:\", plain_text)\nprint(\"Found Key:\", key)\n\nfor i in range(26):\n    shifted_text = ''.join(chr((ord(c) - ord('a') + i) % 26 + ord('a')) if c.isalpha() else c for c in plain_text.lower())\n    if vigenere_cipher(shifted_text, key) == cipher_text:\n        print(\"Shift Value:\", i)\n        print(\"Shifted Text:\", shifted_text)\n        break"}, {"role": "assistant", "content": "Traceback (most recent call last):\n  File \"<string>\", line 29, in <module>\n  File \"<string>\", line 22, in find_key\n  File \"<string>\", line 15, in is_valid_key\n  File \"<string>\", line 11, in vigenere_cipher\n  File \"<string>\", line 11, in <genexpr>\nZeroDivisionError: integer modulo by zero\n"}]}
{"messages": [{"role": "user", "content": "def is_valid_move(board, move, player):\n    if board[move] != ' ':\n        return False\n    board[move] = player\n    win = is_winner(board, player)\n    board[move] = ' '\n    return not win\n\ndef is_winner(board, player):\n    win_conditions = [\n        [0, 1, 2], [3, 4, 5], [6, 7, 8],\n        [0, 3, 6], [1, 4, 7], [2, 5, 8],\n        [0, 4, 8], [2, 4, 6]\n    ]\n    return any(all(board[pos] == player for pos in condition) for condition in win_conditions)\n\ndef minimax(board, depth, is_maximizing):\n    if is_winner(board, 'O'):\n        return -10 + depth\n    if is_winner(board, 'X'):\n        return 10 - depth\n    if ' ' not in board:\n        return 0\n    \n    if is_maximizing:\n        max_eval = float('-inf')\n        for i in range(9):\n            if board[i] == ' ':\n                board[i] = 'X'\n                eval = minimax(board, depth + 1, False)\n                board[i] = ' '\n                max_eval = max(max_eval, eval)\n        return max_eval\n    else:\n        min_eval = float('inf')\n        for i in range(9):\n            if board[i] == ' ':\n                board[i] = 'O'\n                eval = minimax(board, depth + 1, True)\n                board[i] = ' '\n                min_eval = min(min_eval, eval)\n        return min_eval\n\ndef best_move(board):\n    best_val = float('-inf')\n    move = -1\n    for i in range(9):\n        if board[i] == ' ':\n            board[i] = 'X'\n            move_val = minimax(board, 0, False)\n            board[i] = ' '\n            if move_val > best_val:\n                best_val = move_val\n                move = i\n    return move\n\ndef print_board(board):\n    for i in range(3):\n        print(' | '.join(board[i*3:(i+1)*3]))\n        if i < 2:\n            print('---------')\n\ndef play_game():\n    board = [' '] * 9\n    for turn in range(9):\n        if turn % 2 == 0:\n            move = best_move(board)\n            board[move] = 'X'\n            print(f\"AI chooses position {move + 1}\")\n        else:\n            for i in range(9):\n                if is_valid_move(board, i, 'O'):\n                    board[i] = 'O'\n                    break\n            print(f\"Player chooses position {i + 1}\")\n        \n        print_board(board)\n        if is_winner(board, 'X'):\n            print(\"AI wins!\")\n            return\n        if is_winner(board, 'O'):\n            print(\"Player wins!\")\n            return\n        print(\"---\")\n    \n    print(\"It's a draw!\")\n\nplay_game()"}, {"role": "assistant", "content": "AI chooses position 1\nX |   |  \n---------\n  |   |  \n---------\n  |   |  \n---\nPlayer chooses position 2\nX | O |  \n---------\n  |   |  \n---------\n  |   |  \n---\nAI chooses position 4\nX | O |  \n---------\nX |   |  \n---------\n  |   |  \n---\nPlayer chooses position 3\nX | O | O\n---------\nX |   |  \n---------\n  |   |  \n---\nAI chooses position 7\nX | O | O\n---------\nX |   |  \n---------\nX |   |  \nAI wins!\n"}]}
{"messages": [{"role": "user", "content": "import datetime\n\ndef generate_dates():\n    base_date = datetime.date(2023, 1, 1)\n    dates = [base_date + datetime.timedelta(days=i) for i in range(365)]\n    return dates\n\ndef contains_friday_13th(dates):\n    for date in dates:\n        if date.day == 13 and date.weekday() == 4:\n            print(f\"Found Friday the 13th: {date}\")\n            return True\n    return False\n\ndef transform_dates(dates):\n    transformed = [date.strftime(\"%Y-%m-%d\") for date in dates if date.weekday() == 0]\n    print(f\"Transformed dates (Mondays): {len(transformed)}\")\n    return transformed\n\ndates = generate_dates()\nprint(\"Generated dates for 2023\")\nfriday_13th_found = contains_friday_13th(dates)\nif not friday_13th_found:\n    print(\"No Friday the 13th found in 2023\")\n\nmonday_dates = transform_dates(dates)\nprint(\"List of Mondays in 2023:\")\nfor date in monday_dates:\n    print(date)"}, {"role": "assistant", "content": "Generated dates for 2023\nFound Friday the 13th: 2023-01-13\nTransformed dates (Mondays): 52\nList of Mondays in 2023:\n2023-01-02\n2023-01-09\n2023-01-16\n2023-01-23\n2023-01-30\n2023-02-06\n2023-02-13\n2023-02-20\n2023-02-27\n2023-03-06\n2023-03-13\n2023-03-20\n2023-03-27\n2023-04-03\n2023-04-10\n2023-04-17\n2023-04-24\n2023-05-01\n2023-05-08\n2023-05-15\n2023-05-22\n2023-05-29\n2023-06-05\n2023-06-12\n2023-06-19\n2023-06-26\n2023-07-03\n2023-07-10\n2023-07-17\n2023-07-24\n2023-07-31\n2023-08-07\n2023-08-14\n2023-08-21\n2023-08-28\n2023-09-04\n2023-09-11\n2023-09-18\n2023-09-25\n2023-10-02\n2023-10-09\n2023-10-16\n2023-10-23\n2023-10-30\n2023-11-06\n2023-11-13\n2023-11-20\n2023-11-27\n2023-12-04\n2023-12-11\n2023-12-18\n2023-12-25\n"}]}
